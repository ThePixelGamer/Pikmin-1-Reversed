/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

_DWORD __stdcall sub_10001005(_DWORD); // weak
_DWORD __stdcall sub_1000100A(_DWORD); // weak
_DWORD __stdcall ControllerMgr::operator=(_DWORD); // weak
_DWORD __thiscall Joint::MatPoly::MatPoly(Joint::MatPoly *this); // idb
void __thiscall AnimDca::parse(AnimDca *this, struct CmdStream *); // idb
void __thiscall Quat::set(Quat *this, float, float, float, float); // idb
_DWORD __thiscall AnimData::AnimData(AnimData *this, const struct AnimData *); // idb
void __thiscall CacheInfo::remove(CacheInfo *this); // idb
int __thiscall AyuStack::getFree(AyuStack *this); // idb
void __thiscall Joint::recOverrideAnim(Joint *this, struct AnimContext *); // idb
_DWORD __thiscall SplitBar::~SplitBar(SplitBar *this); // idb
_DWORD __thiscall Vector3f::Vector3f(Vector3f *this, const float *, const float *, const float *); // idb
_DWORD __stdcall sub_100010A5(_DWORD); // weak
void __thiscall Vector2f::set(Vector2f *this, float, float); // idb
_DWORD __thiscall BufferedStream::BufferedStream(BufferedStream *this, const struct BufferedStream *); // idb
void __thiscall PVWPolygonColourInfo::animate(PVWPolygonColourInfo *this, float *, struct Colour *); // idb
void __thiscall LightGroup::ageDel(LightGroup *this, struct AgeServer *); // idb
void __thiscall DataChunk::read(DataChunk *this, struct RandomAccessStream *); // idb
void __thiscall NodeMgr::recFindNode(NodeMgr *this, struct CoreNode *, char *); // idb
_DWORD __thiscall TexCacheInfo::TexCacheInfo(TexCacheInfo *this); // idb
_DWORD __thiscall PVWTextureInfo::PVWTextureInfo(PVWTextureInfo *this, const struct PVWTextureInfo *); // idb
void __thiscall PVWLightingInfo::write(PVWLightingInfo *this, struct RandomAccessStream *); // idb
_DWORD __thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this, struct Stream *, unsigned __int8 *, int); // idb
_DWORD __thiscall BinobjInfo::BinobjInfo(BinobjInfo *this); // idb
_DWORD __stdcall sub_1000110E(_DWORD); // weak
void __thiscall ID32::setID(ID32 *this, unsigned __int32); // idb
void __thiscall DispList::prepareTriList(DispList *this, struct TriStripifier *); // idb
int __cdecl sub_10001136(float); // idb
void __thiscall BoundBox::resetBound(BoundBox *this); // idb
bool __thiscall PVWTevColReg::isSame(PVWTevColReg *this, struct PVWTevColReg *); // idb
void __thiscall ControllerMgr::update(ControllerMgr *this); // idb
void __thiscall ObjCollInfo::ageDelCollInfo(ObjCollInfo *this, struct AgeServer *); // idb
struct AnimData *__thiscall BaseShape::loadAnimation(BaseShape *this, char *Str, bool); // idb
void __thiscall Node::init(Node *this, char *); // idb
_DWORD __stdcall ID32::operator==(_DWORD); // weak
struct Vector3f *__thiscall KTri::Origin(KTri *this); // idb
_DWORD __thiscall AnimContext::AnimContext(AnimContext *this); // idb
_DWORD __stdcall sub_10001186(_DWORD); // weak
_DWORD __thiscall ANode::ANode(ANode *this, const struct ANode *); // idb
_DWORD __cdecl sub_100011A4(_DWORD, _DWORD); // weak
void __thiscall ObjCollInfo::showInfo(ObjCollInfo *this, struct Graphics *, struct Matrix4f *); // idb
float __cdecl roundAng(float); // idb
void __thiscall PVWPeInfo::read(PVWPeInfo *this, struct RandomAccessStream *); // idb
_DWORD __thiscall ComboBox::~ComboBox(ComboBox *this); // idb
_DWORD __stdcall sub_100011EF(_DWORD); // weak
_DWORD __thiscall CachedShape::CachedShape(CachedShape *this); // idb
void __thiscall Vector3f::write(Vector3f *this, struct Stream *); // idb
void __thiscall System::genAge(struct AgeServer *); // idb
_DWORD __thiscall Vector3f::Vector3f(Vector3f *this, const struct Vector3f *); // idb
int __stdcall sub_10001208(struct RandomAccessStream *); // idb
void __thiscall Matrix3f::identity(Matrix3f *this); // idb
_DWORD __stdcall sub_10001221(char); // weak
void __thiscall Colour::read(Colour *this, struct Stream *); // idb
int __cdecl sub_1000122B(float); // idb
_DWORD __thiscall GfxobjInfo::GfxobjInfo(GfxobjInfo *this); // idb
int __stdcall sub_1000123A(struct RandomAccessStream *); // idb
void __thiscall ShapeDynMaterials::updateContext(ShapeDynMaterials *this); // idb
void __thiscall StdSystem::setActive(StdSystem *this, bool); // idb
void __thiscall Quat::normalise(Quat *this); // idb
int __cdecl sub_10001258(float); // idb
void __thiscall ObjCollInfo::loadini(ObjCollInfo *this, struct CmdStream *); // idb
void __thiscall WSocket::close(WSocket *this); // idb
void *__thiscall AyuStack::push(AyuStack *this, int); // idb
_DWORD __stdcall sub_10001280(_DWORD); // weak
char *__cdecl StdSystem::stringDup(char *Str); // idb
void __thiscall PVWCombiner::read(PVWCombiner *this, struct RandomAccessStream *); // idb
int __thiscall ANode::getAgeNodeType(ANode *this); // idb
void __thiscall Light::setLightDistAttn(Light *this, float, float, int); // idb
void __thiscall Matrix4f::translate(Matrix4f *this, float, float, float); // idb
void __thiscall WSocket::flushWrite(WSocket *this); // idb
void __thiscall Material::getColour(Material *this, struct Colour *); // idb
_DWORD __thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this); // idb
bool __thiscall CmdStream::endOfCmds(CmdStream *this); // idb
void __thiscall Graphics::drawSphere(Graphics *this, struct Vector3f *, float, struct Matrix4f *); // idb
void __thiscall PVWKeyInfoF32::write(PVWKeyInfoF32 *this, struct RandomAccessStream *); // idb
void __thiscall BoundBox::draw(BoundBox *this, struct Graphics *); // idb
_DWORD __thiscall AnimCacheInfo::AnimCacheInfo(AnimCacheInfo *this); // idb
void __thiscall String::init(String *this, char *, int); // idb
_DWORD __thiscall AtxRouter::AtxRouter(AtxRouter *this, const struct AtxRouter *); // idb
_DWORD *__thiscall sub_10001343(int this);
void __thiscall CullFrustum::update(CullFrustum *this, float, float, float, float); // idb
void __thiscall DataChunk::addData(DataChunk *this, float); // idb
void __thiscall BaseRoomInfo::read(BaseRoomInfo *this, struct RandomAccessStream *); // idb
int __cdecl sub_1000136B(HGLOBAL hMem); // idb
int __thiscall sub_10001370(_DWORD); // weak
_DWORD __thiscall LFInfo::LFInfo(LFInfo *this); // idb
int __thiscall sub_1000137A(_DWORD); // weak
void __thiscall LightFlare::ageDel(LightFlare *this, struct AgeServer *); // idb
_DWORD __thiscall LightDataInfo::LightDataInfo(LightDataInfo *this); // idb
int __stdcall sub_1000138E(struct RandomAccessStream *); // idb
void __thiscall BoundBox::read(BoundBox *this, struct RandomAccessStream *); // idb
_DWORD __stdcall sub_100013A7(_DWORD, _DWORD, _DWORD); // weak
bool __thiscall Node::getFlag(Node *this, int); // idb
int __stdcall sub_100013B1(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
_DWORD __stdcall LightFlare::operator=(_DWORD); // weak
void __thiscall StdSystem::invalidateObjs(StdSystem *this, unsigned __int32, unsigned __int32); // idb
int __thiscall sub_100013DE(_DWORD); // weak
void __thiscall BaseShape::initialise(BaseShape *this); // idb
double __thiscall System::getFrameTime(_DWORD); // weak
_DWORD __stdcall sub_10001415(_DWORD); // weak
int __cdecl sub_1000141A(float, int, int); // idb
void __thiscall MtxGroup::read(MtxGroup *this, struct RandomAccessStream *); // idb
void __thiscall UIFrame::setFrame(UIFrame *this, struct RectArea *); // idb
_DWORD __stdcall AgeServer::NewButton(_DWORD, _DWORD, _DWORD); // weak
_DWORD __stdcall sub_1000145B(_DWORD); // weak
System *__thiscall System::updateSysClock(int this);
int __thiscall System::buildModeList(_DWORD); // weak
_DWORD __thiscall PVWTevColReg::PVWTevColReg(PVWTevColReg *this); // idb
void __thiscall Light::refreshSection(Light *this, struct AgeServer *); // idb
void __thiscall AnimDck::parse(AnimDck *this, struct CmdStream *); // idb
void __thiscall ModuleMgr::UnLoad(ModuleMgr *this, struct Module *); // idb
void __thiscall StdSystem::Shutdown(StdSystem *this); // idb
void __thiscall RandomAccessStream::readFrom(RandomAccessStream *this, int, void *, int); // idb
_DWORD __thiscall Colour::Colour(Colour *this); // idb
void __thiscall String::init(String *this, int); // idb
_DWORD __thiscall UIWindow::~UIWindow(UIWindow *this); // idb
Controller *__thiscall Controller::Controller(Controller *this, unsigned __int32 a2);
_DWORD __stdcall sub_10001532(_DWORD); // weak
bool __thiscall String::isSame(String *this, char *); // idb
_DWORD __thiscall TexAttr::TexAttr(TexAttr *this); // idb
void __thiscall Vector3f::div(Vector3f *this, float); // idb
void __thiscall ObjCollInfo::saveini(ObjCollInfo *this, char *, struct RandomAccessStream *); // idb
_DWORD __thiscall DispList::DispList(DispList *this); // idb
_DWORD __thiscall PVWTevInfo::PVWTevInfo(PVWTevInfo *this); // idb
struct Matrix4f *__thiscall Graphics::getMatrices(Graphics *this, int); // idb
void __thiscall ID32::updateID(ID32 *this); // idb
void __thiscall Light::setLightParallel(Light *this); // idb
bool __thiscall AgeServer::getOpenFilename(AgeServer *this, struct String *, char *); // idb
int __stdcall sub_1000159B(struct RandomAccessStream *); // idb
struct Vector3f *__thiscall KSegment::Direction(KSegment *this); // idb
_DWORD __thiscall RouteGroup::RouteGroup(RouteGroup *this); // idb
_DWORD __thiscall Light::Light(Light *this, const struct Light *); // idb
float __cdecl sqrDistance(struct KSegment *, struct KSegment *, float *, float *); // idb
void __thiscall CullFrustum::projectVector(CullFrustum *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Graphics::cacheShape(Graphics *this, struct BaseShape *, struct ShapeDynMaterials *); // idb
void __thiscall AgeServer::StartBitGroup(AgeServer *this, char *, unsigned __int32 *, int); // idb
void __thiscall AyuHeap::init(AyuHeap *this, char *, int, void *, int); // idb
_DWORD __thiscall ObjCollInfo::ObjCollInfo(ObjCollInfo *this, const struct ObjCollInfo *); // idb
int __thiscall Font::charToIndex(Font *this, char); // idb
_DWORD __thiscall UIWindow::UIWindow(UIWindow *this, const struct UIWindow *); // idb
_DWORD __thiscall Plane::Plane(Plane *this, const struct Plane *); // idb
void __thiscall BufferedInputStream::fillBuffer(BufferedInputStream *this); // idb
void __thiscall Matrix4f::rotate(Matrix4f *this, struct Vector3f *, float); // idb
_DWORD __thiscall EditNode::EditNode(EditNode *this, char *); // idb
void __thiscall UIWindow::updateMove(UIWindow *this, int, int); // idb
void __thiscall Controller::reset(Controller *this, unsigned __int32); // idb
_DWORD __thiscall BaseApp::BaseApp(BaseApp *this, const struct BaseApp *); // idb
int __stdcall sub_1000166D(struct RandomAccessStream *); // idb
_DWORD __stdcall sub_10001677(_DWORD); // weak
void __thiscall AtxStream::close(AtxStream *this); // idb
void __thiscall Matrix4f::inverse(Matrix4f *this, struct Matrix4f *); // idb
void __thiscall AtxStream::init(AtxStream *this); // idb
void __thiscall CollTriInfo::init(CollTriInfo *this, struct RoomInfo *, struct Vector3f *); // idb
void __thiscall AyuStack::reset(AyuStack *this, int); // idb
int __thiscall WSocket::closing(WSocket *this); // idb
_DWORD __thiscall AnimDca::AnimDca(AnimDca *this, char *); // idb
_DWORD __thiscall Camera::Camera(Camera *this, const struct Camera *); // idb
void __thiscall Vector3f::add(Vector3f *this, struct Vector3f *); // idb
char *__thiscall CmdStream::skipLine(CmdStream *this); // idb
unsigned __int32 __thiscall TexImg::convFormat(TexImg *this, unsigned __int32); // idb
_DWORD __stdcall sub_100016EA(_DWORD, _DWORD); // weak
double __thiscall System::getFrameRate(_DWORD); // weak
_DWORD __thiscall KRect::KRect(KRect *this); // idb
int __stdcall sub_100016FE(struct RandomAccessStream *); // idb
bool __thiscall AtxFileStream::open(AtxFileStream *this, char *, unsigned __int32); // idb
void __thiscall BufferedInputStream::init(BufferedInputStream *this, struct Stream *, unsigned __int8 *, int); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, int *, int, int, int); // idb
_DWORD __stdcall Node::operator=(_DWORD); // weak
_DWORD __thiscall BaseApp::~BaseApp(BaseApp *this); // idb
void __thiscall Quat::multiplyTo(Quat *this, struct Quat *, struct Quat *); // idb
_DWORD __stdcall sub_10001730(_DWORD); // weak
void __thiscall Vector2f::read(Vector2f *this, struct Stream *); // idb
float __thiscall Vector3f::normalise(Vector3f *this); // idb
void __thiscall BaseShape::recAddMatpoly(BaseShape *this, struct Joint *, int); // idb
bool __cdecl String::contains(char *, char *); // idb
_DWORD __stdcall SRTNode::operator=(_DWORD); // weak
void __thiscall AnimData::playAnim(AnimData *this, struct AgeServer *); // idb
float __thiscall BaseApp::rnd(BaseApp *this); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, float *, float, float, int); // idb
struct RandomAccessStream *__thiscall System::createFile(char *, bool); // idb
_DWORD __stdcall sub_1000179E(_DWORD); // weak
void __thiscall BaseShape::initIni(BaseShape *this, bool); // idb
void __thiscall PVWTevStage::read(PVWTevStage *this, struct RandomAccessStream *); // idb
int __stdcall sub_100017AD(struct RandomAccessStream *); // idb
float __cdecl sqrDistance(struct Vector3f *, struct KTri *, float *, float *); // idb
_DWORD __stdcall sub_100017BC(_DWORD, _DWORD); // weak
_DWORD __thiscall AyuCache::AyuCache(AyuCache *this, unsigned __int32); // idb
_DWORD __stdcall StdSystem::operator=(_DWORD); // weak
void __thiscall Matrix4f::rotateX(Matrix4f *this, float); // idb
struct LFlareGroup *__thiscall StdSystem::registerLFlare(StdSystem *this, struct Texture *); // idb
int __thiscall String::toInt(String *this); // idb
_DWORD __thiscall GfxObject::GfxObject(GfxObject *this); // idb
void __thiscall LightGroup::saveini(LightGroup *this, char *, struct RandomAccessStream *); // idb
void __thiscall VtxMatrix::read(VtxMatrix *this, struct RandomAccessStream *); // idb
_DWORD __stdcall RouteLink::operator=(_DWORD); // weak
int __thiscall WSocket::pending(WSocket *this); // idb
void __thiscall TexCacheInfo::initData(TexCacheInfo *this); // idb
void __thiscall BufferedInputStream::resetBuffer(BufferedInputStream *this); // idb
int __stdcall sub_10001848(struct RandomAccessStream *); // idb
_DWORD __thiscall SplitBar::SplitBar(SplitBar *this, const struct SplitBar *); // idb
_DWORD __stdcall sub_1000185C(_DWORD); // weak
void __thiscall ID32::ageChangeID(ID32 *this); // idb
struct Shape *__thiscall StdSystem::loadShape(StdSystem *this, char *Str2, bool); // idb
void __thiscall Matrix4f::multiplyTo(Matrix4f *this, struct Matrix4f *, struct Matrix4f *); // idb
int __thiscall AgeServer::writePropValue(_DWORD, _DWORD, _DWORD); // weak
_DWORD __thiscall MtxGroup::MtxGroup(MtxGroup *this); // idb
void __cdecl Texture::decodeS3TC(int, int, unsigned __int8 *, unsigned __int8 *); // idb
void __thiscall PVWKeyInfoF32::read(PVWKeyInfoF32 *this, struct RandomAccessStream *); // idb
void __thiscall PVWColourAnimInfo::extract(PVWColourAnimInfo *this, float, struct Colour *); // idb
int __thiscall AgeServer::update(AgeServer *this); // idb
_DWORD __thiscall Envelope::Envelope(Envelope *this); // idb
_DWORD __stdcall sub_100018CA(_DWORD); // weak
int __cdecl sub_100018D9(float, float); // idb
void __thiscall System::setAtxRouter(struct AtxRouter *); // idb
void __thiscall ObjCollInfo::newCollInfoButton(ObjCollInfo *this, struct AgeServer *); // idb
void __thiscall UIWindow::createWindow(UIWindow *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU); // idb
_DWORD __thiscall Graphics::Graphics(Graphics *this); // idb
void __thiscall Vector3f::genAge(Vector3f *this, struct AgeServer *, char *, struct Vector3f *, struct Vector3f *); // idb
int __stdcall sub_1000190B(struct RandomAccessStream *); // idb
_DWORD __thiscall BaseScalingSystem::BaseScalingSystem(BaseScalingSystem *this); // idb
void __thiscall RandomAccessStream::skipPadding(RandomAccessStream *this, unsigned __int32); // idb
void __thiscall AgeServer::NewNode(AgeServer *this, char *, struct ANode *); // idb
int __cdecl sub_10001938(HGLOBAL hMem); // idb
void __thiscall BoundBox::expandBound(BoundBox *this, struct Vector3f *); // idb
_DWORD __thiscall BoundBox::BoundBox(BoundBox *this, const struct BoundBox *); // idb
void __thiscall Matrix4f::rotateY(Matrix4f *this, float); // idb
_DWORD __thiscall GfxObject::GfxObject(GfxObject *this, const struct GfxObject *); // idb
void __thiscall PVWPolygonColourInfo::write(PVWPolygonColourInfo *this, struct RandomAccessStream *); // idb
int __thiscall ComboBox::processMessage(ComboBox *this, HWND hWnd, unsigned int, unsigned int, int); // idb
void __thiscall Node::clearFlag(Node *this, int); // idb
_DWORD __thiscall Vector2f::Vector2f(Vector2f *this); // idb
void __thiscall AgeServer::NewOption(AgeServer *this, char *, int); // idb
void __thiscall Graphics::resetCacheBuffer(Graphics *this); // idb
void __thiscall RoutePoint::refresh(RoutePoint *this, struct Graphics *); // idb
void __thiscall PVWTextureData::write(PVWTextureData *this, struct RandomAccessStream *); // idb
void __thiscall PVWTexGenData::write(PVWTexGenData *this, struct RandomAccessStream *); // idb
CoreNode *__thiscall CoreNode::CoreNode(CoreNode *this, char *a2);
void __thiscall StdSystem::initSoftReset(StdSystem *this); // idb
void __thiscall UIWindow::closeChildren(UIWindow *this); // idb
int __thiscall Texture::offsetGXtoGL(Texture *this, int); // idb
_DWORD __thiscall Stream::Stream(Stream *this, const struct Stream *); // idb
void __thiscall AgeServer::NewPropWindow(AgeServer *this, char *, unsigned __int32); // idb
_DWORD __stdcall sub_100019F1(_DWORD); // weak
struct AnimData *__thiscall BaseShape::loadDck(BaseShape *this, char *, struct RandomAccessStream *); // idb
struct GfxobjInfo *__thiscall StdSystem::findGfxObject(StdSystem *this, char *Str2, unsigned __int32); // idb
void __thiscall Vector3f::sub(Vector3f *this, struct Vector3f *); // idb
_DWORD __stdcall sub_10001A14(_DWORD, _DWORD, _DWORD, _DWORD); // weak
bool __thiscall CmdStream::whiteSpace(CmdStream *this, char); // idb
void __thiscall SRTNode::setScale(SRTNode *this, struct Vector3f *); // idb
int __cdecl sub_10001A3C(Vector3f *, int, int); // idb
int __thiscall StdSystem::setHeap(StdSystem *this, int); // idb
int __thiscall CullFrustum::isBoundVisible(CullFrustum *this, struct BoundBox *, int); // idb
void __thiscall StdSystem::setTextureBase(StdSystem *this, char *, char *); // idb
void __thiscall RandomAccessStream::writeTo(RandomAccessStream *this, int, void *, int); // idb
void __thiscall RenderWindow::paintRender(RenderWindow *this, struct RectArea *); // idb
_DWORD __stdcall sub_10001A6E(_DWORD, _DWORD); // weak
void __thiscall Graphics::initRender(Graphics *this, int, int); // idb
_DWORD __thiscall String::String(String *this, int); // idb
void __thiscall Texture::decodeData(Texture *this, struct TexImg *); // idb
void __thiscall CoreNode::initCore(CoreNode *this, char *); // idb
void __thiscall GfxobjInfo::insertAfter(GfxobjInfo *this, struct GfxobjInfo *); // idb
int __thiscall sub_10001A9B(_DWORD); // weak
double __thiscall System::getTime(_DWORD); // weak
_DWORD __thiscall CmdStream::CmdStream(CmdStream *this, struct Stream *); // idb
bool __thiscall PVWKeyInfoS10::isSame(PVWKeyInfoS10 *this, struct PVWKeyInfoS10 *); // idb
int __cdecl sub_10001AC3(SIZE_T dwBytes); // idb
struct AnimData *__thiscall BaseShape::loadDca(BaseShape *this, char *, struct RandomAccessStream *); // idb
_DWORD __stdcall AnimData::operator=(_DWORD); // weak
float __thiscall Plane::dist(Plane *this, struct Vector3f *); // idb
ANode *__thiscall ANode::ANode(ANode *this);
void __thiscall Matrix4f::multiply(Matrix4f *this, struct Matrix4f *); // idb
void __thiscall Matrix4f::makeLookfrom(Matrix4f *this, struct Vector3f *, struct Vector3f *); // idb
_DWORD __thiscall AgeServer::AgeServer(AgeServer *this); // idb
void __thiscall Vector3f::sub(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
char *__thiscall CmdStream::getToken(CmdStream *this, bool); // idb
_DWORD __thiscall BaseShape::BaseShape(BaseShape *this, const struct BaseShape *); // idb
_DWORD __thiscall ObjCollInfo::ObjCollInfo(ObjCollInfo *this); // idb
void __thiscall AnimFrameCacher::updateInfo(AnimFrameCacher *this, struct AnimCacheInfo *); // idb
int sub_10001B2C(); // weak
float __thiscall Light::calcLightMapRadius(Light *this); // idb
_DWORD __thiscall TimerInf::TimerInf(TimerInf *this, char *); // idb
_DWORD __stdcall AtxFileStream::operator=(_DWORD); // weak
struct Vector3f *__thiscall KTri::Edge1(KTri *this); // idb
void __thiscall TextureCacher::removeOldest(TextureCacher *this); // idb
void __thiscall StdSystem::addGfxObject(StdSystem *this, struct GfxobjInfo *); // idb
bool __thiscall AgeServer::Open(AgeServer *this); // idb
void __thiscall RouteGroup::setID(RouteGroup *this, unsigned __int32); // idb
void __thiscall PVWTextureData::animate(PVWTextureData *this, float *, struct Matrix4f *); // idb
_DWORD __thiscall Stream::Stream(Stream *this); // idb
void __thiscall PVWAlphaShortAnimInfo::extract(PVWAlphaShortAnimInfo *this, float, struct ShortColour *); // idb
void __thiscall BaseShape::calcBasePose(BaseShape *this, struct Matrix4f *); // idb
int __thiscall System::setStreamType(int); // idb
void __thiscall Colour::genAge(Colour *this, struct AgeServer *, char *); // idb
_DWORD __thiscall KSegment::KSegment(KSegment *this); // idb
void __thiscall Light::setLightSpot(Light *this, float, int); // idb
void __thiscall BaseShape::makeInstance(BaseShape *this, struct ShapeDynMaterials *, int); // idb
void __cdecl __noreturn System::halt(char *, int, char *); // idb
struct Matrix4f *Node::getModelMatrix();
void __thiscall CurveSection::evaluateAt(CurveSection *this, int, float); // idb
float __cdecl sqrDistance(struct KTri *, struct KRect *, float *, float *, float *, float *); // idb
void __thiscall ComboBox::selOption(ComboBox *this, int); // idb
void __thiscall PVWColourShortAnimInfo::extract(PVWColourShortAnimInfo *this, float, struct ShortColour *); // idb
_DWORD __stdcall SplitBar::operator=(_DWORD); // weak
unsigned __int32 __thiscall String::calcHash(String *this); // idb
float __cdecl sqrDistance(struct KSegment *, struct KRect *, float *, float *, float *); // idb
void __thiscall LightGroup::loadini(LightGroup *this, struct CmdStream *); // idb
_DWORD __thiscall RandomAccessStream::RandomAccessStream(RandomAccessStream *this); // idb
void __thiscall AyuCache::cacheFree(AyuCache *this, void *); // idb
_DWORD __thiscall StdSystem::StdSystem(StdSystem *this); // idb
void __thiscall BaseShape::importDca(BaseShape *this, char *, struct CmdStream *); // idb
void __thiscall AyuStack::create(AyuStack *this, char *, int, void *, int, bool); // idb
_DWORD __thiscall UIFrame::UIFrame(UIFrame *this); // idb
void __thiscall RectArea::set(RectArea *this, int, int, int, int); // idb
void __thiscall Texture::grabBuffer(Texture *this, GLsizei width, GLsizei height, bool, bool); // idb
void __thiscall PVWTevStage::write(PVWTevStage *this, struct RandomAccessStream *); // idb
_DWORD __stdcall sub_10001C6C(_DWORD); // weak
_DWORD __thiscall AnmobjInfo::AnmobjInfo(AnmobjInfo *this); // idb
struct AyuHeap *__thiscall StdSystem::getHeap(StdSystem *this, int); // idb
_DWORD __thiscall RouteGroup::RouteGroup(RouteGroup *this, const struct RouteGroup *); // idb
int __thiscall AtxCommandStream::checkCommands(AtxCommandStream *this); // idb
void __thiscall CoreNode::genWrite(CoreNode *this, struct AgeServer *); // idb
void __thiscall Matrix4f::makeIdentity(Matrix4f *this); // idb
void __thiscall BaseShape::drawroutes(BaseShape *this, struct Graphics *, struct Camera *); // idb
int __thiscall sub_10001CD0(_DWORD); // weak
int __cdecl sub_10001CD5(Vector3f *, int, int); // idb
_DWORD __stdcall RandomAccessStream::operator=(_DWORD); // weak
void __thiscall Matrix4f::makeConcatSRT(Matrix4f *this, struct Matrix4f *, struct Matrix4f *, struct SRT *); // idb
void __thiscall DataChunk::setDataSize(DataChunk *this, int); // idb
void __thiscall SplitBar::handleRelease(SplitBar *this, int, int); // idb
_DWORD __stdcall BaseShape::recTraverseMaterials(_DWORD, _DWORD); // weak
_DWORD __stdcall UIWindow::operator=(_DWORD); // weak
int __thiscall Mesh::Mesh(Mesh *this);
_DWORD __stdcall GfxobjInfo::operator=(_DWORD); // weak
void __thiscall Matrix4f::makeLookat(Matrix4f *this, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Joint::recShowHierarchy(Joint *this); // idb
int __thiscall sub_10001D43(_DWORD); // weak
void __thiscall AnimCacheInfo::initData(AnimCacheInfo *this); // idb
_DWORD __thiscall LightFlare::LightFlare(LightFlare *this); // idb
_DWORD __thiscall CollGroup::CollGroup(CollGroup *this); // idb
_DWORD __thiscall GameApp::~GameApp(GameApp *this); // idb
void __thiscall AgeServer::EndGroup(AgeServer *this); // idb
void __thiscall AgeServer::setOnChange(AgeServer *this, struct IDelegate *); // idb
void __thiscall LightGroup::addLight(LightGroup *this, struct Vector3f *, float); // idb
void __thiscall Node::setFlags(Node *this, int); // idb
bool __thiscall BoundBox::intersects(BoundBox *this, struct BoundBox *); // idb
int __thiscall sub_10001D98(_DWORD); // weak
void __thiscall DispList::outputTriData(DispList *this, struct RandomAccessStream *, unsigned __int32, bool); // idb
_DWORD __stdcall sub_10001DA7(_DWORD); // weak
struct AnimData *__thiscall BaseShape::importDck(BaseShape *this, char *, struct CmdStream *); // idb
struct Colour *__thiscall Material::Colour(Material *this); // idb
int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD); // weak
void __thiscall Vector3f::CP(Vector3f *this, struct Vector3f *); // idb
void __thiscall Matrix4f::makeSRT(Matrix4f *this, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
void __thiscall StdSystem::set2DRoot(StdSystem *this, char *, char *); // idb
_DWORD __stdcall AgeServer::setSectionRefresh(_DWORD); // weak
_DWORD __thiscall ShapeDynMaterials::ShapeDynMaterials(ShapeDynMaterials *this); // idb
void __thiscall AnimData::delAnim(AnimData *this, struct AgeServer *); // idb
void __thiscall StdSystem::detachObjs(StdSystem *this); // idb
void __thiscall PVWTextureInfo::write(PVWTextureInfo *this, struct RandomAccessStream *); // idb
void __thiscall TexImg::readTexData(TexImg *this, struct Texture *, struct RandomAccessStream *, unsigned __int8 *); // idb
void __thiscall PVWTexAnimInfo::extract(PVWTexAnimInfo *this, float, struct Vector3f *); // idb
struct CoreNode *__thiscall NodeMgr::firstNode(NodeMgr *this); // idb
void __thiscall StdSystem::onceInit(StdSystem *this); // idb
void __thiscall RoutePoint::loadini(RoutePoint *this, struct CmdStream *); // idb
bool __thiscall CullFrustum::isPointVisible(CullFrustum *this, struct Vector3f *, float); // idb
_DWORD __thiscall StdSystem::StdSystem(StdSystem *this, const struct StdSystem *); // idb
_DWORD __thiscall Vector3f::Vector3f(Vector3f *this); // idb
void __thiscall PVWKeyInfoU8::write(PVWKeyInfoU8 *this, struct RandomAccessStream *); // idb
void __thiscall Vector3f::read(Vector3f *this, struct Stream *); // idb
int __thiscall sub_10001E9C(_DWORD); // weak
_DWORD __thiscall AnimData::AnimData(AnimData *this); // idb
int __stdcall sub_10001EAB(struct UIWindow *, int, int, int, char); // idb
_DWORD __thiscall Light::Light(Light *this); // idb
void __thiscall BaseApp::stopAgeServer(BaseApp *this); // idb
_DWORD __thiscall PVWLightingInfo::PVWLightingInfo(PVWLightingInfo *this); // idb
void __thiscall Vector3f::multMatrix(Vector3f *this, struct Matrix4f *); // idb
_DWORD __thiscall Material::Material(Material *this); // idb
void __thiscall Envelope::read(Envelope *this, struct RandomAccessStream *); // idb
void __thiscall UIWindow::sizeWindow(UIWindow *this, int, int, int); // idb
bool __thiscall TcpStream::connect(TcpStream *this, char *, int); // idb
void __thiscall Plane::read(Plane *this, struct RandomAccessStream *); // idb
_DWORD __thiscall ComboBox::ComboBox(ComboBox *this, struct UIWindow *, int, int, int, bool); // idb
void __thiscall Timers::reset(Timers *this); // idb
bool __thiscall String::contains(String *this, char *); // idb
_DWORD __stdcall sub_10001F46(_DWORD, _DWORD); // weak
void __thiscall KTri::set(KTri *this, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
_DWORD __thiscall UIFrame::UIFrame(UIFrame *this, const struct UIFrame *); // idb
_DWORD __thiscall AnimJoint::AnimJoint(AnimJoint *this); // idb
void __thiscall Vector3f::multMatrixTo(Vector3f *this, struct Matrix4f *, struct Vector3f *); // idb
_DWORD __thiscall PVWTextureInfo::PVWTextureInfo(PVWTextureInfo *this); // idb
void __thiscall ShortColour::read(ShortColour *this, struct RandomAccessStream *); // idb
_DWORD __thiscall SRT::SRT(SRT *this, const struct SRT *); // idb
_DWORD __stdcall Matrix3f::operator()(_DWORD, _DWORD); // weak
void __thiscall UIMgr::activateWindow(UIMgr *this, HWND, struct UIWindow *); // idb
int __thiscall RectArea::width(RectArea *this); // idb
void __thiscall BaseShape::createCollisions(BaseShape *this, int); // idb
_DWORD __stdcall sub_10001FAF(_DWORD); // weak
void __thiscall AnimData::checkMask(AnimData *this); // idb
void __thiscall Node::setFlag(Node *this, int); // idb
void __thiscall Texture::read(Texture *this, struct RandomAccessStream *); // idb
void __thiscall CoreNode::genRead(CoreNode *this, struct AgeServer *); // idb
void __thiscall BaseShape::calcWeightedMatrices(BaseShape *this); // idb
void __thiscall Light::calcLightSizes(Light *this); // idb
void __thiscall CoreNode::del(CoreNode *this); // idb
_DWORD __stdcall ObjCollInfo::operator=(_DWORD); // weak
void __thiscall Plane::reflectVector(Plane *this, struct Vector3f *); // idb
void __thiscall BaseShape::drawshape(BaseShape *this, struct Graphics *, struct Camera *, struct ShapeDynMaterials *); // idb
void __thiscall Light::update(Light *this); // idb
_DWORD __thiscall CullFrustum::CullFrustum(CullFrustum *this, const struct CullFrustum *); // idb
_DWORD __stdcall System::searchFiles(char, _DWORD, _DWORD, _DWORD); // weak
void __thiscall LightFlare::loadini(LightFlare *this, struct CmdStream *); // idb
_DWORD __thiscall Colour::Colour(Colour *this, char, char, char, unsigned __int8); // idb
void __thiscall CmdStream::copyToToken(CmdStream *this, int); // idb
_DWORD __thiscall SRT::SRT(SRT *this); // idb
void __thiscall AgeServer::StartSection(AgeServer *this, char *, bool); // idb
void __thiscall PVWPeInfo::write(PVWPeInfo *this, struct RandomAccessStream *); // idb
_DWORD __thiscall AtxFileStream::AtxFileStream(AtxFileStream *this); // idb
int __stdcall sub_1000207C(struct RandomAccessStream *); // idb
float __thiscall Vector3f::length(Vector3f *this); // idb
void __cdecl TexImg::getTileSize(int, unsigned __int32 *, unsigned __int32 *); // idb
Node *__thiscall Node::Node(Node *this, char *a2);
_DWORD __thiscall Camera::Camera(Camera *this); // idb
void __thiscall AgeServer::RefreshNode(AgeServer *this); // idb
void __thiscall AgeServer::RefreshSection(AgeServer *this); // idb
_DWORD __stdcall ANode::operator=(_DWORD); // weak
int __thiscall Font::stringWidth(Font *this, char *); // idb
void __thiscall PVWTevColReg::animate(PVWTevColReg *this, float *, struct ShortColour *); // idb
_DWORD __thiscall MaterialHandler::MaterialHandler(MaterialHandler *this); // idb
_DWORD __thiscall ComboBox::ComboBox(ComboBox *this, const struct ComboBox *); // idb
void __thiscall SplitBar::handleClick(SplitBar *this, int, int); // idb
void __thiscall AgeServer::EndSection(AgeServer *this); // idb
struct Matrix4f *__thiscall BaseShape::getAnimMatrix(BaseShape *this, int); // idb
void __thiscall ID32::updateString(ID32 *this); // idb
void __thiscall ControllerMgr::updateController(ControllerMgr *this, struct Controller *); // idb
void __thiscall AgeServer::Done(AgeServer *this); // idb
_DWORD __thiscall Plane::Plane(Plane *this); // idb
void __thiscall LightGroup::refresh(LightGroup *this, struct Graphics *, struct Matrix4f *); // idb
void __thiscall GfxobjInfo::remove(GfxobjInfo *this); // idb
_DWORD __thiscall BaseApp::BaseApp(BaseApp *this); // idb
void __thiscall LFlareGroup::addLFlare(LFlareGroup *this, struct Colour *, struct Vector3f *, struct Vector2f *, struct Vector2f *, struct Vector2f *); // idb
void __thiscall Graphics::resetMatrixBuffer(Graphics *this); // idb
_DWORD __thiscall BoundBox::BoundBox(BoundBox *this); // idb
void __thiscall BaseShape::resolveTextureNames(BaseShape *this); // idb
bool __thiscall CmdStream::isToken(CmdStream *this, char *); // idb
void __thiscall AgeServer::EndNode(AgeServer *this); // idb
int __cdecl sub_100021A8(Vector3f *, int); // idb
bool __thiscall AyuCache::isEmpty(AyuCache *this); // idb
void __thiscall RenderWindow::shutdownOpenGL(RenderWindow *this); // idb
_DWORD __thiscall BaseScalingSystem::BaseScalingSystem(BaseScalingSystem *this, const struct BaseScalingSystem *); // idb
_DWORD __thiscall Node::Node(Node *this, const struct Node *); // idb
int __stdcall sub_100021D5(struct RandomAccessStream *); // idb
void __thiscall LightGroup::ageAddFlare(LightGroup *this, struct AgeServer *); // idb
void __thiscall Vector3f::multiply(Vector3f *this, float); // idb
void __thiscall Matrix4f::rotateZ(Matrix4f *this, float); // idb
void __thiscall BaseShape::importIni(BaseShape *this, struct RandomAccessStream *); // idb
void __thiscall ObjCollInfo::ageChangePlatname(ObjCollInfo *this, struct AgeServer *); // idb
_DWORD __thiscall Texture::Texture(Texture *this, const struct Texture *); // idb
int __stdcall sub_10002216(struct RandomAccessStream *); // idb
_DWORD __thiscall FontChar::FontChar(FontChar *this); // idb
void __thiscall Colour::set(Colour *this, char, char, char, unsigned __int8); // idb
_DWORD __thiscall AtxFileStream::AtxFileStream(AtxFileStream *this, const struct AtxFileStream *); // idb
void __thiscall Vector3f::project(Vector3f *this, struct Vector3f *); // idb
void __thiscall NodeMgr::Del(NodeMgr *this, struct Node *); // idb
void __thiscall PVWTevColReg::read(PVWTevColReg *this, struct RandomAccessStream *); // idb
struct Shape *__thiscall StdSystem::getShape(StdSystem *this, char *, char *Str, char *, bool); // idb
int __stdcall sub_10002261(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __thiscall sub_10002266(_DWORD); // weak
void __thiscall CacheInfo::insertAfter(CacheInfo *this, struct CacheInfo *); // idb
float __thiscall Camera::projectWorldPoint(Camera *this, struct Graphics *, struct Vector3f *); // idb
int __stdcall sub_10002298(struct RandomAccessStream *); // idb
int sub_100022A2(); // weak
int __thiscall RectArea::height(RectArea *this); // idb
_DWORD __stdcall Matrix3f::operator()(_DWORD, _DWORD); // weak
_DWORD __stdcall sub_100022B6(_DWORD); // weak
void __thiscall MtxGroup::exportData(MtxGroup *this, struct RandomAccessStream *, unsigned __int32); // idb
void __thiscall StdSystem::resetLFlares(StdSystem *this); // idb
void __thiscall PVWAlphaAnimInfo::extract(PVWAlphaAnimInfo *this, float, struct Colour *); // idb
_DWORD __stdcall BaseApp::operator=(_DWORD); // weak
void __thiscall AgeServer::EndOptionBox(AgeServer *this); // idb
void __thiscall SRTNode::setPosition(SRTNode *this, struct Vector3f *); // idb
struct Texture *__thiscall StdSystem::loadTexture(StdSystem *this, char *Str2, bool); // idb
void __thiscall RouteGroup::saveini(RouteGroup *this, char *, struct RandomAccessStream *); // idb
_DWORD __thiscall AnimDck::AnimDck(AnimDck *this, struct BaseShape *, int); // idb
void __thiscall ID32::genAge(ID32 *this, struct AgeServer *, char *); // idb
void __thiscall AnimFrameCacher::cacheFrameSpace(AnimFrameCacher *this, int, struct AnimCacheInfo *); // idb
_DWORD __stdcall Light::operator=(_DWORD); // weak
int __thiscall sub_10002347(_DWORD); // weak
_DWORD __thiscall MatobjInfo::MatobjInfo(MatobjInfo *this); // idb
_DWORD __stdcall BufferedInputStream::operator=(_DWORD); // weak
_DWORD __thiscall GfxobjInfo::GfxobjInfo(GfxobjInfo *this, const struct GfxobjInfo *); // idb
void __thiscall CoreNode::`default constructor closure'(CoreNode *this); // idb
_DWORD __thiscall BufferedStream::BufferedStream(BufferedStream *this, struct RandomAccessStream *, int); // idb
void __thiscall Matrix4f::makeRotate(Matrix4f *this, struct Vector3f *, float); // idb
void Stream::print(Stream *this, char *Format, ...); // idb
_DWORD __thiscall String::String(String *this, char *, int); // idb
_DWORD __thiscall PVWPolygonColourInfo::PVWPolygonColourInfo(PVWPolygonColourInfo *this); // idb
_DWORD __stdcall EditNode::operator=(_DWORD); // weak
float __thiscall Vector3f::squaredLength(Vector3f *this); // idb
_DWORD __thiscall TcpStream::TcpStream(TcpStream *this); // idb
void __thiscall PVWTextureData::read(PVWTextureData *this, struct RandomAccessStream *); // idb
_DWORD __stdcall sub_100023D8(_DWORD); // weak
_DWORD __stdcall BaseScalingSystem::operator=(_DWORD); // weak
int __stdcall sub_100023F1(struct RandomAccessStream *); // idb
float __cdecl distanceTriRect(struct KTri *, struct KRect *, float *, float *, float *, float *); // idb
bool __thiscall Vector3f::isSame(Vector3f *this, struct Vector3f *); // idb
_DWORD __thiscall CullingPlane::CullingPlane(CullingPlane *this); // idb
void __thiscall UIWindow::initFrame(UIWindow *this, struct UIWindow *, int, int, int, bool); // idb
int __thiscall AgeServer::readPropValue(_DWORD, _DWORD, _DWORD); // weak
void __thiscall CullFrustum::calcLookAt(CullFrustum *this, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
int __thiscall CoreNode::getChildCount(CoreNode *this); // idb
_DWORD __thiscall SplitBar::SplitBar(SplitBar *this, struct UIWindow *, struct UIWindow *, COLORREF color, int); // idb
unsigned __int8 __thiscall Texture::getAlpha(Texture *this, int, int); // idb
char *__thiscall CoreNode::Name(CoreNode *this); // idb
void __thiscall UIMgr::RegisterGenWindowClass(UIMgr *this, LPCSTR lpszClass, void *, bool); // idb
_DWORD __thiscall RandomAccessStream::RandomAccessStream(RandomAccessStream *this, const struct RandomAccessStream *); // idb
_DWORD __thiscall ID32::ID32(ID32 *this); // idb
void __thiscall BaseShape::countMaterials(BaseShape *this, struct Joint *, unsigned __int32); // idb
void __thiscall Node::update(Node *this); // idb
_DWORD __stdcall Stream::operator=(_DWORD); // weak
void __thiscall Vector3f::rotate(Vector3f *this, struct Matrix4f *); // idb
_DWORD __stdcall sub_100024BE(_DWORD, _DWORD); // weak
void __thiscall AyuStack::checkStack(AyuStack *this); // idb
void __thiscall DispList::exportData(DispList *this, struct RandomAccessStream *, unsigned __int32); // idb
void __thiscall String::init(String *this, char *); // idb
struct Module *__thiscall ModuleMgr::findModule(ModuleMgr *this, char *); // idb
_DWORD __stdcall sub_10002504(_DWORD); // weak
_DWORD __stdcall sub_10002509(_DWORD, _DWORD, _DWORD); // weak
_DWORD __thiscall BufferedStream::BufferedStream(BufferedStream *this); // idb
_DWORD __thiscall CullFrustum::CullFrustum(CullFrustum *this); // idb
_DWORD __thiscall PVWTextureData::PVWTextureData(PVWTextureData *this); // idb
void __thiscall Vector3f::rotateTo(Vector3f *this, struct Matrix4f *, struct Vector3f *); // idb
int __stdcall sub_1000253B(struct RandomAccessStream *); // idb
_DWORD __thiscall Joint::MatPoly::MatPoly(Joint::MatPoly *this, const struct Joint::MatPoly *); // idb
void __thiscall PVWKeyInfoU8::read(PVWKeyInfoU8 *this, struct RandomAccessStream *); // idb
void __thiscall BoundBox::expandBound(BoundBox *this, struct BoundBox *); // idb
_DWORD __thiscall AppWindow::AppWindow(AppWindow *this, struct UIWindow *, int, int, int, bool); // idb
_DWORD __thiscall Module::~Module(Module *this); // idb
void __thiscall Font::setTexture(Font *this, struct Texture *, int, int); // idb
_DWORD __thiscall AyuHeap::AyuHeap(AyuHeap *this); // idb
void __thiscall Vector3f::rotate(Vector3f *this, struct Quat *); // idb
void __thiscall WSocket::connect(WSocket *this); // idb
_DWORD __thiscall SRTNode::SRTNode(SRTNode *this, char *); // idb
void __thiscall RouteGroup::refresh(RouteGroup *this, struct Graphics *, struct EditNode *); // idb
void __thiscall Plane::reflect(Plane *this, struct Vector3f *); // idb
_DWORD __stdcall LightGroup::operator=(_DWORD); // weak
void __thiscall CoreNode::Next(CoreNode *this, struct CoreNode *); // idb
_DWORD __stdcall AtxStream::operator=(_DWORD); // weak
_DWORD __stdcall GfxObject::operator=(_DWORD); // weak
void __thiscall RenderWindow::initOpenGL(RenderWindow *this); // idb
bool __thiscall System::setVideoMode(bool, int, int, int); // idb
void __thiscall PVWKeyInfoS10::read(PVWKeyInfoS10 *this, struct RandomAccessStream *); // idb
int __thiscall sub_10002603(_DWORD); // weak
_DWORD __thiscall ShpobjInfo::ShpobjInfo(ShpobjInfo *this); // idb
void __thiscall SceneData::getAnimInfo(SceneData *this, struct CmdStream *); // idb
int __thiscall sub_1000261C(_DWORD); // weak
_DWORD __stdcall sub_10002621(_DWORD); // weak
int __thiscall System::getAtxRouter(_DWORD); // weak
_DWORD __thiscall KTri::KTri(KTri *this, const struct KTri *); // idb
int __cdecl sub_10002635(float); // idb
void __thiscall CullFrustum::updateViewPlanes(CullFrustum *this, float, float, float, float); // idb
void __thiscall BaseShape::drawlights(BaseShape *this, struct Graphics *, struct Camera *); // idb
void __thiscall ShortColour::write(ShortColour *this, struct RandomAccessStream *); // idb
void __thiscall AnimData::initData(AnimData *this); // idb
void __thiscall PVWTevInfo::read(PVWTevInfo *this, struct RandomAccessStream *); // idb
_DWORD __stdcall ComboBox::operator=(_DWORD); // weak
float __thiscall Light::calcLightObjRadius(Light *this); // idb
int __cdecl Texture::offsetGXtoGL(int, int, int, int); // idb
void __thiscall AnimDca::getAnimInfo(AnimDca *this, struct CmdStream *); // idb
void __thiscall Vector3f::sub2(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall RenderWindow::clearRender(RenderWindow *this); // idb
void *__thiscall AyuCache::mallocL(AyuCache *this, unsigned __int32); // idb
void __thiscall PVWTevColReg::write(PVWTevColReg *this, struct RandomAccessStream *); // idb
void __thiscall Joint::overrideAnim(Joint *this, struct AnimContext *); // idb
bool __thiscall CmdStream::endOfSection(CmdStream *this); // idb
_DWORD __stdcall Joint::MatPoly::operator=(_DWORD); // weak
void __thiscall AgeServer::StartOptionBox(AgeServer *this, char *, int *, int); // idb
void __thiscall StdSystem::genAge(StdSystem *this, struct AgeServer *); // idb
void __thiscall CoreNode::add(CoreNode *this, struct CoreNode *); // idb
_DWORD __thiscall ControllerMgr::ControllerMgr(ControllerMgr *this, const struct ControllerMgr *); // idb
float __thiscall Vector3f::distance(Vector3f *this, struct Vector3f *); // idb
void __thiscall BaseApp::startAgeServer(BaseApp *this); // idb
bool __thiscall StdSystem::isActive(StdSystem *this); // idb
_DWORD __thiscall TexobjInfo::TexobjInfo(TexobjInfo *this); // idb
void __thiscall RandomAccessStream::padFile(RandomAccessStream *this, unsigned __int32); // idb
_DWORD __thiscall Texture::Texture(Texture *this); // idb
_DWORD __thiscall Quat::Quat(Quat *this); // idb
_DWORD __thiscall CollTriInfo::CollTriInfo(CollTriInfo *this); // idb
void __thiscall CullFrustum::createInvVecs(CullFrustum *this); // idb
_DWORD __thiscall LFlareGroup::LFlareGroup(LFlareGroup *this); // idb
void __thiscall AgeServer::StartGroup(AgeServer *this, char *); // idb
_DWORD __stdcall FaceNode::operator=(_DWORD); // weak
void __thiscall AyuStack::reset(AyuStack *this); // idb
void __thiscall RouteGroup::loadini(RouteGroup *this, struct CmdStream *); // idb
bool __thiscall KRect::inside(KRect *this, struct Vector3f *); // idb
_DWORD __thiscall ControllerMgr::ControllerMgr(ControllerMgr *this); // idb
struct CoreNode *__thiscall CoreNode::Next(CoreNode *this); // idb
void __thiscall AyuCache::init(AyuCache *this, unsigned __int32, unsigned __int32); // idb
_DWORD __stdcall RoutePoint::operator=(_DWORD); // weak
void __thiscall Matrix4f::makeRotate(Matrix4f *this, struct Vector3f *, float, float); // idb
void __thiscall TexAttr::initImage(TexAttr *this); // idb
void __thiscall Colour::write(Colour *this, struct Stream *); // idb
_DWORD __stdcall sub_100027F2(_DWORD, _DWORD); // weak
void __thiscall AgeServer::EndBitGroup(AgeServer *this); // idb
struct LFInfo *__thiscall StdSystem::getLFlareInfo(StdSystem *this); // idb
void __thiscall StdSystem::attachObjs(StdSystem *this); // idb
_DWORD __stdcall sub_10002824(_DWORD, _DWORD); // weak
_DWORD __stdcall BufferedStream::operator=(_DWORD); // weak
void __thiscall CmdStream::init(CmdStream *this, struct Stream *); // idb
void __thiscall BaseShape::skipChunk(BaseShape *this, struct RandomAccessStream *, unsigned __int32); // idb
struct CoreNode *__thiscall CoreNode::Parent(CoreNode *this); // idb
_DWORD __stdcall BaseShape::operator=(_DWORD); // weak
_DWORD __thiscall FaceNode::FaceNode(FaceNode *this, const struct FaceNode *); // idb
struct Vector3f *__thiscall KTri::Edge0(KTri *this); // idb
_DWORD __thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this, const struct BufferedInputStream *); // idb
void __thiscall StdSystem::setDataRoot(StdSystem *this, char *); // idb
int __thiscall UIWindow::processMessage(UIWindow *this, HWND hWnd, unsigned int, unsigned int, int); // idb
_DWORD __thiscall RenderWindow::RenderWindow(RenderWindow *this, struct UIWindow *, int, int, int, bool); // idb
void __thiscall LightGroup::ageChangeTexture(LightGroup *this, struct AgeServer *); // idb
char *__thiscall CoreNode::getName(CoreNode *this); // idb
_DWORD __thiscall LightFlare::LightFlare(LightFlare *this, const struct LightFlare *); // idb
void __thiscall Matrix4f::rotate(Matrix4f *this, float, float, float); // idb
void __thiscall Timers::stop(Timers *this, char *); // idb
void __thiscall BufferedOutputStream::addChar(BufferedOutputStream *this, char); // idb
void __thiscall ObjCollInfo::sectionJointsChange(ObjCollInfo *this, struct AgeServer *); // idb
int __stdcall sub_100028E2(struct RandomAccessStream *); // idb
int __stdcall sub_100028F6(struct RandomAccessStream *); // idb
_DWORD __thiscall CullingPlane::CullingPlane(CullingPlane *this, const struct CullingPlane *); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, char *, int); // idb
_DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD); // weak
void __thiscall PVWLightingInfo::read(PVWLightingInfo *this, struct RandomAccessStream *); // idb
bool __thiscall AtxStream::open(AtxStream *this, char *, int); // idb
void __thiscall TexImg::importTxe(TexImg *this, struct Texture *, struct RandomAccessStream *); // idb
int __stdcall sub_1000293C(struct RandomAccessStream *); // idb
_DWORD __thiscall BaseCollTriInfo::BaseCollTriInfo(BaseCollTriInfo *this); // idb
struct Vector3f *__thiscall KSegment::Origin(KSegment *this); // idb
char *__cdecl String::copy(char *, char *); // idb
int __thiscall String::getLength(String *this); // idb
_DWORD __stdcall sub_1000295F(_DWORD); // weak
void __thiscall Module::Load(Module *this, char *); // idb
bool __thiscall CmdStream::LineIsComment(CmdStream *this); // idb
void __thiscall AnimDck::getAnimInfo(AnimDck *this, struct CmdStream *); // idb
_DWORD __stdcall sub_1000297D(_DWORD); // weak
struct GfxobjInfo *__thiscall StdSystem::findAnyGfxObject(StdSystem *this, char *Str, unsigned __int32); // idb
_DWORD __thiscall RouteLink::RouteLink(RouteLink *this, const struct RouteLink *); // idb
_DWORD __thiscall Joint::Joint(Joint *this); // idb
_DWORD __stdcall AtxRouter::operator=(_DWORD); // weak
_DWORD __thiscall Matrix4f::Matrix4f(Matrix4f *this); // idb
int __stdcall sub_100029AA(struct RandomAccessStream *); // idb
void __thiscall AgeServer::NewNodeWindow(AgeServer *this, char *); // idb
void __thiscall Vector3f::set(Vector3f *this, const float *, const float *, const float *); // idb
void __thiscall StdSystem::addTexture(StdSystem *this, struct Texture *, char *); // idb
_DWORD __stdcall sub_100029E6(_DWORD); // weak
_DWORD __thiscall String::String(String *this); // idb
void __thiscall Texture::createBuffer(Texture *this, int, int, int, void *); // idb
void __thiscall LightFlare::saveini(LightFlare *this, char *, struct RandomAccessStream *); // idb
void __thiscall TexImg::importBti(TexImg *this, struct Texture *, struct RandomAccessStream *, unsigned __int8 *); // idb
void __thiscall Vector3f::scale(Vector3f *this, float); // idb
int __thiscall Font::charToIndex(Font *this, unsigned __int16); // idb
void __thiscall AgeServer::NewBit(AgeServer *this, char *, unsigned __int32, unsigned __int32); // idb
void __thiscall CullFrustum::draw(CullFrustum *this, struct Graphics *); // idb
_DWORD __stdcall sub_10002A2C(_DWORD); // weak
_DWORD __stdcall RouteGroup::operator=(_DWORD); // weak
void __thiscall PVWPolygonColourInfo::read(PVWPolygonColourInfo *this, struct RandomAccessStream *); // idb
struct CoreNode *__thiscall CoreNode::Child(CoreNode *this); // idb
_DWORD __thiscall LightGroup::LightGroup(LightGroup *this); // idb
_DWORD __thiscall EditNode::EditNode(EditNode *this, const struct EditNode *); // idb
_DWORD __stdcall sub_10002A68(_DWORD, _DWORD); // weak
_DWORD __thiscall UIWindow::UIWindow(UIWindow *this, struct UIWindow *, int, int, int, bool); // idb
_DWORD __stdcall sub_10002A72(_DWORD); // weak
_DWORD __stdcall Material::operator=(_DWORD); // weak
int __cdecl sub_10002A81(SIZE_T dwBytes); // idb
AtxStream *__thiscall AtxStream::AtxStream(AtxStream *this);
void __thiscall Light::recalcLighting(Light *this, struct AgeServer *); // idb
_DWORD __thiscall RouteLink::RouteLink(RouteLink *this); // idb
void __thiscall BaseCollTriInfo::read(BaseCollTriInfo *this, struct RandomAccessStream *); // idb
void __thiscall CullFrustum::vectorToWorldPlane(CullFrustum *this, struct Vector3f *, struct CullingPlane *); // idb
_DWORD __thiscall BaseCollTriInfo::BaseCollTriInfo(BaseCollTriInfo *this, const struct BaseCollTriInfo *); // idb
_DWORD __thiscall Quat::Quat(Quat *this, float, float, float, float); // idb
int __cdecl TexImg::calcDataSize(int, int, int); // idb
_DWORD __stdcall sub_10002AD6(_DWORD, _DWORD); // weak
_DWORD __stdcall sub_10002ADB(_DWORD, _DWORD, _DWORD, _DWORD); // weak
bool __cdecl String::isSame(char *, char *); // idb
_DWORD __stdcall sub_10002AE5(_DWORD, _DWORD); // weak
_DWORD __stdcall Texture::operator=(_DWORD); // weak
void __thiscall Controller::initialise(Controller *this, unsigned __int32); // idb
int __stdcall sub_10002B1C(struct RandomAccessStream *); // idb
_DWORD __thiscall BaseShape::BaseShape(BaseShape *this); // idb
_DWORD __thiscall CoreNode::CoreNode(CoreNode *this, const struct CoreNode *); // idb
_DWORD __thiscall CamDataInfo::CamDataInfo(CamDataInfo *this); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, struct Colour *); // idb
_DWORD __thiscall AtxStream::AtxStream(AtxStream *this, const struct AtxStream *); // idb
char *__cdecl String::dup(char *); // idb
_DWORD __thiscall AnimDca::AnimDca(AnimDca *this, struct BaseShape *, int); // idb
_DWORD __thiscall AnimData::AnimData(AnimData *this, char *); // idb
int __thiscall sub_10002B7B(_DWORD); // weak
void __thiscall CachedShape::insertAfter(CachedShape *this, struct CachedShape *); // idb
_DWORD __thiscall RoutePoint::RoutePoint(RoutePoint *this, const struct RoutePoint *); // idb
void __thiscall GameApp::doInitApp(GameApp *this); // idb
void __thiscall Timers::start(Timers *this, char *, bool); // idb
_DWORD __stdcall AgeServer::setOnChange(_DWORD); // weak
int __stdcall sub_10002BB2(struct UIWindow *); // idb
bool __thiscall UIMgr::isActive(UIMgr *this); // idb
void __thiscall TextureCacher::updateInfo(TextureCacher *this, struct CacheTexture *); // idb
void __thiscall CmdStream::fillBuffer(CmdStream *this, bool); // idb
void __thiscall AyuStack::pop(AyuStack *this); // idb
bool __thiscall AgeServer::getSaveFilename(AgeServer *this, struct String *, char *); // idb
void __thiscall WSocket::setASync(WSocket *this, HWND, unsigned __int32, unsigned __int32, int); // idb
_DWORD __stdcall sub_10002BF8(_DWORD); // weak
int __thiscall BaseApp::idleupdate(BaseApp *this); // idb
void __thiscall Matrix4f::makeLookat(Matrix4f *this, struct Vector3f *, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
void __thiscall DataChunk::write(DataChunk *this, struct RandomAccessStream *); // idb
void __thiscall CullFrustum::createVecs(CullFrustum *this); // idb
void __thiscall SRTNode::setRotation(SRTNode *this, struct Vector3f *); // idb
void __thiscall CoreNode::setName(CoreNode *this, char *); // idb
int __thiscall AyuStack::setAllocType(AyuStack *this, int); // idb
void __thiscall Vector3f::add2(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Controller::updateCont(Controller *this, unsigned __int32); // idb
_DWORD __thiscall KTri::KTri(KTri *this); // idb
_DWORD __thiscall RoutePoint::RoutePoint(RoutePoint *this); // idb
void __thiscall PVWTexGenData::read(PVWTexGenData *this, struct RandomAccessStream *); // idb
void __thiscall WSocket::write(WSocket *this, void *, int); // idb
unsigned __int32 __thiscall AyuCache::largestBlockFree(AyuCache *this); // idb
void __thiscall DataChunk::getData(DataChunk *this, struct CmdStream *); // idb
float __cdecl sqrDistance(struct KSegment *, struct KTri *, float *, float *, float *); // idb
int __thiscall sub_10002C98(_DWORD); // weak
_DWORD __thiscall LightGroup::LightGroup(LightGroup *this, const struct LightGroup *); // idb
void __thiscall AtxFileStream::close(AtxFileStream *this); // idb
_DWORD __thiscall RectArea::RectArea(RectArea *this, int, int, int, int); // idb
void __thiscall RouteGroup::updateID(RouteGroup *this); // idb
void __thiscall StdSystem::addAnimation(StdSystem *this, struct AnimData *, char *); // idb
_DWORD __thiscall AnimDck::AnimDck(AnimDck *this, char *); // idb
_DWORD __thiscall FaceNode::FaceNode(FaceNode *this); // idb
void __thiscall Quat::multiply(Quat *this, struct Quat *); // idb
void __thiscall PVWKeyInfoS10::write(PVWKeyInfoS10 *this, struct RandomAccessStream *); // idb
void __thiscall CoreNode::genAge(CoreNode *this, struct AgeServer *); // idb
float __thiscall Vector3f::DP(Vector3f *this, struct Vector3f *); // idb
_DWORD __stdcall sub_10002D15(_DWORD); // weak
float __cdecl triRectDistance(struct Vector3f *, struct Vector3f *, struct Vector3f *, struct BoundBox *, bool); // idb
_DWORD __thiscall DlobjInfo::DlobjInfo(DlobjInfo *this); // idb
_DWORD __stdcall CoreNode::operator=(_DWORD); // weak
bool __thiscall WSocket::open(WSocket *this, char *, int); // idb
void __thiscall PVWTextureInfo::read(PVWTextureInfo *this, struct RandomAccessStream *); // idb
void __thiscall System::sleep(float); // idb
_DWORD __stdcall sub_10002D3D(_DWORD); // weak
int __cdecl sub_10002D47(float); // idb
_DWORD __thiscall RectArea::RectArea(RectArea *this); // idb
int __cdecl String::getLength(char *); // idb
AtxRouter *__thiscall AtxRouter::AtxRouter(AtxRouter *this);
_DWORD __thiscall Shape::Shape(Shape *this); // idb
_DWORD __stdcall sub_10002D74(_DWORD); // weak
_DWORD __stdcall sub_10002D83(_DWORD); // weak
void __thiscall UIFrame::calcFrameFromClient(UIFrame *this, struct RectArea *); // idb
_DWORD __thiscall DataChunk::DataChunk(DataChunk *this); // idb
_DWORD __thiscall TexImg::TexImg(TexImg *this); // idb
_DWORD __thiscall AyuStack::AyuStack(AyuStack *this); // idb
bool __thiscall StdSystem::isShutdown(StdSystem *this); // idb
_DWORD __stdcall UIFrame::operator=(_DWORD); // weak
int __thiscall AppWindow::processMessage(AppWindow *this, HWND hWnd, unsigned int, unsigned int, int); // idb
_DWORD __stdcall sub_10002DC4(_DWORD, _DWORD); // weak
_DWORD __thiscall Vector2f::Vector2f(Vector2f *this, const float *, const float *); // idb
void __thiscall AnimFrameCacher::removeOldest(AnimFrameCacher *this); // idb
void __thiscall PVWCombiner::write(PVWCombiner *this, struct RandomAccessStream *); // idb
void __thiscall WSocket::read(WSocket *this, char *buf, int); // idb
void __thiscall CullingPlane::CheckMinMaxDir(CullingPlane *this); // idb
void __thiscall CullFrustum::createViewPlanes(CullFrustum *this); // idb
void __thiscall Joint::sectionJoint(Joint *this, struct AgeServer *); // idb
void __cdecl WSocket::init(); // idb
int __cdecl sub_10002E2D(Vector3f *, int, int); // idb
void __thiscall Plane::write(Plane *this, struct RandomAccessStream *); // idb
void __thiscall TextureCacher::cacheTexture(TextureCacher *this, struct CacheTexture *); // idb
_DWORD __thiscall SRTNode::SRTNode(SRTNode *this, const struct SRTNode *); // idb
void __thiscall UIFrame::calcClientFromFrame(UIFrame *this, struct RectArea *); // idb
struct CoreNode *System::firstApp();
void __thiscall Colour::write(Colour *this, struct Stream *); // idb
void __thiscall Colour::genAge(Colour *this, struct AgeServer *, char *); // idb
// void __userpurge PVWLightingInfo::read(PVWLightingInfo *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
void __thiscall PVWLightingInfo::write(PVWLightingInfo *this, struct RandomAccessStream *); // idb
AyuStack *__thiscall AyuStack::AyuStack(AyuStack *this);
void __thiscall PVWPolygonColourInfo::animate(PVWPolygonColourInfo *this, float *, struct Colour *); // idb
void __thiscall AyuStack::inactivate(AyuStack *__hidden this); // idb
int __thiscall AyuStack::setAllocType(AyuStack *this, int); // idb
bool __thiscall AyuStack::checkOverflow(AyuStack *__hidden this); // idb
int __thiscall AyuStack::getTopUsed(AyuStack *__hidden this); // idb
int __thiscall AyuStack::getSize(AyuStack *__hidden this); // idb
int __thiscall AyuStack::getUsed(AyuStack *__hidden this); // idb
double __cdecl sub_10005210(float a1, int a2, int a3);
int __thiscall AyuStack::getFree(AyuStack *__hidden this); // idb
int __thiscall AyuStack::getMaxFree(AyuStack *__hidden this); // idb
void *__thiscall AyuStack::operator=(void *this, const void *a2);
AyuStack *__thiscall AyuHeap::AyuHeap(AyuHeap *this);
void __thiscall PVWColourAnimInfo::extract(PVWColourAnimInfo *this, float, struct Colour *); // idb
_DWORD *__thiscall sub_10005B00(_DWORD *this, int a2, int a3, int a4, int a5);
void *__thiscall AyuHeap::operator=(void *this, const void *a2);
_DWORD *__thiscall MemHead::operator=(_DWORD *this, _DWORD *a2);
void *__thiscall AyuCache::operator=(void *this, const void *a2);
bool Stream::getClosing();
void Stream::flush();
Stream *__thiscall Stream::Stream(Stream *this);
Stream *__thiscall Stream::Stream(Stream *this, const struct Stream *a2);
_DWORD *__thiscall Stream::operator=(_DWORD *this, int a2);
int RandomAccessStream::getPosition();
void __stdcall RandomAccessStream::setPosition(int a2);
int __thiscall RandomAccessStream::getLength(RandomAccessStream *__hidden this); // idb
int __thiscall RandomAccessStream::getPending(RandomAccessStream *__hidden this); // idb
void __thiscall RandomAccessStream::padFile(RandomAccessStream *this, unsigned __int32); // idb
void __thiscall RandomAccessStream::padFileTo(RandomAccessStream *this, unsigned __int32, unsigned __int32); // idb
void __thiscall RandomAccessStream::skipPadding(RandomAccessStream *this, unsigned __int32); // idb
RandomAccessStream *__thiscall RandomAccessStream::RandomAccessStream(RandomAccessStream *this);
RandomAccessStream *__thiscall RandomAccessStream::RandomAccessStream(RandomAccessStream *this, const struct RandomAccessStream *a2);
void __thiscall PVWAlphaAnimInfo::extract(PVWAlphaAnimInfo *this, float, struct Colour *); // idb
void *__thiscall RandomAccessStream::operator=(void *this, int a2);
BufferedOutputStream *__thiscall BufferedOutputStream::BufferedOutputStream(BufferedOutputStream *this, struct Stream *a2, SIZE_T dwBytes, bool a4);
void __thiscall BufferedOutputStream::flush(BufferedOutputStream *__hidden this); // idb
void __thiscall BufferedOutputStream::addChar(BufferedOutputStream *this, char); // idb
void __thiscall BufferedOutputStream::write(BufferedOutputStream *this, void *, int); // idb
void __thiscall PVWColourShortAnimInfo::extract(PVWColourShortAnimInfo *this, float, struct ShortColour *); // idb
BufferedOutputStream *__thiscall BufferedOutputStream::BufferedOutputStream(BufferedOutputStream *this, const struct BufferedOutputStream *a2);
_DWORD *__thiscall BufferedOutputStream::operator=(_DWORD *this, int a2);
void __thiscall BufferedInputStream::open(BufferedInputStream *this, struct Stream *); // idb
void __thiscall BufferedInputStream::close(BufferedInputStream *__hidden this); // idb
RandomAccessStream *__thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this);
void __thiscall BufferedInputStream::resetBuffer(BufferedInputStream *__hidden this); // idb
int __thiscall BufferedInputStream::getPosition(BufferedInputStream *__hidden this); // idb
int __thiscall BufferedInputStream::getPending(BufferedInputStream *__hidden this); // idb
RandomAccessStream *__thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this, const struct BufferedInputStream *a2);
void __thiscall PVWAlphaShortAnimInfo::extract(PVWAlphaShortAnimInfo *this, float, struct ShortColour *); // idb
_DWORD *__thiscall BufferedInputStream::operator=(_DWORD *this, _DWORD *a2);
RandomAccessStream *__thiscall BufferedStream::BufferedStream(BufferedStream *this);
void __thiscall BufferedStream::init(BufferedStream *this, struct RandomAccessStream *, int); // idb
RandomAccessStream *__thiscall BufferedStream::BufferedStream(BufferedStream *this, struct RandomAccessStream *a2, int a3);
void __thiscall PVWTexAnimInfo::extract(PVWTexAnimInfo *this, float, struct Vector3f *); // idb
void __thiscall BufferedStream::read(BufferedStream *this, void *, int); // idb
void __thiscall BufferedStream::close(BufferedStream *__hidden this); // idb
int __thiscall BufferedStream::getPosition(BufferedStream *__hidden this); // idb
void __thiscall BufferedStream::setPosition(BufferedStream *this, int); // idb
int __thiscall BufferedStream::getPending(BufferedStream *__hidden this); // idb
int __thiscall BufferedStream::getLength(BufferedStream *__hidden this); // idb
RandomAccessStream *__thiscall BufferedStream::BufferedStream(BufferedStream *this, const struct BufferedStream *a2);
_DWORD *__thiscall BufferedStream::operator=(_DWORD *this, int a2);
RandomAccessStream *__thiscall RamStream::RamStream(RamStream *this, void *a2, int a3);
int __thiscall RamStream::getPending(RamStream *__hidden this); // idb
void __thiscall RamStream::setPosition(RamStream *this, int); // idb
int __thiscall RamStream::getPosition(RamStream *__hidden this); // idb
int __thiscall RamStream::getLength(RamStream *__hidden this); // idb
void __thiscall RamStream::setLength(RamStream *this, int); // idb
void __thiscall RamStream::read(RamStream *this, void *Dst, int); // idb
void __thiscall PVWTextureData::animate(PVWTextureData *this, float *, struct Matrix4f *); // idb
void __thiscall RamStream::write(RamStream *this, void *Src, int); // idb
RandomAccessStream *__thiscall RamStream::RamStream(RamStream *this, const struct RamStream *a2);
_DWORD *__thiscall RamStream::operator=(_DWORD *this, _DWORD *a2);
void __stdcall ANode::genAge(struct AgeServer *a2);
void __stdcall ANode::genAgeNode(struct AgeServer *a2);
int ANode::getAgeNodeType();
ANode *__thiscall ANode::ANode(ANode *this);
ANode *__thiscall ANode::ANode(ANode *this, const struct ANode *a2);
void *__thiscall ANode::operator=(void *this, int a2);
// void __userpurge PVWTextureData::read(PVWTextureData *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
void __thiscall PVWTextureData::write(PVWTextureData *this, struct RandomAccessStream *); // idb
void __cdecl sub_10008EA0(float a1);
void __cdecl sub_10008EF0(float a1, float a2);
void __thiscall PVWTexGenData::read(PVWTexGenData *this, struct RandomAccessStream *); // idb
void __cdecl sub_10009010(float a1);
void __thiscall PVWTexGenData::write(PVWTexGenData *this, struct RandomAccessStream *); // idb
void __thiscall PVWTextureInfo::read(PVWTextureInfo *this, struct RandomAccessStream *); // idb
void __cdecl sub_100093E0(float a1);
Vector2f *__thiscall Vector2f::Vector2f(Vector2f *this);
Vector2f *__thiscall Vector2f::Vector2f(Vector2f *this, const float *a2, const float *a3);
void __thiscall Vector2f::set(Vector2f *this, float, float); // idb
void __thiscall Vector2f::write(Vector2f *this, struct Stream *); // idb
// void __userpurge Vector2f::read(Vector2f *this@<ecx>, double a2@<st0>, struct Stream *a3);
_DWORD *__thiscall Vector2f::operator=(_DWORD *this, _DWORD *a2);
void __thiscall Vector2i::set(Vector2i *this, int, int); // idb
void __thiscall Vector2i::write(Vector2i *this, struct Stream *); // idb
void __thiscall Vector2i::read(Vector2i *this, struct Stream *); // idb
void __thiscall PVWTevColReg::animate(PVWTevColReg *this, float *, struct ShortColour *); // idb
_DWORD *__thiscall Vector2i::operator=(_DWORD *this, _DWORD *a2);
Vector3f *__thiscall Vector3f::Vector3f(Vector3f *this);
Vector3f *__thiscall Vector3f::Vector3f(Vector3f *this, const float *a2, const float *a3, const float *a4);
Vector3f *__thiscall Vector3f::Vector3f(Vector3f *this, const struct Vector3f *a2);
char __thiscall PVWTevInfo::isSame(PVWTevInfo *this, struct PVWTevInfo *a2);
void __thiscall Vector3f::set(Vector3f *this, const float *, const float *, const float *); // idb
void __thiscall Vector3f::set(Vector3f *this, const struct Vector3f *); // idb
bool __thiscall Vector3f::isSame(Vector3f *this, struct Vector3f *); // idb
void __cdecl sub_1000A2B0(float a1);
void __thiscall Vector3f::lerpTo(Vector3f *this, struct Vector3f *, float, struct Vector3f *); // idb
void __thiscall Vector3f::bounce(Vector3f *this, struct Vector3f *, float); // idb
void __thiscall Vector3f::project(Vector3f *this, struct Vector3f *); // idb
void __thiscall Vector3f::sub(Vector3f *this, struct Vector3f *); // idb
void __thiscall Vector3f::sub(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Vector3f::add(Vector3f *this, float, float, float); // idb
void __thiscall Vector3f::add(Vector3f *this, struct Vector3f *); // idb
void __thiscall Vector3f::add(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Vector3f::div(Vector3f *this, float); // idb
void __thiscall Vector3f::multiply(Vector3f *this, float); // idb
double __thiscall Vector3f::length(Vector3f *this);
double __thiscall Vector3f::squaredLength(Vector3f *this);
void Material::attach();
void __thiscall Material::read(Material *this, struct RandomAccessStream *); // idb
double __thiscall Vector3f::normalise(Vector3f *this);
void __thiscall Vector3f::CP(Vector3f *this, struct Vector3f *); // idb
void __thiscall Material::write(Material *this, struct RandomAccessStream *); // idb
double __thiscall Vector3f::DP(Vector3f *this, struct Vector3f *a2);
void __thiscall Vector3f::normalize(Vector3f *__hidden this); // idb
void __thiscall Vector3f::input(Vector3f *this, struct Vector3f *); // idb
void __thiscall Material::genAge(Material *this, struct AgeServer *); // idb
void __thiscall Vector3f::output(Vector3f *this, struct Vector3f *); // idb
void __thiscall Font::setTexture(Font *this, struct Texture *, int, int); // idb
void __thiscall Vector3f::negate(Vector3f *__hidden this); // idb
void __thiscall Vector3f::add2(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Vector3f::sub2(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
double __thiscall Vector3f::dot(Vector3f *this, struct Vector3f *a2);
void __thiscall Vector3f::scale(Vector3f *this, float); // idb
void __thiscall Vector3f::scale2(Vector3f *this, float, struct Vector3f *); // idb
float __thiscall Vector3f::distance(Vector3f *this, struct Vector3f *); // idb
void __thiscall Vector3f::middle(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Vector3f::cross(Vector3f *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Vector3f::write(Vector3f *this, struct Stream *); // idb
// void __userpurge Vector3f::read(Vector3f *this@<ecx>, double a2@<st0>, struct Stream *a3);
_DWORD *__thiscall Vector3f::operator=(_DWORD *this, _DWORD *a2);
int __stdcall Font::charToIndex(char a2);
int __stdcall Font::charToIndex(unsigned __int16 a2);
signed __int16 __cdecl sub_1000BB20(__int16 a1);
int __thiscall Font::stringWidth(Font *this, char *); // idb
void __thiscall GfxInfo::createCollData(GfxInfo *this, struct Vector3f *, float); // idb
Vector3f *__thiscall Quat::Quat(Quat *this);
Quat *__thiscall Quat::Quat(Quat *this, float a2, float a3, float a4, float a5);
void __thiscall Quat::set(Quat *this, float, float, float, float); // idb
Vector3f *__thiscall Quat::Quat(Quat *this, const struct Quat *a2);
_DWORD *__thiscall Quat::operator=(_DWORD *this, _DWORD *a2);
void __thiscall SRT::write(SRT *this, struct RandomAccessStream *); // idb
void __thiscall SRT::read(SRT *this, struct RandomAccessStream *); // idb
void __thiscall MaterialHandler::setMaterial(MaterialHandler *this, struct Material *); // idb
Vector3f *__thiscall SRT::SRT(SRT *this);
void __thiscall MaterialHandler::setTexMatrix(MaterialHandler *this, bool); // idb
Vector3f *__thiscall SRT::SRT(SRT *this, const struct SRT *a2);
Graphics *__thiscall Graphics::Graphics(Graphics *this);
char *__cdecl sub_1000C8A0(char *Format, char a2);
void *__thiscall SRT::operator=(void *this, const void *a2);
void __thiscall Plane::copy(Plane *this, struct Plane *); // idb
void __thiscall Plane::copyInv(Plane *this, struct Plane *); // idb
double __thiscall Plane::dist(Plane *this, struct Vector3f *a2);
BOOL __thiscall Plane::whichSide(Plane *this, struct Vector3f *a2);
void __thiscall Plane::write(Plane *this, struct RandomAccessStream *); // idb
// void __userpurge Plane::read(Plane *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
Vector3f *__thiscall Plane::Plane(Plane *this);
Vector3f *__thiscall Plane::Plane(Plane *this, const struct Plane *a2);
void __thiscall Graphics::initRender(Graphics *this, int, int); // idb
_DWORD *__thiscall Plane::operator=(_DWORD *this, _DWORD *a2);
Plane *__thiscall CullingPlane::CullingPlane(CullingPlane *this);
void __thiscall Graphics::resetMatrixBuffer(Graphics *__hidden this); // idb
Plane *__thiscall CullingPlane::CullingPlane(CullingPlane *this, const struct CullingPlane *a2);
struct Matrix4f *__thiscall Graphics::getMatrices(Graphics *__hidden this, int); // idb
void __noreturn sub_1000D040(char *Format, ...);
void *__thiscall CullingPlane::operator=(void *this, const void *a2);
Vector3f *__thiscall BoundBox::BoundBox(BoundBox *this);
void __thiscall Graphics::resetCacheBuffer(Graphics *__hidden this); // idb
Vector3f *__thiscall BoundBox::BoundBox(BoundBox *this, struct Vector3f *a2, struct Vector3f *a3);
void __thiscall Graphics::cacheShape(Graphics *__hidden this, struct BaseShape *, struct ShapeDynMaterials *); // idb
void __thiscall BoundBox::resetBound(BoundBox *__hidden this); // idb
void __thiscall BoundBox::expandBound(BoundBox *this, struct Vector3f *); // idb
void __thiscall Graphics::flushCachedShapes(Graphics *__hidden this); // idb
void __thiscall BoundBox::expandBound(BoundBox *this, struct BoundBox *); // idb
int __stdcall TexImg::convFormat(unsigned __int32 a2);
char *__stdcall TexImg::formatName(unsigned __int32 a2);
int __cdecl TexImg::calcDataSize(int, int, int); // idb
bool __thiscall BoundBox::intersects(BoundBox *this, struct BoundBox *); // idb
void __thiscall BoundBox::write(BoundBox *this, struct RandomAccessStream *); // idb
void __thiscall BoundBox::read(BoundBox *this, struct RandomAccessStream *); // idb
void __thiscall TexImg::write(TexImg *this, struct RandomAccessStream *); // idb
Vector3f *__thiscall BoundBox::BoundBox(BoundBox *this, const struct BoundBox *a2);
void *__thiscall BoundBox::operator=(void *this, const void *a2);
void __thiscall BaseRoomInfo::write(BaseRoomInfo *this, struct RandomAccessStream *); // idb
void __thiscall BaseRoomInfo::read(BaseRoomInfo *this, struct RandomAccessStream *); // idb
void __thiscall TexImg::setColour(TexImg *this, struct Colour *); // idb
_DWORD *__thiscall BaseRoomInfo::operator=(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall RoomInfo::operator=(_DWORD *this, _DWORD *a2);
CollGroup *__thiscall CollGroup::CollGroup(CollGroup *this);
void *__thiscall CollGroup::operator=(void *this, const void *a2);
void __thiscall TexImg::read(TexImg *this, struct RandomAccessStream *); // idb
void __thiscall BaseCollTriInfo::write(BaseCollTriInfo *this, struct RandomAccessStream *); // idb
void __cdecl TexImg::getTileSize(int, unsigned __int32 *, unsigned __int32 *); // idb
void __thiscall BaseCollTriInfo::read(BaseCollTriInfo *this, struct RandomAccessStream *); // idb
void __thiscall TexImg::readTexData(TexImg *this, struct Texture *, struct RandomAccessStream *, unsigned __int8 *); // idb
BaseCollTriInfo *__thiscall BaseCollTriInfo::BaseCollTriInfo(BaseCollTriInfo *this);
BaseCollTriInfo *__thiscall BaseCollTriInfo::BaseCollTriInfo(BaseCollTriInfo *this, const struct BaseCollTriInfo *a2);
void *__thiscall BaseCollTriInfo::operator=(void *this, const void *a2);
BaseCollTriInfo *__thiscall CollTriInfo::CollTriInfo(CollTriInfo *this);
char __thiscall CollTriInfo::inTriClampTo(CollTriInfo *this, struct Vector3f *a2);
BaseCollTriInfo *__thiscall CollTriInfo::CollTriInfo(CollTriInfo *this, const struct CollTriInfo *a2);
void *__thiscall CollTriInfo::operator=(void *this, const void *a2);
void __thiscall TexImg::dumpBti(TexImg *this, struct Texture *, char *, struct RandomAccessStream *, struct RandomAccessStream *); // idb
int __thiscall sub_1000F070(_BYTE *this, int a2);
int __stdcall sub_1000F380(int a1, int a2, int a3, void (__thiscall *a4)(int));
Vector3f *__thiscall KnotPoint::KnotPoint(KnotPoint *this);
Vector3f *__thiscall KnotPoint::KnotPoint(KnotPoint *this, const struct KnotPoint *a2);
_DWORD *__thiscall KnotPoint::operator=(_DWORD *this, _DWORD *a2);
CurveSection *__thiscall CurveSection::CurveSection(CurveSection *this);
void __thiscall CurveSection::genCurve(CurveSection *this, int); // idb
void __thiscall CurveSection::evaluateAt(CurveSection *this, int, float); // idb
void __thiscall TexImg::importBti(TexImg *this, struct Texture *, struct RandomAccessStream *, unsigned __int8 *); // idb
void *__thiscall CurveSection::operator=(void *this, const void *a2);
void __thiscall TexImg::importTxe(TexImg *this, struct Texture *, struct RandomAccessStream *); // idb
struct Vector3f *__thiscall KTri::Origin(KTri *__hidden this); // idb
struct Vector3f *__thiscall KTri::Edge0(KTri *__hidden this); // idb
struct Vector3f *__thiscall KTri::Edge1(KTri *__hidden this); // idb
Vector3f *__thiscall KTri::KTri(KTri *this, const struct KTri *a2);
void *__thiscall KTri::operator=(void *this, const void *a2);
void __thiscall TexAttr::initImage(TexAttr *__hidden this); // idb
KTri *__thiscall KRect::KRect(KRect *this);
KTri *__thiscall KRect::KRect(KRect *this, const struct KRect *a2);
void *__thiscall KRect::operator=(void *this, const void *a2);
struct Vector3f *__thiscall KSegment::Origin(KSegment *__hidden this); // idb
struct Vector3f *__thiscall KSegment::Direction(KSegment *__hidden this); // idb
Vector3f *__thiscall KSegment::KSegment(KSegment *this, const struct KSegment *a2);
void *__thiscall KSegment::operator=(void *this, const void *a2);
void __thiscall Matrix3f::identity(Matrix3f *__hidden this); // idb
// void __userpurge TexAttr::read(TexAttr *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
Matrix3f *__thiscall Matrix3f::Matrix3f(Matrix3f *this);
Matrix3f *__thiscall Matrix3f::Matrix3f(Matrix3f *this, float (*a2)[3]);
void __thiscall TexAttr::write(TexAttr *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall Matrix3f::Matrix3f(_DWORD *this, int a2);
void __thiscall Graphics::drawCylinder(Graphics *this, struct Vector3f *, struct Vector3f *, float, struct Matrix4f *); // idb
Vector3f *__cdecl sub_10010C40(Vector3f *a1, int a2, int a3);
Vector3f *__cdecl sub_10010CE0(Vector3f *a1, int a2, int a3);
Vector3f *__cdecl sub_10010D80(Vector3f *a1, int a2, int a3);
void *__thiscall Matrix3f::Matrix3f(void *this, int a2, int a3);
float *__thiscall Matrix3f::operator+=(float *this, int a2);
int __thiscall Matrix3f::operator()(char *this, int a2, int a3);
int __thiscall Matrix3f::operator()(char *this, int a2, int a3);
double __thiscall Matrix3f::GetElement(Matrix3f *this, int a2, int a3);
void __thiscall Graphics::drawCircle(Graphics *this, struct Vector3f *, float, struct Matrix4f *); // idb
struct Matrix3f *__thiscall Matrix3f::SetElement(Matrix3f *this, int, int, float); // idb
void *__thiscall Matrix3f::Matrix3f(void *this, int a2);
void *__thiscall Matrix3f::operator=(void *this, const void *a2);
void __thiscall Graphics::drawSphere(Graphics *this, struct Vector3f *, float, struct Matrix4f *); // idb
void Graphics::perspPrintf(Graphics *this, struct Font *, struct Vector3f *, int, int, char *Format, ...); // idb
int __thiscall Graphics::calcLighting(Graphics *this, float); // idb
int __thiscall Graphics::calcSphereLighting(Graphics *this, struct Vector3f *, float); // idb
int __thiscall Graphics::calcBoxLighting(Graphics *this, struct BoundBox *); // idb
Matrix4f *__thiscall Matrix4f::Matrix4f(Matrix4f *this);
void __thiscall Matrix4f::makeBillVector(Matrix4f *this, struct Vector3f *, struct Matrix4f *, struct Vector3f *); // idb
void __thiscall Matrix4f::rotate(Matrix4f *this, struct Vector3f *); // idb
void __thiscall Matrix4f::makeSRT(Matrix4f *this, char a2, int a3, int a4, char a5, int a6, int a7, char a8, int a9, int a10);
void __thiscall CacheTexture::makeResident(CacheTexture *__hidden this); // idb
void __thiscall Matrix4f::setTranslation(Matrix4f *this, struct Vector3f *); // idb
void __thiscall Matrix4f::setTranslation(Matrix4f *this, float, float, float); // idb
int __thiscall sub_10012550(_DWORD *this, struct RandomAccessStream *a2);
void __thiscall Matrix4f::getRow(Matrix4f *this, int, struct Vector3f *); // idb
void __thiscall Matrix4f::getColumn(Matrix4f *this, int, struct Vector3f *); // idb
int __thiscall sub_10012710(_DWORD *this, struct RandomAccessStream *a2);
void *__thiscall Matrix4f::operator=(void *this, const void *a2);
BaseScalingSystem *__thiscall BaseScalingSystem::BaseScalingSystem(BaseScalingSystem *this);
BaseScalingSystem *__thiscall BaseScalingSystem::BaseScalingSystem(BaseScalingSystem *this, const struct BaseScalingSystem *a2);
void *__thiscall BaseScalingSystem::operator=(void *this, int a2);
void ClassicScalingSystem::blah();
BaseScalingSystem *__thiscall ClassicScalingSystem::ClassicScalingSystem(ClassicScalingSystem *this);
BaseScalingSystem *__thiscall ClassicScalingSystem::ClassicScalingSystem(ClassicScalingSystem *this, const struct ClassicScalingSystem *a2);
void *__thiscall ClassicScalingSystem::operator=(void *this, int a2);
void SoftImageScalingSystem::blah();
BaseScalingSystem *__thiscall SoftImageScalingSystem::SoftImageScalingSystem(SoftImageScalingSystem *this);
BaseScalingSystem *__thiscall SoftImageScalingSystem::SoftImageScalingSystem(SoftImageScalingSystem *this, const struct SoftImageScalingSystem *a2);
void *__thiscall SoftImageScalingSystem::operator=(void *this, int a2);
CoreNode *__thiscall CoreNode::CoreNode(CoreNode *this, char *a2);
void __thiscall CoreNode::initCore(CoreNode *this, char *); // idb
void __thiscall CoreNode::setName(CoreNode *this, char *); // idb
char *__thiscall CoreNode::getName(CoreNode *__hidden this); // idb
char *__thiscall CoreNode::Name(CoreNode *this); // idb
struct CoreNode *__thiscall CoreNode::Parent(CoreNode *__hidden this); // idb
struct CoreNode *__thiscall CoreNode::Next(CoreNode *__hidden this); // idb
void __thiscall CoreNode::Next(CoreNode *this, struct CoreNode *); // idb
struct CoreNode *__thiscall CoreNode::Child(CoreNode *__hidden this); // idb
void __thiscall CoreNode::Child(CoreNode *this, struct CoreNode *); // idb
void __stdcall CoreNode::write(struct RandomAccessStream *a2);
void __stdcall CoreNode::read(struct RandomAccessStream *a2);
ANode *__thiscall CoreNode::CoreNode(CoreNode *this, const struct CoreNode *a2);
CoreNode *__thiscall CoreNode::operator=(CoreNode *this, _DWORD *a2);
void __thiscall CoreNode::`default constructor closure'(CoreNode *__hidden this); // idb
Node *__thiscall Node::Node(Node *this, char *a2);
BOOL __thiscall Node::getFlag(Node *this, int a2);
void __thiscall Node::setFlag(Node *this, int, bool); // idb
void __thiscall Node::setFlag(Node *this, int); // idb
void __thiscall Node::clearFlag(Node *this, int); // idb
void __thiscall Node::togFlag(Node *this, int); // idb
int __thiscall Node::getFlags(Node *__hidden this); // idb
void __thiscall Node::setFlags(Node *this, int); // idb
void __thiscall Node::setType(Node *this, int); // idb
int __thiscall Node::getType(Node *__hidden this); // idb
void Node::concat();
void __thiscall Node::concat(Node *this, struct VQS *); // idb
void __thiscall Node::concat(Node *this, struct SRT *); // idb
void __thiscall Node::concat(Node *this, struct Matrix4f *); // idb
struct Matrix4f *Node::getModelMatrix();
CoreNode *__thiscall Node::Node(Node *this, const struct Node *a2);
Node *__thiscall Node::operator=(Node *this, _DWORD *a2);
void __thiscall Node::`default constructor closure'(Node *__hidden this); // idb
void __thiscall SRTNode::setPosition(SRTNode *this, struct Vector3f *); // idb
struct Vector3f *__thiscall SRTNode::getPosition(SRTNode *__hidden this); // idb
void __thiscall SRTNode::setScale(SRTNode *this, struct Vector3f *); // idb
struct Vector3f *__thiscall SRTNode::getScale(SRTNode *__hidden this); // idb
void __thiscall SRTNode::setRotation(SRTNode *this, struct Vector3f *); // idb
struct Vector3f *__thiscall SRTNode::getRotation(SRTNode *__hidden this); // idb
void __stdcall SRTNode::concat(struct Matrix4f *a2);
void SRTNode::concat();
struct Matrix4f *__thiscall SRTNode::getModelMatrix(SRTNode *__hidden this); // idb
struct Vector3f *__thiscall SRTNode::getWorldPosition(SRTNode *__hidden this); // idb
void __thiscall sub_10013890(int *this, struct RandomAccessStream *a2);
SRTNode *__thiscall SRTNode::SRTNode(SRTNode *this, const struct SRTNode *a2);
char *__thiscall SRTNode::operator=(char *this, int a2);
void __thiscall sub_10013A40(_DWORD *this, struct RandomAccessStream *a2);
void __thiscall SRTNode::`default constructor closure'(SRTNode *__hidden this); // idb
SRTNode *__thiscall ObjMgr::ObjMgr(ObjMgr *this);
SRTNode *__thiscall ObjMgr::ObjMgr(ObjMgr *this, const struct ObjMgr *a2);
void *__thiscall ObjMgr::operator=(void *this, int a2);
struct CoreNode *__thiscall NodeMgr::firstNode(struct_this_1 *this); // idb
NodeMgr *__thiscall NodeMgr::NodeMgr(NodeMgr *this, const struct NodeMgr *a2);
_BYTE *__thiscall NodeMgr::operator=(_BYTE *this, _BYTE *a2);
CoreNode *__thiscall EditNode::EditNode(EditNode *this, char *a2);
void __stdcall EditNode::msgCommand(struct DataMsg *a2);
void __stdcall EditNode::render2d(struct Graphics *a2, int *a3);
CoreNode *__thiscall EditNode::EditNode(EditNode *this, const struct EditNode *a2);
void *__thiscall EditNode::operator=(void *this, int a2);
_DWORD *__thiscall ID32::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall MemInfoNode::MemInfoNode(MemInfoNode *this);
CoreNode *__thiscall MemInfoNode::MemInfoNode(MemInfoNode *this, const struct MemInfoNode *a2);
_DWORD *__thiscall MemInfoNode::operator=(_DWORD *this, int a2);
RectArea *__thiscall RectArea::RectArea(RectArea *this);
RectArea *__thiscall RectArea::RectArea(RectArea *this, int a2, int a3, int a4, int a5);
int __thiscall RectArea::width(RectArea *__hidden this); // idb
int __thiscall RectArea::height(RectArea *__hidden this); // idb
void __thiscall RectArea::set(RectArea *this, int, int, int, int); // idb
bool __thiscall RectArea::pointInside(RectArea *this, int, int); // idb
_DWORD *__thiscall RectArea::operator=(_DWORD *this, _DWORD *a2);
GfxobjInfo *__thiscall GfxobjInfo::GfxobjInfo(GfxobjInfo *this);
void GfxobjInfo::attach();
void GfxobjInfo::detach();
void __thiscall GfxobjInfo::insertAfter(GfxobjInfo *this, struct GfxobjInfo *); // idb
void __thiscall GfxobjInfo::remove(GfxobjInfo *__hidden this); // idb
GfxobjInfo *__thiscall GfxobjInfo::GfxobjInfo(GfxobjInfo *this, const struct GfxobjInfo *a2);
_DWORD *__thiscall GfxobjInfo::operator=(_DWORD *this, _DWORD *a2);
void GfxObject::attach();
void GfxObject::detach();
GfxObject *__thiscall GfxObject::GfxObject(GfxObject *this);
GfxObject *__thiscall GfxObject::GfxObject(GfxObject *this, const struct GfxObject *a2);
void *__thiscall GfxObject::operator=(void *this, int a2);
GfxobjInfo *__thiscall FntobjInfo::FntobjInfo(FntobjInfo *this);
GfxobjInfo *__thiscall FntobjInfo::FntobjInfo(FntobjInfo *this, const struct FntobjInfo *a2);
_DWORD *__thiscall FntobjInfo::operator=(_DWORD *this, int a2);
GfxobjInfo *__thiscall ShpobjInfo::ShpobjInfo(ShpobjInfo *this);
GfxobjInfo *__thiscall ShpobjInfo::ShpobjInfo(ShpobjInfo *this, const struct ShpobjInfo *a2);
_DWORD *__thiscall ShpobjInfo::operator=(_DWORD *this, int a2);
GfxobjInfo *__thiscall AnmobjInfo::AnmobjInfo(AnmobjInfo *this);
GfxobjInfo *__thiscall AnmobjInfo::AnmobjInfo(AnmobjInfo *this, const struct AnmobjInfo *a2);
_DWORD *__thiscall AnmobjInfo::operator=(_DWORD *this, int a2);
GfxobjInfo *__thiscall BinobjInfo::BinobjInfo(BinobjInfo *this);
GfxobjInfo *__thiscall BinobjInfo::BinobjInfo(BinobjInfo *this, const struct BinobjInfo *a2);
_DWORD *__thiscall BinobjInfo::operator=(_DWORD *this, int a2);
GfxobjInfo *__thiscall TexobjInfo::TexobjInfo(TexobjInfo *this);
void __thiscall TexobjInfo::attach(TexobjInfo *__hidden this); // idb
void __thiscall TexobjInfo::detach(TexobjInfo *__hidden this); // idb
GfxobjInfo *__thiscall TexobjInfo::TexobjInfo(TexobjInfo *this, const struct TexobjInfo *a2);
_DWORD *__thiscall TexobjInfo::operator=(_DWORD *this, int a2);
void __thiscall CacheInfo::insertAfter(CacheInfo *this, struct CacheInfo *); // idb
void __thiscall CacheInfo::remove(CacheInfo *__hidden this); // idb
void *__thiscall CacheInfo::operator=(void *this, const void *a2);
TexCacheInfo *__thiscall TexCacheInfo::TexCacheInfo(TexCacheInfo *this);
void __thiscall TexCacheInfo::initData(TexCacheInfo *__hidden this); // idb
void *__thiscall TexCacheInfo::operator=(void *this, const void *a2);
TexCacheInfo *__thiscall TextureCacher::TextureCacher(TextureCacher *this, unsigned __int32 a2);
void *__thiscall TextureCacher::operator=(void *this, const void *a2);
void __thiscall StdSystem::set2DRoot(StdSystem *this, char *, char *); // idb
void __thiscall StdSystem::setDataRoot(StdSystem *this, char *); // idb
int __thiscall StdSystem::getHeapNum(StdSystem *__hidden this); // idb
void __thiscall StdSystem::setFade(StdSystem *this, float, float); // idb
double __thiscall StdSystem::getFade(StdSystem *this);
double __stdcall StdSystem::getRand(float a2);
double __stdcall StdSystem::getHalfRand(float a2);
void __thiscall StdSystem::setFrameClamp(StdSystem *this, int); // idb
void __thiscall StdSystem::softReset(StdSystem *__hidden this); // idb
bool __thiscall StdSystem::resetPending(StdSystem *__hidden this); // idb
struct RandomAccessStream *__stdcall StdSystem::openFile(char *a2, bool a3, bool a4);
unsigned __int32 __stdcall StdSystem::copyRamToCache(unsigned __int32 a2, unsigned __int32 a3, unsigned __int32 a4);
void __stdcall StdSystem::copyCacheToRam(unsigned __int32 a2, unsigned __int32 a3, unsigned __int32 a4);
void StdSystem::copyWaitUntilDone();
void __stdcall StdSystem::copyCacheToTexture(struct CacheTexture *a2);
void __thiscall StdSystem::Shutdown(StdSystem *__hidden this); // idb
bool __thiscall StdSystem::isShutdown(StdSystem *__hidden this); // idb
void __stdcall StdSystem::Activate(bool a2);
void __thiscall StdSystem::setActive(StdSystem *this, bool); // idb
BOOL __thiscall StdSystem::isActive(StdSystem *this);
void __thiscall StdSystem::setTextureBase(StdSystem *this, char *, char *); // idb
void __stdcall StdSystem::parseArchiveDirectory(char *a2, char *a3);
void __stdcall StdSystem::startLoading(struct LoadIdler *a2, bool a3, unsigned __int32 a4);
void StdSystem::endLoading();
StdSystem *__thiscall StdSystem::StdSystem(StdSystem *this, const struct StdSystem *a2);
int __thiscall StdSystem::operator=(int this, int a2);
ControllerMgr *__thiscall ControllerMgr::ControllerMgr(ControllerMgr *this);
BOOL __thiscall ControllerMgr::keyDown(ControllerMgr *this, int a2);
ControllerMgr *__thiscall ControllerMgr::ControllerMgr(ControllerMgr *this, const struct ControllerMgr *a2);
_BYTE *__thiscall ControllerMgr::operator=(_BYTE *this, int a2);
void AtxRouter::lock();
void AtxRouter::unlock();
void AtxRouter::closeAll();
bool AtxRouter::isConnected();
void __stdcall AtxRouter::setWindow(unsigned __int32 a2);
AtxRouter *__thiscall AtxRouter::AtxRouter(AtxRouter *this);
AtxRouter *__thiscall AtxRouter::AtxRouter(AtxRouter *this, const struct AtxRouter *a2);
void *__thiscall AtxRouter::operator=(void *this, int a2);
AtxStream *__thiscall AtxStream::AtxStream(AtxStream *this);
void __thiscall AtxStream::init(AtxStream *__hidden this); // idb
AtxStream *__thiscall AtxStream::AtxStream(AtxStream *this, const struct AtxStream *a2);
_DWORD *__thiscall AtxStream::operator=(_DWORD *this, int a2);
AtxStream *__thiscall AtxCommandStream::AtxCommandStream(AtxCommandStream *this, struct BaseApp *a2);
AtxStream *__thiscall AtxCommandStream::AtxCommandStream(AtxCommandStream *this, const struct AtxCommandStream *a2);
_DWORD *__thiscall AtxCommandStream::operator=(_DWORD *this, int a2);
int __thiscall AtxFileStream::getPending(AtxFileStream *__hidden this); // idb
int __thiscall AtxFileStream::getPosition(AtxFileStream *__hidden this); // idb
int __thiscall AtxFileStream::getLength(AtxFileStream *__hidden this); // idb
void __thiscall AtxFileStream::setLength(AtxFileStream *this, int); // idb
RandomAccessStream *__thiscall AtxFileStream::AtxFileStream(AtxFileStream *this);
RandomAccessStream *__thiscall AtxFileStream::AtxFileStream(AtxFileStream *this, const struct AtxFileStream *a2);
_DWORD *__thiscall AtxFileStream::operator=(_DWORD *this, int a2);
void System::beginRender();
void System::doneRender();
void System::waitRetrace();
int __thiscall System::setStreamType(int this, int a2);
int __thiscall System::getAtxRouter(_DWORD *this);
void __thiscall System::setAtxRouter(struct AtxRouter *this, int a2);
double __thiscall System::getFrameRate(float *this);
double __thiscall System::getFrameTime(float *this);
int __thiscall System::getFrameCount(_DWORD *this);
void __stdcall System::sndPlaySe(int a2);
StdSystem *__thiscall System::System(const struct System *this, struct StdSystem *a2);
System *__thiscall System::operator=(System *this, int a2);
CoreNode *__thiscall LinkedRoomInfo::LinkedRoomInfo(LinkedRoomInfo *this);
CoreNode *__thiscall LinkedRoomInfo::LinkedRoomInfo(LinkedRoomInfo *this, const struct LinkedRoomInfo *a2);
_DWORD *__thiscall LinkedRoomInfo::operator=(_DWORD *this, int a2);
void *__thiscall CmdStream::operator=(void *this, const void *a2);
CullFrustum *__thiscall CullFrustum::CullFrustum(CullFrustum *this);
void __thiscall CullFrustum::projectVector(CullFrustum *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall CullFrustum::setBoundOffset(CullFrustum *this, struct Vector3f *); // idb
int __thiscall CullFrustum::isBoundVisible(CullFrustum *this, struct BoundBox *, int); // idb
CullFrustum *__thiscall CullFrustum::CullFrustum(CullFrustum *this, const struct CullFrustum *a2);
void *__thiscall CullFrustum::operator=(void *this, const void *a2);
void __thiscall Camera::rightDir(Camera *this, struct Vector3f *); // idb
void __thiscall Camera::upDir(Camera *this, struct Vector3f *); // idb
void __thiscall Camera::lookDir(Camera *this, struct Vector3f *); // idb
CullFrustum *__thiscall Camera::Camera(Camera *this, const struct Camera *a2);
void *__thiscall Camera::operator=(void *this, const void *a2);
Camera *__thiscall LightCamera::LightCamera(LightCamera *this);
Camera *__thiscall LightCamera::LightCamera(LightCamera *this, const struct LightCamera *a2);
void *__thiscall LightCamera::operator=(void *this, const void *a2);
Colour *__thiscall Colour::Colour(Colour *this);
Colour *__thiscall Colour::Colour(Colour *this, char a2, char a3, char a4, unsigned __int8 a5);
void __thiscall Colour::set(Colour *this, char, char, char, unsigned __int8); // idb
void __thiscall Colour::add(Colour *this, struct Colour *); // idb
void __thiscall Colour::lerp(Colour *this, struct Colour *, float); // idb
void __thiscall Colour::lerpTo(Colour *this, struct Colour *, float, struct Colour *); // idb
void __thiscall Colour::read(Colour *this, struct Stream *); // idb
_DWORD *__thiscall Colour::operator=(_DWORD *this, _DWORD *a2);
void __thiscall ShortColour::read(ShortColour *this, struct RandomAccessStream *); // idb
void __thiscall ShortColour::write(ShortColour *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall ShortColour::operator=(_DWORD *this, _DWORD *a2);
FontChar *__thiscall FontChar::FontChar(FontChar *this);
void *__thiscall FontChar::operator=(void *this, const void *a2);
int __thiscall Font::stringHeight(Font *this, char *); // idb
_DWORD *__thiscall Font::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall LightFlare::LightFlare(LightFlare *this);
CoreNode *__thiscall LightFlare::LightFlare(LightFlare *this, const struct LightFlare *a2);
_DWORD *__thiscall LightFlare::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall LightGroup::LightGroup(LightGroup *this);
void __thiscall LightGroup::addLight(LightGroup *this, struct Vector3f *, float); // idb
CoreNode *__thiscall LightGroup::LightGroup(LightGroup *this, const struct LightGroup *a2);
_DWORD *__thiscall LightGroup::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall Light::Light(Light *this, const struct Light *a2);
_DWORD *__thiscall Light::operator=(_DWORD *this, _DWORD *a2);
void __stdcall DynCollObject::adjust(struct Creature *a2);
void __stdcall DynCollObject::applyVelocity(struct Plane *a2, struct Vector3f *a3, struct Vector3f *a4);
void __stdcall DynCollObject::touchCallback(struct Plane *a2, struct Vector3f *a3, struct Vector3f *a4);
struct Shape *DynCollObject::getShape();
DynCollObject *__thiscall DynCollObject::DynCollObject(DynCollObject *this);
DynCollObject *__thiscall DynCollObject::DynCollObject(DynCollObject *this, const struct DynCollObject *a2);
_DWORD *__thiscall DynCollObject::operator=(_DWORD *this, _DWORD *a2);
// void __userpurge PVWKeyInfoU8::read(PVWKeyInfoU8 *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
void __thiscall PVWKeyInfoU8::write(PVWKeyInfoU8 *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall PVWKeyInfoU8::operator=(_DWORD *this, _DWORD *a2);
// void __userpurge PVWKeyInfoS10::read(PVWKeyInfoS10 *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
bool __thiscall PVWKeyInfoS10::isSame(PVWKeyInfoS10 *this, struct PVWKeyInfoS10 *); // idb
void __thiscall PVWKeyInfoS10::write(PVWKeyInfoS10 *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall PVWKeyInfoS10::operator=(_DWORD *this, _DWORD *a2);
// void __userpurge PVWKeyInfoF32::read(PVWKeyInfoF32 *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
void __thiscall PVWKeyInfoF32::write(PVWKeyInfoF32 *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall PVWKeyInfoF32::operator=(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall PVWTexAnimInfo::operator=(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall PVWColourAnimInfo::operator=(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall PVWAlphaAnimInfo::operator=(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall PVWColourShortAnimInfo::operator=(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall PVWAlphaShortAnimInfo::operator=(_DWORD *this, _DWORD *a2);
Colour *__thiscall PVWPolygonColourInfo::PVWPolygonColourInfo(PVWPolygonColourInfo *this);
// void __userpurge PVWPolygonColourInfo::read(PVWPolygonColourInfo *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
int __thiscall sub_10019E00(_DWORD *this, struct RandomAccessStream *a2);
unsigned int __thiscall sub_10019ED0(unsigned int *this, struct RandomAccessStream *a2);
void __thiscall sub_10019FA0(int *this, struct RandomAccessStream *a2);
void __thiscall sub_1001A040(int *this, struct RandomAccessStream *a2);
void __thiscall PVWPolygonColourInfo::write(PVWPolygonColourInfo *this, struct RandomAccessStream *); // idb
int __thiscall sub_1001A170(_DWORD *this, struct RandomAccessStream *a2);
int __thiscall sub_1001A210(_DWORD *this, struct RandomAccessStream *a2);
void __thiscall sub_1001A2B0(_DWORD *this, struct RandomAccessStream *a2);
void __thiscall sub_1001A350(_DWORD *this, struct RandomAccessStream *a2);
void *__thiscall PVWPolygonColourInfo::operator=(void *this, const void *a2);
PVWLightingInfo *__thiscall PVWLightingInfo::PVWLightingInfo(PVWLightingInfo *this);
_DWORD *__thiscall PVWLightingInfo::operator=(_DWORD *this, _DWORD *a2);
void __thiscall PVWPeInfo::read(PVWPeInfo *this, struct RandomAccessStream *); // idb
void __thiscall PVWPeInfo::write(PVWPeInfo *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall PVWPeInfo::operator=(_DWORD *this, _DWORD *a2);
PVWTextureData *__thiscall PVWTextureData::PVWTextureData(PVWTextureData *this);
void *__thiscall PVWTextureData::operator=(void *this, const void *a2);
_DWORD *__thiscall PVWTexGenData::operator=(_DWORD *this, _DWORD *a2);
Vector3f *__thiscall PVWTextureInfo::PVWTextureInfo(PVWTextureInfo *this);
void __thiscall PVWTextureInfo::write(PVWTextureInfo *this, struct RandomAccessStream *); // idb
Vector3f *__thiscall PVWTextureInfo::PVWTextureInfo(PVWTextureInfo *this, const struct PVWTextureInfo *a2);
void *__thiscall PVWTextureInfo::operator=(void *this, const void *a2);
void __thiscall PVWCombiner::read(PVWCombiner *this, struct RandomAccessStream *); // idb
void __thiscall PVWCombiner::write(PVWCombiner *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall PVWCombiner::operator=(_DWORD *this, _DWORD *a2);
void __thiscall PVWTevStage::read(PVWTevStage *this, struct RandomAccessStream *); // idb
void __thiscall PVWTevStage::write(PVWTevStage *this, struct RandomAccessStream *); // idb
void *__thiscall PVWTevStage::operator=(void *this, const void *a2);
PVWTevColReg *__thiscall PVWTevColReg::PVWTevColReg(PVWTevColReg *this);
// void __userpurge PVWTevColReg::read(PVWTevColReg *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
int __thiscall sub_1001B240(_DWORD *this, struct RandomAccessStream *a2);
unsigned int __thiscall sub_1001B310(unsigned int *this, struct RandomAccessStream *a2);
void __thiscall sub_1001B3E0(int *this, struct RandomAccessStream *a2);
void __thiscall sub_1001B480(int *this, struct RandomAccessStream *a2);
bool __thiscall PVWTevColReg::isSame(PVWTevColReg *this, struct PVWTevColReg *); // idb
char __thiscall sub_1001B5F0(unsigned int *this, _DWORD *a2);
char __thiscall sub_1001B6B0(unsigned int *this, _DWORD *a2);
bool __thiscall sub_1001B770(_DWORD *this, _DWORD *a2);
bool __thiscall sub_1001B830(_DWORD *this, _DWORD *a2);
void __thiscall PVWTevColReg::write(PVWTevColReg *this, struct RandomAccessStream *); // idb
int __thiscall sub_1001B970(_DWORD *this, struct RandomAccessStream *a2);
int __thiscall sub_1001BA10(_DWORD *this, struct RandomAccessStream *a2);
void __thiscall sub_1001BAB0(_DWORD *this, struct RandomAccessStream *a2);
void __thiscall sub_1001BB50(_DWORD *this, struct RandomAccessStream *a2);
void *__thiscall PVWTevColReg::operator=(void *this, const void *a2);
void __thiscall PVWTevInfo::read(PVWTevInfo *this, struct RandomAccessStream *); // idb
void __thiscall PVWTevInfo::write(PVWTevInfo *this, struct RandomAccessStream *); // idb
PVWTevInfo *__thiscall PVWTevInfo::PVWTevInfo(PVWTevInfo *this);
void *__thiscall PVWTevInfo::operator=(void *this, const void *a2);
Material *__thiscall Material::Material(Material *this);
void __thiscall Material::setColour(Material *this, struct Colour *); // idb
void __thiscall Material::getColour(Material *this, struct Colour *); // idb
struct Colour *__thiscall Material::Colour(Material *__hidden this); // idb
Material *__thiscall Material::Material(Material *this, const struct Material *a2);
_DWORD *__thiscall Material::operator=(_DWORD *this, _DWORD *a2);
LodInfo *__thiscall LodInfo::LodInfo(LodInfo *this);
void *__thiscall LodInfo::operator=(void *this, const void *a2);
BoundBox *__thiscall GfxInfo::GfxInfo(GfxInfo *this);
BoundBox *__thiscall GfxInfo::GfxInfo(GfxInfo *this, const struct GfxInfo *a2);
void *__thiscall GfxInfo::operator=(void *this, const void *a2);
AnimJoint *__thiscall AnimJoint::AnimJoint(AnimJoint *this);
void *__thiscall AnimJoint::operator=(void *this, const void *a2);
AnimPalette *__thiscall AnimPalette::AnimPalette(AnimPalette *this, int a2, int a3);
void *__thiscall AnimPalette::operator=(void *this, const void *a2);
String *__thiscall String::String(String *this);
String *__thiscall String::String(String *this, int a2);
String *__thiscall String::String(String *this, char *a2, int a3);
void __thiscall String::init(String *this, char *); // idb
void __thiscall String::init(String *this, int); // idb
void __thiscall String::init(String *this, char *, int); // idb
bool __cdecl String::equals(char *, char *); // idb
bool __thiscall String::isSame(String *this, struct String *); // idb
bool __cdecl String::contains(char *, char); // idb
bool __thiscall String::contains(String *this, char *); // idb
char *__thiscall String::dup(String *__hidden this); // idb
bool __cdecl String::isWhiteSpace(char); // idb
_DWORD *__thiscall String::operator=(_DWORD *this, _DWORD *a2);
Envelope *__thiscall Envelope::Envelope(Envelope *this);
_DWORD *__thiscall Envelope::operator=(_DWORD *this, _DWORD *a2);
void __thiscall VtxMatrix::read(VtxMatrix *this, struct RandomAccessStream *); // idb
void __thiscall VtxMatrix::write(VtxMatrix *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall VtxMatrix::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall FaceNode::FaceNode(FaceNode *this);
CoreNode *__thiscall FaceNode::FaceNode(FaceNode *this, int a2);
CoreNode *__thiscall FaceNode::FaceNode(FaceNode *this, const struct FaceNode *a2);
_DWORD *__thiscall FaceNode::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall DispList::DispList(DispList *this);
CoreNode *__thiscall DispList::DispList(DispList *this, int a2);
CoreNode *__thiscall DispList::DispList(DispList *this, const struct DispList *a2);
_DWORD *__thiscall DispList::operator=(_DWORD *this, _DWORD *a2);
GfxobjInfo *__thiscall MatobjInfo::MatobjInfo(MatobjInfo *this);
void __thiscall MatobjInfo::attach(MatobjInfo *__hidden this); // idb
void MatobjInfo::detach();
GfxobjInfo *__thiscall MatobjInfo::MatobjInfo(MatobjInfo *this, const struct MatobjInfo *a2);
_DWORD *__thiscall MatobjInfo::operator=(_DWORD *this, int a2);
GfxobjInfo *__thiscall DlobjInfo::DlobjInfo(DlobjInfo *this);
void DlobjInfo::attach();
void __thiscall DlobjInfo::detach(DlobjInfo *__hidden this); // idb
GfxobjInfo *__thiscall DlobjInfo::DlobjInfo(DlobjInfo *this, const struct DlobjInfo *a2);
_DWORD *__thiscall DlobjInfo::operator=(_DWORD *this, int a2);
MtxGroup *__thiscall MtxGroup::MtxGroup(MtxGroup *this);
_DWORD *__thiscall MtxGroup::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall Mesh::Mesh(Mesh *this);
CoreNode *__thiscall Mesh::Mesh(Mesh *this, const struct Mesh *a2);
_DWORD *__thiscall Mesh::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall ObjCollInfo::ObjCollInfo(ObjCollInfo *this);
CoreNode *__thiscall ObjCollInfo::ObjCollInfo(ObjCollInfo *this, const struct ObjCollInfo *a2);
_DWORD *__thiscall ObjCollInfo::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall Joint::MatPoly::MatPoly(Joint::MatPoly *this);
CoreNode *__thiscall Joint::MatPoly::MatPoly(Joint::MatPoly *this, struct Material *a2, struct Mesh *a3);
CoreNode *__thiscall Joint::Joint(Joint *this);
CoreNode *__thiscall Joint::MatPoly::MatPoly(Joint::MatPoly *this, const struct Joint::MatPoly *a2);
_DWORD *__thiscall Joint::MatPoly::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall Joint::Joint(Joint *this, const struct Joint *a2);
_DWORD *__thiscall Joint::operator=(_DWORD *this, _DWORD *a2);
DataChunk *__thiscall DataChunk::DataChunk(DataChunk *this);
void __thiscall DataChunk::setDataSize(DataChunk *this, int); // idb
void __thiscall DataChunk::addData(DataChunk *this, float); // idb
void __thiscall DataChunk::getData(DataChunk *this, struct CmdStream *); // idb
// void __userpurge DataChunk::read(DataChunk *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
void __thiscall DataChunk::write(DataChunk *this, struct RandomAccessStream *); // idb
_DWORD *__thiscall DataChunk::operator=(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall InterpKeyInfo::operator=(_DWORD *this, _DWORD *a2);
Vector3f *__thiscall CamDataInfo::CamDataInfo(CamDataInfo *this, const struct CamDataInfo *a2);
void *__thiscall CamDataInfo::operator=(void *this, const void *a2);
LightDataInfo *__thiscall LightDataInfo::LightDataInfo(LightDataInfo *this);
LightDataInfo *__thiscall LightDataInfo::LightDataInfo(LightDataInfo *this, const struct LightDataInfo *a2);
_DWORD *__thiscall LightDataInfo::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall SceneData::SceneData(SceneData *this);
CoreNode *__thiscall SceneData::SceneData(SceneData *this, const struct SceneData *a2);
_DWORD *__thiscall SceneData::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall AnimData::AnimData(AnimData *this);
CoreNode *__thiscall AnimData::AnimData(AnimData *this, char *a2);
void __stdcall AnimData::writeType(struct RandomAccessStream *a2);
CoreNode *__thiscall AnimData::AnimData(AnimData *this, const struct AnimData *a2);
_DWORD *__thiscall AnimData::operator=(_DWORD *this, _DWORD *a2);
AnimData *__thiscall AnimDca::AnimDca(AnimDca *this, struct BaseShape *a2, int a3);
AnimDca *__thiscall AnimDca::AnimDca(AnimDca *this, char *Str);
AnimData *__thiscall AnimDca::AnimDca(AnimDca *this, const struct AnimDca *a2);
void *__thiscall AnimDca::operator=(void *this, int a2);
AnimData *__thiscall AnimDck::AnimDck(AnimDck *this);
AnimDck *__thiscall AnimDck::AnimDck(AnimDck *this, char *Str);
AnimData *__thiscall AnimDck::AnimDck(AnimDck *this, const struct AnimDck *a2);
void *__thiscall AnimDck::operator=(void *this, int a2);
AnimCacheInfo *__thiscall AnimCacheInfo::AnimCacheInfo(AnimCacheInfo *this);
void __thiscall AnimCacheInfo::initData(AnimCacheInfo *__hidden this); // idb
void *__thiscall AnimCacheInfo::operator=(void *this, const void *a2);
void *__thiscall AnimFrameCacher::operator=(void *this, const void *a2);
AnimContext *__thiscall AnimContext::AnimContext(AnimContext *this);
AnimContext *__thiscall AnimContext::AnimContext(AnimContext *this, struct AnimData *a2);
void __thiscall AnimContext::setState(AnimContext *this, struct AnimData *, float); // idb
AnimContext *__thiscall AnimContext::AnimContext(AnimContext *this, const struct AnimContext *a2);
_DWORD *__thiscall AnimContext::operator=(_DWORD *this, _DWORD *a2);
TexImg *__thiscall TexImg::TexImg(TexImg *this);
TexImg *__thiscall TexImg::TexImg(TexImg *this, const struct TexImg *a2);
_DWORD *__thiscall TexImg::operator=(_DWORD *this, _DWORD *a2);
CoreNode *__thiscall TexAttr::TexAttr(TexAttr *this);
CoreNode *__thiscall TexAttr::TexAttr(TexAttr *this, const struct TexAttr *a2);
_DWORD *__thiscall TexAttr::operator=(_DWORD *this, int a2);
CoreNode *__thiscall RouteLink::RouteLink(RouteLink *this);
CoreNode *__thiscall RouteLink::RouteLink(RouteLink *this, const struct RouteLink *a2);
_DWORD *__thiscall RouteLink::operator=(_DWORD *this, int a2);
CoreNode *__thiscall RoutePoint::RoutePoint(RoutePoint *this, const struct RoutePoint *a2);
_DWORD *__thiscall RoutePoint::operator=(_DWORD *this, _DWORD *a2);
void __thiscall RouteGroup::setID(RouteGroup *this, unsigned __int32); // idb
void __thiscall RouteGroup::updateID(RouteGroup *__hidden this); // idb
EditNode *__thiscall RouteGroup::RouteGroup(RouteGroup *this, const struct RouteGroup *a2);
_DWORD *__thiscall RouteGroup::operator=(_DWORD *this, _DWORD *a2);
ShapeDynMaterials *__thiscall ShapeDynMaterials::ShapeDynMaterials(ShapeDynMaterials *this);
_DWORD *__thiscall ShapeDynMaterials::operator=(_DWORD *this, _DWORD *a2);
struct CollGroup *__thiscall BaseShape::getCollTris(BaseShape *this, struct Vector3f *); // idb
void BaseShape::optimize();
void __thiscall BaseShape::removeMtxDependancy(BaseShape *__hidden this); // idb
void BaseShape::update();
void __stdcall BaseShape::render(struct Graphics *a2);
void __stdcall BaseShape::render2d(struct Graphics *a2);
void __stdcall BaseShape::msgCommand(struct DataMsg *a2);
void __stdcall BaseShape::checkMouseEvent(int a2, int a3, int a4, int a5, int a6, int a7);
struct RouteGroup *__thiscall BaseShape::makeRouteGroup(BaseShape *__hidden this); // idb
CoreNode *__thiscall BaseShape::BaseShape(BaseShape *this, const struct BaseShape *a2);
_DWORD *__thiscall BaseShape::operator=(_DWORD *this, int a2);
BaseShape *__thiscall Shape::Shape(Shape *this);
BaseShape *__thiscall Shape::Shape(Shape *this, const struct Shape *a2);
void *__thiscall Shape::operator=(void *this, int a2);
GfxObject *__thiscall Texture::Texture(Texture *this);
void Texture::makeResident();
GfxObject *__thiscall Texture::Texture(Texture *this, const struct Texture *a2);
_WORD *__thiscall Texture::operator=(_WORD *this, int a2);
Texture *__thiscall CacheTexture::CacheTexture(CacheTexture *this);
Texture *__thiscall CacheTexture::CacheTexture(CacheTexture *this, const struct CacheTexture *a2);
_DWORD *__thiscall CacheTexture::operator=(_DWORD *this, _DWORD *a2);
DrawInfo *__thiscall DrawInfo::DrawInfo(DrawInfo *this);
_DWORD *__thiscall DrawInfo::operator=(_DWORD *this, _DWORD *a2);
MaterialHandler *__thiscall MaterialHandler::MaterialHandler(MaterialHandler *this);
MaterialHandler *__thiscall MaterialHandler::MaterialHandler(MaterialHandler *this, const struct MaterialHandler *a2);
_DWORD *__thiscall MaterialHandler::operator=(_DWORD *this, int a2);
Colour *__thiscall LFInfo::LFInfo(LFInfo *this);
LFInfo *__thiscall LFInfo::LFInfo(LFInfo *this, const struct LFInfo *a2);
void *__thiscall LFInfo::operator=(void *this, const void *a2);
CoreNode *__thiscall LFlareGroup::LFlareGroup(LFlareGroup *this);
void __thiscall LFlareGroup::addLFlare(LFlareGroup *this, struct Colour *, struct Vector3f *, struct Vector2f *, struct Vector2f *, struct Vector2f *); // idb
CoreNode *__thiscall LFlareGroup::LFlareGroup(LFlareGroup *this, const struct LFlareGroup *a2);
_DWORD *__thiscall LFlareGroup::operator=(_DWORD *this, _DWORD *a2);
void __thiscall CachedShape::insertAfter(CachedShape *this, struct CachedShape *); // idb
void __thiscall CachedShape::remove(CachedShape *__hidden this); // idb
CachedShape *__thiscall CachedShape::CachedShape(CachedShape *this);
void *__thiscall CachedShape::operator=(void *this, const void *a2);
void Graphics::videoReset();
void __stdcall Graphics::setVerticalFilter(unsigned __int8 *a2);
void __stdcall Graphics::getVerticalFilter(unsigned __int8 *a2);
unsigned __int8 *Graphics::getDListPtr();
unsigned __int32 Graphics::getDListRemainSize();
unsigned __int32 __stdcall Graphics::compileMaterial(struct Material *a2);
void __stdcall Graphics::useDList(unsigned __int32 a2);
void __thiscall Graphics::resetLights(Graphics *__hidden this); // idb
void __thiscall Graphics::addLight(Graphics *this, struct Light *); // idb
void Graphics::setAmbient();
void __thiscall Graphics::setLightcam(Graphics *this, struct LightCamera *); // idb
void __stdcall Graphics::setBlendMode(unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
void __thiscall Graphics::setMatHandler(Graphics *this, struct MaterialHandler *); // idb
void __thiscall Graphics::useMaterial(Graphics *this, struct Material *); // idb
void __stdcall Graphics::testRectangle(struct RectArea *a2);
void __stdcall Graphics::genAge(struct AgeServer *a2);
Graphics *__thiscall Graphics::Graphics(Graphics *this, const struct Graphics *a2);
_DWORD *__thiscall Graphics::operator=(_DWORD *this, int a2);
AtxStream *__thiscall AgeServer::AgeServer(AgeServer *this);
AtxStream *__thiscall AgeServer::AgeServer(AgeServer *this, const struct AgeServer *a2);
_BYTE *__thiscall AgeServer::operator=(_BYTE *this, int a2);
TimerInf *__thiscall TimerInf::TimerInf(TimerInf *this, char *a2);
void *__thiscall TimerInf::operator=(void *this, const void *a2);
Timers *__thiscall Timers::Timers(Timers *this);
void __thiscall Timers::~Timers(Timers *this);
void __stdcall Timers::start(char *a2, bool a3);
void __stdcall Timers::stop(char *a2);
_DWORD *__thiscall Timers::operator=(_DWORD *this, _DWORD *a2);
Light *__thiscall Light::Light(Light *this);
void __thiscall Light::setLightDistAttn(Light *this, float, float, int); // idb
void __thiscall Light::setLightSpot(Light *this, float, int); // idb
void __thiscall Light::setLightParallel(Light *__hidden this); // idb
void __thiscall Light::calcLightSizes(Light *__hidden this); // idb
double __thiscall Light::calcLightMapRadius(Light *this);
double __thiscall Light::calcLightObjRadius(Light *this);
void __thiscall Light::refresh(Light *this, struct Graphics *, struct LFlareGroup *); // idb
void __thiscall Light::update(Light *__hidden this); // idb
void __thiscall Light::recalcLighting(Light *this, struct AgeServer *); // idb
void __stdcall Light::refreshSection(struct AgeServer *a2);
void __thiscall Light::updAge(Light *this, struct AgeServer *); // idb
void __thiscall Light::genAge(Light *this, struct AgeServer *); // idb
_DWORD *__thiscall sub_10024620(_DWORD *this, int a2, int a3);
int __thiscall sub_10024690(int this, int a2);
_DWORD *__thiscall sub_100246F0(_DWORD *this);
int __thiscall sub_10024730(void *this);
// void __userpurge Envelope::read(Envelope *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
void __thiscall Envelope::write(Envelope *this, struct RandomAccessStream *); // idb
void __thiscall DispList::read(DispList *this, struct RandomAccessStream *); // idb
void __thiscall DispList::prepareTriList(DispList *this, struct TriStripifier *); // idb
void __thiscall DispList::outputTriData(DispList *this, struct RandomAccessStream *, unsigned __int32, bool); // idb
void __thiscall DispList::exportData(DispList *this, struct RandomAccessStream *, unsigned __int32); // idb
int __thiscall sub_10025670(char *this);
void __thiscall MtxGroup::read(MtxGroup *this, struct RandomAccessStream *); // idb
void __thiscall MtxGroup::exportData(MtxGroup *this, struct RandomAccessStream *, unsigned __int32); // idb
void __thiscall Mesh::read(Mesh *this, struct RandomAccessStream *); // idb
void __thiscall Mesh::exportData(Mesh *this, struct RandomAccessStream *); // idb
void __thiscall Joint::recShowHierarchy(Joint *__hidden this); // idb
char *__cdecl sub_10025E40(char *Format, char a2);
void __thiscall Joint::overrideAnim(Joint *this, struct AnimContext *); // idb
void __thiscall Joint::recOverrideAnim(Joint *this, struct AnimContext *); // idb
// void __userpurge Joint::read(Joint *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
void __thiscall Joint::write(Joint *this, struct RandomAccessStream *); // idb
int sub_100264A0();
int sub_100264E0();
int sub_10026550();
int sub_10026590();
void __thiscall Joint::render(Joint *this, struct Graphics *); // idb
void __thiscall Joint::sectionJoint(Joint *this, struct AgeServer *); // idb
void __thiscall Joint::genAge(Joint *this, struct AgeServer *); // idb
void __thiscall AnimContext::animate(AnimContext *this, float); // idb
Vector3f *__thiscall CamDataInfo::CamDataInfo(CamDataInfo *this);
void __thiscall CamDataInfo::update(CamDataInfo *this, float, struct Matrix4f *); // idb
double __cdecl sub_10027DA0(float a1, int a2, int a3);
void __thiscall LightDataInfo::update(LightDataInfo *this, float); // idb
void __stdcall SceneData::genAge(struct AgeServer *a2);
void __thiscall SceneData::parse(SceneData *this, struct CmdStream *); // idb
void __thiscall SceneData::getAnimInfo(SceneData *this, struct CmdStream *); // idb
void __thiscall AnimData::extractSRT(AnimData *this, struct SRT *, int, struct AnimDataInfo *, float); // idb
void __thiscall AnimData::makeAnimSRT(AnimData *this, int, struct Matrix4f *, struct Matrix4f *, struct AnimDataInfo *, float); // idb
void __noreturn sub_1002A170(char *Format, ...);
void __thiscall AnimData::detach(AnimData *__hidden this); // idb
void __thiscall AnimData::initData(AnimData *__hidden this); // idb
void __thiscall AnimData::checkMask(AnimData *__hidden this); // idb
void __thiscall AnimData::genAge(AnimData *this, struct AgeServer *); // idb
void __thiscall AnimData::playAnim(AnimData *this, struct AgeServer *); // idb
void __thiscall AnimData::delAnim(AnimData *this, struct AgeServer *); // idb
void __thiscall AnimDca::read(AnimDca *this, struct RandomAccessStream *); // idb
void __thiscall AnimDca::writeType(AnimDca *this, struct RandomAccessStream *); // idb
void __thiscall AnimDca::write(AnimDca *__hidden this, struct RandomAccessStream *); // idb
void __thiscall AnimDca::parse(AnimDca *this, struct CmdStream *); // idb
void __thiscall AnimDca::getAnimInfo(AnimDca *this, struct CmdStream *); // idb
AnimData *__thiscall AnimDck::AnimDck(AnimDck *this, struct BaseShape *a2, int a3);
void __thiscall AnimDck::read(AnimDck *this, struct RandomAccessStream *); // idb
void __thiscall AnimDck::writeType(AnimDck *this, struct RandomAccessStream *); // idb
void __thiscall AnimDck::write(AnimDck *__hidden this, struct RandomAccessStream *); // idb
void __thiscall AnimDck::parse(AnimDck *this, struct CmdStream *); // idb
void __thiscall AnimDck::getAnimInfo(AnimDck *this, struct CmdStream *); // idb
void __thiscall AnimDck::extractSRT(AnimDck *this, struct SRT *, int, struct AnimDataInfo *, float); // idb
void __thiscall AnimDck::makeAnimSRT(AnimDck *this, int, struct Matrix4f *, struct Matrix4f *, struct AnimDataInfo *, float); // idb
void __thiscall BaseShape::exportIni(BaseShape *__hidden this, struct RandomAccessStream *, bool); // idb
void __thiscall BaseShape::importIni(BaseShape *this, struct RandomAccessStream *); // idb
void __thiscall ShapeDynMaterials::animate(ShapeDynMaterials *this, float *); // idb
void __thiscall ShapeDynMaterials::updateContext(ShapeDynMaterials *__hidden this); // idb
CoreNode *__thiscall BaseShape::BaseShape(BaseShape *this);
void __thiscall BaseShape::countMaterials(BaseShape *this, struct Joint *, unsigned __int32); // idb
int __thiscall BaseShape::recTraverseMaterials(void *this, int a2, void (__thiscall ***a3)(_DWORD, int, _DWORD));
struct ShapeDynMaterials *__thiscall BaseShape::instanceMaterials(BaseShape *this, int); // idb
void __thiscall BaseShape::makeInstance(BaseShape *this, struct ShapeDynMaterials *, int); // idb
void __thiscall BaseShape::drawobjcolls(BaseShape *this, struct Graphics *, struct Camera *); // idb
struct CoreNode *__cdecl sub_1002FD20(struct Graphics *a1, int a2);
void __thiscall BaseShape::drawlights(BaseShape *this, struct Graphics *, struct Camera *); // idb
void __thiscall BaseShape::drawroutes(BaseShape *this, struct Graphics *, struct Camera *); // idb
void __thiscall BaseShape::drawculled(BaseShape *this, struct Graphics *, struct Camera *, struct ShapeDynMaterials *); // idb
void __thiscall BaseShape::drawshape(BaseShape *this, struct Graphics *, struct Camera *, struct ShapeDynMaterials *); // idb
void __thiscall BaseShape::resolveTextureNames(BaseShape *__hidden this); // idb
void __thiscall BaseShape::skipChunk(BaseShape *this, struct RandomAccessStream *, unsigned __int32); // idb
void __thiscall BaseShape::recAddMatpoly(BaseShape *this, struct Joint *, int); // idb
// void __userpurge BaseShape::read(BaseShape *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3);
void __thiscall BaseShape::initIni(BaseShape *this, bool); // idb
void __thiscall BaseShape::initialise(BaseShape *__hidden this); // idb
void __thiscall BaseShape::createCollisions(BaseShape *__hidden this, int); // idb
void __cdecl sub_10035610(float a1);
void __thiscall BaseShape::calcBasePose(BaseShape *this, struct Matrix4f *); // idb
struct CoreNode *__thiscall BaseShape::loadDck(BaseShape *this, char *a2, struct RandomAccessStream *a3);
struct CoreNode *__thiscall BaseShape::importDck(BaseShape *this, char *a2, struct CmdStream *a3);
struct CoreNode *__thiscall BaseShape::loadDca(BaseShape *this, char *a2, struct RandomAccessStream *a3);
void __thiscall BaseShape::importDca(BaseShape *__hidden this, char *, struct CmdStream *); // idb
struct AnimData *__thiscall BaseShape::loadAnimation(BaseShape *this, char *Str, bool); // idb
struct Matrix4f *__thiscall BaseShape::getAnimMatrix(BaseShape *this, int); // idb
void __thiscall BaseShape::backupAnimOverrides(BaseShape *this, struct AnimContext **); // idb
void __thiscall BaseShape::restoreAnimOverrides(BaseShape *__hidden this); // idb
void __thiscall BaseShape::overrideAnim(BaseShape *this, int, struct AnimContext *); // idb
AnimFrameCacher *__thiscall AnimFrameCacher::AnimFrameCacher(AnimFrameCacher *this, int a2);
void __thiscall AnimFrameCacher::updateInfo(AnimFrameCacher *this, struct AnimCacheInfo *); // idb
void __thiscall AnimFrameCacher::removeOldest(AnimFrameCacher *__hidden this); // idb
int __thiscall sub_100363E0(int this);
void __thiscall AnimFrameCacher::cacheFrameSpace(AnimFrameCacher *this, int, struct AnimCacheInfo *); // idb
void __thiscall BaseShape::updateAnim(BaseShape *this, struct Graphics *, struct Matrix4f *, float *); // idb
void __thiscall BaseShape::calcWeightedMatrices(BaseShape *__hidden this); // idb
void __thiscall BaseShape::makeNormalIndexes(BaseShape *this, unsigned __int16 *); // idb
double __thiscall BaseShape::calcJointWorldPos(BaseShape *this, struct Graphics *a2, int a3, struct Vector3f *a4);
void __thiscall BaseShape::calcJointWorldDir(BaseShape *this, struct Graphics *, int, struct Vector3f *); // idb
void __thiscall BaseShape::calcJointWorldScale(BaseShape *this, struct Graphics *, int, struct Vector3f *); // idb
struct CollTriInfo *__thiscall BaseShape::findCollTri(BaseShape *this, struct Vector3f *, struct Vector3f *, struct Vector3f *, char *); // idb
int __thiscall sub_10037230(_DWORD *this, int a2);
_DWORD *__thiscall sub_100372C0(_DWORD *this, int a2, int a3);
int __thiscall sub_10037330(int this, int a2);
_DWORD *__thiscall sub_10037390(_DWORD *this, int a2, int a3);
int __thiscall sub_10037400(int this, int a2);
_DWORD *__thiscall sub_10037460(_DWORD *this, int a2, int a3);
int __thiscall sub_100374D0(int this, int a2, int a3);
_DWORD *__thiscall sub_10037530(_DWORD *this);
int __thiscall sub_10037570(HGLOBAL *this);
int __thiscall sub_100375D0(_DWORD *this, int a2);
int __thiscall sub_100376B0(HGLOBAL *this);
int __thiscall sub_10037710(_DWORD *this, int a2);
int __thiscall sub_100377F0(_DWORD *this, int a2);
int __thiscall sub_10037870(HGLOBAL *this);
int __thiscall sub_100378D0(_DWORD *this, int a2);
int __thiscall sub_10037A40(_DWORD *this, int a2);
_DWORD *__thiscall sub_10037BB0(_DWORD *this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_10037C10(_DWORD *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_10037CD0(_DWORD *this, int a2);
int __thiscall sub_10037D50(HGLOBAL *this);
int __thiscall sub_10037DB0(HGLOBAL *this, void *a2);
int __thiscall sub_10037E50(_DWORD *this, int a2);
_DWORD *__thiscall sub_10037FC0(_DWORD *this);
_DWORD *__thiscall sub_100380A0(_DWORD *this, int a2);
_DWORD *__thiscall sub_10038120(_DWORD *this, int a2);
_DWORD *__thiscall sub_100381A0(_DWORD *this, int a2);
int __thiscall sub_10038220(_DWORD *this, int a2);
void __thiscall LightFlare::loadini(LightFlare *this, struct CmdStream *); // idb
void __thiscall LightFlare::saveini(LightFlare *this, char *, struct RandomAccessStream *); // idb
void __thiscall LightFlare::ageDel(LightFlare *this, struct AgeServer *); // idb
void __thiscall LightFlare::genAge(LightFlare *this, struct AgeServer *); // idb
void __thiscall LightGroup::ageAddFlare(LightGroup *this, struct AgeServer *); // idb
void __thiscall LightGroup::ageDel(LightGroup *this, struct AgeServer *); // idb
void __thiscall LightGroup::ageChangeTexture(LightGroup *this, struct AgeServer *); // idb
char *__cdecl sub_100389D0(char *Format, char a2);
void __thiscall LightGroup::genAge(LightGroup *this, struct AgeServer *); // idb
void __thiscall LightGroup::saveini(LightGroup *this, char *, struct RandomAccessStream *); // idb
void __thiscall LightGroup::loadini(LightGroup *this, struct CmdStream *); // idb
void __thiscall LightGroup::refresh(LightGroup *this, struct Graphics *, struct Matrix4f *); // idb
_DWORD *__thiscall sub_100397B0(_DWORD *this, int a2, int a3);
int __thiscall sub_10039820(int this, int a2);
_DWORD *__thiscall sub_10039880(_DWORD *this, int a2, int a3);
int __thiscall sub_100398F0(int this, int a2);
void __thiscall ObjCollInfo::getCentreSize(ObjCollInfo *this, struct Vector3f *, float *); // idb
void __thiscall ObjCollInfo::showInfo(ObjCollInfo *this, struct Graphics *, struct Matrix4f *); // idb
void __stdcall ObjCollInfo::sectionJointsChange(struct AgeServer *a2);
void __thiscall ObjCollInfo::ageDelCollInfo(ObjCollInfo *this, struct AgeServer *); // idb
void __thiscall ObjCollInfo::newCollInfoButton(ObjCollInfo *__hidden this, struct AgeServer *); // idb
char *__cdecl sub_10039D50(char *Format, char a2);
void __thiscall ObjCollInfo::ageChangePlatname(ObjCollInfo *this, struct AgeServer *); // idb
void __thiscall ObjCollInfo::genAge(ObjCollInfo *this, struct AgeServer *); // idb
void __thiscall ObjCollInfo::saveini(ObjCollInfo *this, char *, struct RandomAccessStream *); // idb
void __thiscall ObjCollInfo::loadini(ObjCollInfo *this, struct CmdStream *); // idb
char *__thiscall sub_1003AC70(String *this);
_DWORD *__thiscall sub_1003ACD0(_DWORD *this, int a2, int a3);
int __thiscall sub_1003AD40(int this, int a2);
CoreNode *__thiscall RoutePoint::RoutePoint(RoutePoint *this);
void __thiscall RoutePoint::refresh(RoutePoint *this, struct Graphics *); // idb
void __thiscall RoutePoint::loadini(RoutePoint *this, struct CmdStream *); // idb
void __stdcall RoutePoint::genAge(struct AgeServer *a2);
RouteGroup *__thiscall RouteGroup::RouteGroup(RouteGroup *this);
void __thiscall RouteGroup::refresh(RouteGroup *this, struct Graphics *, struct EditNode *); // idb
void __thiscall RouteGroup::render2d(RouteGroup *this, struct Graphics *, int *); // idb
void __thiscall RouteGroup::loadini(RouteGroup *this, struct CmdStream *); // idb
void __thiscall RouteGroup::saveini(RouteGroup *this, char *, struct RandomAccessStream *); // idb
void __thiscall CoreNode::add(CoreNode *this, struct CoreNode *); // idb
void __thiscall CoreNode::del(CoreNode *__hidden this); // idb
int __thiscall CoreNode::getChildCount(CoreNode *__hidden this); // idb
void __thiscall CoreNode::load(CoreNode *this, char *, char *, unsigned __int32); // idb
char *__cdecl sub_1003CA60(char *Format, char a2);
int CoreNode::getAgeNodeType();
void __thiscall CoreNode::genAgeNode(CoreNode *this, struct AgeServer *); // idb
void __thiscall CoreNode::genRead(CoreNode *__hidden this, struct AgeServer *); // idb
void __thiscall CoreNode::genWrite(CoreNode *__hidden this, struct AgeServer *); // idb
void __thiscall CoreNode::genAge(CoreNode *this, struct AgeServer *); // idb
void __thiscall Node::init(Node *this, char *); // idb
void __thiscall Node::update(Node *this); // idb
void __thiscall Node::draw(Node *this, struct Graphics *); // idb
void __thiscall Node::render(Node *this, struct Graphics *); // idb
Node *__thiscall SRTNode::SRTNode(SRTNode *this, char *a2);
void __thiscall SRTNode::update(SRTNode *__hidden this); // idb
void __thiscall SRTNode::genAge(SRTNode *this, struct AgeServer *); // idb
void __thiscall NodeMgr::Del(NodeMgr *this, struct Node *); // idb
void __thiscall NodeMgr::recFindNode(NodeMgr *this, struct CoreNode *, char *); // idb
struct CoreNode *__thiscall NodeMgr::findNode(NodeMgr *this, char *, struct CoreNode *); // idb
struct_this *__thiscall NodeMgr::NodeMgr(int this);
void NodeMgr::~NodeMgr();
char *__thiscall sub_1003D960(String *this);
_DWORD *__thiscall sub_1003D9C0(_DWORD *this, int a2, int a3);
int __thiscall sub_1003DA30(int this, int a2);
int sub_1003DA90();
int sub_1003DAD0();
Matrix4f *__thiscall Matrix4f::Matrix4f(Matrix4f *this, float (*const a2)[4]);
void __thiscall Matrix4f::makeIdentity(Matrix4f *__hidden this); // idb
void __thiscall Matrix4f::blend(Matrix4f *this, struct Matrix4f *, float); // idb
void __thiscall Matrix4f::makeOrtho(Matrix4f *this, float, float, float, float, float, float, float); // idb
void __thiscall Matrix4f::makePerspective(Matrix4f *this, float, float, float, float); // idb
void __thiscall Matrix4f::makeRotate(Matrix4f *this, struct Vector3f *, float, float); // idb
// void __userpurge Matrix4f::makeRotate(Matrix4f *this@<ecx>, double a2@<st0>, struct Vector3f *a3, float a4);
void __thiscall Matrix4f::makeBallRotate(Matrix4f *this, struct Vector3f *); // idb
void __thiscall Matrix4f::rotate(Matrix4f *this, struct Vector3f *, float); // idb
void __thiscall Matrix4f::rotate(Matrix4f *this, float, float, float); // idb
void __thiscall Matrix4f::multiply(Matrix4f *this, struct Matrix4f *); // idb
void __thiscall Matrix4f::multiplyTo(Matrix4f *this, struct Matrix4f *, struct Matrix4f *); // idb
// void __userpurge Matrix4f::makeSRT(Matrix4f *this@<ecx>, double a2@<st0>, struct Vector3f *a3, struct Vector3f *a4, struct Vector3f *a5);
// void __userpurge Matrix4f::makeConcatSRT(Matrix4f *this@<ecx>, double a2@<st0>, struct Matrix4f *a3, struct Matrix4f *a4, struct SRT *a5);
void __thiscall Matrix4f::inverse(Matrix4f *this, struct Matrix4f *); // idb
void __thiscall Matrix4f::makeAligned(Matrix4f *this, struct Vector3f *, float); // idb
void __thiscall Matrix4f::rotateX(Matrix4f *this, float); // idb
void __thiscall Matrix4f::rotateY(Matrix4f *this, float); // idb
void __thiscall Matrix4f::rotateZ(Matrix4f *this, float); // idb
void __thiscall Matrix4f::translate(Matrix4f *this, float, float, float); // idb
void __thiscall Matrix4f::scale(Matrix4f *this, struct Vector3f *); // idb
void __thiscall Matrix4f::makeLookfrom(Matrix4f *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Matrix4f::makeLookat(Matrix4f *this, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Matrix4f::makeLookat(Matrix4f *this, struct Vector3f *, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Matrix4f::makeProjection(Matrix4f *this, struct Vector3f *, struct Plane *); // idb
void __thiscall Matrix4f::makeReflection(Matrix4f *this, struct Plane *); // idb
void __thiscall Matrix4f::transposeTo(Matrix4f *this, struct Matrix4f *); // idb
void __thiscall Matrix4f::makeVQS(Matrix4f *this, struct Vector3f *, struct Quat *, struct Vector3f *); // idb
bool __thiscall Plane::equal(Plane *this, struct Plane *); // idb
double __thiscall Plane::calcRadScale(Plane *this);
void __thiscall Plane::reflect(Plane *this, struct Vector3f *); // idb
void __thiscall Plane::reflectVector(Plane *this, struct Vector3f *); // idb
void __thiscall Plane::bounceVector(Plane *this, struct Vector3f *, float); // idb
void __thiscall Plane::frictionVector(Plane *this, struct Vector3f *, float); // idb
void __thiscall CullingPlane::CheckMinMaxDir(CullingPlane *__hidden this); // idb
void __thiscall Vector3f::rotateTranspose(Vector3f *this, struct Matrix4f *); // idb
void __thiscall Vector3f::rotate(Vector3f *this, struct Matrix4f *); // idb
void __thiscall Vector3f::rotateTo(Vector3f *this, struct Matrix4f *, struct Vector3f *); // idb
void __thiscall Vector3f::multMatrix(Vector3f *this, struct Matrix4f *); // idb
void __thiscall Vector3f::multMatrixTo(Vector3f *this, struct Matrix4f *, struct Vector3f *); // idb
void __stdcall Vector3f::genAge(struct AgeServer *a2, char *a3, struct Vector3f *a4, struct Vector3f *a5);
void __thiscall Vector3f::rotate(Vector3f *this, struct Quat *); // idb
void __thiscall Vector3f::rotateInverse(Vector3f *this, struct Quat *); // idb
void __thiscall Quat::fromMat3f(Quat *this, struct Matrix3f *); // idb
void __thiscall Quat::rotate(Quat *this, struct Vector3f *, float); // idb
void __thiscall Quat::multiply(Quat *this, struct Quat *); // idb
void __thiscall Quat::multiplyTo(Quat *this, struct Quat *, struct Quat *); // idb
void __thiscall Quat::normalise(Quat *__hidden this); // idb
void __thiscall Quat::genVectorX(Quat *this, struct Vector3f *); // idb
void __thiscall Quat::genVectorY(Quat *this, struct Vector3f *); // idb
void __thiscall Quat::genVectorZ(Quat *this, struct Vector3f *); // idb
void __thiscall Quat::slerp(Quat *this, struct Quat *, float, int); // idb
void __thiscall Quat::fromEuler(Quat *this, struct Vector3f *); // idb
double __cdecl roundAng(float a1);
double __cdecl angDist(float a1, float a2);
double __cdecl qdist2(float a1, float a2, float a3, float a4);
double __cdecl qdist3(float a1, float a2, float a3, float a4, float a5, float a6);
void __thiscall CollTriInfo::init(CollTriInfo *this, struct RoomInfo *, struct Vector3f *); // idb
int __thiscall CollTriInfo::behindEdge(CollTriInfo *this, struct Vector3f *); // idb
void __thiscall BoundBox::draw(BoundBox *this, struct Graphics *); // idb
double __cdecl triRectDistance(struct Vector3f *a1, struct Vector3f *a2, struct Vector3f *a3, struct BoundBox *a4);
bool __cdecl sub_100432C0(KTri *a1, int a2);
double __cdecl distanceTriRect(struct KTri *a1, struct KRect *a2, float *a3, float *a4, float *a5, float *a6);
bool __thiscall KRect::inside(KRect *this, struct Vector3f *); // idb
Vector3f *__thiscall KTri::KTri(KTri *this);
void __thiscall KTri::set(KTri *this, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
Vector3f *__thiscall KSegment::KSegment(KSegment *this);
double __cdecl sqrDistance(struct KSegment *a1, struct KTri *a2, float *a3, float *a4, float *a5);
double __cdecl sqrDistance(struct KSegment *a1, struct KSegment *a2, float *a3, float *a4);
double __cdecl sqrDistance(struct KSegment *a1, struct KRect *a2, float *a3, float *a4, float *a5);
double __cdecl sqrDistance(struct KTri *a1, struct KRect *a2, float *a3, float *a4, float *a5, float *a6);
double __cdecl sqrDistance(struct Vector3f *a1, struct KTri *a2, float *a3, float *a4);
void __thiscall AyuStack::create(AyuStack *this, char *, int, void *, int, bool); // idb
void __thiscall AyuStack::reset(AyuStack *__hidden this); // idb
void __thiscall AyuStack::checkStack(AyuStack *__hidden this); // idb
void __noreturn sub_1004A040(char *Format, ...);
void __thiscall AyuStack::reset(AyuStack *this, int); // idb
void *__thiscall AyuStack::push(AyuStack *this, int); // idb
void __thiscall AyuStack::pop(AyuStack *__hidden this); // idb
void __thiscall AyuHeap::init(AyuHeap *this, char *, int, void *, int); // idb
AyuCache *__thiscall AyuCache::AyuCache(AyuCache *this, unsigned __int32 a2);
char *__cdecl sub_1004A590(char *Format, char a2);
void __thiscall AyuCache::init(AyuCache *this, unsigned __int32, unsigned __int32); // idb
int __thiscall AyuCache::getIndex(AyuCache *__hidden this); // idb
void __thiscall AyuCache::releaseIndex(AyuCache *this, int); // idb
int __thiscall AyuCache::mallocL(AyuCache *this, unsigned __int32 a2);
_DWORD *__cdecl sub_1004AB20(_DWORD *a1, int a2, int a3);
void __thiscall AyuCache::cacheFree(AyuCache *this, void *); // idb
void __thiscall AyuCache::deleteIdAll(AyuCache *this, unsigned __int32); // idb
int __thiscall AyuCache::amountFree(AyuCache *this);
bool __thiscall AyuCache::isEmpty(AyuCache *__hidden this); // idb
unsigned __int32 __thiscall AyuCache::largestBlockFree(AyuCache *__hidden this); // idb
void __thiscall AgeServer::close(AgeServer *__hidden this); // idb
char __thiscall AgeServer::Open(AgeServer *this);
char *__cdecl sub_1004B040(char *Format, char a2);
// float *__userpurge AgeServer::readPropValue@<eax>(int a1@<ecx>, double a2@<st0>, int a3, float *a4);
void __noreturn sub_1004B350(char *Format, ...);
int __thiscall AgeServer::writeProp(void *this, int a2, int a3);
int __thiscall AgeServer::writePropValue(void *this, int a2, unsigned __int8 *a3);
int __thiscall AgeServer::update(AgeServer *__hidden this); // idb
int __thiscall AgeServer::setSectionRefresh(void *this, int a2);
int __thiscall AgeServer::setOnChange(void *this, int a2);
void __thiscall AgeServer::setOnChange(AgeServer *this, struct IDelegate *); // idb
void __thiscall AgeServer::NewNodeWindow(AgeServer *this, char *); // idb
void __thiscall AgeServer::NewPropWindow(AgeServer *this, char *, unsigned __int32); // idb
void __thiscall AgeServer::RefreshSection(AgeServer *__hidden this); // idb
void __thiscall AgeServer::RefreshNode(AgeServer *__hidden this); // idb
BOOL __thiscall AgeServer::getOpenFilename(AgeServer *this, struct String *a2, char *Str);
BOOL __thiscall AgeServer::getSaveFilename(AgeServer *this, struct String *a2, char *a3);
void __thiscall AgeServer::NewNode(AgeServer *this, char *, struct ANode *); // idb
void __thiscall AgeServer::EndNode(AgeServer *__hidden this); // idb
void __thiscall AgeServer::Done(AgeServer *__hidden this); // idb
void __thiscall AgeServer::StartSection(AgeServer *this, char *, bool); // idb
void __thiscall AgeServer::EndSection(AgeServer *__hidden this); // idb
void __thiscall AgeServer::StartGroup(AgeServer *this, char *); // idb
void __thiscall AgeServer::EndGroup(AgeServer *__hidden this); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, int *, int, int, int); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, __int16 *, int, int, int); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, char *, int, int, int); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, float *, float, float, int); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, struct Colour *); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, char *, int); // idb
void __thiscall AgeServer::NewEditor(AgeServer *this, char *, struct AyuImage *, bool); // idb
void __thiscall AgeServer::NewViewer(AgeServer *this, char *, int *); // idb
void __thiscall AgeServer::NewViewer(AgeServer *this, char *, float *); // idb
void __thiscall AgeServer::StartBitGroup(AgeServer *this, char *, unsigned __int32 *, int); // idb
void __thiscall AgeServer::StartBitGroup(AgeServer *this, char *, unsigned __int8 *, int); // idb
void __thiscall AgeServer::NewBit(AgeServer *this, char *, unsigned __int32, unsigned __int32); // idb
void __thiscall AgeServer::EndBitGroup(AgeServer *__hidden this); // idb
void __thiscall AgeServer::StartOptionBox(AgeServer *this, char *, int *, int); // idb
void __thiscall AgeServer::StartOptionBox(AgeServer *this, char *, unsigned __int8 *, int); // idb
void __thiscall AgeServer::StartOptionBox(AgeServer *this, char *, unsigned __int16 *, int); // idb
void __thiscall AgeServer::NewOption(AgeServer *this, char *, int); // idb
void __thiscall AgeServer::NewLabel(AgeServer *this, char *); // idb
void __thiscall AgeServer::EndOptionBox(AgeServer *__hidden this); // idb
int __thiscall AgeServer::NewButton(void *this, int a2, int a3, int a4);
void __thiscall AgeServer::NewButton(AgeServer *this, char *, struct IDelegate *, int); // idb
void __stdcall BaseApp::InitApp(char *a2);
int BaseApp::idle();
bool __stdcall BaseApp::keyDown(int a2, int a3, int a4);
double BaseApp::rnd();
double __thiscall BaseApp::rnd(BaseApp *this, float a2);
void __thiscall BaseApp::useHeap(BaseApp *this, int); // idb
void __stdcall BaseApp::procCmd(char *a2);
BaseApp *__thiscall BaseApp::BaseApp(BaseApp *this, const struct BaseApp *a2);
_DWORD *__thiscall BaseApp::operator=(_DWORD *this, int a2);
int __thiscall sub_1004D620(char *this, char a2);
void __thiscall AtxStream::close(AtxStream *__hidden this); // idb
char __thiscall AtxStream::open(AtxStream *this, char *a2, int a3);
char *__cdecl sub_1004D870(char *Format, char a2);
void __thiscall AtxStream::write(AtxStream *this, void *, int); // idb
void __thiscall AtxStream::read(AtxStream *this, void *, int); // idb
int __thiscall AtxStream::getPending(AtxStream *__hidden this); // idb
void __thiscall AtxStream::flush(AtxStream *__hidden this); // idb
int __thiscall AtxCommandStream::checkCommands(AtxCommandStream *__hidden this); // idb
char __thiscall AtxFileStream::open(AtxFileStream *this, char *a2, unsigned __int32 a3);
void __thiscall AtxFileStream::setPosition(AtxFileStream *this, int); // idb
void __thiscall AtxFileStream::read(AtxFileStream *this, void *, int); // idb
void __thiscall AtxFileStream::write(AtxFileStream *this, void *, int); // idb
void __thiscall AtxFileStream::close(AtxFileStream *__hidden this); // idb
BaseApp *__thiscall BaseApp::BaseApp(BaseApp *this);
int __thiscall BaseApp::idleupdate(BaseApp *__hidden this); // idb
void __thiscall BaseApp::startAgeServer(BaseApp *__hidden this); // idb
char *__cdecl sub_1004E470(char *Format, char a2);
void __thiscall BaseApp::stopAgeServer(BaseApp *__hidden this); // idb
void __thiscall BaseApp::softReset(BaseApp *__hidden this); // idb
void __stdcall BaseApp::genAge(struct AgeServer *a2);
void __thiscall BaseApp::~BaseApp(BaseApp *this);
void __thiscall CullFrustum::vectorToWorldPlane(CullFrustum *this, struct Vector3f *, struct CullingPlane *); // idb
char __thiscall CullFrustum::isPointVisible(CullFrustum *this, struct Vector3f *a2, float a3);
void __thiscall CullFrustum::draw(CullFrustum *this, struct Graphics *); // idb
// void __userpurge CullFrustum::updateViewPlanes(CullFrustum *this@<ecx>, double a2@<st0>, float a3, float a4, float a5, float a6);
void __thiscall CullFrustum::createViewPlanes(CullFrustum *__hidden this); // idb
void __thiscall CullFrustum::additionalPlanes(CullFrustum *this, struct CullFrustum *); // idb
void __thiscall CullFrustum::createVecs(CullFrustum *__hidden this); // idb
void __thiscall CullFrustum::createInvVecs(CullFrustum *__hidden this); // idb
void __thiscall CullFrustum::update(CullFrustum *this, float, float, float, float); // idb
void __thiscall CullFrustum::calcVectors(CullFrustum *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall CullFrustum::calcLookAt(CullFrustum *this, struct Vector3f *, struct Vector3f *, struct Vector3f *); // idb
void __thiscall CullFrustum::calcLookFrom(CullFrustum *this, struct Vector3f *, struct Vector3f *); // idb
void __thiscall Camera::camReflect(Camera *this, struct Camera *, struct Plane *); // idb
double __thiscall Camera::projectWorldPoint(Camera *this, struct Graphics *a2, struct Vector3f *a3);
double __thiscall Camera::projectCamPoint(Camera *this, struct Vector3f *a2);
CullFrustum *__thiscall Camera::Camera(Camera *this);
void __thiscall LightCamera::initLightmap(LightCamera *this, int, int); // idb
void __thiscall LightCamera::calcProjection(LightCamera *__hidden this, struct Graphics *, bool, struct Node *); // idb
void __thiscall LightCamera::genAge(LightCamera *this, struct AgeServer *); // idb
Vector3f *__cdecl sub_10051AC0(Vector3f *a1, int a2);
void __thiscall CmdStream::init(CmdStream *this, struct Stream *); // idb
CmdStream *__thiscall CmdStream::CmdStream(CmdStream *this);
CmdStream *__thiscall CmdStream::CmdStream(CmdStream *this, struct Stream *a2);
void __thiscall CmdStream::fillBuffer(CmdStream *this, bool); // idb
bool __stdcall CmdStream::whiteSpace(char a2);
bool __thiscall CmdStream::endOfCmds(CmdStream *__hidden this); // idb
bool __thiscall CmdStream::LineIsComment(CmdStream *__hidden this); // idb
void __thiscall CmdStream::copyToToken(CmdStream *this, int); // idb
char *__thiscall CmdStream::skipLine(CmdStream *__hidden this); // idb
char *__thiscall CmdStream::getToken(CmdStream *this, bool); // idb
char __thiscall CmdStream::nextChar(CmdStream *__hidden this); // idb
char __thiscall CmdStream::isToken(CmdStream *this, char *Str);
bool __thiscall CmdStream::endOfSection(CmdStream *__hidden this); // idb
void __thiscall Controller::reset(Controller *this, unsigned __int32); // idb
void __thiscall Controller::updateCont(Controller *this, unsigned __int32); // idb
void __thiscall Controller::update(Controller *__hidden this); // idb
double __thiscall Controller::getMainStickX(Controller *this);
double __thiscall Controller::getMainStickY(Controller *this);
double __thiscall Controller::getSubStickX(Controller *this);
double __thiscall Controller::getSubStickY(Controller *this);
Controller *__thiscall Controller::Controller(Controller *this, unsigned __int32 a2);
void __thiscall Controller::initialise(Controller *this, unsigned __int32); // idb
BOOL __thiscall Controller::keyDown(Controller *this, unsigned __int32 a2);
BOOL __thiscall Controller::keyUp(Controller *this, unsigned __int32 a2);
BOOL __thiscall Controller::keyClick(Controller *this, unsigned __int32 a2);
BOOL __thiscall Controller::keyDoubleClick(Controller *this, unsigned __int32 a2);
BOOL __thiscall Controller::keyUnClick(Controller *this, unsigned __int32 a2);
Controller *__thiscall Controller::Controller(Controller *this, const struct Controller *a2);
Controller *__thiscall Controller::operator=(Module *this, int a2);
void __thiscall Controller::`default constructor closure'(Controller *__hidden this); // idb
ID32 *__thiscall ID32::ID32(ID32 *this);
ID32 *__thiscall ID32::ID32(ID32 *this, unsigned __int32 a2);
void __thiscall ID32::setID(ID32 *this, unsigned __int32); // idb
char __thiscall ID32::match(ID32 *this, char a2, char a3);
void __thiscall ID32::updateID(ID32 *__hidden this); // idb
void __thiscall ID32::updateString(ID32 *__hidden this); // idb
void __thiscall ID32::operator=(ID32 *this, unsigned __int32 a2);
BOOL __thiscall ID32::operator==(_DWORD *this, int a2);
BOOL __thiscall ID32::operator!=(_DWORD *this, int a2);
void __thiscall ID32::write(ID32 *this, struct RandomAccessStream *); // idb
void __thiscall ID32::ageChangeID(ID32 *__hidden this); // idb
void __thiscall ID32::genAge(ID32 *this, struct AgeServer *, char *); // idb
void __thiscall ID32::read(ID32 *this, struct RandomAccessStream *); // idb
void __thiscall ID32::print(ID32 *__hidden this); // idb
char *__cdecl sub_10053600(char *Format, char a2);
void __thiscall ID32::sprint(ID32 *this, char *); // idb
_DWORD *__thiscall sub_100537B0(_DWORD *this, int a2, int a3);
int __thiscall sub_10053820(int this);
_DWORD *__thiscall sub_10053880(_DWORD *this);
void __thiscall AnmobjInfo::detach(AnmobjInfo *__hidden this); // idb
StdSystem *__thiscall StdSystem::StdSystem(StdSystem *this);
void __thiscall StdSystem::onceInit(StdSystem *__hidden this); // idb
struct AyuHeap *__thiscall StdSystem::getHeap(StdSystem *this, int); // idb
void __thiscall StdSystem::resetHeap(StdSystem *this, int, int); // idb
int __thiscall StdSystem::setHeap(StdSystem *this, int); // idb
void __thiscall StdSystem::getAppMemory(StdSystem *this, char *); // idb
struct GfxobjInfo *__thiscall StdSystem::findGfxObject(StdSystem *this, char *Str2, unsigned __int32); // idb
struct GfxobjInfo *__thiscall StdSystem::findAnyGfxObject(StdSystem *this, char *Str, unsigned __int32); // idb
struct Texture *__thiscall StdSystem::loadTexture(StdSystem *this, char *Str2, bool); // idb
struct GfxobjInfo *__thiscall StdSystem::findTexture(StdSystem *this, struct Texture *); // idb
struct Shape *__thiscall StdSystem::loadShape(StdSystem *this, char *Str2, bool); // idb
void __noreturn sub_100542B0(char *Format, ...);
struct AnimData *__thiscall StdSystem::findAnimation(StdSystem *this, char *); // idb
struct AnimData *__thiscall StdSystem::findAnyAnimation(StdSystem *this, char *); // idb
struct AnimData *__thiscall StdSystem::findIndexAnimation(StdSystem *this, char *Str, int); // idb
int __thiscall StdSystem::findAnyIndex(StdSystem *this, char *Str, char *); // idb
void __thiscall StdSystem::ageAnyAnimations(StdSystem *this, struct AgeServer *, char *); // idb
struct AnimData *__thiscall StdSystem::loadAnimation(StdSystem *this, struct Shape *, char *Str2, bool); // idb
void __thiscall StdSystem::addAnimation(StdSystem *this, struct AnimData *, char *); // idb
void __thiscall StdSystem::addGfxObject(StdSystem *this, struct GfxobjInfo *); // idb
void __thiscall StdSystem::attachObjs(StdSystem *__hidden this); // idb
void __thiscall StdSystem::detachObjs(StdSystem *__hidden this); // idb
void __thiscall StdSystem::invalidateObjs(StdSystem *this, unsigned __int32, unsigned __int32); // idb
void __thiscall StdSystem::addTexture(StdSystem *this, struct Texture *, char *); // idb
void __thiscall StdSystem::initSoftReset(StdSystem *__hidden this); // idb
void __stdcall StdSystem::genAge(struct AgeServer *a2);
struct Shape *__thiscall StdSystem::getShape(StdSystem *this, char *, char *Str, char *, bool); // idb
void __thiscall StdSystem::initLFlares(StdSystem *this, int); // idb
void __thiscall StdSystem::resetLFlares(StdSystem *__hidden this); // idb
struct LFInfo *__thiscall StdSystem::getLFlareInfo(StdSystem *__hidden this); // idb
struct CoreNode *__thiscall StdSystem::registerLFlare(StdSystem *this, struct Texture *a2);
void __thiscall StdSystem::flushLFlares(StdSystem *this, struct Graphics *); // idb
void __thiscall StdSystem::loadBundle(StdSystem *this, char *, bool); // idb
char *__cdecl StdSystem::stringDup(char *Str); // idb
void __thiscall TextureCacher::updateInfo(TextureCacher *this, struct CacheTexture *); // idb
void __thiscall TextureCacher::purgeAll(TextureCacher *__hidden this); // idb
void __thiscall TextureCacher::removeOldest(TextureCacher *__hidden this); // idb
void __thiscall TextureCacher::cacheTexture(TextureCacher *this, struct CacheTexture *); // idb
unsigned int __thiscall Stream::readInt(Stream *this);
char __thiscall Stream::readByte(Stream *this);
int __thiscall Stream::readShort(Stream *this);
double __thiscall Stream::readFloat(Stream *this);
char *__thiscall Stream::readString(Stream *__hidden this); // idb
void __thiscall Stream::readString(Stream *this, char *, int); // idb
void __thiscall Stream::readString(Stream *this, struct String *); // idb
void __thiscall Stream::writeInt(Stream *this, int); // idb
void __thiscall Stream::writeByte(Stream *this, unsigned __int8); // idb
void __thiscall Stream::writeShort(Stream *this, __int16); // idb
void __thiscall Stream::writeFloat(Stream *this, float); // idb
void __thiscall Stream::writeString(Stream *this, char *); // idb
void __thiscall Stream::writeString(Stream *this, struct String *); // idb
void Stream::print(Stream *this, char *Format, ...); // idb
void __thiscall Stream::vPrintf(Stream *this, char *Format, char *); // idb
void __stdcall Stream::read(void *a2, int a3);
void __stdcall Stream::write(void *a2, int a3);
int Stream::getPending();
int Stream::getAvailable();
void Stream::close();
void __thiscall RandomAccessStream::writeTo(RandomAccessStream *this, int, void *, int); // idb
void __thiscall RandomAccessStream::readFrom(RandomAccessStream *this, int, void *, int); // idb
void __thiscall RandomAccessStream::writeIntTo(RandomAccessStream *this, int, int); // idb
int __thiscall RandomAccessStream::readIntFrom(RandomAccessStream *this, int); // idb
void __thiscall BufferedInputStream::init(BufferedInputStream *this, struct Stream *, unsigned __int8 *, int); // idb
RandomAccessStream *__thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this, struct Stream *a2, unsigned __int8 *a3, int a4);
void __thiscall BufferedInputStream::fillBuffer(BufferedInputStream *__hidden this); // idb
void __thiscall BufferedInputStream::read(BufferedInputStream *this, void *, int); // idb
bool __thiscall String::isSame(String *this, char *); // idb
int __thiscall String::getLength(String *__hidden this); // idb
double String::toFloat();
int __thiscall String::toInt(String *__hidden this); // idb
int __cdecl String::getLength(char *); // idb
bool __cdecl String::isSame(char *, char *); // idb
char *__cdecl String::dup(char *); // idb
char __cdecl String::contains(char *a1, char *a2);
char *__cdecl String::copy(char *, char *); // idb
bool __cdecl String::copyUntil(char *, char *, char, char **); // idb
void __cdecl String::concat(char *, char *); // idb
unsigned __int32 __cdecl String::calcHash(char *); // idb
int __thiscall String::calcHash(String *this);
int __cdecl String::toInt(char *); // idb
void __thiscall Timers::reset(Timers *__hidden this); // idb
void __thiscall Timers::newFrame(Timers *__hidden this); // idb
void __thiscall Timers::_start(Timers *this, char *Str2, bool); // idb
void __thiscall Timers::_stop(Timers *this, char *); // idb
void __thiscall Timers::showTimes(Timers *__hidden this); // idb
char *__cdecl sub_100578B0(char *Format, char a2);
void __thiscall Timers::draw(Timers *this, struct Graphics *, struct Font *); // idb
void __thiscall sub_10058350(_DWORD *this);
char *__cdecl sub_10058B80(char *Format, char a2);
void *__thiscall sub_10058C90(void *this);
char *__thiscall sub_10058D30(_DWORD *this, int a2);
int __thiscall sub_10059AF0(_DWORD *this, int a2);
int __thiscall sub_10059B80(_DWORD *this, int a2);
int __thiscall sub_10059C10(_DWORD *this, int a2);
int __thiscall sub_10059CA0(_DWORD *this, int a2);
char __stdcall sub_10059D80(int a1);
_DWORD *__thiscall sub_10059DF0(_DWORD *this, int a2);
_DWORD *__thiscall sub_10059EE0(_DWORD *this, int a2);
_DWORD *__thiscall sub_10059FA0(_DWORD *this, int a2);
int __thiscall sub_1005A090(_DWORD *this, int a2);
int __thiscall sub_1005A170(_DWORD *this, int a2);
_DWORD *__thiscall sub_1005A200(_DWORD *this, int a2);
_DWORD *__thiscall sub_1005A2C0(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_1005A320(_DWORD *this, int a2);
Graphics *__thiscall sub_1005A3C0(Graphics *this, int a2, int a3);
char *__cdecl sub_1005A690(char *Format, char a2);
void __thiscall sub_1005A7A0(Graphics *this, GLsizei width, GLsizei height);
int __thiscall sub_1005AB60(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_1005ACA0(_DWORD *this, int a2);
void __thiscall sub_1005ACE0(_DWORD *this, struct Matrix4f *a2, struct Matrix4f *a3);
int __thiscall sub_1005AD50(_DWORD *this, int a2);
int __thiscall sub_1005AF30(_DWORD *this, int a2);
char __thiscall sub_1005B020(_BYTE *this, char a2);
char __thiscall sub_1005B0C0(_BYTE *this, char a2, int a3);
void __thiscall sub_1005B200(int this, int a2, int a3);
void __stdcall sub_1005B660(GLfloat size);
void __thiscall sub_1005B6C0(GLfloat *this, int a2);
void __thiscall sub_1005B740(_DWORD *this, RectArea *a2);
void __thiscall sub_1005B800(int this, _DWORD *a2);
void __thiscall sub_1005B8A0(_DWORD *this, RectArea *a2);
_DWORD *__thiscall sub_1005B930(_DWORD *this, int a2, signed int *a3);
void __thiscall sub_1005BB00(void *this, int a2, float a3, float a4, float a5, float a6, GLfloat x);
void __thiscall sub_1005BCB0(void *this, char a2, float *a3);
int __thiscall sub_1005BD80(_DWORD *this, int a2, int a3);
void __thiscall sub_1005BE60(_DWORD *this, char a2, GLfloat *a3);
void __stdcall sub_1005C450(char a1);
int sub_1005C5D0();
int sub_1005C610();
int sub_1005C680();
int sub_1005C6C0();
void __thiscall sub_1005C710(_DWORD *this, Material *a2, int a3);
void __stdcall sub_1005CD10(int a1);
_DWORD *__thiscall sub_1005CD40(_DWORD *this, BaseShape *a2, int a3);
int __thiscall sub_1005D970(void *this, int a2, int a3);
void __thiscall sub_1005DA20(int this, unsigned __int8 *a2, char a3);
_DWORD *__thiscall sub_1005DB70(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_1005DBC0(_DWORD *this, _DWORD *a2);
void __thiscall sub_1005DC10(unsigned __int8 *this, int a2, char a3);
void __thiscall sub_1005DDB0(GLfloat *this, char a2);
int __thiscall sub_1005DF70(_DWORD *this, char a2, _DWORD *a3, int a4, int a5, int a6);
void __thiscall sub_1005E010(_DWORD *this, signed int *a2, signed int *a3, float *a4);
void __thiscall sub_1005E650(unsigned __int8 *this, signed int *a2);
void __thiscall sub_1005E8A0(unsigned __int8 *this, signed int *a2);
void __thiscall sub_1005EA60(void *this, int a2, int a3, int a4, float a5);
void __thiscall sub_1005EEE0(void *this, int a2, int a3, float a4);
void __thiscall sub_1005F260(void *this, int a2, int a3, float *a4, GLfloat *a5, GLfloat *a6);
void __stdcall sub_1005F4D0(GLvoid *pointer, GLsizei count);
void __stdcall sub_1005F580(const GLfloat *a1, const GLfloat *a2, const GLfloat *a3, int a4);
void __stdcall sub_1005F6A0(const GLfloat *a1, const GLfloat *a2, const GLfloat *a3, int a4);
void __stdcall sub_1005F7C0(GLfloat *a1, GLfloat *a2);
char *sub_1005F880(int a1, Font *a2, int a3, int a4, char *Format, ...);
void __thiscall sub_10060030(char *this, AgeServer *a2);
void sub_100600C0();
char __stdcall sub_100600F0(int a1);
int __thiscall sub_10060130(void *this, int a2, int a3);
void __stdcall sub_10060190(int a1);
void __thiscall Shape::optimize(Shape *__hidden this); // idb
int __cdecl Texture::offsetGXtoGL(int, int, int, int); // idb
int __thiscall Texture::offsetGXtoGL(Texture *this, int); // idb
unsigned __int8 __thiscall Texture::getAlpha(Texture *this, int, int); // idb
unsigned __int8 __thiscall Texture::getRed(Texture *this, int, int); // idb
void __thiscall Texture::read(Texture *this, struct RandomAccessStream *); // idb
void __noreturn sub_10060690(char *Format, ...);
void __thiscall Texture::write(Texture *this, struct Stream *); // idb
void __thiscall Texture::createBuffer(Texture *this, int, int, int, void *); // idb
void __thiscall Texture::grabBuffer(Texture *this, GLsizei width, GLsizei height, bool, bool); // idb
void __thiscall Texture::detach(Texture *__hidden this); // idb
void __thiscall Texture::attach(Texture *__hidden this); // idb
void __cdecl Texture::decodeS3TC(int, int, unsigned __int8 *, unsigned __int8 *); // idb
void __thiscall Texture::decodeData(Texture *__hidden this, struct TexImg *); // idb
char *__cdecl sub_10062280(char *Format, char a2);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
void __noreturn sub_10062970(char *Format, ...);
_DWORD *__thiscall sub_10062A50(int this);
void __thiscall sub_10062B60(void *this);
int __thiscall sub_10062C70(_DWORD *this);
int __thiscall sub_10062CF0(_DWORD *this);
char *__cdecl sub_10062EA0(char *Format, char a2);
AtxRouter *__thiscall AtxDirectRouter::AtxDirectRouter(AtxDirectRouter *this, char *Str1);
void __thiscall AtxDirectRouter::setWindow(AtxDirectRouter *this, unsigned __int32); // idb
char __thiscall AtxDirectRouter::openRoute(AtxDirectRouter *this, struct AtxStream *a2, int a3);
void __stdcall AtxDirectRouter::closeRoute(struct AtxStream *a2);
void AtxDirectRouter::reset();
void AtxDirectRouter::closeAll();
int WSocket::closing();
_DWORD *__thiscall WSocket::operator=(_DWORD *this, _DWORD *a2);
TcpStream *__thiscall TcpStream::TcpStream(TcpStream *this);
TcpStream *__thiscall TcpStream::TcpStream(TcpStream *this, const struct TcpStream *a2);
_DWORD *__thiscall TcpStream::operator=(_DWORD *this, int a2);
bool __thiscall AtxDirectRouter::isConnected(AtxDirectRouter *__hidden this); // idb
void AtxDirectRouter::lock();
void AtxDirectRouter::unlock();
AtxRouter *__thiscall AtxDirectRouter::AtxDirectRouter(AtxDirectRouter *this, const struct AtxDirectRouter *a2);
_DWORD *__thiscall AtxDirectRouter::operator=(_DWORD *this, int a2);
void __thiscall ControllerMgr::update(ControllerMgr *__hidden this); // idb
void __thiscall ControllerMgr::updateController(ControllerMgr *this, struct Controller *); // idb
LPSTR __cdecl getOpenFilename(HWND a1, char *Str);
int __cdecl sub_10063F10(int, char *Str); // idb
BOOL __stdcall sub_10064090(int a1, int a2, int a3, int a4);
LPSTR __cdecl getSaveFilename(HWND a1, char *Str, char *a3);
int __thiscall sub_10064240(BaseApp **this, HWND hWnd, unsigned int a3, int a4, int a5);
char *__cdecl sub_100643D0(char *Format, char a2);
void __thiscall GameApp::doInitApp(GameApp *__hidden this); // idb
AppWindow *__thiscall sub_100649B0(AppWindow *this, struct UIWindow *a2, int a3, int a4, int a5, char a6);
int __thiscall GameApp::idle(GameApp *__hidden this); // idb
void __thiscall GameApp::renderall(GameApp *__hidden this); // idb
void __thiscall UIFrame::calcClientFromFrame(UIFrame *this, struct RectArea *); // idb
void __thiscall UIFrame::calcFrameFromClient(UIFrame *this, struct RectArea *); // idb
void __thiscall UIFrame::setFrame(UIFrame *this, struct RectArea *); // idb
void __thiscall UIFrame::setClient(UIFrame *this, struct RectArea *); // idb
UIFrame *__thiscall UIFrame::UIFrame(UIFrame *this, const struct UIFrame *a2);
_DWORD *__thiscall UIFrame::operator=(_DWORD *this, _DWORD *a2);
void __thiscall UIWindow::refreshWindow(UIWindow *__hidden this); // idb
UIFrame *__thiscall UIWindow::UIWindow(UIWindow *this, const struct UIWindow *a2);
_DWORD *__thiscall UIWindow::operator=(_DWORD *this, int a2);
UIWindow *__thiscall ToolWindow::ToolWindow(ToolWindow *this, const struct ToolWindow *a2);
_DWORD *__thiscall ToolWindow::operator=(_DWORD *this, int a2);
int __thiscall ToolWindow::~ToolWindow(ToolWindow *this);
UIWindow *__thiscall SplitBar::SplitBar(SplitBar *this, const struct SplitBar *a2);
_BYTE *__thiscall SplitBar::operator=(_BYTE *this, int a2);
int __thiscall SplitBar::~SplitBar(SplitBar *this);
SplitBar *__thiscall VertSplitBar::VertSplitBar(VertSplitBar *this, const struct VertSplitBar *a2);
void *__thiscall VertSplitBar::operator=(void *this, int a2);
int __thiscall VertSplitBar::~VertSplitBar(VertSplitBar *this);
SplitBar *__thiscall HorzSplitBar::HorzSplitBar(HorzSplitBar *this, const struct HorzSplitBar *a2);
void *__thiscall HorzSplitBar::operator=(void *this, int a2);
int __thiscall HorzSplitBar::~HorzSplitBar(HorzSplitBar *this);
void __stdcall ComboBox::entryHandler(char *a2);
ComboBox *__thiscall ComboBox::ComboBox(ComboBox *this, const struct ComboBox *a2);
_DWORD *__thiscall ComboBox::operator=(_DWORD *this, int a2);
int __thiscall ComboBox::~ComboBox(ComboBox *this);
ComboBox *__thiscall EditBox::EditBox(EditBox *this, const struct EditBox *a2);
void *__thiscall EditBox::operator=(void *this, int a2);
int __thiscall EditBox::~EditBox(EditBox *this);
void __stdcall OptionBox::selectionChanged(int a2);
ComboBox *__thiscall OptionBox::OptionBox(OptionBox *this, const struct OptionBox *a2);
void *__thiscall OptionBox::operator=(void *this, int a2);
int __thiscall OptionBox::~OptionBox(OptionBox *this);
UIWindow *__thiscall RenderWindow::RenderWindow(RenderWindow *this, const struct RenderWindow *a2);
_DWORD *__thiscall RenderWindow::operator=(_DWORD *this, int a2);
int __thiscall RenderWindow::~RenderWindow(RenderWindow *this);
UIWindow *__thiscall AppWindow::AppWindow(AppWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6);
UIWindow *__thiscall AppWindow::AppWindow(AppWindow *this, const struct AppWindow *a2);
_DWORD *__thiscall AppWindow::operator=(_DWORD *this, int a2);
int __thiscall AppWindow::~AppWindow(AppWindow *this);
char __thiscall UIMgr::isActive(UIMgr *this);
Node *__thiscall UIMgr::UIMgr(UIMgr *this, const struct UIMgr *a2);
void *__thiscall UIMgr::operator=(void *this, int a2);
void *__thiscall Module::operator=(void *this, const void *a2);
_DWORD *__thiscall ModuleMgr::operator=(_DWORD *this, _DWORD *a2);
BaseApp *__thiscall GameApp::GameApp(GameApp *this);
BaseApp *__thiscall GameApp::GameApp(GameApp *this, const struct GameApp *a2);
_DWORD *__thiscall GameApp::operator=(_DWORD *this, int a2);
int __thiscall GameApp::~GameApp(GameApp *this);
int __thiscall sub_10066400(char *this, char a2);
void __thiscall Module::Load(Module *this, char *); // idb
char *__cdecl sub_10066610(char *Format, char a2);
void __thiscall Module::menuPlugins(Module *this, struct MenuPlugin *, HMENU); // idb
void __thiscall Module::~Module(Module *this);
struct Module *__thiscall ModuleMgr::findModule(ModuleMgr *this, char *); // idb
struct Module *__thiscall ModuleMgr::loadModule(ModuleMgr *this, char *); // idb
int __thiscall ModuleMgr::Alloc(ModuleMgr *this, char *a2);
void __thiscall ModuleMgr::listModules(ModuleMgr *__hidden this); // idb
void __thiscall ModuleMgr::UnLoad(ModuleMgr *this, struct Module *); // idb
Module *__thiscall sub_10066D30(Module *this, char a2);
ModuleMgr *__thiscall ModuleMgr::ModuleMgr(ModuleMgr *this);
ModuleMgr *__thiscall ModuleMgr::~ModuleMgr(ModuleMgr *this);
_DWORD *__thiscall sub_10066ED0(_DWORD *this);
_DWORD *__thiscall sub_10066F10(_DWORD *this, int a2);
_BYTE *__cdecl sub_10066F60(SIZE_T dwBytes);
void __noreturn sub_100670A0(char *Format, ...);
char *__cdecl sub_10067140(char *Format, char a2);
_BYTE *__cdecl sub_10067250(SIZE_T dwBytes);
int __cdecl sub_10067410(int a1, int a2);
StdSystem *__cdecl sub_10067490(HGLOBAL hMem);
StdSystem *__cdecl sub_100674F0(HGLOBAL hMem);
BOOL __thiscall System::buildModeList(_DWORD *this);
char *__cdecl sub_10067750(char *Format, char a2);
char __thiscall System::setVideoMode(int this, int a2, int a3, int a4, int a5);
void __noreturn sub_10067AD0(char *Format, ...);
struct RandomAccessStream *__thiscall System::openFile(char *this, int a2, bool a3, char a4);
RandomAccessStream *__thiscall sub_10067DB0(RandomAccessStream *this, int a2, int a3);
int __thiscall sub_10067EB0(FILE **this, void *DstBuf, size_t Count);
size_t __thiscall sub_10067F50(FILE **this, void *Str, size_t Count);
int __thiscall sub_10067FC0(_DWORD *this);
int __thiscall sub_10068000(_DWORD *this);
int __thiscall sub_10068040(FILE **this);
int __thiscall sub_100680A0(FILE **this, int Offset);
int __thiscall sub_10068110(FILE **this);
struct RandomAccessStream *__thiscall System::createFile(char *this, int a2, char a3);
struct UIWindow *__stdcall System::createDebugStream(struct UIWindow *a2);
Stream *__thiscall sub_10068470(Stream *this, struct UIWindow *a2);
int __thiscall sub_10068650(const char *this);
int __thiscall sub_10068800(void *this, int a2, int a3);
_DWORD *__thiscall sub_100688D0(_DWORD *this, char a2);
struct CoreNode *System::firstApp();
WPARAM __thiscall System::run(struct BaseApp *this, int a2);
int __thiscall System::searchFiles(void *this, int a2, int a3, void (__thiscall ***a4)(_DWORD, char *, _fsize_t), char a5);
double __thiscall System::getTime(void *this);
LARGE_INTEGER *__thiscall System::updateSysClock(LARGE_INTEGER *this);
StdSystem *__thiscall System::System(StdSystem *this);
HGLOBAL __thiscall System::~System(HGLOBAL *this);
StdSystem *__thiscall System::hardReset(StdSystem *this);
void __cdecl __noreturn System::halt(char *, int, char *); // idb
void __stdcall System::sleep(float a2);
HANDLE __cdecl startThread(LPTHREAD_START_ROUTINE lpStartAddress, void *lpParameter, int a3);
void __thiscall System::genAge(struct AgeServer *this, struct AgeServer *a2);
TcpStream *__thiscall TcpStream::TcpStream(TcpStream *this, struct WSocket *a2);
BOOL __thiscall TcpStream::connect(TcpStream *this, char *a2, int a3);
int __thiscall TcpStream::getPending(TcpStream *__hidden this); // idb
int TcpStream::getAvailable();
void __thiscall TcpStream::flush(TcpStream *__hidden this); // idb
void __thiscall TcpStream::read(TcpStream *this, char *buf, int); // idb
void __thiscall TcpStream::write(TcpStream *this, void *, int); // idb
void __thiscall TcpStream::close(TcpStream *__hidden this); // idb
BOOL __thiscall TcpStream::closing(TcpStream *this);
void __stdcall handlePopupMenu(HWND hWnd, int *, struct tagPOINT Point, HMENU hMenu); // idb
LRESULT __stdcall sub_10069C80(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
void __thiscall UIMgr::activateWindow(UIMgr *this, HWND, struct UIWindow *); // idb
void __thiscall UIMgr::RegisterGenWindowClass(UIMgr *this, LPCSTR lpszClass, void *, bool); // idb
Node *__thiscall UIMgr::UIMgr(UIMgr *this);
struct CoreNode *__thiscall UIMgr::~UIMgr(UIMgr *this);
UIWindow *__thiscall RenderWindow::RenderWindow(RenderWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6);
void __thiscall RenderWindow::initOpenGL(RenderWindow *__hidden this); // idb
void __thiscall RenderWindow::shutdownOpenGL(RenderWindow *__hidden this); // idb
void RenderWindow::clearRender();
void __thiscall RenderWindow::paintRender(RenderWindow *this, struct RectArea *); // idb
void __thiscall RenderWindow::update(RenderWindow *__hidden this); // idb
void __thiscall RenderWindow::createWindow(RenderWindow *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU); // idb
int __thiscall RenderWindow::processMessage(RenderWindow *this, HWND hWnd, UINT Msg, WPARAM wParam, int); // idb
int __thiscall ToolWindow::processMessage(ToolWindow *this, HWND hWnd, unsigned int, unsigned int, int); // idb
void __thiscall ToolWindow::initTools(ToolWindow *this, HINSTANCE hInstance, WPARAM wParam, LPARAM, struct tagTBADDBITMAP *); // idb
void __thiscall ToolWindow::createWindow(ToolWindow *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU); // idb
UIWindow *__thiscall ToolWindow::ToolWindow(ToolWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6);
UIFrame *__thiscall UIFrame::UIFrame(UIFrame *this);
HDWP __thiscall UIWindow::resizeFrame(UIWindow *this, HDWP hWinPosInfo, struct RectArea *a3);
void __stdcall UIWindow::dockTop(int a2, struct RectArea *a3, struct RectArea *a4);
void *__thiscall UIWindow::resizeChildren(UIWindow *this, void *, struct RectArea *); // idb
void __thiscall UIWindow::updateSizes(UIWindow *this, int, int); // idb
void __thiscall UIWindow::updateMove(UIWindow *this, int, int); // idb
void UIWindow::activate();
int __thiscall UIWindow::processMessage(UIWindow *this, HWND hWnd, unsigned int, unsigned int, int); // idb
LRESULT __stdcall UIWindow::returnMessage(HWND hWnd, UINT Msg, WPARAM wParam, int lParam);
void __thiscall UIWindow::sizeWindow(UIWindow *this, int, int, int); // idb
void __thiscall UIWindow::createWindow(UIWindow *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU); // idb
void __thiscall UIWindow::initFrame(UIWindow *this, struct UIWindow *, int, int, int, bool); // idb
void __thiscall UIWindow::closeChildren(UIWindow *__hidden this); // idb
UIFrame *__thiscall UIWindow::UIWindow(UIWindow *this);
UIWindow *__thiscall UIWindow::UIWindow(UIWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6);
char *__thiscall UIWindow::~UIWindow(UIWindow *this);
char *__cdecl sub_1006C600(char *Format, char a2);
UIWindow *__thiscall SplitBar::SplitBar(SplitBar *this, struct UIWindow *a2, struct UIWindow *a3, COLORREF color, int a5);
int __thiscall SplitBar::processMessage(SplitBar *this, HWND hWnd, unsigned int, unsigned int, int); // idb
void __thiscall SplitBar::handleClick(SplitBar *this, int, int); // idb
void __thiscall SplitBar::handleRelease(SplitBar *this, int, int); // idb
VertSplitBar *__thiscall VertSplitBar::VertSplitBar(VertSplitBar *this, struct UIWindow *a2, struct UIWindow *a3, COLORREF color, int a5);
void __thiscall VertSplitBar::trackMouse(VertSplitBar *this, int, int, int); // idb
HorzSplitBar *__thiscall HorzSplitBar::HorzSplitBar(HorzSplitBar *this, struct UIWindow *a2, struct UIWindow *a3, COLORREF color, int a5);
void __thiscall HorzSplitBar::trackMouse(HorzSplitBar *this, int, int, int); // idb
ComboBox *__thiscall ComboBox::ComboBox(ComboBox *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6);
LRESULT __stdcall sub_1006D070(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __thiscall ComboBox::processMessage(ComboBox *this, HWND hWnd, unsigned int, unsigned int, int); // idb
void __thiscall ComboBox::createWindow(ComboBox *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU); // idb
void __thiscall ComboBox::addOption(ComboBox *this, LPARAM lParam, bool); // idb
void __thiscall ComboBox::selOption(ComboBox *this, int); // idb
ComboBox *__thiscall EditBox::EditBox(EditBox *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6);
void __thiscall EditBox::entryHandler(EditBox *this, char *); // idb
int __thiscall EditBox::processMessage(EditBox *this, HWND hWnd, unsigned int, unsigned int, int); // idb
ComboBox *__thiscall OptionBox::OptionBox(OptionBox *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6);
int __thiscall OptionBox::processMessage(OptionBox *__hidden this, HWND, unsigned int, unsigned int, int); // idb
int __thiscall AppWindow::processMessage(AppWindow *this, HWND hWnd, unsigned int, unsigned int, int); // idb
void __cdecl WSocket::init();
char *__cdecl sub_1006DB60(char *Format, char a2);
char __thiscall WSocket::open(WSocket *this, char *name, int hostshort);
char __thiscall WSocket::create(WSocket *this, char *a2, int hostshort);
void WSocket::flushWrite();
u_long __thiscall WSocket::pending(WSocket *this);
char __thiscall WSocket::checkForConnections(WSocket *this);
void __thiscall WSocket::connect(WSocket *__hidden this); // idb
void __thiscall WSocket::write(WSocket *__hidden this, void *, int); // idb
void __noreturn sub_1006E290(char *Format, ...);
void __thiscall WSocket::read(WSocket *this, char *buf, int); // idb
void __thiscall WSocket::setASync(WSocket *__hidden this, HWND, unsigned __int32, unsigned __int32, int); // idb
void __thiscall WSocket::close(WSocket *__hidden this); // idb
// void __stdcall gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);
// int __stdcall gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data);
// int __stdcall gethostname(char *name, int namelen);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// u_short __stdcall htons(u_short hostshort);
// SOCKET __stdcall socket(int af, int type, int protocol);
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall listen(SOCKET s, int backlog);
// int __stdcall ioctlsocket(SOCKET s, int cmd, u_long *argp);
// int __stdcall _WSAFDIsSet(SOCKET fd, fd_set *);
// int __stdcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// SOCKET __stdcall accept(SOCKET s, struct sockaddr *addr, int *addrlen);
// int __stdcall WSAGetLastError();
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, int lEvent);
// int __stdcall closesocket(SOCKET s);
// BOOL __stdcall GetOpenFileNameA(LPOPENFILENAMEA);
// BOOL __stdcall GetSaveFileNameA(LPOPENFILENAMEA);
// void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
// double __cdecl cos(double x); idb
// double __cdecl fmod(double x, double y); idb
// double __cdecl sin(double x); idb
// int _CxxFrameHandler(void); weak
// double __cdecl sqrt(double x); idb
// double __cdecl fabs(double x); idb
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// double __cdecl acos(double x); idb
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// void *__cdecl memset(void *Dst, int Val, size_t Size);
int PVWTextureInfo::read();
int Font::setTexture();
int GfxInfo::createCollData();
int Graphics::Graphics();
int CurveSection::genCurve();
int TexAttr::initImage();
int TextureCacher::TextureCacher();
int LightGroup::addLight();
int AnimPalette::AnimPalette();
int BaseShape::makeRouteGroup();
int Light::updAge();
int Light::genAge();
int DispList::prepareTriList();
int DispList::exportData();
int SEH_10025670();
int MtxGroup::read();
int Mesh::read();
int Joint::read();
int Joint::genAge();
int SceneData::parse();
int SceneData::getAnimInfo();
int AnimData::initData();
int AnimData::genAge();
int AnimDca::read();
int AnimDca::parse();
int AnimDca::getAnimInfo();
int AnimDck::AnimDck();
int AnimDck::read();
int AnimDck::parse();
int AnimDck::getAnimInfo();
int BaseShape::importIni();
int BaseShape::instanceMaterials();
int BaseShape::makeInstance();
int BaseShape::resolveTextureNames();
int BaseShape::read();
int BaseShape::initialise();
int BaseShape::createCollisions();
int BaseShape::loadDck();
int BaseShape::importDck();
int BaseShape::loadDca();
int BaseShape::importDca();
int BaseShape::loadAnimation();
int AnimFrameCacher::AnimFrameCacher();
int SEH_10037C10();
int SEH_10037FC0();
int LightFlare::genAge();
int LightGroup::genAge();
int LightGroup::loadini();
int ObjCollInfo::newCollInfoButton();
int ObjCollInfo::genAge();
int ObjCollInfo::loadini();
int RouteGroup::loadini();
int CoreNode::genAge();
int BaseApp::startAgeServer();
int LightCamera::initLightmap();
int ID32::genAge();
int StdSystem::loadTexture();
int StdSystem::loadShape();
int StdSystem::addAnimation();
int StdSystem::addTexture();
int StdSystem::getShape();
int StdSystem::initLFlares();
int StdSystem::registerLFlare();
int StdSystem::loadBundle();
int Timers::_start();
int SEH_10058350();
int SEH_10058C90();
int Shape::optimize();
int Texture::read();
int AtxDirectRouter::openRoute();
int GameApp::doInitApp();
int Module::menuPlugins();
int System::openFile();
int System::createFile();
int System::createDebugStream();
int SEH_10068470();
int RenderWindow::initOpenGL();
int ToolWindow::createWindow();
int VertSplitBar::VertSplitBar();
int HorzSplitBar::HorzSplitBar();
int ComboBox::createWindow();
// void __stdcall InitCommonControls();
// int __stdcall SelectClipRgn(HDC hdc, HRGN hrgn);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// HRGN __stdcall CreateRectRgn(int x1, int y1, int x2, int y2);
// BOOL __stdcall SwapBuffers(HDC);
// HBRUSH __stdcall CreateSolidBrush(COLORREF color);
// BOOL __stdcall SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd);
// int __stdcall DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd);
// HGDIOBJ __stdcall GetStockObject(int i);
// int __stdcall ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// BOOL __stdcall QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// DWORD __stdcall SleepEx(DWORD dwMilliseconds, BOOL bAlertable);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// int __cdecl fseek(FILE *File, int Offset, int Origin);
// int __cdecl ftell(FILE *File);
// int __cdecl vsprintf(char *Dest, const char *Format, va_list Args);
// int sprintf(char *Dest, const char *Format, ...);
// int __cdecl rand();
// int sscanf(const char *Src, const char *Format, ...);
// void __cdecl assert(void *, void *, unsigned int);
// char *__cdecl strncpy(char *Dest, const char *Source, size_t Count);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// char *__cdecl getcwd(char *, int);
// size_t __cdecl fread(void *DstBuf, size_t ElementSize, size_t Count, FILE *File);
// size_t __cdecl fwrite(const void *Str, size_t Size, size_t Count, FILE *File);
// int __cdecl fclose(FILE *File);
// int __cdecl fflush(FILE *File);
// int __cdecl findclose(int);
// int __cdecl findnext(int, struct _finddata_t *);
// int __cdecl findfirst(const char *, struct _finddata_t *);
// void __cdecl __noreturn exit(int Code);
// void __cdecl free(void *Memory);
// FILE *__cdecl fopen(const char *Filename, const char *Mode);
// char *__cdecl strdup(const char *Src);
// void __stdcall glLoadMatrixf(const GLfloat *m);
// void __stdcall glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
// void __stdcall glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
// void __stdcall glLightf(GLenum light, GLenum pname, GLfloat param);
// void __stdcall glFinish();
// void __stdcall glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
// BOOL __stdcall wglDeleteContext(HGLRC);
// HGLRC __stdcall wglCreateContext(HDC);
// BOOL __stdcall wglMakeCurrent(HDC, HGLRC);
// void __stdcall glGenTextures(GLsizei n, GLuint *textures);
// void __stdcall glTexParameteri(GLenum target, GLenum pname, GLint param);
// void __stdcall glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
// void __stdcall glDeleteTextures(GLsizei n, const GLuint *textures);
// void __stdcall glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
// void __stdcall glEnable(GLenum cap);
// void __stdcall glDepthFunc(GLenum func);
// void __stdcall glTexGeni(GLenum coord, GLenum pname, GLint param);
// void __stdcall glTexEnvi(GLenum target, GLenum pname, GLint param);
// void __stdcall glTranslatef(GLfloat x, GLfloat y, GLfloat z);
// void __stdcall glMultMatrixf(const GLfloat *m);
// void __stdcall glBindTexture(GLenum target, GLuint texture);
// void __stdcall glDrawArrays(GLenum mode, GLint first, GLsizei count);
// void __stdcall glClipPlane(GLenum plane, const GLdouble *equation);
// void __stdcall glScalef(GLfloat x, GLfloat y, GLfloat z);
// void __stdcall glGetFloatv(GLenum pname, GLfloat *params);
// void __stdcall glMatrixMode(GLenum mode);
// void __stdcall glLoadIdentity();
// void __stdcall glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
// void __stdcall glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
// void __stdcall glEnableClientState(GLenum array);
// void __stdcall glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
// void __stdcall glTexCoord2f(GLfloat s, GLfloat t);
// PROC __stdcall wglGetProcAddress(LPCSTR);
// void __stdcall glVertex3f(GLfloat x, GLfloat y, GLfloat z);
// void __stdcall glFogi(GLenum pname, GLint param);
// void __stdcall glFogfv(GLenum pname, const GLfloat *params);
// void __stdcall glFogf(GLenum pname, GLfloat param);
// void __stdcall glClearDepth(GLclampd depth);
// void __stdcall glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
// void __stdcall glClear(GLbitfield mask);
// void __stdcall glColor4fv(const GLfloat *v);
// void __stdcall glMaterialfv(GLenum face, GLenum pname, const GLfloat *params);
// void __stdcall glCallList(GLuint list);
// void __stdcall glBegin(GLenum mode);
// void __stdcall glNormal3fv(const GLfloat *v);
// void __stdcall glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
// void __stdcall glTexCoord2fv(const GLfloat *v);
// void __stdcall glVertex3fv(const GLfloat *v);
// void __stdcall glEnd();
// void __stdcall glEndList();
// void __stdcall glAlphaFunc(GLenum func, GLclampf ref);
// void __stdcall glDisableClientState(GLenum array);
// void __stdcall glTexGenf(GLenum coord, GLenum pname, GLfloat param);
// void __stdcall glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params);
// void __stdcall glLightfv(GLenum light, GLenum pname, const GLfloat *params);
// void __stdcall glBlendFunc(GLenum sfactor, GLenum dfactor);
// void __stdcall glDrawBuffer(GLenum mode);
// void __stdcall glGetIntegerv(GLenum pname, GLint *params);
// const GLubyte *__stdcall glGetString(GLenum name);
// void __stdcall glShadeModel(GLenum mode);
// void __stdcall glDisable(GLenum cap);
// void __stdcall glDepthMask(GLboolean flag);
// void __stdcall glLineWidth(GLfloat width);
// void __stdcall glPolygonMode(GLenum face, GLenum mode);
// void __stdcall glPointSize(GLfloat size);
// void __stdcall glCullFace(GLenum mode);
// BOOL __stdcall SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// int __stdcall GetSystemMetrics(int nIndex);
// BOOL __stdcall ValidateRect(HWND hWnd, const RECT *lpRect);
// BOOL __stdcall EndDeferWindowPos(HDWP hWinPosInfo);
// HWND __stdcall SetFocus(HWND hWnd);
// HWND __stdcall GetFocus();
// HDWP __stdcall BeginDeferWindowPos(int nNumWindows);
// BOOL __stdcall ReleaseCapture();
// LRESULT __stdcall CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// HWND __stdcall GetParent(HWND hWnd);
// HWND __stdcall ChildWindowFromPoint(HWND hWndParent, POINT Point);
// int __stdcall LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax);
// HDWP __stdcall DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags);
// HBITMAP __stdcall LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName);
// int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// HDC __stdcall GetDC(HWND hWnd);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// BOOL __stdcall SetForegroundWindow(HWND hWnd);
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// BOOL __stdcall GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase);
// HWND __stdcall SetCapture(HWND hWnd);
// BOOL __stdcall GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx);
// HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
// ATOM __stdcall RegisterClassExA(const WNDCLASSEXA *);
// LONG __stdcall GetWindowLongA(HWND hWnd, int nIndex);
// LONG __stdcall SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong);
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// HMENU __stdcall GetSubMenu(HMENU hMenu, int nPos);
// BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint);
// BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// BOOL __stdcall DestroyMenu(HMENU hMenu);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// BOOL __stdcall PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// LRESULT __stdcall DispatchMessageA(const MSG *lpMsg);
// void __stdcall PostQuitMessage(int nExitCode);
// BOOL __stdcall WaitMessage();
// LONG __stdcall ChangeDisplaySettingsA(DEVMODEA *lpDevMode, DWORD dwFlags);
// BOOL __stdcall EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode);
// UINT __stdcall RegisterWindowMessageA(LPCSTR lpString);
// BOOL __stdcall InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi);
// LRESULT __stdcall SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// int __stdcall ShowCursor(BOOL bShow);
// BOOL __stdcall GetKeyboardState(PBYTE lpKeyState);
// BOOL __stdcall AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);

//-------------------------------------------------------------------------
// Data declarations

void *Stream::`vftable' = &Stream::readInt; // weak
void *RandomAccessStream::`vftable' = &Stream::readInt; // weak
void *BufferedOutputStream::`vftable' = &Stream::readInt; // weak
void *BufferedInputStream::`vftable' = &Stream::readInt; // weak
void *BufferedStream::`vftable' = &Stream::readInt; // weak
void *RamStream::`vftable' = &Stream::readInt; // weak
void *ANode::`vftable' = &ANode::genAge; // weak
void *Graphics::`vftable' = &Graphics::videoReset; // weak
char `string'[4] = { '\0', '\0', '\0', '\0' }; // idb
void *BaseScalingSystem::`vftable' = &purecall; // weak
void *ClassicScalingSystem::`vftable' = &ClassicScalingSystem::blah; // weak
void *SoftImageScalingSystem::`vftable' = &SoftImageScalingSystem::blah; // weak
void *CoreNode::`vftable' = &CoreNode::genAge; // weak
void *Node::`vftable' = &CoreNode::genAge; // weak
void *SRTNode::`vftable' = &SRTNode::genAge; // weak
void *ObjMgr::`vftable' = &SRTNode::genAge; // weak
void *EditNode::`vftable' = &CoreNode::genAge; // weak
void *MemInfoNode::`vftable' = &CoreNode::genAge; // weak
void *GfxobjInfo::`vftable' = &GfxobjInfo::attach; // weak
void *GfxObject::`vftable' = &GfxObject::attach; // weak
void *FntobjInfo::`vftable' = &GfxobjInfo::attach; // weak
void *ShpobjInfo::`vftable' = &GfxobjInfo::attach; // weak
void *AnmobjInfo::`vftable' = &GfxobjInfo::attach; // weak
void *BinobjInfo::`vftable' = &GfxobjInfo::attach; // weak
void *TexobjInfo::`vftable' = &TexobjInfo::attach; // weak
void *StdSystem::`vftable' = &StdSystem::initSoftReset; // weak
void *ControllerMgr::`vftable' = &ControllerMgr::keyDown; // weak
void *AtxRouter::`vftable' = &purecall; // weak
void *AtxStream::`vftable' = &Stream::readInt; // weak
void *AtxCommandStream::`vftable' = &Stream::readInt; // weak
void *AtxFileStream::`vftable' = &Stream::readInt; // weak
void *System::`vftable' = &StdSystem::initSoftReset; // weak
void *LinkedRoomInfo::`vftable' = &CoreNode::genAge; // weak
void *LightFlare::`vftable' = &LightFlare::genAge; // weak
void *LightGroup::`vftable' = &LightGroup::genAge; // weak
void *Light::`vftable' = &Light::genAge; // weak
void *DynCollObject::`vftable' = &CoreNode::genAge; // weak
void *Material::`vftable' = &Material::genAge; // weak
void *FaceNode::`vftable' = &CoreNode::genAge; // weak
void *DispList::`vftable' = &CoreNode::genAge; // weak
void *MatobjInfo::`vftable' = &MatobjInfo::attach; // weak
void *DlobjInfo::`vftable' = &DlobjInfo::attach; // weak
void *Mesh::`vftable' = &CoreNode::genAge; // weak
void *ObjCollInfo::`vftable' = &ObjCollInfo::genAge; // weak
void *Joint::MatPoly::`vftable' = &CoreNode::genAge; // weak
void *Joint::`vftable' = &Joint::genAge; // weak
void *SceneData::`vftable' = &SceneData::genAge; // weak
void *AnimData::`vftable' = &AnimData::genAge; // weak
void *AnimDca::`vftable' = &AnimData::genAge; // weak
void *AnimDck::`vftable' = &AnimData::genAge; // weak
void *AnimContext::`vftable' = &AnimContext::animate; // weak
void *TexImg::`vftable' = &CoreNode::genAge; // weak
void *TexAttr::`vftable' = &CoreNode::genAge; // weak
void *RouteLink::`vftable' = &CoreNode::genAge; // weak
void *RoutePoint::`vftable' = &RoutePoint::genAge; // weak
void *RouteGroup::`vftable' = &CoreNode::genAge; // weak
void *BaseShape::`vftable' = &CoreNode::genAge; // weak
void *Shape::`vftable' = &CoreNode::genAge; // weak
void *Texture::`vftable' = &Texture::attach; // weak
void *CacheTexture::`vftable' = &Texture::attach; // weak
void *MaterialHandler::`vftable' = &MaterialHandler::setMaterial; // weak
void *LFlareGroup::`vftable' = &CoreNode::genAge; // weak
void *AgeServer::`vftable' = &Stream::readInt; // weak
int (__stdcall *off_101AE0D8)(int) = &sub_1000191A; // weak
void *off_101AE0DC = &purecall; // weak
int (__stdcall *off_101AEAC4[2])(int) = { &sub_10002676, &sub_10001519 }; // weak
int (__stdcall *off_101AEAC8)(int) = &sub_10001519; // weak
int (__stdcall *off_101AEACC)(int, int) = &sub_10002581; // weak
void *off_101AEAD0 = &purecall; // weak
int (__stdcall *off_101AECF4[2])(int) = { &sub_10001852, &sub_1000236F }; // weak
int (__stdcall *off_101AECF8)(int) = &sub_1000236F; // weak
int (__stdcall *off_101AEEB0)(int) = &sub_10001DB6; // weak
int (__stdcall *off_101AF0F0)(int) = &sub_100026F3; // weak
void *BaseApp::`vftable' = &BaseApp::genAge; // weak
void *Controller::`vftable' = &CoreNode::genAge; // weak
int (*off_101AF598)() = &sub_100029F5; // weak
void *off_101AF59C = &purecall; // weak
void (__thiscall *off_101AF7F8)(Graphics *this) = &Graphics::videoReset; // weak
void *AtxDirectRouter::`vftable' = &AtxDirectRouter::openRoute; // weak
void *TcpStream::`vftable' = &Stream::readInt; // weak
void (__thiscall *off_101AFB84[2])(CoreNode *this, struct AgeServer *) = { &CoreNode::genAge, &CoreNode::genAgeNode }; // weak
void *UIFrame::`vftable' = &CoreNode::genAge; // weak
void *UIWindow::`vftable' = &CoreNode::genAge; // weak
void *ToolWindow::`vftable' = &CoreNode::genAge; // weak
void *SplitBar::`vftable' = &CoreNode::genAge; // weak
void *VertSplitBar::`vftable' = &CoreNode::genAge; // weak
void *HorzSplitBar::`vftable' = &CoreNode::genAge; // weak
void *ComboBox::`vftable' = &CoreNode::genAge; // weak
void *EditBox::`vftable' = &CoreNode::genAge; // weak
void *OptionBox::`vftable' = &CoreNode::genAge; // weak
void *RenderWindow::`vftable' = &CoreNode::genAge; // weak
void *AppWindow::`vftable' = &CoreNode::genAge; // weak
void *UIMgr::`vftable' = &CoreNode::genAge; // weak
void *GameApp::`vftable' = &BaseApp::genAge; // weak
int (__thiscall *off_101B0314)(Stream *this) = &Stream::readInt; // weak
int (__thiscall *off_101B03A4)(Stream *this) = &Stream::readInt; // weak
__int16 word_101B4D88[1478] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255,
  256,
  257,
  258,
  259,
  260,
  261,
  262,
  263,
  264,
  265,
  266,
  267,
  268,
  269,
  270,
  271,
  272,
  273,
  274,
  275,
  276,
  277,
  278,
  279,
  280,
  281,
  282,
  283,
  284,
  285,
  286,
  287,
  288,
  289,
  290,
  291,
  292,
  293,
  294,
  295,
  296,
  297,
  298,
  299,
  300,
  301,
  302,
  303,
  304,
  305,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  314,
  315,
  316,
  317,
  318,
  319,
  320,
  321,
  322,
  323,
  324,
  325,
  326,
  327,
  328,
  329,
  330,
  331,
  332,
  333,
  334,
  335,
  336,
  337,
  338,
  339,
  340,
  341,
  342,
  343,
  344,
  345,
  346,
  347,
  348,
  349,
  350,
  351,
  352,
  353,
  354,
  355,
  356,
  357,
  358,
  359,
  360,
  361,
  362,
  363,
  364,
  365,
  366,
  367,
  368,
  369,
  370,
  371,
  372,
  373,
  374,
  375,
  376,
  377,
  378,
  379,
  380,
  381,
  382,
  383,
  384,
  385,
  386,
  387,
  388,
  389,
  390,
  391,
  392,
  393,
  394,
  395,
  396,
  397,
  398,
  399,
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  408,
  409,
  410,
  411,
  412,
  413,
  414,
  415,
  416,
  417,
  418,
  419,
  420,
  421,
  422,
  423,
  424,
  425,
  426,
  427,
  428,
  429,
  430,
  431,
  432,
  433,
  434,
  435,
  436,
  437,
  438,
  439,
  440,
  441,
  442,
  443,
  444,
  445,
  446,
  447,
  448,
  449,
  450,
  451,
  452,
  453,
  454,
  455,
  456,
  457,
  458,
  459,
  460,
  461,
  462,
  463,
  464,
  465,
  466,
  467,
  468,
  469,
  470,
  471,
  472,
  473,
  474,
  475,
  476,
  477,
  478,
  479,
  480,
  481,
  482,
  483,
  484,
  485,
  486,
  487,
  488,
  489,
  490,
  491,
  492,
  493,
  494,
  495,
  496,
  497,
  498,
  499,
  500,
  501,
  502,
  503,
  504,
  505,
  506,
  507,
  508,
  509,
  510,
  511,
  512,
  513,
  514,
  515,
  516,
  517,
  518,
  519,
  520,
  521,
  522,
  523,
  524,
  525,
  526,
  527,
  528,
  529,
  530,
  531,
  532,
  533,
  534,
  535,
  536,
  537,
  538,
  539,
  540,
  541,
  542,
  543,
  544,
  545,
  546,
  547,
  548,
  549,
  550,
  551,
  552,
  553,
  554,
  555,
  556,
  557,
  558,
  559,
  560,
  561,
  562,
  563,
  564,
  565,
  566,
  567,
  568,
  569,
  570,
  571,
  572,
  573,
  574,
  575,
  576,
  577,
  578,
  579,
  580,
  581,
  582,
  583,
  584,
  585,
  586,
  587,
  588,
  589,
  590,
  591,
  592,
  593,
  594,
  595,
  596,
  597,
  598,
  599,
  600,
  601,
  602,
  603,
  604,
  605,
  606,
  607,
  608,
  609,
  610,
  611,
  612,
  613,
  614,
  615,
  616,
  617,
  618,
  619,
  620,
  621,
  622,
  623,
  624,
  625,
  626,
  627,
  628,
  629,
  630,
  631,
  632,
  633,
  634,
  635,
  636,
  637,
  638,
  639,
  640,
  641,
  642,
  643,
  644,
  645,
  646,
  647,
  648,
  649,
  650,
  651,
  652,
  653,
  654,
  655,
  656,
  657,
  658,
  659,
  660,
  661,
  662,
  663,
  664,
  665,
  666,
  667,
  668,
  669,
  670,
  671,
  672,
  673,
  674,
  675,
  676,
  677,
  678,
  679,
  680,
  681,
  682,
  683,
  684,
  685,
  686,
  687,
  688,
  689,
  690,
  691,
  692,
  693,
  694,
  695,
  696,
  697,
  698,
  699,
  700,
  701,
  702,
  703,
  704,
  705,
  706,
  707,
  708,
  709,
  710,
  711,
  712,
  713,
  714,
  715,
  716,
  717,
  718,
  719,
  720,
  721,
  722,
  723,
  724,
  725,
  726,
  727,
  728,
  729,
  730,
  731,
  732,
  733,
  734,
  735,
  736,
  737,
  738,
  739,
  740,
  741,
  742,
  743,
  744,
  745,
  746,
  747,
  748,
  749,
  750,
  751,
  752,
  753,
  754,
  755,
  756,
  757,
  758,
  759,
  760,
  761,
  762,
  763,
  764,
  765,
  766,
  767,
  768,
  769,
  770,
  771,
  772,
  773,
  774,
  775,
  776,
  777,
  778,
  779,
  780,
  781,
  782,
  783,
  784,
  785,
  786,
  787,
  788,
  789,
  790,
  791,
  792,
  793,
  794,
  795,
  796,
  797,
  798,
  799,
  800,
  801,
  802,
  803,
  804,
  805,
  806,
  807,
  808,
  809,
  810,
  811,
  812,
  813,
  814,
  815,
  816,
  817,
  818,
  819,
  820,
  821,
  822,
  823,
  824,
  825,
  826,
  827,
  828,
  829,
  830,
  831,
  832,
  833,
  834,
  835,
  836,
  837,
  838,
  839,
  840,
  841,
  842,
  843,
  844,
  845,
  846,
  847,
  848,
  849,
  850,
  851,
  852,
  853,
  854,
  855,
  856,
  857,
  858,
  859,
  860,
  861,
  862,
  863,
  864,
  865,
  866,
  867,
  868,
  869,
  870,
  871,
  872,
  873,
  874,
  875,
  876,
  877,
  878,
  879,
  880,
  881,
  882,
  883,
  884,
  885,
  886,
  887,
  888,
  889,
  890,
  891,
  892,
  893,
  894,
  895,
  896,
  897,
  898,
  899,
  900,
  901,
  902,
  903,
  904,
  905,
  906,
  907,
  908,
  909,
  910,
  911,
  912,
  913,
  914,
  915,
  916,
  917,
  918,
  919,
  920,
  921,
  922,
  923,
  924,
  925,
  926,
  927,
  928,
  929,
  930,
  931,
  932,
  933,
  934,
  935,
  936,
  937,
  938,
  939,
  940,
  941,
  942,
  943,
  944,
  945,
  946,
  947,
  948,
  949,
  950,
  951,
  952,
  953,
  954,
  955,
  956,
  957,
  958,
  959,
  960,
  961,
  962,
  963,
  964,
  965,
  966,
  967,
  968,
  969,
  970,
  971,
  972,
  973,
  974,
  975,
  976,
  977,
  978,
  979,
  980,
  981,
  982,
  983,
  984,
  985,
  986,
  987,
  988,
  989,
  990,
  991,
  992,
  993,
  994,
  995,
  996,
  997,
  998,
  999,
  1000,
  1001,
  1002,
  1003,
  1004,
  1005,
  1006,
  1007,
  1008,
  1009,
  1010,
  1011,
  1012,
  1013,
  1014,
  1015,
  1016,
  1017,
  1018,
  1019,
  1020,
  1021,
  1022,
  1023,
  1024,
  1025,
  1026,
  1027,
  1028,
  1029,
  1030,
  1031,
  1032,
  1033,
  1034,
  1035,
  1036,
  1037,
  1038,
  1039,
  1040,
  1041,
  1042,
  1043,
  1044,
  1045,
  1046,
  1047,
  1048,
  1049,
  1050,
  1051,
  1052,
  1053,
  1054,
  1055,
  1056,
  1057,
  1058,
  1059,
  1060,
  1061,
  1062,
  1063,
  1064,
  1065,
  1066,
  1067,
  1068,
  1069,
  1070,
  1071,
  1072,
  1073,
  1074,
  1075,
  1076,
  1077,
  1078,
  1079,
  1080,
  1081,
  1082,
  1083,
  1084,
  1085,
  1086,
  1087,
  1088,
  1089,
  1090,
  1091,
  1092,
  1093,
  1094,
  1095,
  1096,
  1097,
  1098,
  1099,
  1100,
  1101,
  1102,
  1103,
  1104,
  1105,
  1106,
  1107,
  1108,
  1109,
  1110,
  1111,
  1112,
  1113,
  1114,
  1115,
  1116,
  1117,
  1118,
  1119,
  1120,
  1121,
  1122,
  1123,
  1124,
  1125,
  1126,
  1127,
  1128,
  1129,
  1130,
  1131,
  1132,
  1133,
  1134,
  1135,
  1136,
  1137,
  1138,
  1139,
  1140,
  1141,
  1142,
  1143,
  1144,
  1145,
  1146,
  1147,
  1148,
  1149,
  1150,
  1151,
  1152,
  1153,
  1154,
  1155,
  1156,
  1157,
  1158,
  1159,
  1160,
  1161,
  1162,
  1163,
  1164,
  1165,
  1166,
  1167,
  1168,
  1169,
  1170,
  1171,
  1172,
  1173,
  1174,
  1175,
  1176,
  1177,
  1178,
  1179,
  1180,
  1181,
  1182,
  1183,
  1184,
  1185,
  1186,
  1187,
  1188,
  1189,
  1190,
  1191,
  1192,
  1193,
  1194,
  1195,
  1196,
  1197,
  1198,
  1199,
  1200,
  1201,
  1202,
  1203,
  1204,
  1205,
  1206,
  1207,
  1208,
  1209,
  1210,
  1211,
  1212,
  1213,
  1214,
  1215,
  1216,
  1217,
  1218,
  1219,
  1220,
  1221,
  1222,
  1223,
  1224,
  1225,
  1226,
  1227,
  1228,
  1229,
  1230,
  1231,
  1232,
  1233,
  1234,
  1235,
  1236,
  1237,
  1238,
  1239,
  1240,
  1241,
  1242,
  1243,
  1244,
  1245,
  1246,
  1247,
  1248,
  1249,
  1250,
  1251,
  1252,
  1253,
  1254,
  1255,
  1256,
  1257,
  1258,
  1259,
  1260,
  1261,
  1262,
  1263,
  1264,
  1265,
  1266,
  1267,
  1268,
  1269,
  1270,
  1271,
  1272,
  1273,
  1274,
  1275,
  1276,
  1277,
  1278,
  1279,
  1280,
  1281,
  1282,
  1283,
  1284,
  1285,
  1286,
  1287,
  1288,
  1289,
  1290,
  1291,
  1292,
  1293,
  1294,
  1295,
  1296,
  1297,
  1298,
  1299,
  1300,
  1301,
  1302,
  1303,
  1304,
  1305,
  1306,
  1307,
  1308,
  1309,
  1310,
  1311,
  1312,
  1313,
  1314,
  1315,
  1316,
  1317,
  1318,
  1319,
  1320,
  1321,
  1322,
  1323,
  1324,
  1325,
  1326,
  1327,
  1328,
  1329,
  1330,
  1331,
  1332,
  1333,
  1334,
  1335,
  1336,
  1337,
  1338,
  1339,
  1340,
  1341,
  1342,
  1343,
  1344,
  1345,
  1346,
  1347,
  1348,
  1349,
  1350,
  1351,
  1352,
  1353,
  1354,
  1355,
  1356,
  1357,
  1358,
  1359,
  1360,
  1361,
  1362,
  1363,
  1364,
  1365,
  1366,
  1367,
  1368,
  1369,
  1370,
  1371,
  1372,
  1373,
  1374,
  1375,
  1376,
  1377,
  1378,
  1379,
  1380,
  1381,
  1382,
  1383,
  1384,
  1385,
  1386,
  1387,
  1388,
  1389,
  1390,
  1391,
  1392,
  1393,
  1394,
  1395,
  1396,
  1397,
  1398,
  1399,
  1400,
  1401,
  1402,
  1403,
  1404,
  1405,
  1406,
  1407,
  1408,
  1409,
  1410,
  1411,
  1412,
  1413,
  1414,
  1415,
  1416,
  1417,
  1418,
  1419,
  1420,
  1421,
  1422,
  1423,
  1424,
  1425,
  1426,
  1427,
  1428,
  1429,
  1430,
  1431,
  1432,
  1433,
  1434,
  1435,
  1436,
  1437,
  1438,
  1439,
  1440,
  1441,
  1442,
  1443,
  1444,
  1445,
  1446,
  1447,
  1448,
  1449,
  1450,
  1451,
  1452,
  1453,
  1454,
  1455,
  1456,
  1457,
  1458,
  1459,
  1460,
  1461,
  1462,
  1463,
  1464,
  1465,
  1466,
  1467,
  1468,
  1469,
  1470,
  1471,
  1472,
  1473,
  1474,
  1475,
  1476,
  1477
}; // weak
char Str[824] =
{
  '“',
  'ú',
  '–',
  'Ú',
  'Ž',
  'ž',
  'Ž',
  '„',
  '–',
  '¢',
  '’',
  'm',
  '\x90',
  '¯',
  '‘',
  'å',
  '’',
  'n',
  '‰',
  '¡',
  '–',
  '¼',
  '‘',
  'O',
  '‰',
  'F',
  '’',
  'ˆ',
  '—',
  '·',
  '“',
  'r',
  '’',
  '†',
  '—',
  '¬',
  '’',
  'Ä',
  '—',
  'Ž',
  'ˆ',
  '¤',
  '‹',
  '@',
  '\x8D',
  '†',
  '‘',
  '½',
  'Ž',
  '¸',
  '–',
  '³',
  'Ž',
  'c',
  'Ž',
  'p',
  '“',
  '®',
  'ˆ',
  'ê',
  '\x8F',
  'd',
  'Œ',
  '}',
  '‹',
  '³',
  '‹',
  'C',
  '–',
  'Ò',
  '“',
  'Å',
  'Ž',
  '_',
  '‘',
  'f',
  'Š',
  'Ü',
  '\x90',
  '¶',
  '–',
  '½',
  'ˆ',
  'Û',
  'Ž',
  '\x9D',
  '‘',
  '•',
  '’',
  'u',
  'Œ',
  'À',
  '“',
  'x',
  '\x8F',
  'C',
  '•',
  'œ',
  '\x8D',
  'l',
  '‘',
  'D',
  '’',
  'T',
  'Œ',
  'Ÿ',
  'Š',
  'ï',
  '–',
  '­',
  '•',
  '¨',
  '‘',
  'Ì',
  '‘',
  'Ò',
  '—',
  '§',
  '\x8F',
  'ã',
  '‰',
  '½',
  'Š',
  'B',
  'Š',
  'Ï',
  'Ž',
  '@',
  '‰',
  'è',
  'Œ',
  'õ',
  '•',
  'ú',
  'Ž',
  'v',
  'Ž',
  'Ž',
  'ˆ',
  'ø',
  '”',
  '²',
  '\x90',
  'A',
  'Œ',
  '©',
  'Š',
  'Q',
  '\x8D',
  'D',
  '–',
  'ì',
  '\x8D',
  'Ø',
  'Œ',
  'Ä',
  '“',
  'Š',
  '”',
  '½',
  '‰',
  'ž',
  '‘',
  '€',
  '\x8D',
  'ì',
  '‰',
  'ñ',
  '“',
  ']',
  '\x8D',
  '¡',
  '—',
  'ˆ',
  '“',
  '|',
  'Ž',
  'æ',
  '‘',
  '\x9D',
  '\x90',
  'B',
  '•',
  'ê',
  '”',
  'Þ',
  '‘',
  'Ô',
  '•',
  's',
  '‹',
  'c',
  '\x8F',
  '­',
  '”',
  '\\',
  '—',
  'Í',
  '’',
  '²',
  '•',
  'K',
  '—',
  'v',
  '‹',
  '»',
  '–',
  '¡',
  '\x8F',
  'W',
  '’',
  'c',
  '\x8D',
  '‡',
  '\x8D',
  's',
  '\x8F',
  'K',
  '\x90',
  '«',
  '—',
  '˜',
  '—',
  'p',
  'Œ',
  'J',
  'Š',
  'ó',
  '–',
  ']',
  '“',
  '”',
  '‹',
  'ß',
  '‰',
  'Ÿ',
  '‰',
  'ð',
  'Ž',
  'U',
  '‘',
  'à',
  '—',
  'ñ',
  '‹',
  'L',
  '˜',
  '^',
  '‰',
  'æ',
  '–',
  'Ê',
  'ˆ',
  'À',
  '\x90',
  'S',
  '\x8D',
  'K',
  '‰',
  '^',
  'Ž',
  '–',
  '—',
  '£',
  '—',
  '¤',
  '‰',
  'Â',
  '”',
  'ò',
  '–',
  '¾',
  '‘',
  '{',
  '\x8D',
  'õ',
  'Œ',
  'ã',
  '“',
  'ü',
  '\x90',
  'X',
  '\x8D',
  'ð',
  '\x8F',
  'o',
  '‰',
  'º',
  '‘',
  'S',
  '–',
  'Å',
  'Ž',
  'í',
  '’',
  'Í',
  '\x90',
  'Ø',
  '\x90',
  'F',
  '“',
  '¯',
  '\x90',
  'Ô',
  '’',
  '\x8D',
  'ˆ',
  'Ó',
  '\x90',
  '[',
  'Œ',
  'û',
  '•',
  '”',
  '•',
  'ª',
  '‘',
  '¼',
  'ˆ',
  'á',
  '‰',
  '©',
  '‹',
  'A',
  '“',
  'Á',
  'Œ',
  'Š',
  'Œ',
  '@',
  '\x90',
  'Î',
  'Š',
  '„',
  '“',
  'à',
  '\x8D',
  '‚',
  'Ž',
  'û',
  'Œ',
  'Â',
  '”',
  'Í',
  'ˆ',
  'Í',
  '–',
  'v',
  '‘',
  '¾',
  '—',
  'z',
  'Ž',
  'd',
  'ˆ',
  'Ã',
  '‹',
  'Ž',
  '\x90',
  'H',
  '”',
  '­',
  '‰',
  '×',
  '“',
  '`',
  'Ž',
  '¿',
  '’',
  '´',
  '‰',
  'È',
  'Š',
  'w',
  'Œ',
  '‹',
  '\x8F',
  '»',
  '\x8F',
  'œ',
  '‰',
  '˜',
  'ˆ',
  'Ú',
  '‰',
  'i',
  '‹',
  'v',
  '”',
  'R',
  '—',
  '¿',
  '“',
  'd',
  '\x8D',
  'Ï',
  'ˆ',
  'Ê',
  'Š',
  'm',
  '”',
  'F',
  'Š',
  'Ô',
  '’',
  '@',
  '“',
  '–',
  '\x8D',
  'Å',
  'Œ',
  'ƒ',
  '–',
  '{',
  '\x8D',
  'È',
  'Ž',
  'q',
  '‹',
  'Ÿ',
  'Š',
  'ç',
  '•',
  '‚',
  'Ž',
  'Ë',
  '\x90',
  'ü',
  '‰',
  '“',
  'Š',
  'O',
  '‰',
  '¹',
  '–',
  'Â',
  '–',
  'ð',
  '‘',
  '§',
  '\x8D',
  'À',
  '–',
  'º',
  'Œ',
  '³',
  '‹',
  'ó',
  'Œ',
  '‡',
  '—',
  '’',
  '‹',
  '­',
  '•',
  '¬',
  '’',
  'E',
  '‘',
  '¬',
  '‰',
  'Á',
  '”',
  'ï',
  '—',
  'Ç',
  '‰',
  'Æ',
  'Œ',
  'v',
  '\x8F',
  'Õ',
  'Œ',
  '‚',
  '‹',
  'z',
  'ˆ',
  'Ÿ',
  '•',
  '¡',
  '’',
  'Ê',
  'Ž',
  'G',
  '\x8F',
  'ê',
  '\x8F',
  'Š',
  '•',
  'ƒ',
  '\x90',
  'e',
  '\x90',
  'l',
  '”',
  'ü',
  '\x8D',
  'ç',
  '•',
  'Ê',
  'Š',
  '´',
  '‘',
  '±',
  '‹',
  'à',
  '‘',
  '®',
  '•',
  'i',
  '”',
  'ƒ',
  '—',
  '\x9D',
  '—',
  'V',
  '‰',
  'j',
  '\x8D',
  '˜',
  '”',
  'Ó',
  'Œ',
  'É',
  'ˆ',
  'È',
  '\x8F',
  'ó',
  'Ž',
  'À',
  '‘',
  'g',
  'ˆ',
  'Ù',
  '\x8F',
  'í',
  '•',
  '·',
  '‰',
  'õ',
  '”',
  'z',
  '\x8F',
  'æ',
  '–',
  'ñ',
  '‘',
  '©',
  '”',
  'ö',
  'Œ',
  '»',
  '”',
  'O',
  'Œ',
  'Ì',
  '\x8F',
  'I',
  'Š',
  'ª',
  '“',
  'ª',
  '“',
  'y',
  '\x90',
  '»',
  '’',
  'l',
  '‘',
  'Å',
  '–',
  'é',
  'Š',
  'y',
  '\x90',
  'g',
  'Œ',
  'ü',
  'Ž',
  'Z',
  '‰',
  'Ê',
  '\x8F',
  'Ä',
  '•',
  'Ö',
  '\x90',
  '¬',
  'Œ',
  '÷',
  '‹',
  'Á',
  '\x8F',
  '\x8F',
  '•',
  'é',
  '•',
  't',
  'Ž',
  'Ø',
  '–',
  'ß',
  '\x8F',
  '¸',
  '‘',
  '‹',
  '\x8D',
  'L',
  '–',
  'ž',
  '‘',
  'Ñ',
  'Ž',
  'n',
  '˜',
  'f',
  '‘',
  '˜',
  '“',
  'ï',
  '‹',
  '¦',
  'Ž',
  'Ò',
  '‹',
  '½',
  '’',
  '·',
  '–',
  '°',
  '–',
  'û',
  '’',
  'f',
  '•',
  'ž',
  'Š',
  'E',
  '’',
  'B',
  '”',
  'ñ',
  '‘',
  '—',
  '“',
  '¬',
  '\x8D',
  '¶',
  '•',
  '\\',
  'Ž',
  '¦',
  '‘',
  '°',
  '‘',
  '¶',
  '\x8D',
  'Ý',
  '’',
  '¥',
  'Ž',
  '¨',
  '‰',
  'œ',
  'Š',
  'J',
  '“',
  '´',
  'Œ',
  'A',
  '\x90',
  'Â',
  '‰',
  'ï',
  'Ž',
  '‹',
  'Ž',
  'è',
  '‘',
  '«',
  '\x8F',
  '¬',
  '\x90',
  '…',
  'Ž',
  '©',
  '\x8F',
  '•',
  '\x8F',
  'Á',
  'Œ',
  '´',
  'Ž',
  'ü',
  '•',
  'Ó',
  '‰',
  'f',
  '\x8F',
  '\\',
  'Ž',
  'š',
  'Œ',
  'ø',
  '—',
  '¦',
  'Š',
  'á',
  '’',
  'è',
  '\x8D',
  '~',
  'Ž',
  '÷',
  'Š',
  'C',
  '”',
  'õ',
  '‘',
  '\x81',
  '\x8F',
  'A',
  'Ž',
  '¼',
  'Œ',
  '¹',
  '’',
  '©',
  '\x90',
  'i',
  'Š',
  '®',
  '—',
  'û',
  '\x90',
  'Q',
  'Ž',
  'w',
  '\x90',
  '³',
  '’',
  '¼',
  '—',
  'E',
  '\x8F',
  '‰',
  '‹',
  '°',
  'Œ',
  'i',
  'ˆ',
  'õ',
  'Œ',
  '¯',
  '˜',
  'b',
  '\x8F',
  'î',
  '•',
  'ñ',
  '\x90',
  '”',
  '•',
  'Ï',
  '‰',
  '»',
  '—',
  '^',
  '•',
  'û',
  '\x90',
  '®',
  '•',
  '±',
  '\x90',
  'V',
  '“',
  '¹',
  'Œ',
  'b',
  '’',
  'P',
  '”',
  '»',
  '—',
  't',
  '‰',
  'Ô',
  '’',
  '‡',
  '‘',
  'R',
  'Š',
  'l',
  '–',
  '`',
  '”',
  'j',
  '‰',
  'ó',
  '“',
  'G',
  'Œ',
  '—',
  '•',
  '½',
  '•',
  'à',
  '‰',
  'Š',
  '“',
  'V',
  '—',
  '‘',
  '“',
  'î',
  '\x90',
  'Ú',
  '\x90',
  'G',
  'Ž',
  'Š',
  'Ž',
  '€'
}; // idb
int dword_101C5E88[15] =
{
  3,
  4,
  5,
  6,
  0,
  2,
  7,
  4294967295,
  4294967295,
  4294967295,
  4294967295,
  4294967295,
  4294967295,
  4294967295,
  1
}; // idb
char *off_101C5EC4[26] =
{
  "TEX_FMT_RGB565",
  "TEX_FMT_S3TC",
  "TEX_FMT_RGB5A3",
  "TEX_FMT_I4",
  "TEX_FMT_I8",
  "TEX_FMT_IA4",
  "TEX_FMT_IA8",
  "TEX_FMT_RGBA8",
  "GX_TF_I4",
  "GX_TF_I8",
  "GX_TF_IA4",
  "GX_TF_IA8",
  "GX_TF_RGB565",
  "GX_TF_RGB5A3",
  "GX_TF_RGBA8",
  "INVALID",
  "INVALID",
  "INVALID",
  "INVALID",
  "INVALID",
  "INVALID",
  "INVALID",
  "GX_TF_CMPR",
  "GX_TF_C4",
  "GX_TF_C8",
  "GX_TF_C14X2"
}; // weak
char *off_101C5EE4[18] =
{
  "GX_TF_I4",
  "GX_TF_I8",
  "GX_TF_IA4",
  "GX_TF_IA8",
  "GX_TF_RGB565",
  "GX_TF_RGB5A3",
  "GX_TF_RGBA8",
  "INVALID",
  "INVALID",
  "INVALID",
  "INVALID",
  "INVALID",
  "INVALID",
  "INVALID",
  "GX_TF_CMPR",
  "GX_TF_C4",
  "GX_TF_C8",
  "GX_TF_C14X2"
}; // weak
char *off_101C5F20[3] = { "GX_TF_C4", "GX_TF_C8", "GX_TF_C14X2" }; // weak
float flt_101C6144 =  0.0099999998; // weak
int glnWidth = 640; // idb
int glnHeight = 480; // idb
char byte_101C6268[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_101C6368; // weak
_UNKNOWN unk_101C7368; // weak
_UNKNOWN unk_101C8B68; // weak
int dword_101CA368; // weak
int dword_101CA36C; // weak
int dword_101CA370; // weak
NodeMgr *nodeMgr; // idb
char byte_101CB084; // weak
CoreNode stru_101CB088;
float flt_101CF090[4096]; // idb
_UNKNOWN Matrix4f::ident; // weak
void *CmdStream::statbuff; // idb
_UNKNOWN unk_101D4A80; // weak
_UNKNOWN unk_101D4E80; // weak
_UNKNOWN unk_101D5480; // weak
char byte_101D5A80; // weak
int dword_101D5A84; // weak
int dword_101D5A88; // weak
int (__stdcall *dword_101D5A8C)(_DWORD); // weak
int dword_101D5A90; // weak
int (__stdcall *dword_101D5A94)(_DWORD); // weak
int dword_101D5A98; // weak
char byte_101D5A9C; // weak
HINSTANCE hInstance; // idb
struct tagOFNA stru_101D5DE0; // idb
char Dest[256]; // idb
char byte_101D5F2C[256]; // idb
char byte_101D602C[424]; // idb
int dword_101D61D8; // weak
Stream *sysCon; // idb
struct Stream *errCon; // weak
StdSystem *gsys; // idb
HWND sysCurrWnd; // idb
HINSTANCE sysHInst; // idb
CoreNode *uiMgr; // idb
HGLRC RenderWindow::hGLRC; // idb
_UNKNOWN unk_101D6200; // weak
_UNKNOWN unk_101D6300; // weak
HWND hWnd; // idb
WNDPROC lpPrevWndFunc; // idb


//----- (10004CD0) --------------------------------------------------------
void __thiscall Colour::write(Colour *this, struct Stream *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  Colour *v5; // [esp+4Ch] [ebp-4h]

  v5 = this;
  LOBYTE(this) = *this;
  (*(*a2 + 32))(a2, this);
  LOBYTE(v2) = *(v5 + 1);
  (*(*a2 + 32))(a2, v2);
  LOBYTE(v3) = *(v5 + 2);
  (*(*a2 + 32))(a2, v3);
  LOBYTE(v4) = *(v5 + 3);
  (*(*a2 + 32))(a2, v4);
}

//----- (10004DA0) --------------------------------------------------------
void __thiscall Colour::genAge(Colour *this, struct AgeServer *a2, char *a3)
{
  AgeServer::NewEditor(a2, a3, this);
}

//----- (10004DF0) --------------------------------------------------------
void __userpurge PVWLightingInfo::read(PVWLightingInfo *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  int v3; // eax
  PVWLightingInfo *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  v3 = (**a3)(a3);
  *v4 = v3;
  (*(*a3 + 12))(a3);
  *(v4 + 2) = a2;
}

//----- (10004E70) --------------------------------------------------------
void __thiscall PVWLightingInfo::write(PVWLightingInfo *this, struct RandomAccessStream *a2)
{
  PVWLightingInfo *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
  (*(*a2 + 40))(a2, *(v2 + 2));
}

//----- (10004EF0) --------------------------------------------------------
AyuStack *__thiscall AyuStack::AyuStack(AyuStack *this)
{
  *(this + 29) = 0;
  return this;
}

//----- (10004F30) --------------------------------------------------------
void __thiscall PVWPolygonColourInfo::animate(PVWPolygonColourInfo *this, float *a2, struct Colour *a3)
{
  double v3; // st7
  float v4; // ST04_4
  PVWPolygonColourInfo *v5; // [esp+60h] [ebp-4h]

  v5 = this;
  if ( *(this + 1) )
  {
    if ( a2 )
    {
      v3 = *(this + 1);
      v4 = v3;
      sub_100018D9(*a2, v4);
      *(v5 + 7) = v3;
    }
    else
    {
      *(this + 7) = System::getFrameTime(gsys) * (30.0 * *(this + 2)) + *(this + 7);
      if ( (*(v5 + 1) - 1) <= *(v5 + 7) )
        *(v5 + 7) = 0;
    }
    PVWColourAnimInfo::extract((v5 + 12), *(v5 + 7), a3);
    PVWAlphaAnimInfo::extract((v5 + 20), *(v5 + 7), a3);
  }
}
// 10001410: using guessed type double __thiscall System::getFrameTime(_DWORD);

//----- (10005060) --------------------------------------------------------
void __thiscall AyuStack::inactivate(AyuStack *this)
{
  *(this + 29) = 0;
}

//----- (100050A0) --------------------------------------------------------
int __thiscall AyuStack::setAllocType(AyuStack *this, int a2)
{
  int v2; // ST50_4

  v2 = *this;
  *this = a2;
  return v2;
}

//----- (100050F0) --------------------------------------------------------
bool __thiscall AyuStack::checkOverflow(AyuStack *this)
{
  bool result; // al

  if ( *(this + 28) )
    result = **(this + 3) != 305419896;
  else
    result = 0;
  return result;
}

//----- (10005150) --------------------------------------------------------
int __thiscall AyuStack::getTopUsed(AyuStack *this)
{
  return *(this + 4) - *(this + 6);
}

//----- (10005190) --------------------------------------------------------
int __thiscall AyuStack::getSize(AyuStack *this)
{
  return *(this + 1);
}

//----- (100051D0) --------------------------------------------------------
int __thiscall AyuStack::getUsed(AyuStack *this)
{
  return *(this + 2);
}

//----- (10005210) --------------------------------------------------------
double __cdecl sub_10005210(float a1, int a2, int a3)
{
  float v3; // ST64_4
  float v4; // ST60_4
  double v5; // st7
  float v6; // ST5C_4
  float v7; // ST58_4
  double v8; // st7
  float v9; // ST54_4
  float v10; // ST50_4

  v3 = a1 - *a2;
  v4 = 1.0 / (*a3 - *a2);
  v5 = v3 * v3 * v4;
  v6 = v5;
  v7 = v5 * v4;
  v8 = v3 * v7;
  v9 = v8;
  v10 = v8 * v4;
  return (2.0 * v10 - 3.0 * v7 + 1.0) * *(a2 + 4)
       + (-2.0 * v10 + 3.0 * v7) * *(a3 + 4)
       + (v9 - 2.0 * v6 + v3) * *(a2 + 12)
       + (v9 - v6) * *(a3 + 8);
}

//----- (10005310) --------------------------------------------------------
int __thiscall AyuStack::getFree(AyuStack *this)
{
  return *(this + 1) - *(this + 2);
}

//----- (10005350) --------------------------------------------------------
int __thiscall AyuStack::getMaxFree(AyuStack *this)
{
  int v2; // [esp+4Ch] [ebp-8h]

  if ( *(this + 1) - *(this + 2) - 8 <= 0 )
    v2 = 0;
  else
    v2 = *(this + 1) - *(this + 2) - 8;
  return v2;
}

//----- (100053C0) --------------------------------------------------------
void *__thiscall AyuStack::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (10005410) --------------------------------------------------------
AyuStack *__thiscall AyuHeap::AyuHeap(AyuHeap *this)
{
  AyuStack *v1; // ST50_4

  v1 = this;
  AyuStack::AyuStack(this);
  return v1;
}

//----- (10005460) --------------------------------------------------------
void __thiscall PVWColourAnimInfo::extract(PVWColourAnimInfo *this, float a2, struct Colour *a3)
{
  float v3; // ST08_4
  float v4; // ST04_4
  int v5; // ST10_4
  float v6; // ST04_4
  double v7; // st7
  float v8; // ST00_4
  int v9; // eax
  float v10; // ST08_4
  float v11; // ST04_4
  int v12; // ST10_4
  float v13; // ST04_4
  double v14; // st7
  float v15; // ST00_4
  int v16; // eax
  float v17; // ST08_4
  float v18; // ST04_4
  int v19; // ST10_4
  float v20; // ST04_4
  double v21; // st7
  float v22; // ST00_4
  int v23; // eax
  char v24; // [esp+60h] [ebp-E8h]
  char v25; // [esp+64h] [ebp-E4h]
  char v26; // [esp+68h] [ebp-E0h]
  char v27; // [esp+6Ch] [ebp-DCh]
  char v28; // [esp+70h] [ebp-D8h]
  char v29; // [esp+74h] [ebp-D4h]
  float v30; // [esp+130h] [ebp-18h]
  float v31; // [esp+134h] [ebp-14h]
  float v32; // [esp+138h] [ebp-10h]
  int i; // [esp+13Ch] [ebp-Ch]
  int v34; // [esp+140h] [ebp-8h]
  PVWColourAnimInfo *v35; // [esp+144h] [ebp-4h]

  v35 = this;
  if ( *this )
  {
    if ( *this == 1 )
    {
      *a3 = *(*(this + 1) + 4);
      *(a3 + 1) = *(*(this + 1) + 16);
      *(a3 + 2) = *(*(this + 1) + 28);
    }
    else
    {
      v34 = 0;
      for ( i = 0; i < *this - 1; ++i )
      {
        if ( *(*(this + 1) + 40 * i) <= a2 && *(*(this + 1) + 40 * (i + 1)) >= a2 )
        {
          v34 = i;
          break;
        }
      }
      v3 = *(*(this + 1) + 40 * (v34 + 1) + 4);
      v4 = *(*(this + 1) + 40 * (v34 + 1));
      v5 = sub_10001A14(
             LODWORD(v4),
             LODWORD(v3),
             *(*(this + 1) + 40 * (v34 + 1) + 8),
             *(*(this + 1) + 40 * (v34 + 1) + 12));
      v6 = *(*(v35 + 1) + 40 * v34 + 4);
      v7 = *(*(v35 + 1) + 40 * v34);
      v8 = v7;
      v9 = sub_10001A14(LODWORD(v8), LODWORD(v6), *(*(v35 + 1) + 40 * v34 + 8), *(*(v35 + 1) + 40 * v34 + 12));
      sub_1000141A(a2, v9, v5);
      v32 = v7;
      v10 = *(*(v35 + 1) + 40 * (v34 + 1) + 16);
      v11 = *(*(v35 + 1) + 40 * (v34 + 1));
      v12 = sub_10001A14(
              LODWORD(v11),
              LODWORD(v10),
              *(*(v35 + 1) + 40 * (v34 + 1) + 20),
              *(*(v35 + 1) + 40 * (v34 + 1) + 24));
      v13 = *(*(v35 + 1) + 40 * v34 + 16);
      v14 = *(*(v35 + 1) + 40 * v34);
      v15 = v14;
      v16 = sub_10001A14(LODWORD(v15), LODWORD(v13), *(*(v35 + 1) + 40 * v34 + 20), *(*(v35 + 1) + 40 * v34 + 24));
      sub_1000141A(a2, v16, v12);
      v31 = v14;
      v17 = *(*(v35 + 1) + 40 * (v34 + 1) + 28);
      v18 = *(*(v35 + 1) + 40 * (v34 + 1));
      v19 = sub_10001A14(
              LODWORD(v18),
              LODWORD(v17),
              *(*(v35 + 1) + 40 * (v34 + 1) + 32),
              *(*(v35 + 1) + 40 * (v34 + 1) + 36));
      v20 = *(*(v35 + 1) + 40 * v34 + 28);
      v21 = *(*(v35 + 1) + 40 * v34);
      v22 = v21;
      v23 = sub_10001A14(LODWORD(v22), LODWORD(v20), *(*(v35 + 1) + 40 * v34 + 32), *(*(v35 + 1) + 40 * v34 + 36));
      sub_1000141A(a2, v23, v19);
      v30 = v21;
      if ( v32 >= 0.0 )
      {
        if ( v32 <= 255.0 )
          v28 = v32;
        else
          v28 = -1;
        v29 = v28;
      }
      else
      {
        v29 = 0;
      }
      *a3 = v29;
      if ( v31 >= 0.0 )
      {
        if ( v31 <= 255.0 )
          v26 = v31;
        else
          v26 = -1;
        v27 = v26;
      }
      else
      {
        v27 = 0;
      }
      *(a3 + 1) = v27;
      if ( v30 >= 0.0 )
      {
        if ( v30 <= 255.0 )
          v24 = v30;
        else
          v24 = -1;
        v25 = v24;
      }
      else
      {
        v25 = 0;
      }
      *(a3 + 2) = v25;
    }
  }
}
// 10001A14: using guessed type _DWORD __stdcall sub_10001A14(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10005B00) --------------------------------------------------------
_DWORD *__thiscall sub_10005B00(_DWORD *this, int a2, int a3, int a4, int a5)
{
  *this = a2;
  this[1] = a3;
  this[2] = a4;
  this[3] = a5;
  return this;
}

//----- (10005B60) --------------------------------------------------------
void *__thiscall AyuHeap::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x28u);
  return this;
}

//----- (10005BB0) --------------------------------------------------------
_DWORD *__thiscall MemHead::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (10005C10) --------------------------------------------------------
void *__thiscall AyuCache::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x130u);
  return this;
}

//----- (10005C60) --------------------------------------------------------
bool Stream::getClosing()
{
  return 0;
}

//----- (10005C90) --------------------------------------------------------
void Stream::flush()
{
  ;
}

//----- (10005CC0) --------------------------------------------------------
Stream *__thiscall Stream::Stream(Stream *this)
{
  *this = &Stream::`vftable';
  return this;
}
// 101AD188: using guessed type void *Stream::`vftable';

//----- (10005D00) --------------------------------------------------------
Stream *__thiscall Stream::Stream(Stream *this, const struct Stream *a2)
{
  *(this + 1) = *(a2 + 1);
  *this = &Stream::`vftable';
  return this;
}
// 101AD188: using guessed type void *Stream::`vftable';

//----- (10005D50) --------------------------------------------------------
_DWORD *__thiscall Stream::operator=(_DWORD *this, int a2)
{
  this[1] = *(a2 + 4);
  return this;
}

//----- (10005DA0) --------------------------------------------------------
int RandomAccessStream::getPosition()
{
  return 0;
}

//----- (10005DD0) --------------------------------------------------------
void __stdcall RandomAccessStream::setPosition(int a2)
{
  ;
}

//----- (10005E00) --------------------------------------------------------
int __thiscall RandomAccessStream::getLength(RandomAccessStream *this)
{
  RandomAccessStream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  return (*(*this + 64))(this);
}

//----- (10005E60) --------------------------------------------------------
int __thiscall RandomAccessStream::getPending(RandomAccessStream *this)
{
  int v1; // esi
  RandomAccessStream *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v1 = (*(*this + 88))(this);
  return v1 - (*(*v3 + 80))(v3);
}

//----- (10005EE0) --------------------------------------------------------
void __thiscall RandomAccessStream::padFile(RandomAccessStream *this, unsigned __int32 a2)
{
  int i; // [esp+4Ch] [ebp-10h]
  int v3; // [esp+50h] [ebp-Ch]
  int v4; // [esp+54h] [ebp-8h]
  RandomAccessStream *v5; // [esp+58h] [ebp-4h]

  v5 = this;
  v4 = (*(*this + 80))(this);
  v3 = (~(a2 - 1) & (v4 + a2 - 1)) - v4;
  for ( i = 0; i < v3; ++i )
    (*(*v5 + 32))(v5, 0);
}

//----- (10005FA0) --------------------------------------------------------
void __thiscall RandomAccessStream::padFileTo(RandomAccessStream *this, unsigned __int32 a2, unsigned __int32 a3)
{
  int i; // [esp+4Ch] [ebp-10h]
  int v4; // [esp+50h] [ebp-Ch]
  int v5; // [esp+54h] [ebp-8h]
  RandomAccessStream *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  v5 = (*(*this + 80))(this);
  v4 = a2 - v5 - a3;
  for ( i = 0; i < v4; ++i )
    (*(*v6 + 32))(v6, 0);
}

//----- (10006050) --------------------------------------------------------
void __thiscall RandomAccessStream::skipPadding(RandomAccessStream *this, unsigned __int32 a2)
{
  int i; // [esp+4Ch] [ebp-14h]
  char v3; // [esp+50h] [ebp-10h]
  int v4; // [esp+54h] [ebp-Ch]
  int v5; // [esp+58h] [ebp-8h]
  RandomAccessStream *v6; // [esp+5Ch] [ebp-4h]

  v6 = this;
  v5 = (*(*this + 80))(this);
  v4 = (~(a2 - 1) & (v5 + a2 - 1)) - v5;
  for ( i = 0; i < v4; ++i )
    v3 = (*(*v6 + 4))(v6);
}

//----- (10006110) --------------------------------------------------------
RandomAccessStream *__thiscall RandomAccessStream::RandomAccessStream(RandomAccessStream *this)
{
  RandomAccessStream *v1; // ST50_4

  v1 = this;
  Stream::Stream(this);
  *v1 = &RandomAccessStream::`vftable';
  return v1;
}
// 101AD1E8: using guessed type void *RandomAccessStream::`vftable';

//----- (10006170) --------------------------------------------------------
RandomAccessStream *__thiscall RandomAccessStream::RandomAccessStream(RandomAccessStream *this, const struct RandomAccessStream *a2)
{
  RandomAccessStream *v2; // ST50_4

  v2 = this;
  Stream::Stream(this, a2);
  *v2 = &RandomAccessStream::`vftable';
  return v2;
}
// 101AD1E8: using guessed type void *RandomAccessStream::`vftable';

//----- (100061D0) --------------------------------------------------------
void __thiscall PVWAlphaAnimInfo::extract(PVWAlphaAnimInfo *this, float a2, struct Colour *a3)
{
  float v3; // ST08_4
  float v4; // ST04_4
  int v5; // ST10_4
  float v6; // ST04_4
  double v7; // st7
  float v8; // ST00_4
  int v9; // eax
  char v10; // [esp+60h] [ebp-60h]
  char v11; // [esp+64h] [ebp-5Ch]
  float v12; // [esp+B0h] [ebp-10h]
  int i; // [esp+B4h] [ebp-Ch]
  int v14; // [esp+B8h] [ebp-8h]
  PVWAlphaAnimInfo *v15; // [esp+BCh] [ebp-4h]

  v15 = this;
  if ( *this )
  {
    if ( *this == 1 )
    {
      *(a3 + 3) = *(*(this + 1) + 4);
    }
    else
    {
      v14 = 0;
      for ( i = 0; i < *this - 1; ++i )
      {
        if ( *(*(this + 1) + 16 * i) <= a2 && *(*(this + 1) + 16 * (i + 1)) >= a2 )
        {
          v14 = i;
          break;
        }
      }
      v3 = *(*(this + 1) + 16 * (v14 + 1) + 4);
      v4 = *(*(this + 1) + 16 * (v14 + 1));
      v5 = sub_10001A14(
             LODWORD(v4),
             LODWORD(v3),
             *(*(this + 1) + 16 * (v14 + 1) + 8),
             *(*(this + 1) + 16 * (v14 + 1) + 12));
      v6 = *(*(v15 + 1) + 16 * v14 + 4);
      v7 = *(*(v15 + 1) + 16 * v14);
      v8 = v7;
      v9 = sub_10001A14(LODWORD(v8), LODWORD(v6), *(*(v15 + 1) + 16 * v14 + 8), *(*(v15 + 1) + 16 * v14 + 12));
      sub_1000141A(a2, v9, v5);
      v12 = v7;
      if ( v12 >= 0.0 )
      {
        if ( v12 <= 255.0 )
          v10 = v12;
        else
          v10 = -1;
        v11 = v10;
      }
      else
      {
        v11 = 0;
      }
      *(a3 + 3) = v11;
    }
  }
}
// 10001A14: using guessed type _DWORD __stdcall sub_10001A14(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10006480) --------------------------------------------------------
void *__thiscall RandomAccessStream::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  Stream::operator=(a2);
  return v2;
}
// 100024B4: using guessed type _DWORD __stdcall Stream::operator=(_DWORD);

//----- (100064D0) --------------------------------------------------------
BufferedOutputStream *__thiscall BufferedOutputStream::BufferedOutputStream(BufferedOutputStream *this, struct Stream *a2, SIZE_T dwBytes, bool a4)
{
  BufferedOutputStream *v4; // ST54_4

  v4 = this;
  Stream::Stream(this);
  *v4 = &BufferedOutputStream::`vftable';
  *(v4 + 5) = a2;
  *(v4 + 3) = 0;
  *(v4 + 2) = sub_10002A81(dwBytes);
  *(v4 + 24) = a4;
  *(v4 + 4) = dwBytes - 1;
  return v4;
}
// 101AD258: using guessed type void *BufferedOutputStream::`vftable';

//----- (10006580) --------------------------------------------------------
void __thiscall BufferedOutputStream::flush(BufferedOutputStream *this)
{
  BufferedOutputStream *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  *(*(this + 2) + *(this + 3)) = 0;
  (*(**(v1 + 5) + 56))(*(v1 + 5), *(v1 + 2), *(v1 + 3));
  *(v1 + 3) = 0;
}

//----- (10006610) --------------------------------------------------------
void __thiscall BufferedOutputStream::addChar(BufferedOutputStream *this, char a2)
{
  BufferedOutputStream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  *(*(this + 2) + *(this + 3)) = a2;
  if ( ++*(v2 + 3) >= *(v2 + 4) )
    (*(*v2 + 76))(v2);
}

//----- (100066A0) --------------------------------------------------------
void __thiscall BufferedOutputStream::write(BufferedOutputStream *this, void *a2, int a3)
{
  int j; // [esp+4Ch] [ebp-10h]
  char v4; // [esp+50h] [ebp-Ch]
  int i; // [esp+54h] [ebp-8h]
  BufferedOutputStream *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  if ( *(this + 24) )
  {
    for ( i = 0; i < a3; ++i )
    {
      v4 = *(a2 + i);
      BufferedOutputStream::addChar(v6, v4);
      if ( v4 == 10 )
        (*(*v6 + 76))(v6);
    }
  }
  else
  {
    for ( j = 0; j < a3; ++j )
      BufferedOutputStream::addChar(v6, *(a2 + j));
  }
}

//----- (10006790) --------------------------------------------------------
void __thiscall PVWColourShortAnimInfo::extract(PVWColourShortAnimInfo *this, float a2, struct ShortColour *a3)
{
  float v3; // ST08_4
  float v4; // ST04_4
  int v5; // ST10_4
  float v6; // ST04_4
  double v7; // st7
  float v8; // ST00_4
  int v9; // eax
  float v10; // ST08_4
  float v11; // ST04_4
  int v12; // ST10_4
  float v13; // ST04_4
  double v14; // st7
  float v15; // ST00_4
  int v16; // eax
  float v17; // ST08_4
  float v18; // ST04_4
  int v19; // ST10_4
  float v20; // ST04_4
  double v21; // st7
  float v22; // ST00_4
  int v23; // eax
  signed __int16 v24; // [esp+60h] [ebp-E8h]
  signed __int16 v25; // [esp+64h] [ebp-E4h]
  signed __int16 v26; // [esp+68h] [ebp-E0h]
  signed __int16 v27; // [esp+6Ch] [ebp-DCh]
  signed __int16 v28; // [esp+70h] [ebp-D8h]
  signed __int16 v29; // [esp+74h] [ebp-D4h]
  float v30; // [esp+130h] [ebp-18h]
  float v31; // [esp+134h] [ebp-14h]
  float v32; // [esp+138h] [ebp-10h]
  int i; // [esp+13Ch] [ebp-Ch]
  int v34; // [esp+140h] [ebp-8h]
  PVWColourShortAnimInfo *v35; // [esp+144h] [ebp-4h]

  v35 = this;
  if ( *this )
  {
    if ( *this == 1 )
    {
      *a3 = *(*(this + 1) + 4);
      *(a3 + 1) = *(*(this + 1) + 16);
      *(a3 + 2) = *(*(this + 1) + 28);
    }
    else
    {
      v34 = 0;
      for ( i = 0; i < *this - 1; ++i )
      {
        if ( *(*(this + 1) + 40 * i) <= a2 && *(*(this + 1) + 40 * (i + 1)) >= a2 )
        {
          v34 = i;
          break;
        }
      }
      v3 = *(*(this + 1) + 40 * (v34 + 1) + 4);
      v4 = *(*(this + 1) + 40 * (v34 + 1));
      v5 = sub_10001A14(
             LODWORD(v4),
             LODWORD(v3),
             *(*(this + 1) + 40 * (v34 + 1) + 8),
             *(*(this + 1) + 40 * (v34 + 1) + 12));
      v6 = *(*(v35 + 1) + 40 * v34 + 4);
      v7 = *(*(v35 + 1) + 40 * v34);
      v8 = v7;
      v9 = sub_10001A14(LODWORD(v8), LODWORD(v6), *(*(v35 + 1) + 40 * v34 + 8), *(*(v35 + 1) + 40 * v34 + 12));
      sub_1000141A(a2, v9, v5);
      v32 = v7;
      v10 = *(*(v35 + 1) + 40 * (v34 + 1) + 16);
      v11 = *(*(v35 + 1) + 40 * (v34 + 1));
      v12 = sub_10001A14(
              LODWORD(v11),
              LODWORD(v10),
              *(*(v35 + 1) + 40 * (v34 + 1) + 20),
              *(*(v35 + 1) + 40 * (v34 + 1) + 24));
      v13 = *(*(v35 + 1) + 40 * v34 + 16);
      v14 = *(*(v35 + 1) + 40 * v34);
      v15 = v14;
      v16 = sub_10001A14(LODWORD(v15), LODWORD(v13), *(*(v35 + 1) + 40 * v34 + 20), *(*(v35 + 1) + 40 * v34 + 24));
      sub_1000141A(a2, v16, v12);
      v31 = v14;
      v17 = *(*(v35 + 1) + 40 * (v34 + 1) + 28);
      v18 = *(*(v35 + 1) + 40 * (v34 + 1));
      v19 = sub_10001A14(
              LODWORD(v18),
              LODWORD(v17),
              *(*(v35 + 1) + 40 * (v34 + 1) + 32),
              *(*(v35 + 1) + 40 * (v34 + 1) + 36));
      v20 = *(*(v35 + 1) + 40 * v34 + 28);
      v21 = *(*(v35 + 1) + 40 * v34);
      v22 = v21;
      v23 = sub_10001A14(LODWORD(v22), LODWORD(v20), *(*(v35 + 1) + 40 * v34 + 32), *(*(v35 + 1) + 40 * v34 + 36));
      sub_1000141A(a2, v23, v19);
      v30 = v21;
      if ( v32 >= -1023.0 )
      {
        if ( v32 <= 1023.0 )
          v28 = v32;
        else
          v28 = 1023;
        v29 = v28;
      }
      else
      {
        v29 = -1023;
      }
      *a3 = v29;
      if ( v31 >= -1023.0 )
      {
        if ( v31 <= 1023.0 )
          v26 = v31;
        else
          v26 = 1023;
        v27 = v26;
      }
      else
      {
        v27 = -1023;
      }
      *(a3 + 1) = v27;
      if ( v30 >= -1023.0 )
      {
        if ( v30 <= 1023.0 )
          v24 = v30;
        else
          v24 = 1023;
        v25 = v24;
      }
      else
      {
        v25 = -1023;
      }
      *(a3 + 2) = v25;
    }
  }
}
// 10001A14: using guessed type _DWORD __stdcall sub_10001A14(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10006E30) --------------------------------------------------------
BufferedOutputStream *__thiscall BufferedOutputStream::BufferedOutputStream(BufferedOutputStream *this, const struct BufferedOutputStream *a2)
{
  BufferedOutputStream *v2; // ST50_4

  v2 = this;
  Stream::Stream(this, a2);
  *(v2 + 2) = *(a2 + 2);
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  *(v2 + 5) = *(a2 + 5);
  *(v2 + 24) = *(a2 + 24);
  *v2 = &BufferedOutputStream::`vftable';
  return v2;
}
// 101AD258: using guessed type void *BufferedOutputStream::`vftable';

//----- (10006EE0) --------------------------------------------------------
_DWORD *__thiscall BufferedOutputStream::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  Stream::operator=(a2);
  v2[2] = *(a2 + 8);
  v2[3] = *(a2 + 12);
  v2[4] = *(a2 + 16);
  v2[5] = *(a2 + 20);
  *(v2 + 24) = *(a2 + 24);
  return v2;
}
// 100024B4: using guessed type _DWORD __stdcall Stream::operator=(_DWORD);

//----- (10006F80) --------------------------------------------------------
void __thiscall BufferedInputStream::open(BufferedInputStream *this, struct Stream *a2)
{
  *(this + 5) = 0;
  *(this + 6) = 0;
  *(this + 4) = 0;
  *(this + 7) = a2;
}

//----- (10006FE0) --------------------------------------------------------
void __thiscall BufferedInputStream::close(BufferedInputStream *this)
{
  BufferedInputStream *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(**(this + 7) + 68))(*(this + 7));
}

//----- (10007040) --------------------------------------------------------
RandomAccessStream *__thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this)
{
  RandomAccessStream *v1; // ST50_4

  v1 = this;
  RandomAccessStream::RandomAccessStream(this);
  *v1 = &BufferedInputStream::`vftable';
  *(v1 + 2) = 0;
  *(v1 + 7) = 0;
  return v1;
}
// 101AD2C0: using guessed type void *BufferedInputStream::`vftable';

//----- (100070B0) --------------------------------------------------------
void __thiscall BufferedInputStream::resetBuffer(BufferedInputStream *this)
{
  *(this + 5) = 0;
  *(this + 4) = 0;
}

//----- (10007100) --------------------------------------------------------
int __thiscall BufferedInputStream::getPosition(BufferedInputStream *this)
{
  return *(this + 6);
}

//----- (10007140) --------------------------------------------------------
int __thiscall BufferedInputStream::getPending(BufferedInputStream *this)
{
  int v1; // eax
  BufferedInputStream *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v1 = (*(**(this + 7) + 60))(*(this + 7));
  return v1 - *(v3 + 6);
}

//----- (100071B0) --------------------------------------------------------
RandomAccessStream *__thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this, const struct BufferedInputStream *a2)
{
  RandomAccessStream *v2; // ST50_4

  v2 = this;
  RandomAccessStream::RandomAccessStream(this, a2);
  *(v2 + 2) = *(a2 + 2);
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  *(v2 + 5) = *(a2 + 5);
  *(v2 + 6) = *(a2 + 6);
  *(v2 + 7) = *(a2 + 7);
  *v2 = &BufferedInputStream::`vftable';
  return v2;
}
// 101AD2C0: using guessed type void *BufferedInputStream::`vftable';

//----- (10007270) --------------------------------------------------------
void __thiscall PVWAlphaShortAnimInfo::extract(PVWAlphaShortAnimInfo *this, float a2, struct ShortColour *a3)
{
  float v3; // ST08_4
  float v4; // ST04_4
  int v5; // ST10_4
  float v6; // ST04_4
  double v7; // st7
  float v8; // ST00_4
  int v9; // eax
  signed __int16 v10; // [esp+60h] [ebp-60h]
  signed __int16 v11; // [esp+64h] [ebp-5Ch]
  float v12; // [esp+B0h] [ebp-10h]
  int i; // [esp+B4h] [ebp-Ch]
  int v14; // [esp+B8h] [ebp-8h]
  PVWAlphaShortAnimInfo *v15; // [esp+BCh] [ebp-4h]

  v15 = this;
  if ( *this )
  {
    if ( *this == 1 )
    {
      *(a3 + 3) = *(*(this + 1) + 4);
    }
    else
    {
      v14 = 0;
      for ( i = 0; i < *this - 1; ++i )
      {
        if ( *(*(this + 1) + 16 * i) <= a2 && *(*(this + 1) + 16 * (i + 1)) >= a2 )
        {
          v14 = i;
          break;
        }
      }
      v3 = *(*(this + 1) + 16 * (v14 + 1) + 4);
      v4 = *(*(this + 1) + 16 * (v14 + 1));
      v5 = sub_10001A14(
             LODWORD(v4),
             LODWORD(v3),
             *(*(this + 1) + 16 * (v14 + 1) + 8),
             *(*(this + 1) + 16 * (v14 + 1) + 12));
      v6 = *(*(v15 + 1) + 16 * v14 + 4);
      v7 = *(*(v15 + 1) + 16 * v14);
      v8 = v7;
      v9 = sub_10001A14(LODWORD(v8), LODWORD(v6), *(*(v15 + 1) + 16 * v14 + 8), *(*(v15 + 1) + 16 * v14 + 12));
      sub_1000141A(a2, v9, v5);
      v12 = v7;
      if ( v12 >= 0.0 )
      {
        if ( v12 <= 255.0 )
          v10 = v12;
        else
          v10 = 255;
        v11 = v10;
      }
      else
      {
        v11 = 0;
      }
      *(a3 + 3) = v11;
    }
  }
}
// 10001A14: using guessed type _DWORD __stdcall sub_10001A14(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10007520) --------------------------------------------------------
_DWORD *__thiscall BufferedInputStream::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  RandomAccessStream::operator=(a2);
  v2[2] = a2[2];
  v2[3] = a2[3];
  v2[4] = a2[4];
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  return v2;
}
// 10001CEE: using guessed type _DWORD __stdcall RandomAccessStream::operator=(_DWORD);

//----- (100075D0) --------------------------------------------------------
RandomAccessStream *__thiscall BufferedStream::BufferedStream(BufferedStream *this)
{
  RandomAccessStream *v1; // ST50_4

  v1 = this;
  RandomAccessStream::RandomAccessStream(this);
  BufferedInputStream::BufferedInputStream((v1 + 12));
  *v1 = &BufferedStream::`vftable';
  return v1;
}
// 101AD330: using guessed type void *BufferedStream::`vftable';

//----- (10007630) --------------------------------------------------------
void __thiscall BufferedStream::init(BufferedStream *this, struct RandomAccessStream *a2, int a3)
{
  BufferedStream *v3; // ST58_4

  v3 = this;
  BufferedInputStream::init((this + 12), a2, 0, a3);
  *(v3 + 1) = *(a2 + 1);
  *(v3 + 2) = a2;
}

//----- (100076A0) --------------------------------------------------------
RandomAccessStream *__thiscall BufferedStream::BufferedStream(BufferedStream *this, struct RandomAccessStream *a2, int a3)
{
  RandomAccessStream *v3; // ST58_4

  v3 = this;
  RandomAccessStream::RandomAccessStream(this);
  BufferedInputStream::BufferedInputStream((v3 + 12), a2, 0, a3);
  *v3 = &BufferedStream::`vftable';
  *(v3 + 1) = *(a2 + 1);
  *(v3 + 2) = a2;
  return v3;
}
// 101AD330: using guessed type void *BufferedStream::`vftable';

//----- (10007730) --------------------------------------------------------
void __thiscall PVWTexAnimInfo::extract(PVWTexAnimInfo *this, float a2, struct Vector3f *a3)
{
  float v3; // ST04_4
  int v4; // ST10_4
  double v5; // st7
  float v6; // ST00_4
  int v7; // eax
  float v8; // ST04_4
  int v9; // ST10_4
  double v10; // st7
  float v11; // ST00_4
  int v12; // eax
  float v13; // ST04_4
  int v14; // ST10_4
  double v15; // st7
  float v16; // ST00_4
  int v17; // eax
  int i; // [esp+108h] [ebp-Ch]
  int v19; // [esp+10Ch] [ebp-8h]
  PVWTexAnimInfo *v20; // [esp+110h] [ebp-4h]

  v20 = this;
  if ( *this )
  {
    if ( *this == 1 )
    {
      *a3 = *(*(this + 1) + 4);
      *(a3 + 1) = *(*(this + 1) + 16);
      *(a3 + 2) = *(*(this + 1) + 28);
    }
    else
    {
      v19 = 0;
      if ( *(*(this + 1) + 40 * (*this - 1)) > a2 )
      {
        for ( i = 0; i < *this - 1; ++i )
        {
          if ( *(*(this + 1) + 40 * i) <= a2 && *(*(this + 1) + 40 * (i + 1)) >= a2 )
          {
            v19 = i;
            break;
          }
        }
        v3 = *(*(this + 1) + 40 * (v19 + 1));
        v4 = sub_10001A14(
               LODWORD(v3),
               *(*(this + 1) + 40 * (v19 + 1) + 4),
               *(*(this + 1) + 40 * (v19 + 1) + 8),
               *(*(this + 1) + 40 * (v19 + 1) + 12));
        v5 = *(*(v20 + 1) + 40 * v19);
        v6 = v5;
        v7 = sub_10001A14(
               LODWORD(v6),
               *(*(v20 + 1) + 40 * v19 + 4),
               *(*(v20 + 1) + 40 * v19 + 8),
               *(*(v20 + 1) + 40 * v19 + 12));
        sub_1000141A(a2, v7, v4);
        *a3 = v5;
        v8 = *(*(v20 + 1) + 40 * (v19 + 1));
        v9 = sub_10001A14(
               LODWORD(v8),
               *(*(v20 + 1) + 40 * (v19 + 1) + 16),
               *(*(v20 + 1) + 40 * (v19 + 1) + 20),
               *(*(v20 + 1) + 40 * (v19 + 1) + 24));
        v10 = *(*(v20 + 1) + 40 * v19);
        v11 = v10;
        v12 = sub_10001A14(
                LODWORD(v11),
                *(*(v20 + 1) + 40 * v19 + 16),
                *(*(v20 + 1) + 40 * v19 + 20),
                *(*(v20 + 1) + 40 * v19 + 24));
        sub_1000141A(a2, v12, v9);
        *(a3 + 1) = v10;
        v13 = *(*(v20 + 1) + 40 * (v19 + 1));
        v14 = sub_10001A14(
                LODWORD(v13),
                *(*(v20 + 1) + 40 * (v19 + 1) + 28),
                *(*(v20 + 1) + 40 * (v19 + 1) + 32),
                *(*(v20 + 1) + 40 * (v19 + 1) + 36));
        v15 = *(*(v20 + 1) + 40 * v19);
        v16 = v15;
        v17 = sub_10001A14(
                LODWORD(v16),
                *(*(v20 + 1) + 40 * v19 + 28),
                *(*(v20 + 1) + 40 * v19 + 32),
                *(*(v20 + 1) + 40 * v19 + 36));
        sub_1000141A(a2, v17, v14);
        *(a3 + 2) = v15;
      }
      else
      {
        *a3 = *(*(this + 1) + 40 * (*this - 1) + 4);
        *(a3 + 1) = *(*(this + 1) + 40 * (*this - 1) + 16);
        *(a3 + 2) = *(*(this + 1) + 40 * (*this - 1) + 28);
      }
    }
  }
}
// 10001A14: using guessed type _DWORD __stdcall sub_10001A14(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10007C80) --------------------------------------------------------
void __thiscall BufferedStream::read(BufferedStream *this, void *a2, int a3)
{
  BufferedStream *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*(this + 3) + 52))(this + 12, a2, a3);
}

//----- (10007CF0) --------------------------------------------------------
void __thiscall BufferedStream::close(BufferedStream *this)
{
  BufferedStream *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(**(this + 2) + 68))(*(this + 2));
}

//----- (10007D50) --------------------------------------------------------
int __thiscall BufferedStream::getPosition(BufferedStream *this)
{
  int v1; // eax
  BufferedStream *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v1 = (*(**(this + 2) + 80))(*(this + 2));
  return v1 - (*(v3 + 7) - *(v3 + 8));
}

//----- (10007DC0) --------------------------------------------------------
void __thiscall BufferedStream::setPosition(BufferedStream *this, int a2)
{
  BufferedStream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  BufferedInputStream::resetBuffer((this + 12));
  (*(**(v2 + 2) + 84))(*(v2 + 2), a2);
}

//----- (10007E30) --------------------------------------------------------
int __thiscall BufferedStream::getPending(BufferedStream *this)
{
  BufferedStream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  return (*(*(this + 3) + 60))(this + 12);
}

//----- (10007E90) --------------------------------------------------------
int __thiscall BufferedStream::getLength(BufferedStream *this)
{
  BufferedStream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  return (*(**(this + 2) + 88))(*(this + 2));
}

//----- (10007EF0) --------------------------------------------------------
RandomAccessStream *__thiscall BufferedStream::BufferedStream(BufferedStream *this, const struct BufferedStream *a2)
{
  RandomAccessStream *v2; // ST50_4

  v2 = this;
  RandomAccessStream::RandomAccessStream(this, a2);
  *(v2 + 2) = *(a2 + 2);
  BufferedInputStream::BufferedInputStream((v2 + 12), (a2 + 12));
  *v2 = &BufferedStream::`vftable';
  return v2;
}
// 101AD330: using guessed type void *BufferedStream::`vftable';

//----- (10007F70) --------------------------------------------------------
_DWORD *__thiscall BufferedStream::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  RandomAccessStream::operator=(a2);
  v2[2] = *(a2 + 8);
  BufferedInputStream::operator=(a2 + 12);
  return v2;
}
// 10001CEE: using guessed type _DWORD __stdcall RandomAccessStream::operator=(_DWORD);
// 1000236A: using guessed type _DWORD __stdcall BufferedInputStream::operator=(_DWORD);

//----- (10007FF0) --------------------------------------------------------
RandomAccessStream *__thiscall RamStream::RamStream(RamStream *this, void *a2, int a3)
{
  RandomAccessStream *v3; // ST50_4

  v3 = this;
  RandomAccessStream::RandomAccessStream(this);
  *v3 = &RamStream::`vftable';
  *(v3 + 2) = a2;
  *(v3 + 3) = 0;
  *(v3 + 4) = a3;
  return v3;
}
// 101AD3A0: using guessed type void *RamStream::`vftable';

//----- (10008070) --------------------------------------------------------
int __thiscall RamStream::getPending(RamStream *this)
{
  return *(this + 4) - *(this + 3);
}

//----- (100080B0) --------------------------------------------------------
void __thiscall RamStream::setPosition(RamStream *this, int a2)
{
  *(this + 3) = a2;
}

//----- (100080F0) --------------------------------------------------------
int __thiscall RamStream::getPosition(RamStream *this)
{
  return *(this + 3);
}

//----- (10008130) --------------------------------------------------------
int __thiscall RamStream::getLength(RamStream *this)
{
  return *(this + 4);
}

//----- (10008170) --------------------------------------------------------
void __thiscall RamStream::setLength(RamStream *this, int a2)
{
  *(this + 4) = a2;
}

//----- (100081B0) --------------------------------------------------------
void __thiscall RamStream::read(RamStream *this, void *Dst, int Size)
{
  RamStream *v3; // ST58_4

  v3 = this;
  memcpy(Dst, (*(this + 3) + *(this + 2)), Size);
  *(v3 + 3) += Size;
}

//----- (10008230) --------------------------------------------------------
void __thiscall PVWTextureData::animate(PVWTextureData *this, float *a2, struct Matrix4f *a3)
{
  double v3; // st7
  float v4; // ST08_4
  double v5; // st7
  double v6; // st7
  float v7; // ST08_4
  double v8; // st7
  float v9; // ST08_4
  float v10; // [esp+60h] [ebp-64h]
  float v11; // [esp+64h] [ebp-60h]
  float v12; // [esp+68h] [ebp-5Ch]
  float v13; // [esp+6Ch] [ebp-58h]
  float v14; // [esp+70h] [ebp-54h]
  float v15; // [esp+74h] [ebp-50h]
  float v16; // [esp+78h] [ebp-4Ch]
  float v17; // [esp+7Ch] [ebp-48h]
  float v18; // [esp+80h] [ebp-44h]
  float v19; // [esp+84h] [ebp-40h]
  float v20; // [esp+88h] [ebp-3Ch]
  float v21; // [esp+8Ch] [ebp-38h]
  float v22; // [esp+90h] [ebp-34h]
  float v23; // [esp+94h] [ebp-30h]
  float v24; // [esp+98h] [ebp-2Ch]
  float v25; // [esp+9Ch] [ebp-28h]
  float v26; // [esp+A0h] [ebp-24h]
  char v27; // [esp+A8h] [ebp-1Ch]
  float v28; // [esp+B0h] [ebp-14h]
  float v29; // [esp+B4h] [ebp-10h]
  float v30; // [esp+B8h] [ebp-Ch]
  PVWTextureData *v31; // [esp+C0h] [ebp-4h]

  v31 = this;
  if ( *(this + 20) != 255 )
  {
    v22 = 0.0;
    v21 = 1.0;
    v20 = 1.0;
    Vector3f::Vector3f(&v29, &v20, &v21, &v22);
    v19 = 0.0;
    v18 = 0.0;
    v17 = 0.0;
    Vector3f::Vector3f(&v27, &v17, &v18, &v19);
    v16 = 0.0;
    v15 = 0.0;
    v14 = 0.0;
    Vector3f::Vector3f(&v25, &v14, &v15, &v16);
    if ( *(v31 + 14) )
    {
      if ( a2 )
      {
        v3 = *(v31 + 14);
        v4 = v3;
        sub_100018D9(*a2, v4);
        *(v31 + 22) = v3;
      }
      else
      {
        v5 = System::getFrameTime(gsys);
        *(v31 + 22) = v5 * (30.0 * *(v31 + 15)) + *(v31 + 22);
        if ( (*(v31 + 14) - 1) <= *(v31 + 22) )
          *(v31 + 22) = 0;
      }
      PVWTexAnimInfo::extract((v31 + 64), *(v31 + 22), &v29);
      PVWTexAnimInfo::extract((v31 + 72), *(v31 + 22), &v27);
      PVWTexAnimInfo::extract((v31 + 80), *(v31 + 22), &v25);
      *(v31 + 22) = 0;
    }
    else if ( !*(v31 + 22) )
    {
      v13 = 0.0;
      Vector3f::set(&v29, v31 + 7, v31 + 8, &v13);
      v12 = 0.0;
      v11 = 0.0;
      Vector3f::set(&v27, &v11, &v12, v31 + 9);
      v10 = 0.0;
      Vector3f::set(&v25, v31 + 10, v31 + 11, &v10);
    }
    if ( !*(v31 + 22) )
    {
      v6 = v28 * 3.1415927 / 180.0;
      v7 = v6;
      sub_10002635(v7);
      v24 = v6;
      v8 = v28 * 3.1415927 / 180.0;
      v9 = v8;
      sub_10002D47(v9);
      v23 = v8;
      *a3 = v29 * v23;
      *(a3 + 1) = -v29 * v24;
      *(a3 + 2) = 0;
      *(a3 + 3) = -v29 * v23 * *(v31 + 12) + v29 * v24 * *(v31 + 13) + *(v31 + 12) + v25;
      *(a3 + 4) = v30 * v24;
      *(a3 + 5) = v30 * v23;
      *(a3 + 6) = 0;
      *(a3 + 7) = -v30 * v24 * *(v31 + 12) - v30 * v23 * *(v31 + 13) + *(v31 + 13) + v26;
      *(a3 + 8) = 0;
      *(a3 + 9) = 0;
      *(a3 + 10) = 1065353216;
      *(a3 + 11) = 0;
      *(a3 + 12) = 0;
      *(a3 + 13) = 0;
      *(a3 + 14) = 0;
      *(a3 + 15) = 1065353216;
      *(v31 + 22) = 1;
    }
  }
}
// 10001410: using guessed type double __thiscall System::getFrameTime(_DWORD);

//----- (10008660) --------------------------------------------------------
void __thiscall RamStream::write(RamStream *this, void *Src, int Size)
{
  RamStream *v3; // ST58_4

  v3 = this;
  memcpy((*(this + 3) + *(this + 2)), Src, Size);
  *(v3 + 3) += Size;
}

//----- (100086E0) --------------------------------------------------------
RandomAccessStream *__thiscall RamStream::RamStream(RamStream *this, const struct RamStream *a2)
{
  RandomAccessStream *v2; // ST50_4

  v2 = this;
  RandomAccessStream::RandomAccessStream(this, a2);
  *(v2 + 2) = *(a2 + 2);
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  *v2 = &RamStream::`vftable';
  return v2;
}
// 101AD3A0: using guessed type void *RamStream::`vftable';

//----- (10008770) --------------------------------------------------------
_DWORD *__thiscall RamStream::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  RandomAccessStream::operator=(a2);
  v2[2] = a2[2];
  v2[3] = a2[3];
  v2[4] = a2[4];
  return v2;
}
// 10001CEE: using guessed type _DWORD __stdcall RandomAccessStream::operator=(_DWORD);

//----- (100087F0) --------------------------------------------------------
void __stdcall ANode::genAge(struct AgeServer *a2)
{
  ;
}

//----- (10008820) --------------------------------------------------------
void __stdcall ANode::genAgeNode(struct AgeServer *a2)
{
  ;
}

//----- (10008850) --------------------------------------------------------
int ANode::getAgeNodeType()
{
  return 0;
}

//----- (10008880) --------------------------------------------------------
ANode *__thiscall ANode::ANode(ANode *this)
{
  *this = &ANode::`vftable';
  return this;
}
// 101AD41C: using guessed type void *ANode::`vftable';

//----- (100088C0) --------------------------------------------------------
ANode *__thiscall ANode::ANode(ANode *this, const struct ANode *a2)
{
  *this = &ANode::`vftable';
  return this;
}
// 101AD41C: using guessed type void *ANode::`vftable';

//----- (10008900) --------------------------------------------------------
void *__thiscall ANode::operator=(void *this, int a2)
{
  return this;
}

//----- (10008940) --------------------------------------------------------
void __userpurge PVWTextureData::read(PVWTextureData *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  int v3; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  char v6; // al
  char v7; // al
  char v8; // al
  char v9; // al
  char v10; // al
  int v11; // eax
  PVWTextureData *v12; // [esp+4Ch] [ebp-4h]

  v12 = this;
  v3 = (**a3)(a3);
  *v12 = v3;
  v4 = (*(*a3 + 8))(a3);
  *(v12 + 6) = v4;
  v5 = (*(*a3 + 8))(a3);
  *(v12 + 7) = v5;
  v6 = (*(*a3 + 4))(a3);
  *(v12 + 16) = v6;
  v7 = (*(*a3 + 4))(a3);
  *(v12 + 17) = v7;
  v8 = (*(*a3 + 4))(a3);
  *(v12 + 18) = v8;
  v9 = (*(*a3 + 4))(a3);
  *(v12 + 19) = v9;
  v10 = (**a3)(a3);
  *(v12 + 20) = v10;
  v11 = (**a3)(a3);
  *(v12 + 14) = v11;
  (*(*a3 + 12))(a3);
  *(v12 + 15) = a2;
  (*(*a3 + 12))(a3);
  *(v12 + 7) = a2;
  (*(*a3 + 12))(a3);
  *(v12 + 8) = a2;
  (*(*a3 + 12))(a3);
  *(v12 + 9) = a2;
  (*(*a3 + 12))(a3);
  *(v12 + 10) = a2;
  (*(*a3 + 12))(a3);
  *(v12 + 11) = a2;
  (*(*a3 + 12))(a3);
  *(v12 + 12) = a2;
  (*(*a3 + 12))(a3);
  *(v12 + 13) = a2;
  sub_10001208(a3);
  sub_10001208(a3);
  sub_10001208(a3);
}

//----- (10008BE0) --------------------------------------------------------
void __thiscall PVWTextureData::write(PVWTextureData *this, struct RandomAccessStream *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  PVWTextureData *v8; // [esp+4Ch] [ebp-4h]

  v8 = this;
  (*(*a2 + 28))(a2, *this);
  LOWORD(v2) = *(v8 + 6);
  (*(*a2 + 36))(a2, v2);
  LOWORD(v3) = *(v8 + 7);
  (*(*a2 + 36))(a2, v3);
  LOBYTE(v4) = *(v8 + 16);
  (*(*a2 + 32))(a2, v4);
  LOBYTE(v5) = *(v8 + 17);
  (*(*a2 + 32))(a2, v5);
  LOBYTE(v6) = *(v8 + 18);
  (*(*a2 + 32))(a2, v6);
  LOBYTE(v7) = *(v8 + 19);
  (*(*a2 + 32))(a2, v7);
  (*(*a2 + 28))(a2, *(v8 + 20));
  (*(*a2 + 28))(a2, *(v8 + 14));
  (*(*a2 + 40))(a2, *(v8 + 15));
  (*(*a2 + 40))(a2, *(v8 + 7));
  (*(*a2 + 40))(a2, *(v8 + 8));
  (*(*a2 + 40))(a2, *(v8 + 9));
  (*(*a2 + 40))(a2, *(v8 + 10));
  (*(*a2 + 40))(a2, *(v8 + 11));
  (*(*a2 + 40))(a2, *(v8 + 12));
  (*(*a2 + 40))(a2, *(v8 + 13));
  sub_100029AA(a2);
  sub_100029AA(a2);
  sub_100029AA(a2);
}

//----- (10008EA0) --------------------------------------------------------
void __cdecl sub_10008EA0(float a1)
{
  float v1; // ST54_4

  v1 = cos(a1);
}

//----- (10008EF0) --------------------------------------------------------
void __cdecl sub_10008EF0(float a1, float a2)
{
  float v2; // ST5C_4

  v2 = fmod(a1, a2);
}

//----- (10008F50) --------------------------------------------------------
void __thiscall PVWTexGenData::read(PVWTexGenData *this, struct RandomAccessStream *a2)
{
  char v2; // al
  char v3; // al
  char v4; // al
  char v5; // al
  PVWTexGenData *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  v2 = (*(*a2 + 4))(a2);
  *v6 = v2;
  v3 = (*(*a2 + 4))(a2);
  *(v6 + 1) = v3;
  v4 = (*(*a2 + 4))(a2);
  *(v6 + 2) = v4;
  v5 = (*(*a2 + 4))(a2);
  *(v6 + 3) = v5;
}

//----- (10009010) --------------------------------------------------------
void __cdecl sub_10009010(float a1)
{
  float v1; // ST54_4

  v1 = sin(a1);
}

//----- (10009060) --------------------------------------------------------
void __thiscall PVWTexGenData::write(PVWTexGenData *this, struct RandomAccessStream *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  PVWTexGenData *v5; // [esp+4Ch] [ebp-4h]

  v5 = this;
  LOBYTE(this) = *this;
  (*(*a2 + 32))(a2, this);
  LOBYTE(v2) = *(v5 + 1);
  (*(*a2 + 32))(a2, v2);
  LOBYTE(v3) = *(v5 + 2);
  (*(*a2 + 32))(a2, v3);
  LOBYTE(v4) = *(v5 + 3);
  (*(*a2 + 32))(a2, v4);
}

//----- (10009130) --------------------------------------------------------
void __thiscall PVWTextureInfo::read(PVWTextureInfo *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  HGLOBAL v5; // [esp+4Ch] [ebp-2Ch]
  HGLOBAL hMem; // [esp+50h] [ebp-28h]
  HGLOBAL v7; // [esp+54h] [ebp-24h]
  int v8; // [esp+58h] [ebp-20h]
  unsigned int j; // [esp+5Ch] [ebp-1Ch]
  int v10; // [esp+60h] [ebp-18h]
  unsigned int i; // [esp+64h] [ebp-14h]
  Vector3f *v12; // [esp+68h] [ebp-10h]
  int v13; // [esp+74h] [ebp-4h]

  v12 = this;
  v2 = (**a2)(a2);
  *(v12 + 5) = v2;
  Vector3f::read(v12, a2);
  v3 = (**a2)(a2);
  *(v12 + 4) = v3;
  if ( *(v12 + 4) )
  {
    v8 = sub_10001AC3(4 * *(v12 + 4));
    *(v12 + 8) = v8;
    for ( i = 0; i < *(v12 + 4); ++i )
      PVWTexGenData::read((*(v12 + 8) + 4 * i), a2);
  }
  *(v12 + 6) = 0;
  v4 = (**a2)(a2);
  *(v12 + 3) = v4;
  if ( *(v12 + 3) )
  {
    v10 = *(v12 + 3);
    hMem = sub_10001AC3(156 * v10);
    v13 = 0;
    if ( hMem )
    {
      sub_1000291E(hMem, 156, v10, PVWTextureData::PVWTextureData);
      v5 = hMem;
    }
    else
    {
      v5 = 0;
    }
    v7 = v5;
    v13 = -1;
    *(v12 + 7) = v5;
    for ( j = 0; j < *(v12 + 3); ++j )
    {
      PVWTextureData::read((*(v12 + 7) + 156 * j), a2);
      if ( *(*(v12 + 7) + 156 * j + 17) == 2 )
        ++*(v12 + 6);
    }
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100093E0) --------------------------------------------------------
void __cdecl sub_100093E0(float a1)
{
  float v1; // ST54_4

  v1 = sqrt(a1);
}

//----- (10009430) --------------------------------------------------------
Vector2f *__thiscall Vector2f::Vector2f(Vector2f *this)
{
  return this;
}

//----- (10009460) --------------------------------------------------------
Vector2f *__thiscall Vector2f::Vector2f(Vector2f *this, const float *a2, const float *a3)
{
  *this = *a2;
  *(this + 1) = *a3;
  return this;
}

//----- (100094B0) --------------------------------------------------------
void __thiscall Vector2f::set(Vector2f *this, float a2, float a3)
{
  *this = a2;
  *(this + 1) = a3;
}

//----- (10009500) --------------------------------------------------------
void __thiscall Vector2f::write(Vector2f *this, struct Stream *a2)
{
  Vector2f *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 40))(a2, *this);
  (*(*a2 + 40))(a2, *(v2 + 1));
}

//----- (10009580) --------------------------------------------------------
void __userpurge Vector2f::read(Vector2f *this@<ecx>, double a2@<st0>, struct Stream *a3)
{
  float *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*a3 + 12))(a3);
  *v3 = a2;
  (*(*a3 + 12))(a3);
  v3[1] = a2;
}

//----- (10009600) --------------------------------------------------------
_DWORD *__thiscall Vector2f::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10009650) --------------------------------------------------------
void __thiscall Vector2i::set(Vector2i *this, int a2, int a3)
{
  *this = a2;
  *(this + 1) = a3;
}

//----- (100096A0) --------------------------------------------------------
void __thiscall Vector2i::write(Vector2i *this, struct Stream *a2)
{
  Vector2i *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
  (*(*a2 + 28))(a2, *(v2 + 1));
}

//----- (10009720) --------------------------------------------------------
void __thiscall Vector2i::read(Vector2i *this, struct Stream *a2)
{
  int v2; // eax
  int v3; // eax
  Vector2i *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  v2 = (**a2)(a2);
  *v4 = v2;
  v3 = (**a2)(a2);
  *(v4 + 1) = v3;
}

//----- (100097A0) --------------------------------------------------------
void __thiscall PVWTevColReg::animate(PVWTevColReg *this, float *a2, struct ShortColour *a3)
{
  double v3; // st7
  float v4; // ST04_4
  PVWTevColReg *v5; // [esp+60h] [ebp-4h]

  v5 = this;
  if ( *(this + 2) )
  {
    if ( a2 )
    {
      v3 = *(this + 2);
      v4 = v3;
      sub_100018D9(*a2, v4);
      *(v5 + 8) = v3;
    }
    else
    {
      *(this + 8) = System::getFrameTime(gsys) * (30.0 * *(this + 3)) + *(this + 8);
      if ( (*(v5 + 2) - 1) <= *(v5 + 8) )
        *(v5 + 8) = 0;
    }
    PVWColourShortAnimInfo::extract((v5 + 16), *(v5 + 8), a3);
    PVWAlphaShortAnimInfo::extract((v5 + 24), *(v5 + 8), a3);
  }
}
// 10001410: using guessed type double __thiscall System::getFrameTime(_DWORD);

//----- (100098D0) --------------------------------------------------------
_DWORD *__thiscall Vector2i::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10009920) --------------------------------------------------------
Vector3f *__thiscall Vector3f::Vector3f(Vector3f *this)
{
  *(this + 2) = 0;
  *(this + 1) = 0;
  *this = 0;
  return this;
}

//----- (10009980) --------------------------------------------------------
Vector3f *__thiscall Vector3f::Vector3f(Vector3f *this, const float *a2, const float *a3, const float *a4)
{
  *this = *a2;
  *(this + 1) = *a3;
  *(this + 2) = *a4;
  return this;
}

//----- (100099E0) --------------------------------------------------------
Vector3f *__thiscall Vector3f::Vector3f(Vector3f *this, const struct Vector3f *a2)
{
  *this = *a2;
  *(this + 1) = *(a2 + 1);
  *(this + 2) = *(a2 + 2);
  return this;
}

//----- (10009A40) --------------------------------------------------------
char __thiscall PVWTevInfo::isSame(PVWTevInfo *this, struct PVWTevInfo *a2)
{
  signed int i; // [esp+4Ch] [ebp-8h]
  signed int j; // [esp+4Ch] [ebp-8h]
  int k; // [esp+4Ch] [ebp-8h]
  PVWTevInfo *v6; // [esp+50h] [ebp-4h]

  v6 = this;
  if ( *(this + 31) != *(a2 + 31) )
    return 0;
  for ( i = 0; i < 3; ++i )
  {
    if ( !PVWTevColReg::isSame((v6 + 36 * i), (a2 + 36 * i)) )
      return 0;
  }
  for ( j = 0; j < 4; ++j )
  {
    if ( *(v6 + 4 * j + 108) != *(a2 + 4 * j + 108)
      || *(v6 + 4 * j + 109) != *(a2 + 4 * j + 109)
      || *(v6 + 4 * j + 110) != *(a2 + 4 * j + 110)
      || *(v6 + 4 * j + 111) != *(a2 + 4 * j + 111) )
    {
      return 0;
    }
  }
  for ( k = 0; k < *(v6 + 31); ++k )
  {
    if ( *(*(v6 + 32) + 30 * k) != *(*(a2 + 32) + 30 * k)
      || *(*(v6 + 32) + 30 * k + 1) != *(*(a2 + 32) + 30 * k + 1)
      || *(*(v6 + 32) + 30 * k + 2) != *(*(a2 + 32) + 30 * k + 2)
      || *(*(v6 + 32) + 30 * k + 3) != *(*(a2 + 32) + 30 * k + 3) )
    {
      return 0;
    }
    if ( *(*(v6 + 32) + 30 * k + 6) != *(*(a2 + 32) + 30 * k + 6)
      || *(*(v6 + 32) + 30 * k + 7) != *(*(a2 + 32) + 30 * k + 7)
      || *(*(v6 + 32) + 30 * k + 8) != *(*(a2 + 32) + 30 * k + 8)
      || *(*(v6 + 32) + 30 * k + 9) != *(*(a2 + 32) + 30 * k + 9)
      || *(*(v6 + 32) + 30 * k + 10) != *(*(a2 + 32) + 30 * k + 10)
      || *(*(v6 + 32) + 30 * k + 11) != *(*(a2 + 32) + 30 * k + 11)
      || *(*(v6 + 32) + 30 * k + 12) != *(*(a2 + 32) + 30 * k + 12)
      || *(*(v6 + 32) + 30 * k + 13) != *(*(a2 + 32) + 30 * k + 13)
      || *(*(v6 + 32) + 30 * k + 14) != *(*(a2 + 32) + 30 * k + 14) )
    {
      return 0;
    }
    if ( *(*(v6 + 32) + 30 * k + 18) != *(*(a2 + 32) + 30 * k + 18)
      || *(*(v6 + 32) + 30 * k + 19) != *(*(a2 + 32) + 30 * k + 19)
      || *(*(v6 + 32) + 30 * k + 20) != *(*(a2 + 32) + 30 * k + 20)
      || *(*(v6 + 32) + 30 * k + 21) != *(*(a2 + 32) + 30 * k + 21)
      || *(*(v6 + 32) + 30 * k + 22) != *(*(a2 + 32) + 30 * k + 22)
      || *(*(v6 + 32) + 30 * k + 23) != *(*(a2 + 32) + 30 * k + 23)
      || *(*(v6 + 32) + 30 * k + 24) != *(*(a2 + 32) + 30 * k + 24)
      || *(*(v6 + 32) + 30 * k + 25) != *(*(a2 + 32) + 30 * k + 25)
      || *(*(v6 + 32) + 30 * k + 26) != *(*(a2 + 32) + 30 * k + 26) )
    {
      return 0;
    }
  }
  return 1;
}

//----- (1000A120) --------------------------------------------------------
void __thiscall Vector3f::set(Vector3f *this, const float *a2, const float *a3, const float *a4)
{
  *this = *a2;
  *(this + 1) = *a3;
  *(this + 2) = *a4;
}

//----- (1000A180) --------------------------------------------------------
void __thiscall Vector3f::set(Vector3f *this, const struct Vector3f *a2)
{
  Vector3f::set(this, a2, a2 + 1, a2 + 2);
}

//----- (1000A1E0) --------------------------------------------------------
bool __thiscall Vector3f::isSame(Vector3f *this, struct Vector3f *a2)
{
  double v2; // st7
  float v3; // ST00_4
  double v4; // st7
  float v5; // ST00_4
  double v6; // st7
  float v7; // ST00_4
  bool result; // al
  Vector3f *v9; // [esp+50h] [ebp-4h]

  v9 = this;
  v2 = *this - *a2;
  v3 = v2;
  sub_10001136(v3);
  result = 0;
  if ( v2 < 0.000099999997 )
  {
    v4 = *(v9 + 1) - *(a2 + 1);
    v5 = v4;
    sub_10001136(v5);
    if ( v4 < 0.000099999997 )
    {
      v6 = *(v9 + 2) - *(a2 + 2);
      v7 = v6;
      sub_10001136(v7);
      if ( v6 < 0.000099999997 )
        result = 1;
    }
  }
  return result;
}

//----- (1000A2B0) --------------------------------------------------------
void __cdecl sub_1000A2B0(float a1)
{
  float v1; // ST54_4

  v1 = fabs(a1);
}

//----- (1000A300) --------------------------------------------------------
void __thiscall Vector3f::lerpTo(Vector3f *this, struct Vector3f *a2, float a3, struct Vector3f *a4)
{
  Vector3f *v4; // ST50_4

  v4 = this;
  *a4 = (*a2 - *this) * a3 + *this;
  *(a4 + 1) = (*(a2 + 1) - *(v4 + 1)) * a3 + *(v4 + 1);
  *(a4 + 2) = (*(a2 + 2) - *(v4 + 2)) * a3 + *(v4 + 2);
}

//----- (1000A390) --------------------------------------------------------
void __thiscall Vector3f::bounce(Vector3f *this, struct Vector3f *a2, float a3)
{
  float v3; // [esp+4Ch] [ebp-8h]
  float *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  v3 = -Vector3f::DP(this, a2) * a3;
  if ( v3 > 0.0 )
  {
    *v4 = v3 * *a2 + *v4;
    v4[1] = v3 * *(a2 + 1) + v4[1];
    v4[2] = v3 * *(a2 + 2) + v4[2];
  }
}

//----- (1000A450) --------------------------------------------------------
void __thiscall Vector3f::project(Vector3f *this, struct Vector3f *a2)
{
  float *v2; // ST54_4
  float v3; // ST50_4

  v2 = this;
  v3 = Vector3f::DP(this, a2);
  *v2 = -(v3 * *a2 - *v2);
  v2[1] = -(v3 * *(a2 + 1) - v2[1]);
  v2[2] = -(v3 * *(a2 + 2) - v2[2]);
}

//----- (1000A500) --------------------------------------------------------
void __thiscall Vector3f::sub(Vector3f *this, struct Vector3f *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  *this = *this - *a2;
  *(v2 + 1) = *(v2 + 1) - *(a2 + 1);
  *(v2 + 2) = *(v2 + 2) - *(a2 + 2);
}

//----- (1000A570) --------------------------------------------------------
void __thiscall Vector3f::sub(Vector3f *this, struct Vector3f *a2, struct Vector3f *a3)
{
  *this = *a2 - *a3;
  *(this + 1) = *(a2 + 1) - *(a3 + 1);
  *(this + 2) = *(a2 + 2) - *(a3 + 2);
}

//----- (1000A5E0) --------------------------------------------------------
void __thiscall Vector3f::add(Vector3f *this, float a2, float a3, float a4)
{
  *this = a2 + *this;
  *(this + 1) = a3 + *(this + 1);
  *(this + 2) = a4 + *(this + 2);
}

//----- (1000A650) --------------------------------------------------------
void __thiscall Vector3f::add(Vector3f *this, struct Vector3f *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  *this = *this + *a2;
  *(v2 + 1) = *(v2 + 1) + *(a2 + 1);
  *(v2 + 2) = *(v2 + 2) + *(a2 + 2);
}

//----- (1000A6C0) --------------------------------------------------------
void __thiscall Vector3f::add(Vector3f *this, struct Vector3f *a2, struct Vector3f *a3)
{
  *this = *a2 + *a3;
  *(this + 1) = *(a2 + 1) + *(a3 + 1);
  *(this + 2) = *(a2 + 2) + *(a3 + 2);
}

//----- (1000A730) --------------------------------------------------------
void __thiscall Vector3f::div(Vector3f *this, float a2)
{
  *this = *this / a2;
  *(this + 1) = *(this + 1) / a2;
  *(this + 2) = *(this + 2) / a2;
}

//----- (1000A7A0) --------------------------------------------------------
void __thiscall Vector3f::multiply(Vector3f *this, float a2)
{
  *this = a2 * *this;
  *(this + 1) = a2 * *(this + 1);
  *(this + 2) = a2 * *(this + 2);
}

//----- (1000A810) --------------------------------------------------------
double __thiscall Vector3f::length(Vector3f *this)
{
  double result; // st7
  float v2; // ST00_4

  result = *this * *this + *(this + 1) * *(this + 1) + *(this + 2) * *(this + 2);
  v2 = result;
  sub_1000122B(v2);
  return result;
}

//----- (1000A890) --------------------------------------------------------
double __thiscall Vector3f::squaredLength(Vector3f *this)
{
  return *this * *this + *(this + 1) * *(this + 1) + *(this + 2) * *(this + 2);
}

//----- (1000A8F0) --------------------------------------------------------
void Material::attach()
{
  ;
}

//----- (1000A920) --------------------------------------------------------
void __thiscall Material::read(Material *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // eax
  Colour *v4; // eax
  int v5; // eax
  Material *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  v2 = (**a2)(a2);
  *(v6 + 6) = v2;
  v3 = (**a2)(a2);
  *(v6 + 7) = v3;
  v4 = Material::Colour(v6);
  Colour::read(v4, a2);
  if ( *(v6 + 6) & 1 )
  {
    v5 = (**a2)(a2);
    *(v6 + 35) = v5;
    PVWPolygonColourInfo::read((v6 + 44), a2);
    PVWLightingInfo::read((v6 + 76), a2);
    PVWPeInfo::read((v6 + 88), a2);
    PVWTextureInfo::read((v6 + 104), a2);
  }
}

//----- (1000AA30) --------------------------------------------------------
double __thiscall Vector3f::normalise(Vector3f *this)
{
  float v2; // [esp+4Ch] [ebp-8h]
  Vector3f *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  v2 = Vector3f::length(this);
  if ( v2 != 0.0 )
    Vector3f::div(v3, v2);
  return v2;
}

//----- (1000AAA0) --------------------------------------------------------
void __thiscall Vector3f::CP(Vector3f *this, struct Vector3f *a2)
{
  float v2; // [esp+4Ch] [ebp-10h]
  float v3; // [esp+50h] [ebp-Ch]
  float v4; // [esp+54h] [ebp-8h]
  float *v5; // [esp+58h] [ebp-4h]

  v5 = this;
  Vector3f::Vector3f(&v2);
  v2 = v5[1] * *(a2 + 2) - v5[2] * *(a2 + 1);
  v3 = v5[2] * *a2 - *v5 * *(a2 + 2);
  v4 = *v5 * *(a2 + 1) - v5[1] * *a2;
  *v5 = v2;
  v5[1] = v3;
  v5[2] = v4;
}

//----- (1000AB70) --------------------------------------------------------
void __thiscall Material::write(Material *this, struct RandomAccessStream *a2)
{
  Colour *v2; // eax
  Material *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*a2 + 28))(a2, *(this + 6));
  (*(*a2 + 28))(a2, *(v3 + 7));
  v2 = Material::Colour(v3);
  Colour::write(v2, a2);
  if ( *(v3 + 6) & 1 )
  {
    (*(*a2 + 28))(a2, *(v3 + 35));
    PVWPolygonColourInfo::write((v3 + 44), a2);
    PVWLightingInfo::write((v3 + 76), a2);
    PVWPeInfo::write((v3 + 88), a2);
    PVWTextureInfo::write((v3 + 104), a2);
  }
}

//----- (1000AC90) --------------------------------------------------------
double __thiscall Vector3f::DP(Vector3f *this, struct Vector3f *a2)
{
  return *this * *a2 + *(this + 1) * *(a2 + 1) + *(this + 2) * *(a2 + 2);
}

//----- (1000ACF0) --------------------------------------------------------
void __thiscall Vector3f::normalize(Vector3f *this)
{
  Vector3f::normalise(this);
}

//----- (1000AD40) --------------------------------------------------------
void __thiscall Vector3f::input(Vector3f *this, struct Vector3f *a2)
{
  Vector3f::set(this, a2, a2 + 1, a2 + 2);
}

//----- (1000ADA0) --------------------------------------------------------
void __thiscall Material::genAge(Material *this, struct AgeServer *a2)
{
  Material *v2; // ST54_4
  Colour *v3; // eax

  v2 = this;
  AgeServer::StartSection(a2, *(this + 1), 1);
  AgeServer::StartGroup(a2, *(v2 + 1));
  v3 = Material::Colour(v2);
  Colour::genAge(v3, a2, "diffuse");
  AgeServer::EndGroup(a2);
  AgeServer::EndSection(a2);
}

//----- (1000AE40) --------------------------------------------------------
void __thiscall Vector3f::output(Vector3f *this, struct Vector3f *a2)
{
  Vector3f::set(a2, this, this + 1, this + 2);
}

//----- (1000AEA0) --------------------------------------------------------
void __thiscall Font::setTexture(Font *this, struct Texture *a2, int a3, int a4)
{
  HGLOBAL v4; // [esp+4Ch] [ebp-64h]
  HGLOBAL hMem; // [esp+50h] [ebp-60h]
  unsigned __int8 v6; // [esp+58h] [ebp-58h]
  signed int ii; // [esp+5Ch] [ebp-54h]
  int v8; // [esp+60h] [ebp-50h]
  signed int v9; // [esp+64h] [ebp-4Ch]
  int n; // [esp+6Ch] [ebp-44h]
  int v11; // [esp+70h] [ebp-40h]
  int m; // [esp+74h] [ebp-3Ch]
  int l; // [esp+7Ch] [ebp-34h]
  int v14; // [esp+80h] [ebp-30h]
  int k; // [esp+84h] [ebp-2Ch]
  int v16; // [esp+88h] [ebp-28h]
  __int16 v17; // [esp+8Ch] [ebp-24h]
  int j; // [esp+90h] [ebp-20h]
  int i; // [esp+94h] [ebp-1Ch]
  int v20; // [esp+98h] [ebp-18h]
  Font *v21; // [esp+A0h] [ebp-10h]

  v21 = this;
  *this = a2;
  hMem = sub_10001AC3(28 * a4 * a3);
  if ( hMem )
  {
    sub_1000291E(hMem, 28, a4 * a3, FontChar::FontChar);
    v4 = hMem;
  }
  else
  {
    v4 = 0;
  }
  *(v21 + 3) = v4;
  *(v21 + 1) = *(*v21 + 8) / a3;
  *(v21 + 2) = *(*v21 + 10) / a4;
  v20 = 0;
  for ( i = 0; i < a4; ++i )
  {
    for ( j = 0; j < a3; ++j )
    {
      v17 = 0;
      LOWORD(v16) = 0;
      for ( k = 0; k < *(v21 + 1); ++k )
      {
        v14 = 0;
        for ( l = 0; l < *(v21 + 2) - 1; ++l )
        {
          if ( !Texture::getAlpha(a2, k + *(v21 + 1) * j, l + *(v21 + 2) * i) )
            ++v14;
        }
        if ( v14 != *(v21 + 2) - 1 )
          break;
        v17 = k;
      }
      for ( m = *(v21 + 1) - 1; m >= 0; --m )
      {
        v11 = 0;
        for ( n = 0; n < *(v21 + 2) - 1; ++n )
        {
          if ( !Texture::getAlpha(a2, m + *(v21 + 1) * j, n + *(v21 + 2) * i) )
            ++v11;
        }
        if ( v11 != *(v21 + 2) - 1 )
          break;
        v16 = *(v21 + 1) - m;
      }
      v9 = -1;
      v8 = *(v21 + 1);
      for ( ii = 0; ii < *(v21 + 1); ++ii )
      {
        v6 = Texture::getAlpha(a2, ii + *(v21 + 1) * j, *(v21 + 2) * i + *(v21 + 2) - 1);
        if ( v9 >= 0 )
        {
          if ( v6 )
          {
            LOWORD(v8) = ii;
            break;
          }
        }
        else if ( !v6 )
        {
          v9 = ii;
        }
      }
      *(*(v21 + 3) + 28 * v20 + 8) = v8 - v9;
      *(*(v21 + 3) + 28 * v20 + 10) = v9 - v17;
      *(*(v21 + 3) + 28 * v20) = v17 + *(v21 + 2) * j;
      *(*(v21 + 3) + 28 * v20 + 4) = *(v21 + 1) - v17 - v16;
      *(*(v21 + 3) + 28 * v20 + 2) = *(v21 + 4) * i;
      *(*(v21 + 3) + 28 * v20 + 6) = *(v21 + 2) - 1;
      *(*(v21 + 3) + 28 * v20 + 12) = *(*(v21 + 3) + 28 * v20);
      *(*(v21 + 3) + 28 * v20 + 16) = *(*(v21 + 3) + 28 * v20 + 2);
      *(*(v21 + 3) + 28 * v20 + 20) = *(*(v21 + 3) + 28 * v20 + 4) + *(*(v21 + 3) + 28 * v20);
      *(*(v21 + 3) + 28 * v20 + 24) = *(*(v21 + 3) + 28 * v20 + 2) + *(*(v21 + 3) + 28 * v20 + 6) - 1;
      ++v20;
    }
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000B430) --------------------------------------------------------
void __thiscall Vector3f::negate(Vector3f *this)
{
  *this = -*this;
  *(this + 1) = -*(this + 1);
  *(this + 2) = -*(this + 2);
}

//----- (1000B490) --------------------------------------------------------
void __thiscall Vector3f::add2(Vector3f *this, struct Vector3f *a2, struct Vector3f *a3)
{
  float v3; // [esp+4Ch] [ebp-10h]
  float v4; // [esp+50h] [ebp-Ch]
  float v5; // [esp+54h] [ebp-8h]
  Vector3f *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  v5 = *(a2 + 2) + *(a3 + 2);
  v4 = *(a2 + 1) + *(a3 + 1);
  v3 = *a2 + *a3;
  Vector3f::set(this, &v3, &v4, &v5);
}

//----- (1000B520) --------------------------------------------------------
void __thiscall Vector3f::sub2(Vector3f *this, struct Vector3f *a2, struct Vector3f *a3)
{
  float v3; // [esp+4Ch] [ebp-10h]
  float v4; // [esp+50h] [ebp-Ch]
  float v5; // [esp+54h] [ebp-8h]
  Vector3f *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  v5 = *(a2 + 2) - *(a3 + 2);
  v4 = *(a2 + 1) - *(a3 + 1);
  v3 = *a2 - *a3;
  Vector3f::set(this, &v3, &v4, &v5);
}

//----- (1000B5B0) --------------------------------------------------------
double __thiscall Vector3f::dot(Vector3f *this, struct Vector3f *a2)
{
  return *this * *a2 + *(this + 1) * *(a2 + 1) + *(this + 2) * *(a2 + 2);
}

//----- (1000B610) --------------------------------------------------------
void __thiscall Vector3f::scale(Vector3f *this, float a2)
{
  *this = a2 * *this;
  *(this + 1) = a2 * *(this + 1);
  *(this + 2) = a2 * *(this + 2);
}

//----- (1000B680) --------------------------------------------------------
void __thiscall Vector3f::scale2(Vector3f *this, float a2, struct Vector3f *a3)
{
  *this = a2 * *a3;
  *(this + 1) = a2 * *(a3 + 1);
  *(this + 2) = a2 * *(a3 + 2);
}

//----- (1000B6F0) --------------------------------------------------------
float __thiscall Vector3f::distance(Vector3f *this, struct Vector3f *a2)
{
  char v4; // [esp+4Ch] [ebp-10h]
  struct Vector3f *v5; // [esp+58h] [ebp-4h]

  v5 = this;
  Vector3f::Vector3f(&v4);
  Vector3f::sub2(&v4, a2, v5);
  return Vector3f::length(&v4);
}

//----- (1000B760) --------------------------------------------------------
void __thiscall Vector3f::middle(Vector3f *this, struct Vector3f *a2, struct Vector3f *a3)
{
  Vector3f *v3; // ST54_4

  v3 = this;
  Vector3f::add2(this, a2, a3);
  Vector3f::scale(v3, 0.5);
}

//----- (1000B7C0) --------------------------------------------------------
void __thiscall Vector3f::cross(Vector3f *this, struct Vector3f *a2, struct Vector3f *a3)
{
  float v3; // [esp+4Ch] [ebp-10h]
  float v4; // [esp+50h] [ebp-Ch]
  float v5; // [esp+54h] [ebp-8h]
  Vector3f *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  v5 = *a2 * *(a3 + 1) - *(a2 + 1) * *a3;
  v4 = *(a2 + 2) * *a3 - *a2 * *(a3 + 2);
  v3 = *(a2 + 1) * *(a3 + 2) - *(a2 + 2) * *(a3 + 1);
  Vector3f::set(this, &v3, &v4, &v5);
}

//----- (1000B880) --------------------------------------------------------
void __thiscall Vector3f::write(Vector3f *this, struct Stream *a2)
{
  Vector3f *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 40))(a2, *this);
  (*(*a2 + 40))(a2, *(v2 + 1));
  (*(*a2 + 40))(a2, *(v2 + 2));
}

//----- (1000B920) --------------------------------------------------------
void __userpurge Vector3f::read(Vector3f *this@<ecx>, double a2@<st0>, struct Stream *a3)
{
  float *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*a3 + 12))(a3);
  *v3 = a2;
  (*(*a3 + 12))(a3);
  v3[1] = a2;
  (*(*a3 + 12))(a3);
  v3[2] = a2;
}

//----- (1000B9C0) --------------------------------------------------------
_DWORD *__thiscall Vector3f::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (1000BA10) --------------------------------------------------------
int __stdcall Font::charToIndex(char a2)
{
  return a2 - 32;
}

//----- (1000BA50) --------------------------------------------------------
int __stdcall Font::charToIndex(unsigned __int16 a2)
{
  signed __int16 v3; // [esp+4Ch] [ebp-Ch]
  int v4; // [esp+50h] [ebp-8h]

  if ( a2 >= 33088 && a2 <= 33686 )
    return word_101B4D88[a2 + 666];
  v3 = sub_1000BB20(a2);
  if ( v3 == -1 )
    v4 = 95;
  else
    v4 = v3 + 294;
  return v4;
}
// 101B4D88: using guessed type __int16 word_101B4D88[1478];

//----- (1000BB20) --------------------------------------------------------
signed __int16 __cdecl sub_1000BB20(__int16 a1)
{
  __int16 i; // [esp+4Ch] [ebp-14h]
  signed __int16 v3; // [esp+54h] [ebp-Ch]
  __int16 v4; // [esp+58h] [ebp-8h]

  v4 = strlen(Str) >> 1;
  v3 = -1;
  for ( i = 0; i < v4; ++i )
  {
    if ( Str[2 * i] == (a1 & 0xFF00) >> 8 && Str[2 * i + 1] == a1 )
      return i;
  }
  return v3;
}

//----- (1000BC20) --------------------------------------------------------
int __thiscall Font::stringWidth(Font *this, char *a2)
{
  int v2; // edx
  int v4; // [esp+50h] [ebp-Ch]
  int v5; // [esp+54h] [ebp-8h]
  Font *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  v5 = 0;
  while ( *a2 )
  {
    if ( *a2 & 0x80 )
    {
      v2 = a2[1] | (*a2 << 8);
      v4 = Font::charToIndex(v6, _byteswap_ushort(*a2));
      a2 += 2;
    }
    else
    {
      v4 = Font::charToIndex(v6, *a2++);
    }
    v5 += *(*(v6 + 3) + 28 * v4 + 8);
  }
  return v5 + 1;
}

//----- (1000BD20) --------------------------------------------------------
void __thiscall GfxInfo::createCollData(GfxInfo *this, struct Vector3f *a2, float a3)
{
  double v3; // st7
  HGLOBAL v4; // [esp+4Ch] [ebp-58h]
  HGLOBAL hMem; // [esp+50h] [ebp-54h]
  char v6; // [esp+58h] [ebp-4Ch]
  char v7; // [esp+64h] [ebp-40h]
  char v8; // [esp+70h] [ebp-34h]
  char v9; // [esp+7Ch] [ebp-28h]
  int i; // [esp+88h] [ebp-1Ch]
  int v11; // [esp+8Ch] [ebp-18h]
  unsigned __int16 *v12; // [esp+90h] [ebp-14h]
  BoundBox *v13; // [esp+94h] [ebp-10h]
  int v14; // [esp+A0h] [ebp-4h]

  v13 = this;
  v12 = *(this + 7);
  v11 = *v12;
  hMem = sub_10001AC3(100 * v11);
  v14 = 0;
  if ( hMem )
  {
    sub_1000291E(hMem, 100, v11, CollTriInfo::CollTriInfo);
    v4 = hMem;
  }
  else
  {
    v4 = 0;
  }
  v14 = -1;
  *(v13 + 8) = v4;
  BoundBox::resetBound(v13);
  for ( i = 0; i < *v12; ++i )
  {
    *(*(v13 + 8) + 100 * i + 4) = *(*(v12 + 1) + 6 * i);
    *(*(v13 + 8) + 100 * i + 8) = *(*(v12 + 1) + 6 * i + 2);
    *(*(v13 + 8) + 100 * i + 12) = *(*(v12 + 1) + 6 * i + 4);
    Vector3f::Vector3f(&v9, (a2 + 12 * *(*(v13 + 8) + 100 * i + 4)));
    Vector3f::Vector3f(&v8, (a2 + 12 * *(*(v13 + 8) + 100 * i + 8)));
    Vector3f::Vector3f(&v7, (a2 + 12 * *(*(v13 + 8) + 100 * i + 12)));
    BoundBox::expandBound(v13, &v9);
    BoundBox::expandBound(v13, &v8);
    BoundBox::expandBound(v13, &v7);
    Vector3f::Vector3f(&v6, &v9);
    Vector3f::sub(&v6, &v7);
    Vector3f::sub((*(v13 + 8) + 100 * i + 24), &v8, &v9);
    Vector3f::CP((*(v13 + 8) + 100 * i + 24), &v6);
    Vector3f::normalise((*(v13 + 8) + 100 * i + 24));
    v3 = Vector3f::DP((*(v13 + 8) + 100 * i + 24), &v9);
    *(*(v13 + 8) + 100 * i + 36) = v3;
    CollTriInfo::init((100 * i + *(v13 + 8)), 0, a2);
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000C050) --------------------------------------------------------
Vector3f *__thiscall Quat::Quat(Quat *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  return v1;
}

//----- (1000C0A0) --------------------------------------------------------
Quat *__thiscall Quat::Quat(Quat *this, float a2, float a3, float a4, float a5)
{
  Quat *v5; // ST5C_4

  v5 = this;
  Vector3f::Vector3f(this);
  Quat::set(v5, a2, a3, a4, a5);
  return v5;
}

//----- (1000C110) --------------------------------------------------------
void __thiscall Quat::set(Quat *this, float a2, float a3, float a4, float a5)
{
  *this = a2;
  *(this + 1) = a3;
  *(this + 2) = a4;
  *(this + 3) = a5;
}

//----- (1000C170) --------------------------------------------------------
Vector3f *__thiscall Quat::Quat(Quat *this, const struct Quat *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::Vector3f(this, a2);
  *(v2 + 3) = *(a2 + 3);
  return v2;
}

//----- (1000C1D0) --------------------------------------------------------
_DWORD *__thiscall Quat::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (1000C230) --------------------------------------------------------
void __thiscall SRT::write(SRT *this, struct RandomAccessStream *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::write(this, a2);
  Vector3f::write((v2 + 12), a2);
  Vector3f::write((v2 + 24), a2);
}

//----- (1000C2A0) --------------------------------------------------------
void __thiscall SRT::read(SRT *this, struct RandomAccessStream *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::read(this, a2);
  Vector3f::read((v2 + 12), a2);
  Vector3f::read((v2 + 24), a2);
}

//----- (1000C310) --------------------------------------------------------
void __thiscall MaterialHandler::setMaterial(MaterialHandler *this, struct Material *a2)
{
  MaterialHandler *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(**(this + 1) + 188))(*(this + 1), a2, 0);
}

//----- (1000C380) --------------------------------------------------------
Vector3f *__thiscall SRT::SRT(SRT *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  Vector3f::Vector3f((v1 + 12));
  Vector3f::Vector3f((v1 + 24));
  return v1;
}

//----- (1000C3F0) --------------------------------------------------------
void __thiscall MaterialHandler::setTexMatrix(MaterialHandler *this, bool a2)
{
  MaterialHandler *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(**(this + 1) + 224))(*(this + 1), a2);
}

//----- (1000C460) --------------------------------------------------------
Vector3f *__thiscall SRT::SRT(SRT *this, const struct SRT *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::Vector3f(this, a2);
  Vector3f::Vector3f((v2 + 12), (a2 + 12));
  Vector3f::Vector3f((v2 + 24), (a2 + 24));
  return v2;
}

//----- (1000C4E0) --------------------------------------------------------
Graphics *__thiscall Graphics::Graphics(Graphics *this)
{
  char v2; // [esp+8h] [ebp-7Ch]
  HGLOBAL v3; // [esp+54h] [ebp-30h]
  int v4; // [esp+58h] [ebp-2Ch]
  HGLOBAL v5; // [esp+5Ch] [ebp-28h]
  MaterialHandler *hMem; // [esp+64h] [ebp-20h]
  int v7; // [esp+6Ch] [ebp-18h]
  signed int i; // [esp+70h] [ebp-14h]
  Graphics *v9; // [esp+74h] [ebp-10h]

  v9 = this;
  Light::Light((this + 20));
  Colour::Colour((v9 + 792));
  Colour::Colour((v9 + 796));
  Colour::Colour((v9 + 800));
  Vector3f::Vector3f((v9 + 832));
  Colour::Colour((v9 + 872));
  Colour::Colour((v9 + 876));
  Colour::Colour((v9 + 880));
  CachedShape::CachedShape((v9 + 916));
  *v9 = &Graphics::`vftable';
  sub_1000C8A0("dgxgraphics constructor\n", v2);
  *(v9 + 1) = 0;
  for ( i = 0; i < 4096; ++i )
  {
    flt_101CF090[i] = sin(i / 4096.0 * 6.2831855);
    *(&stru_101CB088.Parent + i) = cos(i / 4096.0 * 6.2831855);
  }
  *(v9 + 187) = 0;
  *(v9 + 188) = 0;
  *(v9 + 189) = 0;
  *(v9 + 190) = 0;
  *(v9 + 191) = 0;
  *(v9 + 192) = 0;
  *(v9 + 193) = 0;
  *(v9 + 194) = 0;
  *(v9 + 195) = 0;
  *(v9 + 214) = 0;
  *(v9 + 207) = 0;
  Matrix4f::makeIdentity(&Matrix4f::ident);
  *(v9 + 213) = 0;
  hMem = sub_10002A81(8u);
  if ( hMem )
    v4 = MaterialHandler::MaterialHandler(hMem);
  else
    v4 = 0;
  *(v9 + 212) = v4;
  *(v9 + 227) = *(gsys + 16);
  *(v9 + 226) = *(gsys + 17);
  *(v9 + 236) = 1000;
  v7 = *(v9 + 236);
  v5 = sub_10001AC3(24 * v7);
  if ( v5 )
  {
    sub_1000291E(v5, 24, v7, CachedShape::CachedShape);
    v3 = v5;
  }
  else
  {
    v3 = 0;
  }
  *(v9 + 235) = v3;
  Colour::set((v9 + 876), 0, 0, 48, 0xFFu);
  *(v9 + 222) = 1065353216;
  return v9;
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);
// 101AD464: using guessed type void *Graphics::`vftable';

//----- (1000C8A0) --------------------------------------------------------
char *__cdecl sub_1000C8A0(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "Graphics" )
      Stream::print(sysCon, "%s: ", "Graphics");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1000C9B0) --------------------------------------------------------
void *__thiscall SRT::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (1000CA00) --------------------------------------------------------
void __thiscall Plane::copy(Plane *this, struct Plane *a2)
{
  *this = *a2;
  *(this + 1) = *(a2 + 1);
  *(this + 2) = *(a2 + 2);
  *(this + 3) = *(a2 + 3);
}

//----- (1000CA70) --------------------------------------------------------
void __thiscall Plane::copyInv(Plane *this, struct Plane *a2)
{
  *this = -*a2;
  *(this + 1) = -*(a2 + 1);
  *(this + 2) = -*(a2 + 2);
  *(this + 3) = -*(a2 + 3);
}

//----- (1000CAF0) --------------------------------------------------------
double __thiscall Plane::dist(Plane *this, struct Vector3f *a2)
{
  return Vector3f::DP(this, a2) - *(this + 3);
}

//----- (1000CB50) --------------------------------------------------------
BOOL __thiscall Plane::whichSide(Plane *this, struct Vector3f *a2)
{
  BOOL result; // eax
  float v3; // [esp+4Ch] [ebp-8h]

  v3 = Plane::dist(this, a2);
  if ( v3 <= 0.1 )
    result = v3 < -0.1;
  else
    result = 1;
  return result;
}

//----- (1000CBE0) --------------------------------------------------------
void __thiscall Plane::write(Plane *this, struct RandomAccessStream *a2)
{
  Vector3f *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  Vector3f::write(this, a2);
  (*(*a2 + 40))(a2, *(v2 + 3));
}

//----- (1000CC50) --------------------------------------------------------
void __userpurge Plane::read(Plane *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  Vector3f *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  Vector3f::read(this, a3);
  (*(*a3 + 12))(a3);
  *(v3 + 3) = a2;
}

//----- (1000CCC0) --------------------------------------------------------
Vector3f *__thiscall Plane::Plane(Plane *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  return v1;
}

//----- (1000CD10) --------------------------------------------------------
Vector3f *__thiscall Plane::Plane(Plane *this, const struct Plane *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::Vector3f(this, a2);
  *(v2 + 3) = *(a2 + 3);
  return v2;
}

//----- (1000CD70) --------------------------------------------------------
void __thiscall Graphics::initRender(Graphics *this, int a2, int a3)
{
  Graphics *v3; // ST50_4

  v3 = this;
  *(this + 223) = 0;
  CoreNode::initCore(this + 1, `string');
  Graphics::resetMatrixBuffer(v3);
  Graphics::resetCacheBuffer(v3);
}

//----- (1000CDF0) --------------------------------------------------------
_DWORD *__thiscall Plane::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (1000CE50) --------------------------------------------------------
Plane *__thiscall CullingPlane::CullingPlane(CullingPlane *this)
{
  Plane *v1; // ST50_4

  v1 = this;
  Plane::Plane(this);
  return v1;
}

//----- (1000CEA0) --------------------------------------------------------
void __thiscall Graphics::resetMatrixBuffer(Graphics *this)
{
  *(this + 228) = 0;
}

//----- (1000CEE0) --------------------------------------------------------
Plane *__thiscall CullingPlane::CullingPlane(CullingPlane *this, const struct CullingPlane *a2)
{
  Plane *v2; // ST50_4
  _DWORD *v3; // edx
  _DWORD *v4; // eax

  v2 = this;
  Plane::Plane(this, a2);
  v3 = (v2 + 16);
  *v3 = *(a2 + 4);
  v3[1] = *(a2 + 5);
  v3[2] = *(a2 + 6);
  v4 = (v2 + 28);
  *v4 = *(a2 + 7);
  v4[1] = *(a2 + 8);
  v4[2] = *(a2 + 9);
  *(v2 + 40) = *(a2 + 40);
  return v2;
}

//----- (1000CF90) --------------------------------------------------------
struct Matrix4f *__thiscall Graphics::getMatrices(Graphics *this, int a2)
{
  int v2; // ST50_4

  if ( a2 + *(this + 228) > *(this + 227) )
    sub_1000D040("using too many matrices!!\n");
  v2 = (*(this + 228) << 6) + *(this + 226);
  *(this + 228) += a2;
  return v2;
}

//----- (1000D040) --------------------------------------------------------
void __noreturn sub_1000D040(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscommon\\graphics.cpp", 17, &Dest);
}

//----- (1000D0E0) --------------------------------------------------------
void *__thiscall CullingPlane::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x2Cu);
  return this;
}

//----- (1000D130) --------------------------------------------------------
Vector3f *__thiscall BoundBox::BoundBox(BoundBox *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  Vector3f::Vector3f((v1 + 12));
  BoundBox::resetBound(v1);
  return v1;
}

//----- (1000D190) --------------------------------------------------------
void __thiscall Graphics::resetCacheBuffer(Graphics *this)
{
  *(this + 230) = this + 916;
  *(this + 229) = *(this + 230);
  *(this + 237) = 0;
}

//----- (1000D200) --------------------------------------------------------
Vector3f *__thiscall BoundBox::BoundBox(BoundBox *this, struct Vector3f *a2, struct Vector3f *a3)
{
  Vector3f *v3; // ST50_4
  _DWORD *v4; // edx

  v3 = this;
  Vector3f::Vector3f(this);
  Vector3f::Vector3f((v3 + 12));
  *v3 = *a2;
  *(v3 + 1) = *(a2 + 1);
  *(v3 + 2) = *(a2 + 2);
  v4 = (v3 + 12);
  *v4 = *a3;
  v4[1] = *(a3 + 1);
  v4[2] = *(a3 + 2);
  return v3;
}

//----- (1000D2A0) --------------------------------------------------------
void __thiscall Graphics::cacheShape(Graphics *this, struct BaseShape *a2, struct ShapeDynMaterials *a3)
{
  const float *v3; // ST08_4
  const float *v4; // ST04_4
  struct Matrix4f *v5; // eax
  double v6; // st7
  float *i; // [esp+4Ch] [ebp-1Ch]
  char v8; // [esp+50h] [ebp-18h]
  char v9; // [esp+54h] [ebp-14h]
  struct CachedShape *v10; // [esp+60h] [ebp-8h]
  Graphics *v11; // [esp+64h] [ebp-4h]

  v11 = this;
  if ( *(this + 237) >= *(this + 236) )
    sub_1000D040("using too many shapes!!\n");
  v10 = (24 * *(v11 + 237) + *(v11 + 235));
  v3 = (BaseShape::getAnimMatrix(a2, 0) + 44);
  v4 = (BaseShape::getAnimMatrix(a2, 0) + 28);
  v5 = BaseShape::getAnimMatrix(a2, 0);
  Vector3f::Vector3f(&v9, v5 + 3, v4, v3);
  v6 = Vector3f::length(&v9);
  *(v10 + 5) = v6;
  v8 = 0;
  for ( i = *(v11 + 229); i != (v11 + 916); i = *i )
  {
    if ( *(v10 + 5) >= i[5] )
    {
      CachedShape::insertAfter(i, v10);
      v8 = 1;
      break;
    }
  }
  if ( !v8 )
    CachedShape::insertAfter((v11 + 916), v10);
  *(v10 + 2) = a3;
  *(v10 + 3) = a2;
  *(v10 + 4) = *(a2 + 10);
  ++*(v11 + 237);
}

//----- (1000D440) --------------------------------------------------------
void __thiscall BoundBox::resetBound(BoundBox *this)
{
  float v1; // [esp+4Ch] [ebp-1Ch]
  float v2; // [esp+50h] [ebp-18h]
  float v3; // [esp+54h] [ebp-14h]
  float v4; // [esp+58h] [ebp-10h]
  float v5; // [esp+5Ch] [ebp-Ch]
  float v6; // [esp+60h] [ebp-8h]
  Vector3f *v7; // [esp+64h] [ebp-4h]

  v7 = this;
  v6 = 32768.0;
  v5 = 32768.0;
  v4 = 32768.0;
  Vector3f::set(this, &v4, &v5, &v6);
  v3 = -32768.0;
  v2 = -32768.0;
  v1 = -32768.0;
  Vector3f::set((v7 + 12), &v1, &v2, &v3);
}

//----- (1000D4F0) --------------------------------------------------------
void __thiscall BoundBox::expandBound(BoundBox *this, struct Vector3f *a2)
{
  if ( *a2 < *this )
    *this = *a2;
  if ( *(a2 + 1) < *(this + 1) )
    *(this + 1) = *(a2 + 1);
  if ( *(a2 + 2) < *(this + 2) )
    *(this + 2) = *(a2 + 2);
  if ( *a2 > *(this + 3) )
    *(this + 3) = *a2;
  if ( *(a2 + 1) > *(this + 4) )
    *(this + 4) = *(a2 + 1);
  if ( *(a2 + 2) > *(this + 5) )
    *(this + 5) = *(a2 + 2);
}

//----- (1000D600) --------------------------------------------------------
void __thiscall Graphics::flushCachedShapes(Graphics *this)
{
  ShapeDynMaterials *j; // [esp+4Ch] [ebp-10h]
  int i; // [esp+50h] [ebp-Ch]
  int v3; // [esp+54h] [ebp-8h]
  Graphics *v4; // [esp+58h] [ebp-4h]

  v4 = this;
  v3 = *(this + 2);
  *(this + 2) = 1024;
  for ( i = *(v4 + 229); i != (v4 + 916); i = *i )
  {
    if ( *(i + 8) )
    {
      for ( j = *(i + 8); j; j = *j )
        ShapeDynMaterials::updateContext(j);
    }
    *(*(i + 12) + 40) = *(i + 16);
    (*(*v4 + 124))(v4, *(v4 + 186), *(i + 12));
  }
  *(v4 + 2) = v3;
}

//----- (1000D710) --------------------------------------------------------
void __thiscall BoundBox::expandBound(BoundBox *this, struct BoundBox *a2)
{
  if ( *a2 < *this )
    *this = *a2;
  if ( *(a2 + 1) < *(this + 1) )
    *(this + 1) = *(a2 + 1);
  if ( *(a2 + 2) < *(this + 2) )
    *(this + 2) = *(a2 + 2);
  if ( *(a2 + 3) > *(this + 3) )
    *(this + 3) = *(a2 + 3);
  if ( *(a2 + 4) > *(this + 4) )
    *(this + 4) = *(a2 + 4);
  if ( *(a2 + 5) > *(this + 5) )
    *(this + 5) = *(a2 + 5);
}

//----- (1000D830) --------------------------------------------------------
int __stdcall TexImg::convFormat(unsigned __int32 a2)
{
  return dword_101C5E88[a2];
}

//----- (1000D870) --------------------------------------------------------
char *__stdcall TexImg::formatName(unsigned __int32 a2)
{
  return off_101C5EC4[a2];
}
// 101C5EC4: using guessed type char *off_101C5EC4[26];

//----- (1000D8B0) --------------------------------------------------------
int __cdecl TexImg::calcDataSize(int a1, int a2, int a3)
{
  int v4; // [esp+50h] [ebp-4h]

  v4 = 0;
  switch ( a1 )
  {
    case 0:
      v4 = 2 * a3 * a2;
      break;
    case 1:
      v4 = 4 * (a3 * a2 / 8);
      break;
    case 2:
      v4 = 2 * a3 * a2;
      break;
    case 3:
      v4 = a3 * a2 / 2;
      break;
    case 4:
      v4 = a3 * a2;
      break;
    case 5:
      v4 = a3 * a2;
      break;
    case 6:
      v4 = 2 * a3 * a2;
      break;
    case 7:
      v4 = 4 * a3 * a2;
      break;
    case 8:
      v4 = a3 * a2;
      break;
    case 9:
      v4 = a3 * a2;
      break;
    default:
      return v4;
  }
  return v4;
}

//----- (1000D9F0) --------------------------------------------------------
bool __thiscall BoundBox::intersects(BoundBox *this, struct BoundBox *a2)
{
  return *a2 <= *(this + 3)
      && *(a2 + 3) >= *this
      && *(a2 + 1) <= *(this + 4)
      && *(a2 + 4) >= *(this + 1)
      && *(a2 + 2) <= *(this + 5)
      && *(a2 + 5) >= *(this + 2);
}

//----- (1000DAC0) --------------------------------------------------------
void __thiscall BoundBox::write(BoundBox *this, struct RandomAccessStream *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::write(this, a2);
  Vector3f::write((v2 + 12), a2);
}

//----- (1000DB20) --------------------------------------------------------
void __thiscall BoundBox::read(BoundBox *this, struct RandomAccessStream *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::read(this, a2);
  Vector3f::read((v2 + 12), a2);
}

//----- (1000DB80) --------------------------------------------------------
void __thiscall TexImg::write(TexImg *this, struct RandomAccessStream *a2)
{
  int v2; // edx
  TexImg *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  LOWORD(this) = *(this + 14);
  (*(*a2 + 36))(a2, this);
  LOWORD(v2) = *(v3 + 16);
  (*(*a2 + 36))(a2, v2);
  (*(*a2 + 28))(a2, *(v3 + 6));
  (*(*a2 + 28))(a2, *(v3 + 9));
  (*(*a2 + 28))(a2, 0);
  (*(*a2 + 28))(a2, 0);
  (*(*a2 + 28))(a2, 0);
  (*(*a2 + 28))(a2, 0);
  (*(*a2 + 28))(a2, *(v3 + 10));
  (*(*a2 + 56))(a2, *(v3 + 11), *(v3 + 10));
}

//----- (1000DD00) --------------------------------------------------------
Vector3f *__thiscall BoundBox::BoundBox(BoundBox *this, const struct BoundBox *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::Vector3f(this, a2);
  Vector3f::Vector3f((v2 + 12), (a2 + 12));
  return v2;
}

//----- (1000DD70) --------------------------------------------------------
void *__thiscall BoundBox::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x18u);
  return this;
}

//----- (1000DDC0) --------------------------------------------------------
void __thiscall BaseRoomInfo::write(BaseRoomInfo *this, struct RandomAccessStream *a2)
{
  BaseRoomInfo *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
}

//----- (1000DE20) --------------------------------------------------------
void __thiscall BaseRoomInfo::read(BaseRoomInfo *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  BaseRoomInfo *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v2 = (**a2)(a2);
  *v3 = v2;
}

//----- (1000DE80) --------------------------------------------------------
void __thiscall TexImg::setColour(TexImg *this, struct Colour *a2)
{
  __int16 v2; // ST50_2
  int i; // [esp+50h] [ebp-Ch]
  int v4; // [esp+54h] [ebp-8h]

  *(this + 6) = 0;
  v4 = *(this + 11);
  for ( i = 0; i < *(this + 8) * *(this + 7); ++i )
  {
    v2 = (*(a2 + 2) >> 3) | 32 * (*(a2 + 1) >> 2) | ((*a2 >> 3) << 11);
    *(v4 + 2 * i) = ((v2 & 0xFF00) >> 8) | (v2 << 8);
  }
}

//----- (1000DF70) --------------------------------------------------------
_DWORD *__thiscall BaseRoomInfo::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  return this;
}

//----- (1000DFB0) --------------------------------------------------------
_DWORD *__thiscall RoomInfo::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  return this;
}

//----- (1000DFF0) --------------------------------------------------------
CollGroup *__thiscall CollGroup::CollGroup(CollGroup *this)
{
  *(this + 2) = 0;
  *(this + 2) = 0;
  *(this + 6) = 0;
  *(this + 3) = 0;
  return this;
}

//----- (1000E060) --------------------------------------------------------
void *__thiscall CollGroup::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (1000E0B0) --------------------------------------------------------
void __thiscall TexImg::read(TexImg *this, struct RandomAccessStream *a2)
{
  __int16 v2; // ax
  __int16 v3; // ax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // [esp+4Ch] [ebp-Ch]
  int v8; // [esp+50h] [ebp-8h]
  TexImg *v9; // [esp+54h] [ebp-4h]

  v9 = this;
  v2 = (*(*a2 + 8))(a2);
  *(v9 + 7) = v2;
  v3 = (*(*a2 + 8))(a2);
  *(v9 + 8) = v3;
  v4 = (**a2)(a2);
  *(v9 + 6) = v4;
  v5 = (**a2)(a2);
  *(v9 + 9) = v5;
  v8 = (**a2)(a2);
  v8 = (**a2)(a2);
  v8 = (**a2)(a2);
  v8 = (**a2)(a2);
  v6 = (**a2)(a2);
  *(v9 + 10) = v6;
  v7 = sub_100011A4(*(v9 + 10), 32);
  *(v9 + 11) = v7;
  (*(*a2 + 52))(a2, *(v9 + 11), *(v9 + 10));
}
// 100011A4: using guessed type _DWORD __cdecl sub_100011A4(_DWORD, _DWORD);

//----- (1000E250) --------------------------------------------------------
void __thiscall BaseCollTriInfo::write(BaseCollTriInfo *this, struct RandomAccessStream *a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  BaseCollTriInfo *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  (*(*a2 + 28))(a2, *this);
  (*(*a2 + 28))(a2, *(v6 + 1));
  (*(*a2 + 28))(a2, *(v6 + 2));
  (*(*a2 + 28))(a2, *(v6 + 3));
  LOWORD(v2) = *(v6 + 8);
  (*(*a2 + 36))(a2, v2);
  LOWORD(v3) = *(v6 + 9);
  (*(*a2 + 36))(a2, v3);
  LOWORD(v4) = *(v6 + 10);
  (*(*a2 + 36))(a2, v4);
  LOWORD(v5) = *(v6 + 11);
  (*(*a2 + 36))(a2, v5);
  Plane::write((v6 + 24), a2);
}

//----- (1000E3B0) --------------------------------------------------------
void __cdecl TexImg::getTileSize(int a1, unsigned __int32 *a2, unsigned __int32 *a3)
{
  switch ( a1 )
  {
    case 3:
      *a2 = 8;
      *a3 = 8;
      break;
    case 4:
    case 5:
    case 9:
      *a2 = 8;
      *a3 = 4;
      break;
    default:
      *a2 = 4;
      *a3 = 4;
      break;
  }
}

//----- (1000E470) --------------------------------------------------------
void __thiscall BaseCollTriInfo::read(BaseCollTriInfo *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  __int16 v6; // ax
  __int16 v7; // ax
  __int16 v8; // ax
  __int16 v9; // ax
  BaseCollTriInfo *v10; // [esp+4Ch] [ebp-4h]

  v10 = this;
  v2 = (**a2)(a2);
  *v10 = v2;
  v3 = (**a2)(a2);
  *(v10 + 1) = v3;
  v4 = (**a2)(a2);
  *(v10 + 2) = v4;
  v5 = (**a2)(a2);
  *(v10 + 3) = v5;
  v6 = (*(*a2 + 8))(a2);
  *(v10 + 8) = v6;
  v7 = (*(*a2 + 8))(a2);
  *(v10 + 9) = v7;
  v8 = (*(*a2 + 8))(a2);
  *(v10 + 10) = v8;
  v9 = (*(*a2 + 8))(a2);
  *(v10 + 11) = v9;
  Plane::read((v10 + 24), a2);
}

//----- (1000E5D0) --------------------------------------------------------
void __thiscall TexImg::readTexData(TexImg *this, struct Texture *a2, struct RandomAccessStream *a3, unsigned __int8 *a4)
{
  int v4; // [esp+4Ch] [ebp-8h]
  struct TexImg *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  *(this + 10) = TexImg::calcDataSize(*(this + 6), *(this + 7), *(this + 8));
  if ( a4 )
  {
    *(v5 + 11) = a4;
  }
  else
  {
    v4 = sub_100011A4(*(v5 + 10), 32);
    *(v5 + 11) = v4;
  }
  (*(*a3 + 52))(a3, *(v5 + 11), *(v5 + 10));
  TexImg::getTileSize(*(v5 + 6), a2 + 3, a2 + 4);
  *(a2 + 7) = 1.0 / *(v5 + 7);
  *(a2 + 8) = 1.0 / *(v5 + 8);
  Texture::decodeData(a2, v5);
}
// 100011A4: using guessed type _DWORD __cdecl sub_100011A4(_DWORD, _DWORD);

//----- (1000E700) --------------------------------------------------------
BaseCollTriInfo *__thiscall BaseCollTriInfo::BaseCollTriInfo(BaseCollTriInfo *this)
{
  BaseCollTriInfo *v1; // ST50_4

  v1 = this;
  Plane::Plane((this + 24));
  return v1;
}

//----- (1000E750) --------------------------------------------------------
BaseCollTriInfo *__thiscall BaseCollTriInfo::BaseCollTriInfo(BaseCollTriInfo *this, const struct BaseCollTriInfo *a2)
{
  BaseCollTriInfo *v2; // ST50_4
  _DWORD *v3; // ecx
  int v4; // edx

  v2 = this;
  *this = *a2;
  v3 = (this + 4);
  *v3 = *(a2 + 1);
  v3[1] = *(a2 + 2);
  v3[2] = *(a2 + 3);
  *(v2 + 8) = *(a2 + 8);
  v4 = v2 + 18;
  *v4 = *(a2 + 18);
  *(v4 + 4) = *(a2 + 11);
  Plane::Plane((v2 + 24), (a2 + 24));
  return v2;
}

//----- (1000E810) --------------------------------------------------------
void *__thiscall BaseCollTriInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x28u);
  return this;
}

//----- (1000E860) --------------------------------------------------------
BaseCollTriInfo *__thiscall CollTriInfo::CollTriInfo(CollTriInfo *this)
{
  BaseCollTriInfo *v1; // ST5C_4

  v1 = this;
  BaseCollTriInfo::BaseCollTriInfo(this);
  sub_1000291E(v1 + 40, 16, 3, Plane::Plane);
  return v1;
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000E8D0) --------------------------------------------------------
char __thiscall CollTriInfo::inTriClampTo(CollTriInfo *this, struct Vector3f *a2)
{
  float v2; // ST50_4
  signed int i; // [esp+50h] [ebp-Ch]
  char v5; // [esp+54h] [ebp-8h]
  CollTriInfo *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  *(a2 + 1) = -(*a2 * *(this + 6) + *(a2 + 2) * *(this + 8) - *(this + 9)) / *(this + 7);
  v5 = 1;
  for ( i = 0; v5 && i < 3; ++i )
  {
    v2 = Plane::dist((v6 + 16 * i + 40), a2);
    if ( v2 < 0.0 )
      v5 = 0;
  }
  return v5;
}

//----- (1000E9C0) --------------------------------------------------------
BaseCollTriInfo *__thiscall CollTriInfo::CollTriInfo(CollTriInfo *this, const struct CollTriInfo *a2)
{
  _DWORD *v2; // edx
  struct Plane *v4; // [esp+4Ch] [ebp-10h]
  Plane *v5; // [esp+50h] [ebp-Ch]
  signed int v6; // [esp+54h] [ebp-8h]
  BaseCollTriInfo *v7; // [esp+58h] [ebp-4h]

  v7 = this;
  BaseCollTriInfo::BaseCollTriInfo(this, a2);
  v6 = 3;
  v5 = (v7 + 40);
  v4 = (a2 + 40);
  do
  {
    Plane::Plane(v5, v4);
    v5 = (v5 + 16);
    v4 = (v4 + 16);
    --v6;
  }
  while ( v6 );
  v2 = (v7 + 88);
  *v2 = *(a2 + 22);
  v2[1] = *(a2 + 23);
  v2[2] = *(a2 + 24);
  return v7;
}

//----- (1000EA90) --------------------------------------------------------
void *__thiscall CollTriInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x64u);
  return this;
}

//----- (1000EAE0) --------------------------------------------------------
void __thiscall TexImg::dumpBti(TexImg *this, struct Texture *a2, char *a3, struct RandomAccessStream *a4, struct RandomAccessStream *a5)
{
  int v5; // eax
  __int16 v6; // dx
  int v7; // eax
  int v8; // [esp+4Ch] [ebp-5Ch]
  int l; // [esp+50h] [ebp-58h]
  int k; // [esp+54h] [ebp-54h]
  int v11; // [esp+58h] [ebp-50h]
  int v12; // [esp+5Ch] [ebp-4Ch]
  int v13; // [esp+60h] [ebp-48h]
  int v14; // [esp+64h] [ebp-44h]
  char v15; // [esp+68h] [ebp-40h]
  int v16; // [esp+6Ch] [ebp-3Ch]
  int v17; // [esp+70h] [ebp-38h]
  int v18; // [esp+74h] [ebp-34h]
  int j; // [esp+78h] [ebp-30h]
  int i; // [esp+7Ch] [ebp-2Ch]
  int v21; // [esp+80h] [ebp-28h]
  int v22; // [esp+84h] [ebp-24h]
  unsigned __int16 v23; // [esp+88h] [ebp-20h]
  unsigned __int8 v24; // [esp+8Dh] [ebp-1Bh]
  unsigned __int16 v25; // [esp+8Eh] [ebp-1Ah]
  int v26; // [esp+90h] [ebp-18h]
  TexImg *v27; // [esp+A4h] [ebp-4h]

  v27 = this;
  sub_10001415(a4);
  *(v27 + 7) = HIWORD(v22);
  *(v27 + 8) = v23;
  if ( v26 )
    *(v27 + 6) = (v24 != 0) + 3;
  else
    *(v27 + 6) = TexImg::convFormat(v27, v22);
  TexImg::readTexData(v27, a2, a4, 0);
  if ( v26 )
  {
    v5 = TexImg::calcDataSize(*(v27 + 6), *(v27 + 7), *(v27 + 8));
    Stream::print(a5, "// %s (%d colour) format %s : data = %d bytes\n", *(a5 + 1), v25, off_101C5F20[v24], v5);
    Stream::print(a5, "// texture size = %d x %d\n", *(v27 + 7), *(v27 + 8));
    (*(*a4 + 84))(a4, v26);
    v8 = sub_10001AC3(2 * v25);
    v21 = v8;
    (*(*a4 + 52))(a4, v8, 2 * v25);
    Stream::print(a5, "static u16 %s_palette[%d] ATTRIBUTE_ALIGN(32) = {\n", a3, v25);
    for ( i = 0; i < v25 >> 3; ++i )
    {
      Stream::print(a5, "\t");
      for ( j = 0; j < 8; ++j )
      {
        LOWORD(v14) = ((*(v21 + 2 * (j + 8 * i)) & 0xFF00) >> 8) | ((*(v21 + 2 * (j + 8 * i)) & 0xFF) << 8);
        LOBYTE(v18) = 8 * ((v14 >> 11) & 0x1F);
        LOBYTE(v17) = 4 * ((v14 >> 5) & 0x3F);
        LOBYTE(v16) = 8 * (v14 & 0x1F);
        v15 = -1;
        sub_1000C8A0("sending colour %d, %d, %d\n", 8 * ((v14 >> 11) & 0x1F));
        v6 = (v18 >> 3) << 10;
        HIBYTE(v6) = 4 * (v18 >> 3) | 0x80;
        LOWORD(v14) = (v16 >> 3) | 32 * (v17 >> 3) | v6;
        Stream::print(a5, "0x%04x,", v14);
      }
      Stream::print(a5, "\n");
    }
    Stream::print(a5, "\t};\n\n");
  }
  else
  {
    *(v27 + 6) = TexImg::convFormat(v27, v22);
    v7 = TexImg::calcDataSize(*(v27 + 6), *(v27 + 7), *(v27 + 8));
    Stream::print(a5, "// %s got normal image of format %s : data = %d bytes\n", *(a5 + 1), off_101C5EE4[v22], v7);
    Stream::print(a5, "// texture size = %d x %d\n", *(v27 + 7), *(v27 + 8));
  }
  v13 = TexImg::calcDataSize(*(v27 + 6), *(v27 + 7), *(v27 + 8));
  v12 = *(v27 + 11);
  Stream::print(a5, "static u8 %s_data[%d] ATTRIBUTE_ALIGN(32) = {\n", a3, v13);
  v11 = 0;
  for ( k = 0; k < v13 / 32; ++k )
  {
    Stream::print(a5, "\t");
    for ( l = 0; l < 32; ++l )
      Stream::print(a5, "0x%02x,", *(v12 + l + 32 * k));
    Stream::print(a5, "\n");
  }
  Stream::print(a5, "\t};\n\n");
}
// 10001415: using guessed type _DWORD __stdcall sub_10001415(_DWORD);
// 101C5EE4: using guessed type char *off_101C5EE4[18];
// 101C5F20: using guessed type char *off_101C5F20[3];

//----- (1000F070) --------------------------------------------------------
int __thiscall sub_1000F070(_BYTE *this, int a2)
{
  char v2; // al
  char v3; // al
  __int16 v4; // ax
  __int16 v5; // ax
  char v6; // al
  char v7; // al
  char v8; // al
  char v9; // al
  __int16 v10; // ax
  int v11; // eax
  char v12; // al
  char v13; // al
  char v14; // al
  char v15; // al
  char v16; // al
  char v17; // al
  char v18; // al
  char v19; // al
  char v20; // al
  char v21; // al
  __int16 v22; // ax
  int result; // eax
  _BYTE *v24; // [esp+4Ch] [ebp-4h]

  v24 = this;
  v2 = (*(*a2 + 4))(a2);
  *v24 = v2;
  v3 = (*(*a2 + 4))(a2);
  v24[1] = v3;
  v4 = (*(*a2 + 8))(a2);
  *(v24 + 1) = v4;
  v5 = (*(*a2 + 8))(a2);
  *(v24 + 2) = v5;
  v6 = (*(*a2 + 4))(a2);
  v24[6] = v6;
  v7 = (*(*a2 + 4))(a2);
  v24[7] = v7;
  v8 = (*(*a2 + 4))(a2);
  v24[8] = v8;
  v9 = (*(*a2 + 4))(a2);
  v24[9] = v9;
  v10 = (*(*a2 + 8))(a2);
  *(v24 + 5) = v10;
  v11 = (**a2)(a2);
  *(v24 + 3) = v11;
  v12 = (*(*a2 + 4))(a2);
  v24[16] = v12;
  v13 = (*(*a2 + 4))(a2);
  v24[17] = v13;
  v14 = (*(*a2 + 4))(a2);
  v24[18] = v14;
  v15 = (*(*a2 + 4))(a2);
  v24[19] = v15;
  v16 = (*(*a2 + 4))(a2);
  v24[20] = v16;
  v17 = (*(*a2 + 4))(a2);
  v24[21] = v17;
  v18 = (*(*a2 + 4))(a2);
  v24[22] = v18;
  v19 = (*(*a2 + 4))(a2);
  v24[23] = v19;
  v20 = (*(*a2 + 4))(a2);
  v24[24] = v20;
  v21 = (*(*a2 + 4))(a2);
  v24[25] = v21;
  v22 = (*(*a2 + 8))(a2);
  *(v24 + 13) = v22;
  result = (**a2)(a2);
  *(v24 + 7) = result;
  return result;
}

//----- (1000F380) --------------------------------------------------------
int __stdcall sub_1000F380(int a1, int a2, int a3, void (__thiscall *a4)(int))
{
  int result; // eax

  while ( 1 )
  {
    result = a3-- - 1;
    if ( a3 < 0 )
      break;
    a4(a1);
    a1 += a2;
  }
  return result;
}

//----- (1000F3F0) --------------------------------------------------------
Vector3f *__thiscall KnotPoint::KnotPoint(KnotPoint *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  *(v1 + 3) = 0;
  return v1;
}

//----- (1000F450) --------------------------------------------------------
Vector3f *__thiscall KnotPoint::KnotPoint(KnotPoint *this, const struct KnotPoint *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::Vector3f(this, a2);
  *(v2 + 3) = *(a2 + 3);
  return v2;
}

//----- (1000F4B0) --------------------------------------------------------
_DWORD *__thiscall KnotPoint::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (1000F510) --------------------------------------------------------
CurveSection *__thiscall CurveSection::CurveSection(CurveSection *this)
{
  *(this + 7) = 0;
  *(this + 6) = 0;
  *(this + 5) = 0;
  *(this + 1) = 7;
  return this;
}

//----- (1000F580) --------------------------------------------------------
void __thiscall CurveSection::genCurve(CurveSection *this, int a2)
{
  _DWORD *v2; // edx
  _DWORD *v3; // ecx
  float v4; // ST0C_4
  _DWORD *v5; // edx
  _DWORD *v6; // eax
  HGLOBAL v7; // [esp+50h] [ebp-50h]
  HGLOBAL v8; // [esp+54h] [ebp-4Ch]
  HGLOBAL v9; // [esp+58h] [ebp-48h]
  HGLOBAL v10; // [esp+6Ch] [ebp-34h]
  signed int k; // [esp+78h] [ebp-28h]
  float v12; // [esp+7Ch] [ebp-24h]
  int v13; // [esp+80h] [ebp-20h]
  int j; // [esp+84h] [ebp-1Ch]
  int i; // [esp+88h] [ebp-18h]
  int v16; // [esp+8Ch] [ebp-14h]
  CurveSection *v17; // [esp+90h] [ebp-10h]

  v17 = this;
  if ( *(this + 6) )
    sub_10001938(*(this + 6));
  v16 = *(v17 + 2);
  v10 = sub_10002A81(12 * v16);
  if ( v10 )
  {
    sub_1000291E(v10, 12, v16, Vector3f::Vector3f);
    v8 = v10;
  }
  else
  {
    v8 = 0;
  }
  *(v17 + 6) = v8;
  if ( *(v17 + 5) )
  {
    for ( i = 0; i < *(v17 + 4); ++i )
    {
      if ( *(*(v17 + 5) + 4 * i) )
        sub_10001938(*(*(v17 + 5) + 4 * i));
    }
    sub_10001938(*(v17 + 5));
  }
  *(v17 + 3) = a2;
  *(v17 + 4) = *(v17 + 3);
  *(v17 + 5) = sub_10002A81(4 * *(v17 + 3));
  for ( j = 0; j < *(v17 + 3); ++j )
  {
    v13 = *(v17 + 3);
    v9 = sub_10002A81(12 * v13);
    if ( v9 )
    {
      sub_1000291E(v9, 12, v13, Vector3f::Vector3f);
      v7 = v9;
    }
    else
    {
      v7 = 0;
    }
    *(*(v17 + 5) + 4 * j) = v7;
    v2 = (16 * j + *(v17 + 7));
    v3 = *(*(v17 + 5) + 4 * j);
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
  }
  v12 = 1.0 / *(v17 + 2);
  for ( k = 0; k < *(v17 + 2); ++k )
  {
    v4 = k * v12;
    CurveSection::evaluateAt(v17, 0, v4);
    v5 = (12 * (*(v17 + 3) - 1) + **(v17 + 5));
    v6 = (12 * (*(v17 + 2) - 1 - k) + *(v17 + 6));
    *v6 = *v5;
    v6[1] = v5[1];
    v6[2] = v5[2];
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000F8D0) --------------------------------------------------------
void __thiscall CurveSection::evaluateAt(CurveSection *this, int a2, float a3)
{
  float v3; // ST60_4
  float v4; // ST5C_4
  float v5; // ST58_4
  int i; // [esp+4Ch] [ebp-14h]

  if ( a2 != *(this + 3) - 1 )
  {
    for ( i = 0; i < *(this + 3) - a2 - 1; ++i )
    {
      v3 = a3 * *(*(*(this + 5) + 4 * i) + 12 * a2) + (1.0 - a3) * *(*(*(this + 5) + 4 * i + 4) + 12 * a2);
      v4 = a3 * *(*(*(this + 5) + 4 * i) + 12 * a2 + 4) + (1.0 - a3) * *(*(*(this + 5) + 4 * i + 4) + 12 * a2 + 4);
      v5 = a3 * *(*(*(this + 5) + 4 * i) + 12 * a2 + 8) + (1.0 - a3) * *(*(*(this + 5) + 4 * i + 4) + 12 * a2 + 8);
      *(*(*(this + 5) + 4 * i) + 12 * (a2 + 1)) = v3;
      *(*(*(this + 5) + 4 * i) + 12 * (a2 + 1) + 4) = v4;
      *(*(*(this + 5) + 4 * i) + 12 * (a2 + 1) + 8) = v5;
    }
    CurveSection::evaluateAt(this, a2 + 1, a3);
  }
}

//----- (1000FAC0) --------------------------------------------------------
void __thiscall TexImg::importBti(TexImg *this, struct Texture *a2, struct RandomAccessStream *a3, unsigned __int8 *a4)
{
  int v4; // eax
  unsigned __int32 v5; // [esp+4Ch] [ebp-2Ch]
  unsigned __int32 v6; // [esp+50h] [ebp-28h]
  int v7; // [esp+54h] [ebp-24h]
  int v8; // [esp+58h] [ebp-20h]
  char v9[4]; // [esp+70h] [ebp-8h]
  TexImg *v10; // [esp+74h] [ebp-4h]

  v10 = this;
  sub_10001415(a3);
  *(v10 + 6) = TexImg::convFormat(v10, v7);
  *(v10 + 7) = HIWORD(v7);
  *(v10 + 8) = v8;
  TexImg::getTileSize(*(v10 + 6), &v6, &v5);
  if ( *(v10 + 7) % v6 || *(v10 + 8) % v5 )
    sub_1000D040("Texture %s is not correct size %d x %d\n", *(a3 + 1), *(v10 + 7), *(v10 + 8));
  if ( *v9 != 32 )
    sub_1000D040("Bti file has imageData at offset %d!!!\n", *v9);
  v4 = -(HIBYTE(v8) != 0);
  LOBYTE(v4) = 0;
  *(a2 + 3) = (v4 + 256) | (BYTE2(v8) == 0);
  TexImg::readTexData(v10, a2, a3, a4);
}
// 10001415: using guessed type _DWORD __stdcall sub_10001415(_DWORD);

//----- (1000FC30) --------------------------------------------------------
void *__thiscall CurveSection::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x20u);
  return this;
}

//----- (1000FC80) --------------------------------------------------------
void __thiscall TexImg::importTxe(TexImg *this, struct Texture *a2, struct RandomAccessStream *a3)
{
  __int16 v3; // ax
  __int16 v4; // ax
  unsigned __int16 v5; // ax
  __int16 v6; // [esp+4Ch] [ebp-14h]
  int i; // [esp+50h] [ebp-10h]
  int v8; // [esp+54h] [ebp-Ch]
  __int16 v9; // [esp+58h] [ebp-8h]
  TexImg *v10; // [esp+5Ch] [ebp-4h]

  v10 = this;
  v3 = (*(*a3 + 8))(a3);
  *(v10 + 7) = v3;
  v4 = (*(*a3 + 8))(a3);
  *(v10 + 8) = v4;
  v5 = (*(*a3 + 8))(a3);
  *(v10 + 6) = v5;
  *(a2 + 3) = *(v10 + 6) >> 8;
  *(v10 + 6) &= 0xFFu;
  v9 = (*(*a3 + 8))(a3);
  v8 = (**a3)(a3);
  for ( i = 0; i < 10; ++i )
    v6 = (*(*a3 + 8))(a3);
  TexImg::readTexData(v10, a2, a3, 0);
}

//----- (1000FDF0) --------------------------------------------------------
struct Vector3f *__thiscall KTri::Origin(KTri *this)
{
  return this;
}

//----- (1000FE20) --------------------------------------------------------
struct Vector3f *__thiscall KTri::Edge0(KTri *this)
{
  return (this + 12);
}

//----- (1000FE60) --------------------------------------------------------
struct Vector3f *__thiscall KTri::Edge1(KTri *this)
{
  return (this + 24);
}

//----- (1000FEA0) --------------------------------------------------------
Vector3f *__thiscall KTri::KTri(KTri *this, const struct KTri *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::Vector3f(this, a2);
  Vector3f::Vector3f((v2 + 12), (a2 + 12));
  Vector3f::Vector3f((v2 + 24), (a2 + 24));
  return v2;
}

//----- (1000FF20) --------------------------------------------------------
void *__thiscall KTri::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (1000FF70) --------------------------------------------------------
void __thiscall TexAttr::initImage(TexAttr *this)
{
  int v1; // [esp+4Ch] [ebp-120h]
  HGLOBAL hMem; // [esp+50h] [ebp-11Ch]
  int v3; // [esp+54h] [ebp-118h]
  char Dest; // [esp+58h] [ebp-114h]
  int i; // [esp+158h] [ebp-14h]
  TexAttr *v6; // [esp+15Ch] [ebp-10h]
  int v7; // [esp+168h] [ebp-4h]

  v6 = this;
  hMem = sub_10002A81(0x34u);
  v7 = 0;
  if ( hMem )
    v1 = Texture::Texture(hMem);
  else
    v1 = 0;
  v3 = v1;
  v7 = -1;
  *(v6 + 11) = v1;
  if ( !*(v6 + 11) )
    sub_1000D040("could not make texture!!\n");
  TexImg::getTileSize(*(*(v6 + 12) + 24), (*(v6 + 11) + 12), (*(v6 + 11) + 16));
  if ( *(v6 + 16) )
  {
    *(*(v6 + 11) + 36) = *(*(v6 + 12) + 36) - 1;
    *(*(v6 + 11) + 40) = *(v6 + 9);
  }
  else
  {
    *(*(v6 + 11) + 36) = 0;
    *(*(v6 + 11) + 40) = 0;
  }
  *(*(v6 + 11) + 28) = 1.0 / *(*(v6 + 12) + 28);
  *(*(v6 + 11) + 32) = 1.0 / *(*(v6 + 12) + 32);
  *(*(v6 + 11) + 6) = *(v6 + 14);
  for ( i = strlen(*(*(gsys + 127) + 4)) - 1; i >= 0 && *(*(*(gsys + 127) + 4) + i) != 47; --i )
    ;
  sprintf(&Dest, "%s:%d", *(*(gsys + 127) + 4) + i + 1, *(v6 + 6));
  StdSystem::addTexture(gsys, *(v6 + 11), &Dest);
  Texture::decodeData(*(v6 + 11), *(v6 + 12));
}

//----- (10010230) --------------------------------------------------------
KTri *__thiscall KRect::KRect(KRect *this)
{
  KTri *v1; // ST50_4

  v1 = this;
  KTri::KTri(this);
  return v1;
}

//----- (10010280) --------------------------------------------------------
KTri *__thiscall KRect::KRect(KRect *this, const struct KRect *a2)
{
  KTri *v2; // ST50_4

  v2 = this;
  KTri::KTri(this, a2);
  return v2;
}

//----- (100102D0) --------------------------------------------------------
void *__thiscall KRect::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (10010320) --------------------------------------------------------
struct Vector3f *__thiscall KSegment::Origin(KSegment *this)
{
  return this;
}

//----- (10010350) --------------------------------------------------------
struct Vector3f *__thiscall KSegment::Direction(KSegment *this)
{
  return (this + 12);
}

//----- (10010390) --------------------------------------------------------
Vector3f *__thiscall KSegment::KSegment(KSegment *this, const struct KSegment *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::Vector3f(this, a2);
  Vector3f::Vector3f((v2 + 12), (a2 + 12));
  return v2;
}

//----- (10010400) --------------------------------------------------------
void *__thiscall KSegment::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x18u);
  return this;
}

//----- (10010450) --------------------------------------------------------
void __thiscall Matrix3f::identity(Matrix3f *this)
{
  signed int i; // [esp+4Ch] [ebp-8h]

  for ( i = 0; i < 9; ++i )
    *(this + i) = 0;
  *(this + 8) = 1065353216;
  *(this + 4) = 1065353216;
  *this = 1065353216;
}

//----- (100104E0) --------------------------------------------------------
void __userpurge TexAttr::read(TexAttr *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  __int16 v3; // ax
  __int16 v4; // ax
  __int16 v5; // ax
  TexAttr *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  v3 = (*(*a3 + 8))(a3);
  *(v6 + 6) = v3;
  (*(*a3 + 8))(a3);
  v4 = (*(*a3 + 8))(a3);
  *(v6 + 14) = v4;
  v5 = (*(*a3 + 8))(a3);
  *(v6 + 16) = v5;
  (*(*a3 + 12))(a3);
  *(v6 + 9) = a2;
}

//----- (100105C0) --------------------------------------------------------
Matrix3f *__thiscall Matrix3f::Matrix3f(Matrix3f *this)
{
  Matrix3f *v1; // ST50_4

  v1 = this;
  Matrix3f::identity(this);
  return v1;
}

//----- (10010610) --------------------------------------------------------
Matrix3f *__thiscall Matrix3f::Matrix3f(Matrix3f *this, float (*a2)[3])
{
  signed int j; // [esp+4Ch] [ebp-10h]
  signed int i; // [esp+50h] [ebp-Ch]
  Matrix3f *v5; // [esp+58h] [ebp-4h]

  v5 = this;
  for ( i = 0; i < 3; ++i )
  {
    for ( j = 0; j < 3; ++j )
      *Matrix3f::operator()(i, j) = (*a2)[3 * i + j];
  }
  return v5;
}
// 10001F91: using guessed type _DWORD __stdcall Matrix3f::operator()(_DWORD, _DWORD);

//----- (100106D0) --------------------------------------------------------
void __thiscall TexAttr::write(TexAttr *this, struct RandomAccessStream *a2)
{
  int v2; // ecx
  int v3; // edx
  TexAttr *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  LOWORD(this) = *(this + 12);
  (*(*a2 + 36))(a2, this);
  (*(*a2 + 36))(a2, 0);
  LOWORD(v2) = *(v4 + 14);
  (*(*a2 + 36))(a2, v2);
  LOWORD(v3) = *(v4 + 16);
  (*(*a2 + 36))(a2, v3);
  (*(*a2 + 40))(a2, *(v4 + 9));
}

//----- (100107C0) --------------------------------------------------------
_DWORD *__thiscall Matrix3f::Matrix3f(_DWORD *this, int a2)
{
  signed int i; // [esp+4Ch] [ebp-Ch]

  for ( i = 0; i < 3; ++i )
  {
    this[3 * i] = 0;
    this[3 * i + 1] = 0;
    this[3 * i + 2] = 0;
  }
  return this;
}

//----- (10010860) --------------------------------------------------------
void __thiscall Graphics::drawCylinder(Graphics *this, struct Vector3f *a2, struct Vector3f *a3, float a4, struct Matrix4f *a5)
{
  const struct Vector3f *v5; // eax
  int *v6; // eax
  struct Vector3f *v7; // ST0C_4
  struct Vector3f *v8; // eax
  double v9; // st7
  double v10; // st7
  double v11; // st7
  double v12; // st7
  int v13; // ST10_4
  int v14; // eax
  int *v15; // eax
  int v16; // [esp+4Ch] [ebp-13Ch]
  char v17; // [esp+50h] [ebp-138h]
  float v18; // [esp+5Ch] [ebp-12Ch]
  float v19; // [esp+60h] [ebp-128h]
  float v20; // [esp+64h] [ebp-124h]
  char v21; // [esp+68h] [ebp-120h]
  float v22; // [esp+74h] [ebp-114h]
  float v23; // [esp+78h] [ebp-110h]
  float v24; // [esp+7Ch] [ebp-10Ch]
  char v25; // [esp+80h] [ebp-108h]
  float v26; // [esp+8Ch] [ebp-FCh]
  float v27; // [esp+90h] [ebp-F8h]
  float v28; // [esp+94h] [ebp-F4h]
  char v29; // [esp+98h] [ebp-F0h]
  float v30; // [esp+A4h] [ebp-E4h]
  float v31; // [esp+A8h] [ebp-E0h]
  float v32; // [esp+ACh] [ebp-DCh]
  char v33; // [esp+B0h] [ebp-D8h]
  char v34; // [esp+BCh] [ebp-CCh]
  int v35; // [esp+C8h] [ebp-C0h]
  char v36; // [esp+CCh] [ebp-BCh]
  float v37; // [esp+D8h] [ebp-B0h]
  float v38; // [esp+DCh] [ebp-ACh]
  int j; // [esp+E0h] [ebp-A8h]
  char v40; // [esp+E4h] [ebp-A4h]
  char v41; // [esp+124h] [ebp-64h]
  int i; // [esp+164h] [ebp-24h]
  float v43; // [esp+168h] [ebp-20h]
  int v44; // [esp+16Ch] [ebp-1Ch]
  int v45; // [esp+170h] [ebp-18h]
  int v46; // [esp+174h] [ebp-14h]
  int v47; // [esp+178h] [ebp-10h]
  int v48; // [esp+17Ch] [ebp-Ch]
  int v49; // [esp+180h] [ebp-8h]
  Graphics *v50; // [esp+184h] [ebp-4h]

  v50 = this;
  (*(*this + 196))(this, 0, 0);
  Vector3f::Vector3f(&v47, a2);
  v5 = sub_10002E2D(&v36, a3, a2);
  Vector3f::Vector3f(&v44, v5);
  v43 = Vector3f::normalise(&v44);
  *&v35 = v43 / 16.0;
  v6 = sub_10001CD5(&v34, &v44, &v35);
  v44 = *v6;
  v45 = v6[1];
  v46 = v6[2];
  for ( i = 0; i < 16; ++i )
  {
    Matrix4f::Matrix4f(&v41);
    Matrix4f::Matrix4f(&v40);
    v32 = 0.0;
    v31 = i * 0.39269909;
    v30 = 0.0;
    v28 = 1.0;
    v27 = 1.0;
    v26 = 1.0;
    v7 = Vector3f::Vector3f(&v33, &v30, &v31, &v32);
    v8 = Vector3f::Vector3f(&v29, &v26, &v27, &v28);
    Matrix4f::makeSRT(&v41, v8, v7, &v47);
    Matrix4f::multiplyTo(a5, &v41, &v40);
    (*(*v50 + 108))(v50, &v40, 0);
    for ( j = 0; j < 16; ++j )
    {
      v38 = j * 0.39269909;
      v16 = (j + 1) % 32;
      v9 = v16 * 0.39269909;
      v37 = v9;
      sub_10002D47(v37);
      v10 = v9 * a4;
      v24 = v10;
      v23 = 0.0;
      sub_10002635(v37);
      v11 = v10 * a4;
      v22 = v11;
      sub_10002D47(v38);
      v12 = v11 * a4;
      v20 = v12;
      v19 = 0.0;
      sub_10002635(v38);
      v18 = v12 * a4;
      v13 = Vector3f::Vector3f(&v25, &v22, &v23, &v24);
      v14 = Vector3f::Vector3f(&v21, &v18, &v19, &v20);
      (*(*v50 + 144))(v50, v14, v13);
    }
    v15 = sub_10001A3C(&v17, &v47, &v44);
    v47 = *v15;
    v48 = v15[1];
    v49 = v15[2];
  }
}

//----- (10010C40) --------------------------------------------------------
Vector3f *__cdecl sub_10010C40(Vector3f *a1, int a2, int a3)
{
  const struct Vector3f *v3; // eax
  float v5; // [esp+4Ch] [ebp-18h]
  float v6; // [esp+50h] [ebp-14h]
  float v7; // [esp+54h] [ebp-10h]
  char v8; // [esp+58h] [ebp-Ch]

  v7 = *(a2 + 8) + *(a3 + 8);
  v6 = *(a2 + 4) + *(a3 + 4);
  v5 = *a2 + *a3;
  v3 = Vector3f::Vector3f(&v8, &v5, &v6, &v7);
  Vector3f::Vector3f(a1, v3);
  return a1;
}

//----- (10010CE0) --------------------------------------------------------
Vector3f *__cdecl sub_10010CE0(Vector3f *a1, int a2, int a3)
{
  const struct Vector3f *v3; // eax
  float v5; // [esp+4Ch] [ebp-18h]
  float v6; // [esp+50h] [ebp-14h]
  float v7; // [esp+54h] [ebp-10h]
  char v8; // [esp+58h] [ebp-Ch]

  v7 = *(a2 + 8) - *(a3 + 8);
  v6 = *(a2 + 4) - *(a3 + 4);
  v5 = *a2 - *a3;
  v3 = Vector3f::Vector3f(&v8, &v5, &v6, &v7);
  Vector3f::Vector3f(a1, v3);
  return a1;
}

//----- (10010D80) --------------------------------------------------------
Vector3f *__cdecl sub_10010D80(Vector3f *a1, int a2, int a3)
{
  const struct Vector3f *v3; // eax
  float v5; // [esp+4Ch] [ebp-18h]
  float v6; // [esp+50h] [ebp-14h]
  float v7; // [esp+54h] [ebp-10h]
  char v8; // [esp+58h] [ebp-Ch]

  v7 = *(a2 + 8) * *a3;
  v6 = *(a2 + 4) * *a3;
  v5 = *a2 * *a3;
  v3 = Vector3f::Vector3f(&v8, &v5, &v6, &v7);
  Vector3f::Vector3f(a1, v3);
  return a1;
}

//----- (10010E10) --------------------------------------------------------
void *__thiscall Matrix3f::Matrix3f(void *this, int a2, int a3)
{
  void *v3; // ST68_4
  float v4; // ST5C_4
  float v5; // ST58_4
  float v6; // ST54_4

  v3 = this;
  *Matrix3f::operator()(0, 0) = 0;
  v4 = -*(a2 + 8);
  *Matrix3f::operator()(0, 1) = v4;
  *Matrix3f::operator()(0, 2) = *(a2 + 4);
  *Matrix3f::operator()(1, 0) = *(a2 + 8);
  *Matrix3f::operator()(1, 1) = 0;
  v5 = -*a2;
  *Matrix3f::operator()(1, 2) = v5;
  v6 = -*(a2 + 4);
  *Matrix3f::operator()(2, 0) = v6;
  *Matrix3f::operator()(2, 1) = *a2;
  *Matrix3f::operator()(2, 2) = 0;
  return v3;
}
// 10001F91: using guessed type _DWORD __stdcall Matrix3f::operator()(_DWORD, _DWORD);

//----- (10010F60) --------------------------------------------------------
float *__thiscall Matrix3f::operator+=(float *this, int a2)
{
  signed int i; // [esp+4Ch] [ebp-8h]
  float *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  for ( i = 0; i < 3; ++i )
  {
    v4[i] = v4[i] + *Matrix3f::operator()(0, i);
    v4[i + 3] = v4[i + 3] + *Matrix3f::operator()(1, i);
    v4[i + 6] = v4[i + 6] + *Matrix3f::operator()(2, i);
  }
  return v4;
}
// 100022B1: using guessed type _DWORD __stdcall Matrix3f::operator()(_DWORD, _DWORD);

//----- (10011050) --------------------------------------------------------
int __thiscall Matrix3f::operator()(char *this, int a2, int a3)
{
  return &this[12 * a2 + 4 * a3];
}

//----- (100110A0) --------------------------------------------------------
int __thiscall Matrix3f::operator()(char *this, int a2, int a3)
{
  return &this[12 * a2 + 4 * a3];
}

//----- (100110F0) --------------------------------------------------------
double __thiscall Matrix3f::GetElement(Matrix3f *this, int a2, int a3)
{
  return *(this + 3 * a2 + a3);
}

//----- (10011140) --------------------------------------------------------
void __thiscall Graphics::drawCircle(Graphics *this, struct Vector3f *a2, float a3, struct Matrix4f *a4)
{
  struct Vector3f *v4; // ST0C_4
  struct Vector3f *v5; // eax
  double v6; // st7
  double v7; // st7
  double v8; // st7
  double v9; // st7
  int v10; // ST10_4
  int v11; // eax
  int v12; // [esp+4Ch] [ebp-F8h]
  float v13; // [esp+50h] [ebp-F4h]
  float v14; // [esp+54h] [ebp-F0h]
  float v15; // [esp+58h] [ebp-ECh]
  char v16; // [esp+5Ch] [ebp-E8h]
  float v17; // [esp+68h] [ebp-DCh]
  float v18; // [esp+6Ch] [ebp-D8h]
  float v19; // [esp+70h] [ebp-D4h]
  char v20; // [esp+74h] [ebp-D0h]
  float v21; // [esp+80h] [ebp-C4h]
  float v22; // [esp+84h] [ebp-C0h]
  float v23; // [esp+88h] [ebp-BCh]
  char v24; // [esp+8Ch] [ebp-B8h]
  float v25; // [esp+98h] [ebp-ACh]
  float v26; // [esp+9Ch] [ebp-A8h]
  float v27; // [esp+A0h] [ebp-A4h]
  char v28; // [esp+A4h] [ebp-A0h]
  float v29; // [esp+B0h] [ebp-94h]
  float v30; // [esp+B4h] [ebp-90h]
  int j; // [esp+B8h] [ebp-8Ch]
  char v32; // [esp+BCh] [ebp-88h]
  char v33; // [esp+FCh] [ebp-48h]
  int i; // [esp+13Ch] [ebp-8h]
  Graphics *v35; // [esp+140h] [ebp-4h]

  v35 = this;
  (*(*this + 196))(this, 0, 0);
  for ( i = 0; i < 1; ++i )
  {
    Matrix4f::Matrix4f(&v33);
    Matrix4f::Matrix4f(&v32);
    v27 = 0.0;
    v26 = i * 0.39269909;
    v25 = 0.0;
    v23 = 1.0;
    v22 = 1.0;
    v21 = 1.0;
    v4 = Vector3f::Vector3f(&v28, &v25, &v26, &v27);
    v5 = Vector3f::Vector3f(&v24, &v21, &v22, &v23);
    Matrix4f::makeSRT(&v33, v5, v4, a2);
    Matrix4f::multiplyTo(a4, &v33, &v32);
    (*(*v35 + 108))(v35, &v32, 0);
    for ( j = 0; j < 16; ++j )
    {
      v30 = j * 0.39269909;
      v12 = (j + 1) % 32;
      v6 = v12 * 0.39269909;
      v29 = v6;
      sub_10002D47(v29);
      v7 = v6 * a3;
      v19 = v7;
      v18 = 0.0;
      sub_10002635(v29);
      v8 = v7 * a3;
      v17 = v8;
      sub_10002D47(v30);
      v9 = v8 * a3;
      v15 = v9;
      v14 = 0.0;
      sub_10002635(v30);
      v13 = v9 * a3;
      v10 = Vector3f::Vector3f(&v20, &v17, &v18, &v19);
      v11 = Vector3f::Vector3f(&v16, &v13, &v14, &v15);
      (*(*v35 + 144))(v35, v11, v10);
    }
  }
}

//----- (10011470) --------------------------------------------------------
struct Matrix3f *__thiscall Matrix3f::SetElement(Matrix3f *this, int a2, int a3, float a4)
{
  *(this + 3 * a2 + a3) = a4;
  return this;
}

//----- (100114C0) --------------------------------------------------------
void *__thiscall Matrix3f::Matrix3f(void *this, int a2)
{
  return this;
}

//----- (10011500) --------------------------------------------------------
void *__thiscall Matrix3f::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (10011550) --------------------------------------------------------
void __thiscall Graphics::drawSphere(Graphics *this, struct Vector3f *a2, float a3, struct Matrix4f *a4)
{
  struct Vector3f *v4; // ST0C_4
  struct Vector3f *v5; // eax
  double v6; // st7
  double v7; // st7
  double v8; // st7
  double v9; // st7
  int v10; // ST10_4
  int v11; // eax
  int v12; // [esp+4Ch] [ebp-F8h]
  float v13; // [esp+50h] [ebp-F4h]
  float v14; // [esp+54h] [ebp-F0h]
  float v15; // [esp+58h] [ebp-ECh]
  char v16; // [esp+5Ch] [ebp-E8h]
  float v17; // [esp+68h] [ebp-DCh]
  float v18; // [esp+6Ch] [ebp-D8h]
  float v19; // [esp+70h] [ebp-D4h]
  char v20; // [esp+74h] [ebp-D0h]
  float v21; // [esp+80h] [ebp-C4h]
  float v22; // [esp+84h] [ebp-C0h]
  float v23; // [esp+88h] [ebp-BCh]
  char v24; // [esp+8Ch] [ebp-B8h]
  float v25; // [esp+98h] [ebp-ACh]
  float v26; // [esp+9Ch] [ebp-A8h]
  float v27; // [esp+A0h] [ebp-A4h]
  char v28; // [esp+A4h] [ebp-A0h]
  float v29; // [esp+B0h] [ebp-94h]
  float v30; // [esp+B4h] [ebp-90h]
  int j; // [esp+B8h] [ebp-8Ch]
  char v32; // [esp+BCh] [ebp-88h]
  char v33; // [esp+FCh] [ebp-48h]
  int i; // [esp+13Ch] [ebp-8h]
  Graphics *v35; // [esp+140h] [ebp-4h]

  v35 = this;
  (*(*this + 196))(this, 0, 0);
  for ( i = 0; i < 16; ++i )
  {
    Matrix4f::Matrix4f(&v33);
    Matrix4f::Matrix4f(&v32);
    v27 = 0.0;
    v26 = i * 0.39269909;
    v25 = 0.0;
    v23 = 1.0;
    v22 = 1.0;
    v21 = 1.0;
    v4 = Vector3f::Vector3f(&v28, &v25, &v26, &v27);
    v5 = Vector3f::Vector3f(&v24, &v21, &v22, &v23);
    Matrix4f::makeSRT(&v33, v5, v4, a2);
    Matrix4f::multiplyTo(a4, &v33, &v32);
    (*(*v35 + 108))(v35, &v32, 0);
    for ( j = 0; j < 16; ++j )
    {
      v30 = j * 0.39269909;
      v12 = (j + 1) % 32;
      v6 = v12 * 0.39269909;
      v29 = v6;
      v19 = 0.0;
      sub_10002D47(v29);
      v7 = v6 * a3;
      v18 = v7;
      sub_10002635(v29);
      v8 = v7 * a3;
      v17 = v8;
      v15 = 0.0;
      sub_10002D47(v30);
      v9 = v8 * a3;
      v14 = v9;
      sub_10002635(v30);
      v13 = v9 * a3;
      v10 = Vector3f::Vector3f(&v20, &v17, &v18, &v19);
      v11 = Vector3f::Vector3f(&v16, &v13, &v14, &v15);
      (*(*v35 + 144))(v35, v11, v10);
    }
  }
}

//----- (10011880) --------------------------------------------------------
void Graphics::perspPrintf(Graphics *this, struct Font *a2, struct Vector3f *a3, int a4, int a5, char *Format, ...)
{
  signed int v6; // eax
  char v7; // [esp+4Ch] [ebp-120h]
  int i; // [esp+5Ch] [ebp-110h]
  int v9; // [esp+60h] [ebp-10Ch]
  int v10; // [esp+64h] [ebp-108h]
  va_list Args; // [esp+68h] [ebp-104h]
  char Dest[256]; // [esp+6Ch] [ebp-100h]
  va_list va; // [esp+18Ch] [ebp+20h]

  va_start(va, Format);
  vsprintf(Dest, Format, va);
  Args = 0;
  (*(*this + 196))(this, *a2, 0);
  v10 = a4;
  v9 = a5;
  for ( i = 0; ; ++i )
  {
    v6 = strlen(Dest);
    if ( i >= v6 )
      break;
    RectArea::RectArea(
      &v7,
      v10 - *(*(a2 + 3) + 28 * (Dest[i] - 32) + 10),
      *(*(a2 + 3) + 28 * (Dest[i] - 32) + 6) + v9,
      *(*(a2 + 3) + 28 * (Dest[i] - 32) + 4) + v10 - *(*(a2 + 3) + 28 * (Dest[i] - 32) + 10),
      v9);
    (*(*this + 200))(this, &v7, *(a2 + 3) + 28 * (Dest[i] - 32) + 12, a3);
    v10 += *(*(a2 + 3) + 28 * (Dest[i] - 32) + 8);
  }
}
// 10011880: using guessed type char Dest[256];

//----- (10011AF0) --------------------------------------------------------
int __thiscall Graphics::calcLighting(Graphics *this, float a2)
{
  int i; // [esp+4Ch] [ebp-10h]
  int v4; // [esp+50h] [ebp-Ch]
  int v5; // [esp+54h] [ebp-8h]
  Graphics *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  v5 = *(this + 223);
  *(this + 222) = a2;
  (*(*v6 + 36))(v6);
  v4 = 0;
  *(v6 + 223) = 0;
  for ( i = *(v6 + 9); i; i = *(i + 12) )
  {
    *(v6 + 223) |= 1 << v4;
    (*(*v6 + 44))(v6, i, v4++);
    if ( v4 == 7 )
      break;
  }
  if ( *(v6 + 9) )
  {
    *(v6 + 221) = 1112014848;
    (*(*v6 + 44))(v6, *(v6 + 9), 7);
  }
  if ( v4 > *(gsys + 109) )
    *(gsys + 109) = v4;
  (*(*v6 + 40))(v6, 1, 0);
  return v4;
}

//----- (10011C90) --------------------------------------------------------
int __thiscall Graphics::calcSphereLighting(Graphics *this, struct Vector3f *a2, float a3)
{
  double v3; // st7
  int v5; // [esp+4Ch] [ebp-1Ch]
  float v6; // [esp+50h] [ebp-18h]
  int v7; // [esp+54h] [ebp-14h]
  Light *i; // [esp+58h] [ebp-10h]
  int v9; // [esp+5Ch] [ebp-Ch]
  int v10; // [esp+60h] [ebp-8h]
  Graphics *v11; // [esp+64h] [ebp-4h]

  v11 = this;
  v10 = *(this + 223);
  v9 = 0;
  *(this + 223) = 0;
  for ( i = *(v11 + 9); i; i = *(i + 3) )
  {
    if ( *(i + 5) & 0x100 )
    {
      LOBYTE(v7) = 0;
      v5 = *(i + 5) & 0xFF;
      if ( v5 == 2 )
      {
        v6 = Vector3f::distance((i + 84), a2);
        v3 = Light::calcLightObjRadius(i);
        if ( v3 + a3 > v6 )
          LOBYTE(v7) = 1;
      }
      else if ( v5 == 3 && CullFrustum::isPointVisible((i + 116), a2, a3) )
      {
        LOBYTE(v7) = 1;
      }
      if ( v7 )
      {
        *(v11 + 223) |= 1 << v9;
        (*(*v11 + 44))(v11, i, v9++);
        if ( v9 == 7 )
          break;
      }
    }
  }
  if ( v9 > *(gsys + 109) )
    *(gsys + 109) = v9;
  if ( !*(v11 + 804) || v10 != *(v11 + 223) )
    (*(*v11 + 40))(v11, 1, 0);
  return v9;
}

//----- (10011EA0) --------------------------------------------------------
int __thiscall Graphics::calcBoxLighting(Graphics *this, struct BoundBox *a2)
{
  double v2; // st7
  double v3; // st7
  double v4; // st7
  double v5; // st7
  double v6; // st7
  double v7; // st7
  int v9; // [esp+4Ch] [ebp-18h]
  int v10; // [esp+50h] [ebp-14h]
  Light *i; // [esp+54h] [ebp-10h]
  int v12; // [esp+58h] [ebp-Ch]
  int v13; // [esp+5Ch] [ebp-8h]
  Graphics *v14; // [esp+60h] [ebp-4h]

  v14 = this;
  v13 = *(this + 223);
  v12 = 0;
  *(this + 223) = 0;
  for ( i = *(v14 + 9); i; i = *(i + 3) )
  {
    if ( *(i + 5) & 0x200 )
    {
      LOBYTE(v10) = 0;
      v9 = *(i + 5) & 0xFF;
      if ( v9 == 2 )
      {
        v2 = Light::calcLightMapRadius(i);
        if ( *a2 - v2 < *(i + 21) )
        {
          v3 = Light::calcLightMapRadius(i);
          if ( v3 + *(a2 + 3) > *(i + 21) )
          {
            v4 = Light::calcLightMapRadius(i);
            if ( *(a2 + 1) - v4 < *(i + 22) )
            {
              v5 = Light::calcLightMapRadius(i);
              if ( v5 + *(a2 + 4) > *(i + 22) )
              {
                v6 = Light::calcLightMapRadius(i);
                if ( *(a2 + 2) - v6 < *(i + 23) )
                {
                  v7 = Light::calcLightMapRadius(i);
                  if ( v7 + *(a2 + 5) > *(i + 23) )
                    LOBYTE(v10) = 1;
                }
              }
            }
          }
        }
      }
      else if ( v9 == 3 && CullFrustum::isBoundVisible((i + 116), a2, 32831) )
      {
        LOBYTE(v10) = 1;
      }
      if ( v10 )
      {
        *(v14 + 223) |= 1 << v12;
        (*(*v14 + 44))(v14, i, v12++);
        if ( v12 == 7 )
          break;
      }
    }
  }
  if ( v12 > *(gsys + 109) )
    *(gsys + 109) = v12;
  if ( !*(v14 + 804) || v13 != *(v14 + 223) )
    (*(*v14 + 40))(v14, 1, 0);
  return v12;
}

//----- (10012150) --------------------------------------------------------
Matrix4f *__thiscall Matrix4f::Matrix4f(Matrix4f *this)
{
  return this;
}

//----- (10012180) --------------------------------------------------------
void __thiscall Matrix4f::makeBillVector(Matrix4f *this, struct Vector3f *a2, struct Matrix4f *a3, struct Vector3f *a4)
{
  float v4; // [esp+4Ch] [ebp-10h]
  float v5; // [esp+50h] [ebp-Ch]
  float v6; // [esp+54h] [ebp-8h]
  float *v7; // [esp+58h] [ebp-4h]

  v7 = this;
  Vector3f::Vector3f(&v4);
  v4 = *a3 * *a2 + *(a3 + 4) * *(a2 + 1) + *(a3 + 8) * *(a2 + 2) + *(a3 + 12);
  v5 = *(a3 + 1) * *a2 + *(a3 + 5) * *(a2 + 1) + *(a3 + 9) * *(a2 + 2) + *(a3 + 13);
  v6 = *(a3 + 2) * *a2 + *(a3 + 6) * *(a2 + 1) + *(a3 + 10) * *(a2 + 2) + *(a3 + 14);
  *a4 = v4 * *v7 + v5 * v7[4] + v6 * v7[8] + v7[12];
  *(a4 + 1) = v4 * v7[1] + v5 * v7[5] + v6 * v7[9] + v7[13];
  *(a4 + 2) = v4 * v7[2] + v5 * v7[6] + v6 * v7[10] + v7[14];
}

//----- (10012320) --------------------------------------------------------
void __thiscall Matrix4f::rotate(Matrix4f *this, struct Vector3f *a2)
{
  Matrix4f::rotate(this, *a2, *(a2 + 1), *(a2 + 2));
}

//----- (10012380) --------------------------------------------------------
void __thiscall Matrix4f::makeSRT(Matrix4f *this, char a2, int a3, int a4, char a5, int a6, int a7, char a8, int a9, int a10)
{
  Matrix4f::makeSRT(this, &a2, &a5, &a8);
}

//----- (100123E0) --------------------------------------------------------
void __thiscall CacheTexture::makeResident(CacheTexture *this)
{
  struct CacheTexture *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  if ( *(gsys + 15) )
  {
    if ( *(v1 + 14) )
    {
      TextureCacher::updateInfo(*(gsys + 15), v1);
    }
    else
    {
      TextureCacher::cacheTexture(*(gsys + 15), v1);
      (*(*gsys + 20))(gsys, v1);
    }
  }
}

//----- (10012490) --------------------------------------------------------
void __thiscall Matrix4f::setTranslation(Matrix4f *this, struct Vector3f *a2)
{
  *(this + 3) = *a2;
  *(this + 7) = *(a2 + 1);
  *(this + 11) = *(a2 + 2);
}

//----- (100124F0) --------------------------------------------------------
void __thiscall Matrix4f::setTranslation(Matrix4f *this, float a2, float a3, float a4)
{
  *(this + 3) = a2;
  *(this + 7) = a3;
  *(this + 11) = a4;
}

//----- (10012550) --------------------------------------------------------
int __thiscall sub_10012550(_DWORD *this, struct RandomAccessStream *a2)
{
  int result; // eax
  int v3; // ecx
  int v4; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]
  _DWORD *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  result = (**a2)(a2);
  *v6 = result;
  if ( *v6 )
  {
    v4 = sub_10001AC3(40 * *v6);
    v6[1] = v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *v6 )
        break;
      v3 = v6[1];
      sub_1000123A(a2);
    }
  }
  return result;
}

//----- (10012620) --------------------------------------------------------
void __thiscall Matrix4f::getRow(Matrix4f *this, int a2, struct Vector3f *a3)
{
  Vector3f::set(a3, this + 4 * a2, this + 4 * a2 + 1, this + 4 * a2 + 2);
}

//----- (100126A0) --------------------------------------------------------
void __thiscall Matrix4f::getColumn(Matrix4f *this, int a2, struct Vector3f *a3)
{
  Vector3f::set(a3, this + a2, this + a2 + 4, this + a2 + 8);
}

//----- (10012710) --------------------------------------------------------
int __thiscall sub_10012710(_DWORD *this, struct RandomAccessStream *a2)
{
  int result; // eax
  int v3; // ecx
  int i; // [esp+4Ch] [ebp-8h]
  _DWORD *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  (*(*a2 + 28))(a2, *this);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *v5 )
      break;
    v3 = v5[1];
    sub_10002216(a2);
  }
  return result;
}

//----- (100127B0) --------------------------------------------------------
void *__thiscall Matrix4f::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x40u);
  return this;
}

//----- (10012800) --------------------------------------------------------
BaseScalingSystem *__thiscall BaseScalingSystem::BaseScalingSystem(BaseScalingSystem *this)
{
  *this = &BaseScalingSystem::`vftable';
  return this;
}
// 101AD820: using guessed type void *BaseScalingSystem::`vftable';

//----- (10012840) --------------------------------------------------------
BaseScalingSystem *__thiscall BaseScalingSystem::BaseScalingSystem(BaseScalingSystem *this, const struct BaseScalingSystem *a2)
{
  *this = &BaseScalingSystem::`vftable';
  return this;
}
// 101AD820: using guessed type void *BaseScalingSystem::`vftable';

//----- (10012880) --------------------------------------------------------
void *__thiscall BaseScalingSystem::operator=(void *this, int a2)
{
  return this;
}

//----- (100128C0) --------------------------------------------------------
void ClassicScalingSystem::blah()
{
  ;
}

//----- (100128F0) --------------------------------------------------------
BaseScalingSystem *__thiscall ClassicScalingSystem::ClassicScalingSystem(ClassicScalingSystem *this)
{
  BaseScalingSystem *v1; // ST50_4

  v1 = this;
  BaseScalingSystem::BaseScalingSystem(this);
  *v1 = &ClassicScalingSystem::`vftable';
  return v1;
}
// 101AD824: using guessed type void *ClassicScalingSystem::`vftable';

//----- (10012950) --------------------------------------------------------
BaseScalingSystem *__thiscall ClassicScalingSystem::ClassicScalingSystem(ClassicScalingSystem *this, const struct ClassicScalingSystem *a2)
{
  BaseScalingSystem *v2; // ST50_4

  v2 = this;
  BaseScalingSystem::BaseScalingSystem(this, a2);
  *v2 = &ClassicScalingSystem::`vftable';
  return v2;
}
// 101AD824: using guessed type void *ClassicScalingSystem::`vftable';

//----- (100129B0) --------------------------------------------------------
void *__thiscall ClassicScalingSystem::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  BaseScalingSystem::operator=(a2);
  return v2;
}
// 100023DD: using guessed type _DWORD __stdcall BaseScalingSystem::operator=(_DWORD);

//----- (10012A00) --------------------------------------------------------
void SoftImageScalingSystem::blah()
{
  ;
}

//----- (10012A30) --------------------------------------------------------
BaseScalingSystem *__thiscall SoftImageScalingSystem::SoftImageScalingSystem(SoftImageScalingSystem *this)
{
  BaseScalingSystem *v1; // ST50_4

  v1 = this;
  BaseScalingSystem::BaseScalingSystem(this);
  *v1 = &SoftImageScalingSystem::`vftable';
  return v1;
}
// 101AD828: using guessed type void *SoftImageScalingSystem::`vftable';

//----- (10012A90) --------------------------------------------------------
BaseScalingSystem *__thiscall SoftImageScalingSystem::SoftImageScalingSystem(SoftImageScalingSystem *this, const struct SoftImageScalingSystem *a2)
{
  BaseScalingSystem *v2; // ST50_4

  v2 = this;
  BaseScalingSystem::BaseScalingSystem(this, a2);
  *v2 = &SoftImageScalingSystem::`vftable';
  return v2;
}
// 101AD828: using guessed type void *SoftImageScalingSystem::`vftable';

//----- (10012AF0) --------------------------------------------------------
void *__thiscall SoftImageScalingSystem::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  BaseScalingSystem::operator=(a2);
  return v2;
}
// 100023DD: using guessed type _DWORD __stdcall BaseScalingSystem::operator=(_DWORD);

//----- (10012B40) --------------------------------------------------------
CoreNode *__thiscall CoreNode::CoreNode(CoreNode *this, char *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  ANode::ANode(this);
  v2->vtblPointer = &CoreNode::`vftable';
  CoreNode::initCore(v2, a2);
  return v2;
}
// 101AD82C: using guessed type void *CoreNode::`vftable';

//----- (10012BB0) --------------------------------------------------------
void __thiscall CoreNode::initCore(CoreNode *this, char *a2)
{
  this->Child = 0;
  this->Next = 0;
  this->Parent = 0;
  CoreNode::setName(this, a2);
}

//----- (10012C20) --------------------------------------------------------
void __thiscall CoreNode::setName(CoreNode *this, char *a2)
{
  this->name = a2;
}

//----- (10012C60) --------------------------------------------------------
char *__thiscall CoreNode::getName(CoreNode *this)
{
  return this->name;
}

//----- (10012CA0) --------------------------------------------------------
char *__thiscall CoreNode::Name(CoreNode *this)
{
  return this->name;
}

//----- (10012CE0) --------------------------------------------------------
struct CoreNode *__thiscall CoreNode::Parent(CoreNode *this)
{
  return this->Parent;
}

//----- (10012D20) --------------------------------------------------------
struct CoreNode *__thiscall CoreNode::Next(CoreNode *this)
{
  return this->Next;
}

//----- (10012D60) --------------------------------------------------------
void __thiscall CoreNode::Next(CoreNode *this, struct CoreNode *a2)
{
  this->Next = a2;
}

//----- (10012DA0) --------------------------------------------------------
struct CoreNode *__thiscall CoreNode::Child(CoreNode *this)
{
  return this->Child;
}

//----- (10012DE0) --------------------------------------------------------
void __thiscall CoreNode::Child(CoreNode *this, struct CoreNode *a2)
{
  this->Child = a2;
}

//----- (10012E20) --------------------------------------------------------
void __stdcall CoreNode::write(struct RandomAccessStream *a2)
{
  ;
}

//----- (10012E50) --------------------------------------------------------
void __stdcall CoreNode::read(struct RandomAccessStream *a2)
{
  ;
}

//----- (10012E80) --------------------------------------------------------
ANode *__thiscall CoreNode::CoreNode(CoreNode *this, const struct CoreNode *a2)
{
  ANode *v2; // ST50_4

  v2 = this;
  ANode::ANode(this, a2);
  *(v2 + 1) = a2->name;
  *(v2 + 2) = a2->Parent;
  *(v2 + 3) = a2->Next;
  *(v2 + 4) = a2->Child;
  *v2 = &CoreNode::`vftable';
  return v2;
}
// 101AD82C: using guessed type void *CoreNode::`vftable';

//----- (10012F20) --------------------------------------------------------
CoreNode *__thiscall CoreNode::operator=(CoreNode *this, _DWORD *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  ANode::operator=(a2);
  v2->name = a2[1];
  v2->Parent = a2[2];
  v2->Next = a2[3];
  v2->Child = a2[4];
  return v2;
}
// 100020C7: using guessed type _DWORD __stdcall ANode::operator=(_DWORD);

//----- (10012FB0) --------------------------------------------------------
void __thiscall CoreNode::`default constructor closure'(CoreNode *this)
{
  CoreNode::CoreNode(this, "CoreNode");
}

//----- (10013000) --------------------------------------------------------
Node *__thiscall Node::Node(Node *this, char *a2)
{
  Node *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2->pVtbl = &Node::`vftable';
  Node::init(v2, a2);
  return v2;
}
// 101AD850: using guessed type void *Node::`vftable';

//----- (10013070) --------------------------------------------------------
BOOL __thiscall Node::getFlag(Node *this, int a2)
{
  return (a2 & this->flags) != 0;
}

//----- (100130C0) --------------------------------------------------------
void __thiscall Node::setFlag(Node *this, int a2, bool a3)
{
  if ( a3 )
    Node::setFlag(this, a2);
  else
    Node::clearFlag(this, a2);
}

//----- (10013130) --------------------------------------------------------
void __thiscall Node::setFlag(Node *this, int a2)
{
  this->flags |= a2;
}

//----- (10013180) --------------------------------------------------------
void __thiscall Node::clearFlag(Node *this, int a2)
{
  this->flags &= ~a2;
}

//----- (100131D0) --------------------------------------------------------
void __thiscall Node::togFlag(Node *this, int a2)
{
  this->flags ^= a2;
}

//----- (10013220) --------------------------------------------------------
int __thiscall Node::getFlags(Node *this)
{
  return this->flags;
}

//----- (10013260) --------------------------------------------------------
void __thiscall Node::setFlags(Node *this, int a2)
{
  this->flags = a2;
}

//----- (100132A0) --------------------------------------------------------
void __thiscall Node::setType(Node *this, int a2)
{
  this->type = a2;
}

//----- (100132E0) --------------------------------------------------------
int __thiscall Node::getType(Node *this)
{
  return this->type;
}

//----- (10013320) --------------------------------------------------------
void Node::concat()
{
  ;
}

//----- (10013350) --------------------------------------------------------
void __thiscall Node::concat(Node *this, struct VQS *a2)
{
  Node *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(this->pVtbl + 44))(this);
}

//----- (100133B0) --------------------------------------------------------
void __thiscall Node::concat(Node *this, struct SRT *a2)
{
  Node *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(this->pVtbl + 44))(this);
}

//----- (10013410) --------------------------------------------------------
void __thiscall Node::concat(Node *this, struct Matrix4f *a2)
{
  Node *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(this->pVtbl + 44))(this);
}

//----- (10013470) --------------------------------------------------------
struct Matrix4f *Node::getModelMatrix()
{
  return 0;
}

//----- (100134A0) --------------------------------------------------------
CoreNode *__thiscall Node::Node(Node *this, const struct Node *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = a2->type;
  v2[1].name = a2->flags;
  v2[1].Parent = a2->dword1C;
  v2->vtblPointer = &Node::`vftable';
  return v2;
}
// 101AD850: using guessed type void *Node::`vftable';

//----- (10013530) --------------------------------------------------------
Node *__thiscall Node::operator=(Node *this, _DWORD *a2)
{
  Node *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2->type = a2[5];
  v2->flags = a2[6];
  v2->dword1C = a2[7];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (100135B0) --------------------------------------------------------
void __thiscall Node::`default constructor closure'(Node *this)
{
  Node::Node(this, "<Node>");
}

//----- (10013600) --------------------------------------------------------
void __thiscall SRTNode::setPosition(SRTNode *this, struct Vector3f *a2)
{
  _DWORD *v2; // ecx

  v2 = (this + 120);
  *v2 = *a2;
  v2[1] = *(a2 + 1);
  v2[2] = *(a2 + 2);
}

//----- (10013650) --------------------------------------------------------
struct Vector3f *__thiscall SRTNode::getPosition(SRTNode *this)
{
  return (this + 120);
}

//----- (10013690) --------------------------------------------------------
void __thiscall SRTNode::setScale(SRTNode *this, struct Vector3f *a2)
{
  _DWORD *v2; // ecx

  v2 = (this + 96);
  *v2 = *a2;
  v2[1] = *(a2 + 1);
  v2[2] = *(a2 + 2);
}

//----- (100136E0) --------------------------------------------------------
struct Vector3f *__thiscall SRTNode::getScale(SRTNode *this)
{
  return (this + 96);
}

//----- (10013720) --------------------------------------------------------
void __thiscall SRTNode::setRotation(SRTNode *this, struct Vector3f *a2)
{
  _DWORD *v2; // ecx

  v2 = (this + 108);
  *v2 = *a2;
  v2[1] = *(a2 + 1);
  v2[2] = *(a2 + 2);
}

//----- (10013770) --------------------------------------------------------
struct Vector3f *__thiscall SRTNode::getRotation(SRTNode *this)
{
  return (this + 108);
}

//----- (100137B0) --------------------------------------------------------
void __stdcall SRTNode::concat(struct Matrix4f *a2)
{
  ;
}

//----- (100137E0) --------------------------------------------------------
void SRTNode::concat()
{
  ;
}

//----- (10013810) --------------------------------------------------------
struct Matrix4f *__thiscall SRTNode::getModelMatrix(SRTNode *this)
{
  return (this + 32);
}

//----- (10013850) --------------------------------------------------------
struct Vector3f *__thiscall SRTNode::getWorldPosition(SRTNode *this)
{
  return (this + 80);
}

//----- (10013890) --------------------------------------------------------
void __thiscall sub_10013890(int *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v2 = (**a2)(a2);
  *v3 = v2;
  PVWKeyInfoF32::read((v3 + 1), a2);
  PVWKeyInfoF32::read((v3 + 4), a2);
  PVWKeyInfoF32::read((v3 + 7), a2);
}

//----- (10013930) --------------------------------------------------------
SRTNode *__thiscall SRTNode::SRTNode(SRTNode *this, const struct SRTNode *a2)
{
  SRTNode *v2; // ST50_4

  v2 = this;
  Node::Node(this, a2);
  qmemcpy(v2 + 32, a2 + 32, 0x40u);
  SRT::SRT((v2 + 96), (a2 + 96));
  *v2 = &SRTNode::`vftable';
  return v2;
}
// 101AD898: using guessed type void *SRTNode::`vftable';

//----- (100139C0) --------------------------------------------------------
char *__thiscall SRTNode::operator=(char *this, int a2)
{
  char *v2; // ST50_4

  v2 = this;
  Node::operator=(a2);
  qmemcpy(v2 + 32, (a2 + 32), 0x40u);
  qmemcpy(v2 + 96, (a2 + 96), 0x24u);
  return v2;
}
// 1000171C: using guessed type _DWORD __stdcall Node::operator=(_DWORD);

//----- (10013A40) --------------------------------------------------------
void __thiscall sub_10013A40(_DWORD *this, struct RandomAccessStream *a2)
{
  _DWORD *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
  PVWKeyInfoF32::write((v2 + 1), a2);
  PVWKeyInfoF32::write((v2 + 4), a2);
  PVWKeyInfoF32::write((v2 + 7), a2);
}

//----- (10013AE0) --------------------------------------------------------
void __thiscall SRTNode::`default constructor closure'(SRTNode *this)
{
  SRTNode::SRTNode(this, "<SRTNode>");
}

//----- (10013B30) --------------------------------------------------------
SRTNode *__thiscall ObjMgr::ObjMgr(ObjMgr *this)
{
  SRTNode *v1; // ST50_4

  v1 = this;
  SRTNode::SRTNode(this, "<SRTNode>");
  *v1 = &ObjMgr::`vftable';
  return v1;
}
// 101AD8E4: using guessed type void *ObjMgr::`vftable';

//----- (10013B90) --------------------------------------------------------
SRTNode *__thiscall ObjMgr::ObjMgr(ObjMgr *this, const struct ObjMgr *a2)
{
  SRTNode *v2; // ST50_4

  v2 = this;
  SRTNode::SRTNode(this, a2);
  *v2 = &ObjMgr::`vftable';
  return v2;
}
// 101AD8E4: using guessed type void *ObjMgr::`vftable';

//----- (10013BF0) --------------------------------------------------------
void *__thiscall ObjMgr::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  SRTNode::operator=(a2);
  return v2;
}
// 10001771: using guessed type _DWORD __stdcall SRTNode::operator=(_DWORD);

//----- (10013C40) --------------------------------------------------------
struct CoreNode *__thiscall NodeMgr::firstNode(struct_this_1 *this)
{
  return &this->corenode4;
}

//----- (10013C80) --------------------------------------------------------
NodeMgr *__thiscall NodeMgr::NodeMgr(NodeMgr *this, const struct NodeMgr *a2)
{
  NodeMgr *v2; // ST50_4

  v2 = this;
  *this = *a2;
  CoreNode::CoreNode((this + 4), (a2 + 4));
  return v2;
}

//----- (10013CF0) --------------------------------------------------------
_BYTE *__thiscall NodeMgr::operator=(_BYTE *this, _BYTE *a2)
{
  _BYTE *v2; // ST50_4

  v2 = this;
  *this = *a2;
  CoreNode::operator=(a2 + 4);
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10013D60) --------------------------------------------------------
CoreNode *__thiscall EditNode::EditNode(EditNode *this, char *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2->vtblPointer = &EditNode::`vftable';
  return v2;
}
// 101AD924: using guessed type void *EditNode::`vftable';

//----- (10013DC0) --------------------------------------------------------
void __stdcall EditNode::msgCommand(struct DataMsg *a2)
{
  ;
}

//----- (10013DF0) --------------------------------------------------------
void __stdcall EditNode::render2d(struct Graphics *a2, int *a3)
{
  ;
}

//----- (10013E20) --------------------------------------------------------
CoreNode *__thiscall EditNode::EditNode(EditNode *this, const struct EditNode *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2->vtblPointer = &EditNode::`vftable';
  return v2;
}
// 101AD924: using guessed type void *EditNode::`vftable';

//----- (10013E80) --------------------------------------------------------
void *__thiscall EditNode::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10013ED0) --------------------------------------------------------
_DWORD *__thiscall ID32::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (10013F20) --------------------------------------------------------
CoreNode *__thiscall MemInfoNode::MemInfoNode(MemInfoNode *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "meminfo");
  v1->vtblPointer = &MemInfoNode::`vftable';
  return v1;
}
// 101AD948: using guessed type void *MemInfoNode::`vftable';

//----- (10013F80) --------------------------------------------------------
CoreNode *__thiscall MemInfoNode::MemInfoNode(MemInfoNode *this, const struct MemInfoNode *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2->vtblPointer = &MemInfoNode::`vftable';
  return v2;
}
// 101AD948: using guessed type void *MemInfoNode::`vftable';

//----- (10013FF0) --------------------------------------------------------
_DWORD *__thiscall MemInfoNode::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = *(a2 + 20);
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10014050) --------------------------------------------------------
RectArea *__thiscall RectArea::RectArea(RectArea *this)
{
  *(this + 3) = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  *this = 0;
  return this;
}

//----- (100140C0) --------------------------------------------------------
RectArea *__thiscall RectArea::RectArea(RectArea *this, int a2, int a3, int a4, int a5)
{
  *this = a2;
  *(this + 1) = a3;
  *(this + 2) = a4;
  *(this + 3) = a5;
  return this;
}

//----- (10014120) --------------------------------------------------------
int __thiscall RectArea::width(RectArea *this)
{
  return *(this + 2) - *this;
}

//----- (10014160) --------------------------------------------------------
int __thiscall RectArea::height(RectArea *this)
{
  return *(this + 3) - *(this + 1);
}

//----- (100141A0) --------------------------------------------------------
void __thiscall RectArea::set(RectArea *this, int a2, int a3, int a4, int a5)
{
  *this = a2;
  *(this + 1) = a3;
  *(this + 2) = a4;
  *(this + 3) = a5;
}

//----- (10014200) --------------------------------------------------------
bool __thiscall RectArea::pointInside(RectArea *this, int a2, int a3)
{
  return a2 > *this && a2 < *(this + 2) && a3 > *(this + 1) && a3 < *(this + 3);
}

//----- (10014270) --------------------------------------------------------
_DWORD *__thiscall RectArea::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (100142D0) --------------------------------------------------------
GfxobjInfo *__thiscall GfxobjInfo::GfxobjInfo(GfxobjInfo *this)
{
  GfxobjInfo *v1; // ST50_4

  v1 = this;
  ID32::ID32((this + 16));
  *v1 = &GfxobjInfo::`vftable';
  *(v1 + 2) = 0;
  *(v1 + 1) = 0;
  *(v1 + 3) = `string';
  ID32::setID((v1 + 16), 0x6E6F6E65u);
  *(v1 + 7) = 0;
  return v1;
}
// 101AD96C: using guessed type void *GfxobjInfo::`vftable';

//----- (10014370) --------------------------------------------------------
void GfxobjInfo::attach()
{
  ;
}

//----- (100143A0) --------------------------------------------------------
void GfxobjInfo::detach()
{
  ;
}

//----- (100143D0) --------------------------------------------------------
void __thiscall GfxobjInfo::insertAfter(GfxobjInfo *this, struct GfxobjInfo *a2)
{
  *(a2 + 2) = *(this + 2);
  *(a2 + 1) = this;
  *(*(this + 2) + 4) = a2;
  *(this + 2) = a2;
}

//----- (10014440) --------------------------------------------------------
void __thiscall GfxobjInfo::remove(GfxobjInfo *this)
{
  *(*(this + 2) + 4) = *(this + 1);
  *(*(this + 1) + 8) = *(this + 2);
}

//----- (100144A0) --------------------------------------------------------
GfxobjInfo *__thiscall GfxobjInfo::GfxobjInfo(GfxobjInfo *this, const struct GfxobjInfo *a2)
{
  GfxobjInfo *v2; // ST50_4
  _DWORD *v3; // ecx

  v2 = this;
  *(this + 1) = *(a2 + 1);
  *(this + 2) = *(a2 + 2);
  *(this + 3) = *(a2 + 3);
  v3 = (this + 16);
  *v3 = *(a2 + 4);
  v3[1] = *(a2 + 5);
  v3[2] = *(a2 + 6);
  *(v2 + 7) = *(a2 + 7);
  *v2 = &GfxobjInfo::`vftable';
  return v2;
}
// 101AD96C: using guessed type void *GfxobjInfo::`vftable';

//----- (10014540) --------------------------------------------------------
_DWORD *__thiscall GfxobjInfo::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // ecx

  v2 = this;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  v3 = this + 4;
  *v3 = a2[4];
  v3[1] = a2[5];
  v3[2] = a2[6];
  v2[7] = a2[7];
  return v2;
}

//----- (100145E0) --------------------------------------------------------
void GfxObject::attach()
{
  ;
}

//----- (10014610) --------------------------------------------------------
void GfxObject::detach()
{
  ;
}

//----- (10014640) --------------------------------------------------------
GfxObject *__thiscall GfxObject::GfxObject(GfxObject *this)
{
  *this = &GfxObject::`vftable';
  return this;
}
// 101AD978: using guessed type void *GfxObject::`vftable';

//----- (10014680) --------------------------------------------------------
GfxObject *__thiscall GfxObject::GfxObject(GfxObject *this, const struct GfxObject *a2)
{
  *this = &GfxObject::`vftable';
  return this;
}
// 101AD978: using guessed type void *GfxObject::`vftable';

//----- (100146C0) --------------------------------------------------------
void *__thiscall GfxObject::operator=(void *this, int a2)
{
  return this;
}

//----- (10014700) --------------------------------------------------------
GfxobjInfo *__thiscall FntobjInfo::FntobjInfo(FntobjInfo *this)
{
  GfxobjInfo *v1; // ST50_4

  v1 = this;
  GfxobjInfo::GfxobjInfo(this);
  *v1 = &FntobjInfo::`vftable';
  *(v1 + 8) = 0;
  return v1;
}
// 101AD984: using guessed type void *FntobjInfo::`vftable';

//----- (10014760) --------------------------------------------------------
GfxobjInfo *__thiscall FntobjInfo::FntobjInfo(FntobjInfo *this, const struct FntobjInfo *a2)
{
  GfxobjInfo *v2; // ST50_4

  v2 = this;
  GfxobjInfo::GfxobjInfo(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *v2 = &FntobjInfo::`vftable';
  return v2;
}
// 101AD984: using guessed type void *FntobjInfo::`vftable';

//----- (100147D0) --------------------------------------------------------
_DWORD *__thiscall FntobjInfo::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  GfxobjInfo::operator=(a2);
  v2[8] = *(a2 + 32);
  return v2;
}
// 10001D2A: using guessed type _DWORD __stdcall GfxobjInfo::operator=(_DWORD);

//----- (10014830) --------------------------------------------------------
GfxobjInfo *__thiscall ShpobjInfo::ShpobjInfo(ShpobjInfo *this)
{
  GfxobjInfo *v1; // ST50_4

  v1 = this;
  GfxobjInfo::GfxobjInfo(this);
  *v1 = &ShpobjInfo::`vftable';
  *(v1 + 8) = 0;
  return v1;
}
// 101AD990: using guessed type void *ShpobjInfo::`vftable';

//----- (10014890) --------------------------------------------------------
GfxobjInfo *__thiscall ShpobjInfo::ShpobjInfo(ShpobjInfo *this, const struct ShpobjInfo *a2)
{
  GfxobjInfo *v2; // ST50_4

  v2 = this;
  GfxobjInfo::GfxobjInfo(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *v2 = &ShpobjInfo::`vftable';
  return v2;
}
// 101AD990: using guessed type void *ShpobjInfo::`vftable';

//----- (10014900) --------------------------------------------------------
_DWORD *__thiscall ShpobjInfo::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  GfxobjInfo::operator=(a2);
  v2[8] = *(a2 + 32);
  return v2;
}
// 10001D2A: using guessed type _DWORD __stdcall GfxobjInfo::operator=(_DWORD);

//----- (10014960) --------------------------------------------------------
GfxobjInfo *__thiscall AnmobjInfo::AnmobjInfo(AnmobjInfo *this)
{
  GfxobjInfo *v1; // ST50_4

  v1 = this;
  GfxobjInfo::GfxobjInfo(this);
  *v1 = &AnmobjInfo::`vftable';
  *(v1 + 8) = 0;
  return v1;
}
// 101AD99C: using guessed type void *AnmobjInfo::`vftable';

//----- (100149C0) --------------------------------------------------------
GfxobjInfo *__thiscall AnmobjInfo::AnmobjInfo(AnmobjInfo *this, const struct AnmobjInfo *a2)
{
  GfxobjInfo *v2; // ST50_4

  v2 = this;
  GfxobjInfo::GfxobjInfo(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *v2 = &AnmobjInfo::`vftable';
  return v2;
}
// 101AD99C: using guessed type void *AnmobjInfo::`vftable';

//----- (10014A30) --------------------------------------------------------
_DWORD *__thiscall AnmobjInfo::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  GfxobjInfo::operator=(a2);
  v2[8] = *(a2 + 32);
  return v2;
}
// 10001D2A: using guessed type _DWORD __stdcall GfxobjInfo::operator=(_DWORD);

//----- (10014A90) --------------------------------------------------------
GfxobjInfo *__thiscall BinobjInfo::BinobjInfo(BinobjInfo *this)
{
  GfxobjInfo *v1; // ST50_4

  v1 = this;
  GfxobjInfo::GfxobjInfo(this);
  *v1 = &BinobjInfo::`vftable';
  *(v1 + 8) = 0;
  return v1;
}
// 101AD9A8: using guessed type void *BinobjInfo::`vftable';

//----- (10014AF0) --------------------------------------------------------
GfxobjInfo *__thiscall BinobjInfo::BinobjInfo(BinobjInfo *this, const struct BinobjInfo *a2)
{
  GfxobjInfo *v2; // ST50_4

  v2 = this;
  GfxobjInfo::GfxobjInfo(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *v2 = &BinobjInfo::`vftable';
  return v2;
}
// 101AD9A8: using guessed type void *BinobjInfo::`vftable';

//----- (10014B60) --------------------------------------------------------
_DWORD *__thiscall BinobjInfo::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  GfxobjInfo::operator=(a2);
  v2[8] = *(a2 + 32);
  return v2;
}
// 10001D2A: using guessed type _DWORD __stdcall GfxobjInfo::operator=(_DWORD);

//----- (10014BC0) --------------------------------------------------------
GfxobjInfo *__thiscall TexobjInfo::TexobjInfo(TexobjInfo *this)
{
  GfxobjInfo *v1; // ST50_4

  v1 = this;
  GfxobjInfo::GfxobjInfo(this);
  *v1 = &TexobjInfo::`vftable';
  *(v1 + 8) = 0;
  return v1;
}
// 101AD9B4: using guessed type void *TexobjInfo::`vftable';

//----- (10014C20) --------------------------------------------------------
void __thiscall TexobjInfo::attach(TexobjInfo *this)
{
  TexobjInfo *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (***(this + 8))(*(this + 8));
}

//----- (10014C80) --------------------------------------------------------
void __thiscall TexobjInfo::detach(TexobjInfo *this)
{
  TexobjInfo *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(**(this + 8) + 4))(*(this + 8));
}

//----- (10014CE0) --------------------------------------------------------
GfxobjInfo *__thiscall TexobjInfo::TexobjInfo(TexobjInfo *this, const struct TexobjInfo *a2)
{
  GfxobjInfo *v2; // ST50_4

  v2 = this;
  GfxobjInfo::GfxobjInfo(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *v2 = &TexobjInfo::`vftable';
  return v2;
}
// 101AD9B4: using guessed type void *TexobjInfo::`vftable';

//----- (10014D50) --------------------------------------------------------
_DWORD *__thiscall TexobjInfo::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  GfxobjInfo::operator=(a2);
  v2[8] = *(a2 + 32);
  return v2;
}
// 10001D2A: using guessed type _DWORD __stdcall GfxobjInfo::operator=(_DWORD);

//----- (10014DB0) --------------------------------------------------------
void __thiscall CacheInfo::insertAfter(CacheInfo *this, struct CacheInfo *a2)
{
  *(a2 + 2) = *(this + 2);
  *(a2 + 1) = this;
  *(*(this + 2) + 4) = a2;
  *(this + 2) = a2;
}

//----- (10014E20) --------------------------------------------------------
void __thiscall CacheInfo::remove(CacheInfo *this)
{
  *(*(this + 2) + 4) = *(this + 1);
  *(*(this + 1) + 8) = *(this + 2);
}

//----- (10014E80) --------------------------------------------------------
void *__thiscall CacheInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x14u);
  return this;
}

//----- (10014ED0) --------------------------------------------------------
TexCacheInfo *__thiscall TexCacheInfo::TexCacheInfo(TexCacheInfo *this)
{
  TexCacheInfo *v1; // ST50_4

  v1 = this;
  TexCacheInfo::initData(this);
  return v1;
}

//----- (10014F20) --------------------------------------------------------
void __thiscall TexCacheInfo::initData(TexCacheInfo *this)
{
  *(this + 4) = 0;
}

//----- (10014F60) --------------------------------------------------------
void *__thiscall TexCacheInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x14u);
  return this;
}

//----- (10014FB0) --------------------------------------------------------
TexCacheInfo *__thiscall TextureCacher::TextureCacher(TextureCacher *this, unsigned __int32 a2)
{
  int v3; // [esp+4Ch] [ebp-1Ch]
  AyuCache *hMem; // [esp+50h] [ebp-18h]
  TexCacheInfo *v5; // [esp+58h] [ebp-10h]

  v5 = this;
  TexCacheInfo::TexCacheInfo(this);
  hMem = sub_10002A81(0x130u);
  if ( hMem )
    v3 = AyuCache::AyuCache(hMem, a2);
  else
    v3 = 0;
  *(v5 + 5) = v3;
  *v5 = "root";
  *(v5 + 1) = v5;
  *(v5 + 2) = v5;
  return v5;
}

//----- (100150A0) --------------------------------------------------------
void *__thiscall TextureCacher::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x18u);
  return this;
}

//----- (100150F0) --------------------------------------------------------
void __thiscall StdSystem::set2DRoot(StdSystem *this, char *a2, char *a3)
{
  *(this + 18) = a2;
  *(this + 19) = a3;
}

//----- (10015140) --------------------------------------------------------
void __thiscall StdSystem::setDataRoot(StdSystem *this, char *a2)
{
  *(this + 21) = a2;
}

//----- (10015180) --------------------------------------------------------
int __thiscall StdSystem::getHeapNum(StdSystem *this)
{
  return *(this + 102);
}

//----- (100151C0) --------------------------------------------------------
void __thiscall StdSystem::setFade(StdSystem *this, float a2, float a3)
{
  *(this + 3) = a2;
  *(this + 4) = a3;
}

//----- (10015210) --------------------------------------------------------
double __thiscall StdSystem::getFade(StdSystem *this)
{
  return *(this + 2);
}

//----- (10015250) --------------------------------------------------------
double __stdcall StdSystem::getRand(float a2)
{
  return rand() / 32767.0 * a2;
}

//----- (100152C0) --------------------------------------------------------
double __stdcall StdSystem::getHalfRand(float a2)
{
  return (rand() / 32767.0 - 0.5) * a2;
}

//----- (10015330) --------------------------------------------------------
void __thiscall StdSystem::setFrameClamp(StdSystem *this, int a2)
{
  *(this + 6) = a2;
}

//----- (10015370) --------------------------------------------------------
void __thiscall StdSystem::softReset(StdSystem *this)
{
  *(this + 4) = 1;
}

//----- (100153B0) --------------------------------------------------------
bool __thiscall StdSystem::resetPending(StdSystem *this)
{
  return *(this + 4);
}

//----- (100153F0) --------------------------------------------------------
struct RandomAccessStream *__stdcall StdSystem::openFile(char *a2, bool a3, bool a4)
{
  return 0;
}

//----- (10015430) --------------------------------------------------------
unsigned __int32 __stdcall StdSystem::copyRamToCache(unsigned __int32 a2, unsigned __int32 a3, unsigned __int32 a4)
{
  return 0;
}

//----- (10015470) --------------------------------------------------------
void __stdcall StdSystem::copyCacheToRam(unsigned __int32 a2, unsigned __int32 a3, unsigned __int32 a4)
{
  ;
}

//----- (100154A0) --------------------------------------------------------
void StdSystem::copyWaitUntilDone()
{
  ;
}

//----- (100154D0) --------------------------------------------------------
void __stdcall StdSystem::copyCacheToTexture(struct CacheTexture *a2)
{
  ;
}

//----- (10015500) --------------------------------------------------------
void __thiscall StdSystem::Shutdown(StdSystem *this)
{
  *(this + 114) = 2147483648;
}

//----- (10015540) --------------------------------------------------------
bool __thiscall StdSystem::isShutdown(StdSystem *this)
{
  return *(this + 114) == 2147483648;
}

//----- (10015590) --------------------------------------------------------
void __stdcall StdSystem::Activate(bool a2)
{
  ;
}

//----- (100155C0) --------------------------------------------------------
void __thiscall StdSystem::setActive(StdSystem *this, bool a2)
{
  StdSystem *v2; // edx
  int v3; // ecx
  int v4; // [esp+4Ch] [ebp-8h]
  StdSystem *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  if ( a2 )
  {
    *(v5 + 114) |= 0x200000u;
    v2 = *(v5 + 114);
  }
  else
  {
    v2 = v5;
    *(v5 + 114) &= 0xFFDFFFFF;
    v3 = *(v5 + 114);
  }
  v4 = *(v5 + 114);
  LOBYTE(v2) = a2;
  (*(*v5 + 24))(v5, v2);
}

//----- (10015690) --------------------------------------------------------
BOOL __thiscall StdSystem::isActive(StdSystem *this)
{
  return (*(this + 114) & 0x200000) == 0x200000;
}

//----- (100156E0) --------------------------------------------------------
void __thiscall StdSystem::setTextureBase(StdSystem *this, char *a2, char *a3)
{
  *(this + 125) = a2;
  *(this + 126) = a3;
}

//----- (10015730) --------------------------------------------------------
void __stdcall StdSystem::parseArchiveDirectory(char *a2, char *a3)
{
  ;
}

//----- (10015760) --------------------------------------------------------
void __stdcall StdSystem::startLoading(struct LoadIdler *a2, bool a3, unsigned __int32 a4)
{
  ;
}

//----- (10015790) --------------------------------------------------------
void StdSystem::endLoading()
{
  ;
}

//----- (100157C0) --------------------------------------------------------
StdSystem *__thiscall StdSystem::StdSystem(StdSystem *this, const struct StdSystem *a2)
{
  StdSystem *v2; // ST50_4

  v2 = this;
  *(this + 4) = *(a2 + 4);
  *(this + 2) = *(a2 + 2);
  *(this + 3) = *(a2 + 3);
  *(this + 4) = *(a2 + 4);
  *(this + 5) = *(a2 + 5);
  *(this + 6) = *(a2 + 6);
  *(this + 7) = *(a2 + 7);
  *(this + 8) = *(a2 + 8);
  *(this + 9) = *(a2 + 9);
  *(this + 10) = *(a2 + 10);
  *(this + 11) = *(a2 + 11);
  *(this + 12) = *(a2 + 12);
  *(this + 13) = *(a2 + 13);
  *(this + 14) = *(a2 + 14);
  *(this + 15) = *(a2 + 15);
  *(this + 16) = *(a2 + 16);
  *(this + 17) = *(a2 + 17);
  *(this + 18) = *(a2 + 18);
  *(this + 19) = *(a2 + 19);
  *(this + 20) = *(a2 + 20);
  *(this + 21) = *(a2 + 21);
  qmemcpy(this + 88, a2 + 88, 0x178u);
  GfxobjInfo::GfxobjInfo((this + 464), (a2 + 464));
  *(v2 + 496) = *(a2 + 496);
  *(v2 + 125) = *(a2 + 125);
  *(v2 + 126) = *(a2 + 126);
  *(v2 + 127) = *(a2 + 127);
  CoreNode::CoreNode((v2 + 512), (a2 + 512));
  CoreNode::CoreNode((v2 + 532), (a2 + 532));
  *(v2 + 138) = *(a2 + 138);
  *(v2 + 139) = *(a2 + 139);
  *(v2 + 140) = *(a2 + 140);
  *(v2 + 141) = *(a2 + 141);
  *(v2 + 142) = *(a2 + 142);
  *(v2 + 143) = *(a2 + 143);
  *(v2 + 144) = *(a2 + 144);
  *v2 = &StdSystem::`vftable';
  return v2;
}
// 101AD9D0: using guessed type void *StdSystem::`vftable';

//----- (10015BF0) --------------------------------------------------------
int __thiscall StdSystem::operator=(int this, int a2)
{
  unsigned int i; // [esp+4Ch] [ebp-8h]
  int v4; // [esp+50h] [ebp-4h]

  v4 = this;
  *(this + 4) = *(a2 + 4);
  *(this + 8) = *(a2 + 8);
  *(this + 12) = *(a2 + 12);
  *(this + 16) = *(a2 + 16);
  *(this + 20) = *(a2 + 20);
  *(this + 24) = *(a2 + 24);
  *(this + 28) = *(a2 + 28);
  *(this + 32) = *(a2 + 32);
  *(this + 36) = *(a2 + 36);
  *(this + 40) = *(a2 + 40);
  *(this + 44) = *(a2 + 44);
  *(this + 48) = *(a2 + 48);
  *(this + 52) = *(a2 + 52);
  *(this + 56) = *(a2 + 56);
  *(this + 60) = *(a2 + 60);
  *(this + 64) = *(a2 + 64);
  *(this + 68) = *(a2 + 68);
  *(this + 72) = *(a2 + 72);
  *(this + 76) = *(a2 + 76);
  *(this + 80) = *(a2 + 80);
  *(this + 84) = *(a2 + 84);
  for ( i = 0; i < 8; ++i )
    qmemcpy((this + 40 * i + 88), (a2 + 40 * i + 88), 0x28u);
  *(this + 408) = *(a2 + 408);
  *(this + 412) = *(a2 + 412);
  *(this + 416) = *(a2 + 416);
  *(this + 420) = *(a2 + 420);
  *(this + 424) = *(a2 + 424);
  *(this + 428) = *(a2 + 428);
  *(this + 432) = *(a2 + 432);
  *(this + 436) = *(a2 + 436);
  *(this + 440) = *(a2 + 440);
  *(this + 444) = *(a2 + 444);
  *(this + 448) = *(a2 + 448);
  *(this + 452) = *(a2 + 452);
  *(this + 456) = *(a2 + 456);
  *(this + 460) = *(a2 + 460);
  GfxobjInfo::operator=(a2 + 464);
  *(v4 + 496) = *(a2 + 496);
  *(v4 + 500) = *(a2 + 500);
  *(v4 + 504) = *(a2 + 504);
  *(v4 + 508) = *(a2 + 508);
  CoreNode::operator=(a2 + 512);
  CoreNode::operator=(a2 + 532);
  *(v4 + 552) = *(a2 + 552);
  *(v4 + 556) = *(a2 + 556);
  *(v4 + 560) = *(a2 + 560);
  *(v4 + 564) = *(a2 + 564);
  *(v4 + 568) = *(a2 + 568);
  *(v4 + 572) = *(a2 + 572);
  *(v4 + 576) = *(a2 + 576);
  return v4;
}
// 10001D2A: using guessed type _DWORD __stdcall GfxobjInfo::operator=(_DWORD);
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10016040) --------------------------------------------------------
ControllerMgr *__thiscall ControllerMgr::ControllerMgr(ControllerMgr *this)
{
  signed int i; // [esp+4Ch] [ebp-8h]

  *this = &ControllerMgr::`vftable';
  for ( i = 0; i < 256; ++i )
    *(this + i + 4) = 0;
  return this;
}
// 101ADA04: using guessed type void *ControllerMgr::`vftable';

//----- (100160B0) --------------------------------------------------------
BOOL __thiscall ControllerMgr::keyDown(ControllerMgr *this, int a2)
{
  return (*(this + a2 + 4) & 0x80) == 128;
}

//----- (10016110) --------------------------------------------------------
ControllerMgr *__thiscall ControllerMgr::ControllerMgr(ControllerMgr *this, const struct ControllerMgr *a2)
{
  qmemcpy(this + 4, a2 + 4, 0x100u);
  *this = &ControllerMgr::`vftable';
  return this;
}
// 101ADA04: using guessed type void *ControllerMgr::`vftable';

//----- (10016170) --------------------------------------------------------
_BYTE *__thiscall ControllerMgr::operator=(_BYTE *this, int a2)
{
  unsigned int i; // [esp+4Ch] [ebp-8h]

  for ( i = 0; i < 0x100; ++i )
    this[i + 4] = *(i + a2 + 4);
  return this;
}

//----- (100161E0) --------------------------------------------------------
void AtxRouter::lock()
{
  ;
}

//----- (10016210) --------------------------------------------------------
void AtxRouter::unlock()
{
  ;
}

//----- (10016240) --------------------------------------------------------
void AtxRouter::closeAll()
{
  ;
}

//----- (10016270) --------------------------------------------------------
bool AtxRouter::isConnected()
{
  return 0;
}

//----- (100162A0) --------------------------------------------------------
void __stdcall AtxRouter::setWindow(unsigned __int32 a2)
{
  ;
}

//----- (100162D0) --------------------------------------------------------
AtxRouter *__thiscall AtxRouter::AtxRouter(AtxRouter *this)
{
  *this = &AtxRouter::`vftable';
  return this;
}
// 101ADA08: using guessed type void *AtxRouter::`vftable';

//----- (10016310) --------------------------------------------------------
AtxRouter *__thiscall AtxRouter::AtxRouter(AtxRouter *this, const struct AtxRouter *a2)
{
  *this = &AtxRouter::`vftable';
  return this;
}
// 101ADA08: using guessed type void *AtxRouter::`vftable';

//----- (10016350) --------------------------------------------------------
void *__thiscall AtxRouter::operator=(void *this, int a2)
{
  return this;
}

//----- (10016390) --------------------------------------------------------
AtxStream *__thiscall AtxStream::AtxStream(AtxStream *this)
{
  AtxStream *v1; // ST50_4

  v1 = this;
  Stream::Stream(this);
  *v1 = &AtxStream::`vftable';
  AtxStream::init(v1);
  return v1;
}
// 101ADA30: using guessed type void *AtxStream::`vftable';

//----- (100163F0) --------------------------------------------------------
void __thiscall AtxStream::init(AtxStream *this)
{
  *(this + 3) = 0;
}

//----- (10016430) --------------------------------------------------------
AtxStream *__thiscall AtxStream::AtxStream(AtxStream *this, const struct AtxStream *a2)
{
  AtxStream *v2; // ST50_4

  v2 = this;
  Stream::Stream(this, a2);
  *(v2 + 2) = *(a2 + 2);
  *(v2 + 3) = *(a2 + 3);
  *v2 = &AtxStream::`vftable';
  return v2;
}
// 101ADA30: using guessed type void *AtxStream::`vftable';

//----- (100164B0) --------------------------------------------------------
_DWORD *__thiscall AtxStream::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  Stream::operator=(a2);
  v2[2] = *(a2 + 8);
  v2[3] = *(a2 + 12);
  return v2;
}
// 100024B4: using guessed type _DWORD __stdcall Stream::operator=(_DWORD);

//----- (10016520) --------------------------------------------------------
AtxStream *__thiscall AtxCommandStream::AtxCommandStream(AtxCommandStream *this, struct BaseApp *a2)
{
  AtxStream *v2; // ST50_4

  v2 = this;
  AtxStream::AtxStream(this);
  *v2 = &AtxCommandStream::`vftable';
  *(v2 + 4) = a2;
  return v2;
}
// 101ADA90: using guessed type void *AtxCommandStream::`vftable';

//----- (10016580) --------------------------------------------------------
AtxStream *__thiscall AtxCommandStream::AtxCommandStream(AtxCommandStream *this, const struct AtxCommandStream *a2)
{
  AtxStream *v2; // ST50_4

  v2 = this;
  AtxStream::AtxStream(this, a2);
  *(v2 + 4) = *(a2 + 4);
  *v2 = &AtxCommandStream::`vftable';
  return v2;
}
// 101ADA90: using guessed type void *AtxCommandStream::`vftable';

//----- (100165F0) --------------------------------------------------------
_DWORD *__thiscall AtxCommandStream::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  AtxStream::operator=(a2);
  v2[4] = *(a2 + 16);
  return v2;
}
// 100025D1: using guessed type _DWORD __stdcall AtxStream::operator=(_DWORD);

//----- (10016650) --------------------------------------------------------
int __thiscall AtxFileStream::getPending(AtxFileStream *this)
{
  return *(this + 3) - *(this + 2);
}

//----- (10016690) --------------------------------------------------------
int __thiscall AtxFileStream::getPosition(AtxFileStream *this)
{
  return *(this + 2);
}

//----- (100166D0) --------------------------------------------------------
int __thiscall AtxFileStream::getLength(AtxFileStream *this)
{
  return *(this + 3);
}

//----- (10016710) --------------------------------------------------------
void __thiscall AtxFileStream::setLength(AtxFileStream *this, int a2)
{
  *(this + 3) = a2;
}

//----- (10016750) --------------------------------------------------------
RandomAccessStream *__thiscall AtxFileStream::AtxFileStream(AtxFileStream *this)
{
  RandomAccessStream *v1; // ST50_4

  v1 = this;
  RandomAccessStream::RandomAccessStream(this);
  AtxStream::AtxStream((v1 + 16));
  *v1 = &AtxFileStream::`vftable';
  return v1;
}
// 101ADAF0: using guessed type void *AtxFileStream::`vftable';

//----- (100167B0) --------------------------------------------------------
RandomAccessStream *__thiscall AtxFileStream::AtxFileStream(AtxFileStream *this, const struct AtxFileStream *a2)
{
  RandomAccessStream *v2; // ST50_4

  v2 = this;
  RandomAccessStream::RandomAccessStream(this, a2);
  *(v2 + 2) = *(a2 + 2);
  *(v2 + 3) = *(a2 + 3);
  AtxStream::AtxStream((v2 + 16), (a2 + 16));
  *v2 = &AtxFileStream::`vftable';
  return v2;
}
// 101ADAF0: using guessed type void *AtxFileStream::`vftable';

//----- (10016840) --------------------------------------------------------
_DWORD *__thiscall AtxFileStream::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  RandomAccessStream::operator=(a2);
  v2[2] = *(a2 + 8);
  v2[3] = *(a2 + 12);
  AtxStream::operator=(a2 + 16);
  return v2;
}
// 10001CEE: using guessed type _DWORD __stdcall RandomAccessStream::operator=(_DWORD);
// 100025D1: using guessed type _DWORD __stdcall AtxStream::operator=(_DWORD);

//----- (100168D0) --------------------------------------------------------
void System::beginRender()
{
  ;
}

//----- (10016900) --------------------------------------------------------
void System::doneRender()
{
  ;
}

//----- (10016930) --------------------------------------------------------
void System::waitRetrace()
{
  ;
}

//----- (10016960) --------------------------------------------------------
int __thiscall System::setStreamType(int this, int a2)
{
  int v2; // ST50_4

  v2 = *(this + 688);
  *(this + 688) = a2;
  return v2;
}

//----- (100169C0) --------------------------------------------------------
int __thiscall System::getAtxRouter(_DWORD *this)
{
  return this[270];
}

//----- (10016A00) --------------------------------------------------------
void __thiscall System::setAtxRouter(struct AtxRouter *this, int a2)
{
  *(this + 270) = a2;
}

//----- (10016A40) --------------------------------------------------------
double __thiscall System::getFrameRate(float *this)
{
  return this[279];
}

//----- (10016A80) --------------------------------------------------------
double __thiscall System::getFrameTime(float *this)
{
  return this[278];
}

//----- (10016AC0) --------------------------------------------------------
int __thiscall System::getFrameCount(_DWORD *this)
{
  return this[282];
}

//----- (10016B00) --------------------------------------------------------
void __stdcall System::sndPlaySe(int a2)
{
  ;
}

//----- (10016B30) --------------------------------------------------------
StdSystem *__thiscall System::System(const struct System *this, struct StdSystem *a2)
{
  StdSystem *v2; // ST50_4

  v2 = this;
  StdSystem::StdSystem(this, a2);
  *(v2 + 145) = *(a2 + 145);
  *(v2 + 146) = *(a2 + 146);
  *(v2 + 588) = *(a2 + 588);
  *(v2 + 589) = *(a2 + 589);
  *(v2 + 590) = *(a2 + 590);
  *(v2 + 148) = *(a2 + 148);
  *(v2 + 149) = *(a2 + 149);
  *(v2 + 150) = *(a2 + 150);
  *(v2 + 151) = *(a2 + 151);
  *(v2 + 152) = *(a2 + 152);
  AtxFileStream::AtxFileStream((v2 + 612), (a2 + 612));
  BufferedStream::BufferedStream((v2 + 644), (a2 + 644));
  *(v2 + 172) = *(a2 + 172);
  ControllerMgr::ControllerMgr((v2 + 692), (a2 + 692));
  qmemcpy(v2 + 952, a2 + 952, 0x84u);
  *(v2 + 272) = *(a2 + 272);
  *(v2 + 273) = *(a2 + 273);
  *(v2 + 274) = *(a2 + 274);
  *(v2 + 275) = *(a2 + 275);
  *(v2 + 276) = *(a2 + 276);
  *(v2 + 277) = *(a2 + 277);
  *(v2 + 278) = *(a2 + 278);
  *(v2 + 279) = *(a2 + 279);
  *(v2 + 280) = *(a2 + 280);
  *(v2 + 281) = *(a2 + 281);
  *(v2 + 282) = *(a2 + 282);
  *v2 = &System::`vftable';
  return v2;
}
// 101ADB64: using guessed type void *System::`vftable';

//----- (10016E00) --------------------------------------------------------
System *__thiscall System::operator=(System *this, int a2)
{
  unsigned int i; // [esp+4Ch] [ebp-8h]

  StdSystem::operator=(a2);
  this->dword244 = *(a2 + 580);
  this->dword248 = *(a2 + 584);
  this->byte24C = *(a2 + 588);
  this->byte24D = *(a2 + 589);
  this->byte24E = *(a2 + 590);
  this->dword250 = *(a2 + 592);
  this->dword254 = *(a2 + 596);
  this->dword258 = *(a2 + 600);
  this->dword25C = *(a2 + 604);
  this->dword260 = *(a2 + 608);
  AtxFileStream::operator=(a2 + 612);
  BufferedStream::operator=(a2 + 644);
  this->dword2B0 = *(a2 + 688);
  ControllerMgr::operator=(a2 + 692);
  for ( i = 0; i < 0x80; ++i )
    this->gap2B4[i + 260] = *(i + a2 + 952);
  this->dword438 = *(a2 + 1080);
  this->dword440 = *(a2 + 1088);
  this->dword444 = *(a2 + 1092);
  this->dword448 = *(a2 + 1096);
  this->dword44C = *(a2 + 1100);
  this->dword450 = *(a2 + 1104);
  this->dword454 = *(a2 + 1108);
  this->dword458 = *(a2 + 1112);
  this->dword45C = *(a2 + 1116);
  this->dword460 = *(a2 + 1120);
  this->dword464 = *(a2 + 1124);
  this->dword468 = *(a2 + 1128);
  return this;
}
// 1000100F: using guessed type _DWORD __stdcall ControllerMgr::operator=(_DWORD);
// 100017D0: using guessed type _DWORD __stdcall StdSystem::operator=(_DWORD);
// 10001B4F: using guessed type _DWORD __stdcall AtxFileStream::operator=(_DWORD);
// 1000282E: using guessed type _DWORD __stdcall BufferedStream::operator=(_DWORD);

//----- (100170E0) --------------------------------------------------------
CoreNode *__thiscall LinkedRoomInfo::LinkedRoomInfo(LinkedRoomInfo *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, `string');
  v1->vtblPointer = &LinkedRoomInfo::`vftable';
  v1[1].name = 0;
  return v1;
}
// 101ADB98: using guessed type void *LinkedRoomInfo::`vftable';

//----- (10017150) --------------------------------------------------------
CoreNode *__thiscall LinkedRoomInfo::LinkedRoomInfo(LinkedRoomInfo *this, const struct LinkedRoomInfo *a2)
{
  _DWORD *v3; // [esp+4Ch] [ebp-8h]
  CoreNode *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  CoreNode::CoreNode(this, a2);
  if ( a2 )
    v3 = (a2 + 20);
  else
    v3 = 0;
  v4[1].vtblPointer = *v3;
  v4[1].name = *(a2 + 6);
  v4->vtblPointer = &LinkedRoomInfo::`vftable';
  return v4;
}
// 101ADB98: using guessed type void *LinkedRoomInfo::`vftable';

//----- (100171F0) --------------------------------------------------------
_DWORD *__thiscall LinkedRoomInfo::operator=(_DWORD *this, int a2)
{
  _DWORD *v3; // [esp+4Ch] [ebp-8h]
  _DWORD *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  CoreNode::operator=(a2);
  if ( a2 )
    v3 = (a2 + 20);
  else
    v3 = 0;
  v4[5] = *v3;
  v4[6] = *(a2 + 24);
  return v4;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10017280) --------------------------------------------------------
void *__thiscall CmdStream::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x11Cu);
  return this;
}

//----- (100172D0) --------------------------------------------------------
CullFrustum *__thiscall CullFrustum::CullFrustum(CullFrustum *this)
{
  float v2; // [esp+4Ch] [ebp-10h]
  float v3; // [esp+50h] [ebp-Ch]
  float v4; // [esp+54h] [ebp-8h]
  CullFrustum *v5; // [esp+58h] [ebp-4h]

  v5 = this;
  sub_1000291E(this + 12, 44, 6, CullingPlane::CullingPlane);
  Vector3f::Vector3f((v5 + 344));
  Vector3f::Vector3f((v5 + 356));
  Vector3f::Vector3f((v5 + 368));
  Vector3f::Vector3f((v5 + 380));
  Vector3f::Vector3f((v5 + 392));
  Vector3f::Vector3f((v5 + 404));
  Vector3f::Vector3f((v5 + 416));
  Vector3f::Vector3f((v5 + 428));
  Vector3f::Vector3f((v5 + 440));
  Matrix4f::Matrix4f((v5 + 480));
  Matrix4f::Matrix4f((v5 + 544));
  *(v5 + 341) = 0;
  v4 = 0.0;
  v3 = 0.0;
  v2 = 0.0;
  Vector3f::set((v5 + 356), &v2, &v3, &v4);
  *(v5 + 115) = 1114636288;
  *(v5 + 116) = 1065353216;
  *(v5 + 117) = 1148846080;
  return v5;
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10017460) --------------------------------------------------------
void __thiscall CullFrustum::projectVector(CullFrustum *this, struct Vector3f *a2, struct Vector3f *a3)
{
  CullFrustum *v3; // ST50_4

  v3 = this;
  *a3 = Vector3f::DP(a2, (this + 380));
  *(a3 + 1) = Vector3f::DP(a2, (v3 + 392));
  *(a3 + 2) = Vector3f::DP(a2, (v3 + 404));
}

//----- (10017500) --------------------------------------------------------
void __thiscall CullFrustum::setBoundOffset(CullFrustum *this, struct Vector3f *a2)
{
  _DWORD *v2; // edx

  *(this + 340) = a2 != 0;
  if ( *(this + 340) )
  {
    v2 = (this + 344);
    *v2 = *a2;
    v2[1] = *(a2 + 1);
    v2[2] = *(a2 + 2);
  }
}

//----- (10017580) --------------------------------------------------------
int __thiscall CullFrustum::isBoundVisible(CullFrustum *this, struct BoundBox *a2, int a3)
{
  int v4; // [esp+4Ch] [ebp-10h]
  int i; // [esp+50h] [ebp-Ch]

  for ( i = 0; i < *(this + 1); ++i )
  {
    v4 = *(this + i + 69);
    if ( *(v4 + 40) && (1 << i) & a3 )
    {
      if ( *(this + 340) )
      {
        if ( (*(a2 + *(v4 + 28)) + *(this + 86)) * *v4
           + (*(a2 + *(v4 + 32)) + *(this + 87)) * *(v4 + 4)
           + (*(a2 + *(v4 + 36)) + *(this + 88)) * *(v4 + 8)
           - *(v4 + 12) < 0.0 )
          return 0;
        if ( (*(a2 + *(v4 + 16)) + *(this + 86)) * *v4
           + (*(a2 + *(v4 + 20)) + *(this + 87)) * *(v4 + 4)
           + (*(a2 + *(v4 + 24)) + *(this + 88)) * *(v4 + 8)
           - *(v4 + 12) >= 0.0 )
          a3 &= ~(1 << i);
      }
      else
      {
        if ( *(a2 + *(v4 + 28)) * *v4 + *(a2 + *(v4 + 32)) * *(v4 + 4) + *(a2 + *(v4 + 36)) * *(v4 + 8) - *(v4 + 12) < 0.0 )
          return 0;
        if ( *(a2 + *(v4 + 16)) * *v4 + *(a2 + *(v4 + 20)) * *(v4 + 4) + *(a2 + *(v4 + 24)) * *(v4 + 8) - *(v4 + 12) >= 0.0 )
          a3 &= ~(1 << i);
      }
    }
  }
  return a3;
}

//----- (10017850) --------------------------------------------------------
CullFrustum *__thiscall CullFrustum::CullFrustum(CullFrustum *this, const struct CullFrustum *a2)
{
  struct CullingPlane *v3; // [esp+4Ch] [ebp-10h]
  CullingPlane *v4; // [esp+50h] [ebp-Ch]
  signed int v5; // [esp+54h] [ebp-8h]
  CullFrustum *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  *this = *a2;
  *(this + 1) = *(a2 + 1);
  *(this + 2) = *(a2 + 2);
  v5 = 6;
  v4 = (this + 12);
  v3 = (a2 + 12);
  do
  {
    CullingPlane::CullingPlane(v4, v3);
    v4 = (v4 + 44);
    v3 = (v3 + 44);
    --v5;
  }
  while ( v5 );
  qmemcpy(v6 + 276, a2 + 276, 0x42u);
  Vector3f::Vector3f((v6 + 344), (a2 + 344));
  Vector3f::Vector3f((v6 + 356), (a2 + 356));
  Vector3f::Vector3f((v6 + 368), (a2 + 368));
  Vector3f::Vector3f((v6 + 380), (a2 + 380));
  Vector3f::Vector3f((v6 + 392), (a2 + 392));
  Vector3f::Vector3f((v6 + 404), (a2 + 404));
  Vector3f::Vector3f((v6 + 416), (a2 + 416));
  Vector3f::Vector3f((v6 + 428), (a2 + 428));
  Vector3f::Vector3f((v6 + 440), (a2 + 440));
  *(v6 + 113) = *(a2 + 113);
  *(v6 + 114) = *(a2 + 114);
  *(v6 + 115) = *(a2 + 115);
  *(v6 + 116) = *(a2 + 116);
  *(v6 + 117) = *(a2 + 117);
  *(v6 + 118) = *(a2 + 118);
  *(v6 + 119) = *(a2 + 119);
  qmemcpy(v6 + 480, a2 + 480, 0x40u);
  qmemcpy(v6 + 544, a2 + 544, 0x40u);
  return v6;
}

//----- (10017B50) --------------------------------------------------------
void *__thiscall CullFrustum::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x260u);
  return this;
}

//----- (10017BA0) --------------------------------------------------------
void __thiscall Camera::rightDir(Camera *this, struct Vector3f *a2)
{
  *(this + 120) = *a2;
  *(this + 124) = *(a2 + 1);
  *(this + 128) = -*(a2 + 2);
}

//----- (10017C10) --------------------------------------------------------
void __thiscall Camera::upDir(Camera *this, struct Vector3f *a2)
{
  *(this + 121) = *a2;
  *(this + 125) = *(a2 + 1);
  *(this + 129) = -*(a2 + 2);
}

//----- (10017C80) --------------------------------------------------------
void __thiscall Camera::lookDir(Camera *this, struct Vector3f *a2)
{
  *(this + 122) = *a2;
  *(this + 126) = *(a2 + 1);
  *(this + 130) = -*(a2 + 2);
}

//----- (10017CF0) --------------------------------------------------------
CullFrustum *__thiscall Camera::Camera(Camera *this, const struct Camera *a2)
{
  CullFrustum *v2; // ST50_4

  v2 = this;
  CullFrustum::CullFrustum(this, a2);
  qmemcpy(v2 + 608, a2 + 608, 0x40u);
  qmemcpy(v2 + 672, a2 + 672, 0x40u);
  qmemcpy(v2 + 736, a2 + 736, 0x40u);
  Vector3f::Vector3f((v2 + 800), (a2 + 800));
  Vector3f::Vector3f((v2 + 812), (a2 + 812));
  Vector3f::Vector3f((v2 + 824), (a2 + 824));
  *(v2 + 209) = *(a2 + 209);
  return v2;
}

//----- (10017E10) --------------------------------------------------------
void *__thiscall Camera::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x348u);
  return this;
}

//----- (10017E60) --------------------------------------------------------
Camera *__thiscall LightCamera::LightCamera(LightCamera *this)
{
  Camera *v1; // ST50_4

  v1 = this;
  Camera::Camera(this);
  Vector3f::Vector3f((v1 + 860));
  *(v1 + 214) = 0;
  return v1;
}

//----- (10017ED0) --------------------------------------------------------
Camera *__thiscall LightCamera::LightCamera(LightCamera *this, const struct LightCamera *a2)
{
  Camera *v2; // ST50_4

  v2 = this;
  Camera::Camera(this, a2);
  *(v2 + 210) = *(a2 + 210);
  *(v2 + 211) = *(a2 + 211);
  *(v2 + 212) = *(a2 + 212);
  *(v2 + 213) = *(a2 + 213);
  *(v2 + 214) = *(a2 + 214);
  Vector3f::Vector3f((v2 + 860), (a2 + 860));
  return v2;
}

//----- (10017FB0) --------------------------------------------------------
void *__thiscall LightCamera::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x368u);
  return this;
}

//----- (10018000) --------------------------------------------------------
Colour *__thiscall Colour::Colour(Colour *this)
{
  return this;
}

//----- (10018030) --------------------------------------------------------
Colour *__thiscall Colour::Colour(Colour *this, char a2, char a3, char a4, unsigned __int8 a5)
{
  Colour *v5; // ST5C_4

  v5 = this;
  Colour::set(this, a2, a3, a4, a5);
  return v5;
}

//----- (10018090) --------------------------------------------------------
void __thiscall Colour::set(Colour *this, char a2, char a3, char a4, unsigned __int8 a5)
{
  *this = a2;
  *(this + 1) = a3;
  *(this + 2) = a4;
  *(this + 3) = a5;
}

//----- (100180F0) --------------------------------------------------------
void __thiscall Colour::add(Colour *this, struct Colour *a2)
{
  unsigned __int16 v2; // [esp+4Ch] [ebp-14h]
  unsigned __int16 v3; // [esp+50h] [ebp-10h]
  unsigned __int16 v4; // [esp+54h] [ebp-Ch]
  unsigned __int16 v5; // [esp+58h] [ebp-8h]

  v5 = *a2 + *this;
  if ( v5 <= 255 )
  {
    if ( v5 < 0 )
      LOBYTE(v5) = 0;
  }
  else
  {
    LOBYTE(v5) = -1;
  }
  v4 = *(a2 + 1) + *(this + 1);
  if ( v4 <= 255 )
  {
    if ( v4 < 0 )
      LOBYTE(v4) = 0;
  }
  else
  {
    LOBYTE(v4) = -1;
  }
  v3 = *(a2 + 2) + *(this + 2);
  if ( v3 <= 255 )
  {
    if ( v3 < 0 )
      LOBYTE(v3) = 0;
  }
  else
  {
    LOBYTE(v3) = -1;
  }
  v2 = *(a2 + 3) + *(this + 3);
  if ( v2 <= 255 )
  {
    if ( v2 < 0 )
      LOBYTE(v2) = 0;
    Colour::set(this, v5, v4, v3, v2);
  }
  else
  {
    Colour::set(this, v5, v4, v3, 0xFFu);
  }
}

//----- (100182A0) --------------------------------------------------------
void __thiscall Colour::lerp(Colour *this, struct Colour *a2, float a3)
{
  Colour *v3; // ST80_4

  v3 = this;
  *this = ((*a2 - *this) * a3 + *this);
  *(v3 + 1) = ((*(a2 + 1) - *(v3 + 1)) * a3 + *(v3 + 1));
  *(v3 + 2) = ((*(a2 + 2) - *(v3 + 2)) * a3 + *(v3 + 2));
  *(this + 3) = ((*(a2 + 3) - *(v3 + 3)) * a3 + *(v3 + 3));
}

//----- (100183F0) --------------------------------------------------------
void __thiscall Colour::lerpTo(Colour *this, struct Colour *a2, float a3, struct Colour *a4)
{
  unsigned __int8 *v4; // ST80_4

  v4 = this;
  *a4 = ((*a2 - *this) * a3 + *this);
  *(a4 + 1) = ((*(a2 + 1) - v4[1]) * a3 + v4[1]);
  *(a4 + 2) = ((*(a2 + 2) - v4[2]) * a3 + v4[2]);
  *(a4 + 3) = ((*(a2 + 3) - v4[3]) * a3 + v4[3]);
}

//----- (10018540) --------------------------------------------------------
void __thiscall Colour::read(Colour *this, struct Stream *a2)
{
  char v2; // al
  char v3; // al
  char v4; // al
  char v5; // al
  Colour *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  v2 = (*(*a2 + 4))(a2);
  *v6 = v2;
  v3 = (*(*a2 + 4))(a2);
  *(v6 + 1) = v3;
  v4 = (*(*a2 + 4))(a2);
  *(v6 + 2) = v4;
  v5 = (*(*a2 + 4))(a2);
  *(v6 + 3) = v5;
}

//----- (10018600) --------------------------------------------------------
_DWORD *__thiscall Colour::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  return this;
}

//----- (10018640) --------------------------------------------------------
void __thiscall ShortColour::read(ShortColour *this, struct RandomAccessStream *a2)
{
  __int16 v2; // ax
  __int16 v3; // ax
  __int16 v4; // ax
  __int16 v5; // ax
  ShortColour *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  v2 = (*(*a2 + 8))(a2);
  *v6 = v2;
  v3 = (*(*a2 + 8))(a2);
  *(v6 + 1) = v3;
  v4 = (*(*a2 + 8))(a2);
  *(v6 + 2) = v4;
  v5 = (*(*a2 + 8))(a2);
  *(v6 + 3) = v5;
}

//----- (10018710) --------------------------------------------------------
void __thiscall ShortColour::write(ShortColour *this, struct RandomAccessStream *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  ShortColour *v5; // [esp+4Ch] [ebp-4h]

  v5 = this;
  LOWORD(this) = *this;
  (*(*a2 + 36))(a2, this);
  LOWORD(v2) = *(v5 + 1);
  (*(*a2 + 36))(a2, v2);
  LOWORD(v3) = *(v5 + 2);
  (*(*a2 + 36))(a2, v3);
  LOWORD(v4) = *(v5 + 3);
  (*(*a2 + 36))(a2, v4);
}

//----- (100187E0) --------------------------------------------------------
_DWORD *__thiscall ShortColour::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10018830) --------------------------------------------------------
FontChar *__thiscall FontChar::FontChar(FontChar *this)
{
  FontChar *v1; // ST50_4

  v1 = this;
  RectArea::RectArea((this + 12));
  *(v1 + 1) = 0;
  *v1 = 0;
  *(v1 + 3) = 8;
  *(v1 + 2) = 8;
  return v1;
}

//----- (100188B0) --------------------------------------------------------
void *__thiscall FontChar::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x1Cu);
  return this;
}

//----- (10018900) --------------------------------------------------------
int __thiscall Font::stringHeight(Font *this, char *a2)
{
  return *(this + 2);
}

//----- (10018940) --------------------------------------------------------
_DWORD *__thiscall Font::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (100189A0) --------------------------------------------------------
CoreNode *__thiscall LightFlare::LightFlare(LightFlare *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, `string');
  Vector3f::Vector3f(&v1[1].name);
  v1->vtblPointer = &LightFlare::`vftable';
  return v1;
}
// 101ADBB0: using guessed type void *LightFlare::`vftable';

//----- (10018A10) --------------------------------------------------------
CoreNode *__thiscall LightFlare::LightFlare(LightFlare *this, const struct LightFlare *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  Vector3f::Vector3f(&v2[1].name, (a2 + 24));
  v2->vtblPointer = &LightFlare::`vftable';
  return v2;
}
// 101ADBB0: using guessed type void *LightFlare::`vftable';

//----- (10018A90) --------------------------------------------------------
_DWORD *__thiscall LightFlare::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // edx

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v3 = v2 + 6;
  *v3 = a2[6];
  v3[1] = a2[7];
  v3[2] = a2[8];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10018B10) --------------------------------------------------------
CoreNode *__thiscall LightGroup::LightGroup(LightGroup *this)
{
  CoreNode *v1; // ST5C_4

  v1 = this;
  CoreNode::CoreNode(this, "CoreNode");
  Vector3f::Vector3f(&v1[1].Child);
  Colour::Colour(&v1[2].Parent);
  LightFlare::LightFlare(&v1[3].name);
  v1->vtblPointer = &LightGroup::`vftable';
  v1[1].vtblPointer = 0;
  v1[1].name = 0;
  v1[1].Parent = -1;
  v1[1].Next = 0;
  CoreNode::initCore((v1 + 64), `string');
  Colour::set(&v1[2].Parent, 255, 255, 255, 0xFFu);
  v1[2].Next = 0;
  v1[3].vtblPointer = 0;
  v1[5].name = 0;
  return v1;
}
// 101ADBC8: using guessed type void *LightGroup::`vftable';

//----- (10018C30) --------------------------------------------------------
void __thiscall LightGroup::addLight(LightGroup *this, struct Vector3f *a2, float a3)
{
  _DWORD *v3; // eax
  int v4; // [esp+4Ch] [ebp-20h]
  LightFlare *hMem; // [esp+50h] [ebp-1Ch]
  LightGroup *v6; // [esp+5Ch] [ebp-10h]

  v6 = this;
  hMem = sub_10002A81(0x24u);
  if ( hMem )
    v4 = LightFlare::LightFlare(hMem);
  else
    v4 = 0;
  v3 = (v4 + 24);
  *v3 = *a2;
  v3[1] = *(a2 + 1);
  v3[2] = *(a2 + 2);
  *(v4 + 20) = a3;
  CoreNode::add((v6 + 64), v4);
}

//----- (10018D30) --------------------------------------------------------
CoreNode *__thiscall LightGroup::LightGroup(LightGroup *this, const struct LightGroup *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  Vector3f::Vector3f(&v2[1].Child, (a2 + 36));
  v2[2].Parent = *(a2 + 12);
  v2[2].Next = *(a2 + 13);
  v2[2].Child = *(a2 + 14);
  v2[3].vtblPointer = *(a2 + 15);
  LightFlare::LightFlare(&v2[3].name, (a2 + 64));
  v2[5].vtblPointer = *(a2 + 25);
  v2[5].name = *(a2 + 26);
  v2->vtblPointer = &LightGroup::`vftable';
  return v2;
}
// 101ADBC8: using guessed type void *LightGroup::`vftable';

//----- (10018E50) --------------------------------------------------------
_DWORD *__thiscall LightGroup::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // edx

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v3 = v2 + 9;
  *v3 = a2[9];
  v3[1] = a2[10];
  v3[2] = a2[11];
  v2[12] = a2[12];
  v2[13] = a2[13];
  v2[14] = a2[14];
  v2[15] = a2[15];
  LightFlare::operator=(a2 + 16);
  v2[25] = a2[25];
  v2[26] = a2[26];
  return v2;
}
// 100013CA: using guessed type _DWORD __stdcall LightFlare::operator=(_DWORD);
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10018F70) --------------------------------------------------------
CoreNode *__thiscall Light::Light(Light *this, const struct Light *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  v2[2].vtblPointer = *(a2 + 10);
  v2[2].name = *(a2 + 11);
  v2[2].Parent = *(a2 + 12);
  v2[2].Next = *(a2 + 13);
  v2[2].Child = *(a2 + 14);
  v2[3].vtblPointer = *(a2 + 15);
  v2[3].name = *(a2 + 16);
  v2[3].Parent = *(a2 + 17);
  v2[3].Next = *(a2 + 18);
  v2[3].Child = *(a2 + 19);
  v2[4].vtblPointer = *(a2 + 20);
  Vector3f::Vector3f(&v2[4].name, (a2 + 84));
  Vector3f::Vector3f(&v2[4].Child, (a2 + 96));
  v2[5].Parent = *(a2 + 27);
  v2[5].Next = *(a2 + 28);
  CullFrustum::CullFrustum(&v2[5].Child, (a2 + 116));
  v2->vtblPointer = &Light::`vftable';
  return v2;
}
// 101ADBE0: using guessed type void *Light::`vftable';

//----- (10019120) --------------------------------------------------------
_DWORD *__thiscall Light::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // edx
  _DWORD *v4; // eax

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  v2[10] = a2[10];
  v2[11] = a2[11];
  v2[12] = a2[12];
  v2[13] = a2[13];
  v2[14] = a2[14];
  v2[15] = a2[15];
  v2[16] = a2[16];
  v2[17] = a2[17];
  v2[18] = a2[18];
  v2[19] = a2[19];
  v2[20] = a2[20];
  v3 = v2 + 21;
  *v3 = a2[21];
  v3[1] = a2[22];
  v3[2] = a2[23];
  v4 = v2 + 24;
  *v4 = a2[24];
  v4[1] = a2[25];
  v4[2] = a2[26];
  v2[27] = a2[27];
  v2[28] = a2[28];
  qmemcpy(v2 + 29, a2 + 29, 0x260u);
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (100192E0) --------------------------------------------------------
void __stdcall DynCollObject::adjust(struct Creature *a2)
{
  ;
}

//----- (10019310) --------------------------------------------------------
void __stdcall DynCollObject::applyVelocity(struct Plane *a2, struct Vector3f *a3, struct Vector3f *a4)
{
  ;
}

//----- (10019340) --------------------------------------------------------
void __stdcall DynCollObject::touchCallback(struct Plane *a2, struct Vector3f *a3, struct Vector3f *a4)
{
  ;
}

//----- (10019370) --------------------------------------------------------
struct Shape *DynCollObject::getShape()
{
  return 0;
}

//----- (100193A0) --------------------------------------------------------
DynCollObject *__thiscall DynCollObject::DynCollObject(DynCollObject *this)
{
  DynCollObject *v1; // ST50_4

  v1 = this;
  Node::Node(this, `string');
  *v1 = &DynCollObject::`vftable';
  *(v1 + 8) = 0;
  *(v1 + 9) = -1;
  *(v1 + 10) = 0;
  return v1;
}
// 101ADBFC: using guessed type void *DynCollObject::`vftable';

//----- (10019420) --------------------------------------------------------
DynCollObject *__thiscall DynCollObject::DynCollObject(DynCollObject *this, const struct DynCollObject *a2)
{
  DynCollObject *v2; // ST50_4

  v2 = this;
  Node::Node(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *(v2 + 9) = *(a2 + 9);
  *(v2 + 10) = *(a2 + 10);
  *v2 = &DynCollObject::`vftable';
  return v2;
}
// 101ADBFC: using guessed type void *DynCollObject::`vftable';

//----- (100194B0) --------------------------------------------------------
_DWORD *__thiscall DynCollObject::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  Node::operator=(a2);
  v2[8] = a2[8];
  v2[9] = a2[9];
  v2[10] = a2[10];
  return v2;
}
// 1000171C: using guessed type _DWORD __stdcall Node::operator=(_DWORD);

//----- (10019530) --------------------------------------------------------
void __userpurge PVWKeyInfoU8::read(PVWKeyInfoU8 *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  char v3; // al
  char v4; // [esp+4Ch] [ebp-8h]
  PVWKeyInfoU8 *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  v3 = (*(*a3 + 4))(a3);
  *v5 = v3;
  v4 = (*(*a3 + 4))(a3);
  v4 = (*(*a3 + 4))(a3);
  v4 = (*(*a3 + 4))(a3);
  (*(*a3 + 12))(a3);
  *(v5 + 1) = a2;
  (*(*a3 + 12))(a3);
  *(v5 + 2) = a2;
}

//----- (10019630) --------------------------------------------------------
void __thiscall PVWKeyInfoU8::write(PVWKeyInfoU8 *this, struct RandomAccessStream *a2)
{
  PVWKeyInfoU8 *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  LOBYTE(this) = *this;
  (*(*a2 + 32))(a2, this);
  (*(*a2 + 32))(a2, 0);
  (*(*a2 + 32))(a2, 0);
  (*(*a2 + 32))(a2, 0);
  (*(*a2 + 40))(a2, *(v2 + 1));
  (*(*a2 + 40))(a2, *(v2 + 2));
}

//----- (10019730) --------------------------------------------------------
_DWORD *__thiscall PVWKeyInfoU8::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (10019780) --------------------------------------------------------
void __userpurge PVWKeyInfoS10::read(PVWKeyInfoS10 *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  __int16 v3; // ax
  __int16 v4; // [esp+4Ch] [ebp-8h]
  PVWKeyInfoS10 *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  v3 = (*(*a3 + 8))(a3);
  *v5 = v3;
  v4 = (*(*a3 + 8))(a3);
  (*(*a3 + 12))(a3);
  *(v5 + 1) = a2;
  (*(*a3 + 12))(a3);
  *(v5 + 2) = a2;
}

//----- (10019840) --------------------------------------------------------
bool __thiscall PVWKeyInfoS10::isSame(PVWKeyInfoS10 *this, struct PVWKeyInfoS10 *a2)
{
  return *this == *a2 && *(this + 1) == *(a2 + 1) && *(this + 2) == *(a2 + 2);
}

//----- (100198C0) --------------------------------------------------------
void __thiscall PVWKeyInfoS10::write(PVWKeyInfoS10 *this, struct RandomAccessStream *a2)
{
  PVWKeyInfoS10 *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  LOWORD(this) = *this;
  (*(*a2 + 36))(a2, this);
  (*(*a2 + 36))(a2, 0);
  (*(*a2 + 40))(a2, *(v2 + 1));
  (*(*a2 + 40))(a2, *(v2 + 2));
}

//----- (10019980) --------------------------------------------------------
_DWORD *__thiscall PVWKeyInfoS10::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (100199D0) --------------------------------------------------------
void __userpurge PVWKeyInfoF32::read(PVWKeyInfoF32 *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  float *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*a3 + 12))(a3);
  *v3 = a2;
  (*(*a3 + 12))(a3);
  v3[1] = a2;
  (*(*a3 + 12))(a3);
  v3[2] = a2;
}

//----- (10019A70) --------------------------------------------------------
void __thiscall PVWKeyInfoF32::write(PVWKeyInfoF32 *this, struct RandomAccessStream *a2)
{
  PVWKeyInfoF32 *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 40))(a2, *this);
  (*(*a2 + 40))(a2, *(v2 + 1));
  (*(*a2 + 40))(a2, *(v2 + 2));
}

//----- (10019B10) --------------------------------------------------------
_DWORD *__thiscall PVWKeyInfoF32::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (10019B60) --------------------------------------------------------
_DWORD *__thiscall PVWTexAnimInfo::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10019BB0) --------------------------------------------------------
_DWORD *__thiscall PVWColourAnimInfo::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10019C00) --------------------------------------------------------
_DWORD *__thiscall PVWAlphaAnimInfo::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10019C50) --------------------------------------------------------
_DWORD *__thiscall PVWColourShortAnimInfo::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10019CA0) --------------------------------------------------------
_DWORD *__thiscall PVWAlphaShortAnimInfo::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10019CF0) --------------------------------------------------------
Colour *__thiscall PVWPolygonColourInfo::PVWPolygonColourInfo(PVWPolygonColourInfo *this)
{
  Colour *v1; // ST50_4

  v1 = this;
  Colour::Colour(this);
  *(v1 + 7) = 0;
  return v1;
}

//----- (10019D50) --------------------------------------------------------
void __userpurge PVWPolygonColourInfo::read(PVWPolygonColourInfo *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  int v3; // eax
  Colour *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  Colour::read(this, a3);
  v3 = (**a3)(a3);
  *(v4 + 1) = v3;
  (*(*a3 + 12))(a3);
  *(v4 + 2) = a2;
  sub_10002298(a3);
  sub_1000166D(a3);
}

//----- (10019E00) --------------------------------------------------------
int __thiscall sub_10019E00(_DWORD *this, struct RandomAccessStream *a2)
{
  int result; // eax
  int v3; // ecx
  int v4; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]
  _DWORD *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  result = (**a2)(a2);
  *v6 = result;
  if ( *v6 )
  {
    v4 = sub_10001AC3(40 * *v6);
    v6[1] = v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *v6 )
        break;
      v3 = v6[1];
      sub_1000190B(a2);
    }
  }
  return result;
}

//----- (10019ED0) --------------------------------------------------------
unsigned int __thiscall sub_10019ED0(unsigned int *this, struct RandomAccessStream *a2)
{
  unsigned int result; // eax
  unsigned int v3; // ecx
  int v4; // [esp+4Ch] [ebp-Ch]
  unsigned int i; // [esp+50h] [ebp-8h]
  unsigned int *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  result = (**a2)(a2);
  *v6 = result;
  if ( *v6 )
  {
    v4 = sub_10001AC3(16 * *v6);
    v6[1] = v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *v6 )
        break;
      v3 = v6[1];
      sub_1000159B(a2);
    }
  }
  return result;
}

//----- (10019FA0) --------------------------------------------------------
void __thiscall sub_10019FA0(int *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v2 = (**a2)(a2);
  *v3 = v2;
  PVWKeyInfoU8::read((v3 + 1), a2);
  PVWKeyInfoU8::read((v3 + 4), a2);
  PVWKeyInfoU8::read((v3 + 7), a2);
}

//----- (1001A040) --------------------------------------------------------
void __thiscall sub_1001A040(int *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v2 = (**a2)(a2);
  *v3 = v2;
  PVWKeyInfoU8::read((v3 + 1), a2);
}

//----- (1001A0B0) --------------------------------------------------------
void __thiscall PVWPolygonColourInfo::write(PVWPolygonColourInfo *this, struct RandomAccessStream *a2)
{
  Colour *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  Colour::write(this, a2);
  (*(*a2 + 28))(a2, *(v2 + 1));
  (*(*a2 + 40))(a2, *(v2 + 2));
  sub_10002B1C(a2);
  sub_10001848(a2);
}

//----- (1001A170) --------------------------------------------------------
int __thiscall sub_1001A170(_DWORD *this, struct RandomAccessStream *a2)
{
  int result; // eax
  int v3; // ecx
  int i; // [esp+4Ch] [ebp-8h]
  _DWORD *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  (*(*a2 + 28))(a2, *this);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *v5 )
      break;
    v3 = v5[1];
    sub_100016FE(a2);
  }
  return result;
}

//----- (1001A210) --------------------------------------------------------
int __thiscall sub_1001A210(_DWORD *this, struct RandomAccessStream *a2)
{
  int result; // eax
  int v3; // ecx
  int i; // [esp+4Ch] [ebp-8h]
  _DWORD *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  (*(*a2 + 28))(a2, *this);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *v5 )
      break;
    v3 = v5[1];
    sub_1000253B(a2);
  }
  return result;
}

//----- (1001A2B0) --------------------------------------------------------
void __thiscall sub_1001A2B0(_DWORD *this, struct RandomAccessStream *a2)
{
  _DWORD *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
  PVWKeyInfoU8::write((v2 + 1), a2);
  PVWKeyInfoU8::write((v2 + 4), a2);
  PVWKeyInfoU8::write((v2 + 7), a2);
}

//----- (1001A350) --------------------------------------------------------
void __thiscall sub_1001A350(_DWORD *this, struct RandomAccessStream *a2)
{
  _DWORD *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
  PVWKeyInfoU8::write((v2 + 1), a2);
}

//----- (1001A3C0) --------------------------------------------------------
void *__thiscall PVWPolygonColourInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x20u);
  return this;
}

//----- (1001A410) --------------------------------------------------------
PVWLightingInfo *__thiscall PVWLightingInfo::PVWLightingInfo(PVWLightingInfo *this)
{
  *(this + 1) = 1;
  *this = 1;
  *(this + 2) = 1112014848;
  return this;
}

//----- (1001A470) --------------------------------------------------------
_DWORD *__thiscall PVWLightingInfo::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (1001A4C0) --------------------------------------------------------
void __thiscall PVWPeInfo::read(PVWPeInfo *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  PVWPeInfo *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  v2 = (**a2)(a2);
  *v6 = v2;
  v3 = (**a2)(a2);
  *(v6 + 1) = v3;
  v4 = (**a2)(a2);
  *(v6 + 2) = v4;
  v5 = (**a2)(a2);
  *(v6 + 3) = v5;
}

//----- (1001A580) --------------------------------------------------------
void __thiscall PVWPeInfo::write(PVWPeInfo *this, struct RandomAccessStream *a2)
{
  PVWPeInfo *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
  (*(*a2 + 28))(a2, *(v2 + 1));
  (*(*a2 + 28))(a2, *(v2 + 2));
  (*(*a2 + 28))(a2, *(v2 + 3));
}

//----- (1001A650) --------------------------------------------------------
_DWORD *__thiscall PVWPeInfo::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (1001A6B0) --------------------------------------------------------
PVWTextureData *__thiscall PVWTextureData::PVWTextureData(PVWTextureData *this)
{
  PVWTextureData *v1; // ST50_4

  v1 = this;
  Matrix4f::Matrix4f((this + 92));
  *(v1 + 22) = 0;
  *(v1 + 2) = 0;
  *(v1 + 22) = 0;
  return v1;
}

//----- (1001A720) --------------------------------------------------------
void *__thiscall PVWTextureData::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x9Cu);
  return this;
}

//----- (1001A770) --------------------------------------------------------
_DWORD *__thiscall PVWTexGenData::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  return this;
}

//----- (1001A7B0) --------------------------------------------------------
Vector3f *__thiscall PVWTextureInfo::PVWTextureInfo(PVWTextureInfo *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  *(v1 + 6) = 0;
  *(v1 + 4) = 0;
  return v1;
}

//----- (1001A810) --------------------------------------------------------
void __thiscall PVWTextureInfo::write(PVWTextureInfo *this, struct RandomAccessStream *a2)
{
  unsigned int j; // [esp+4Ch] [ebp-Ch]
  unsigned int i; // [esp+50h] [ebp-8h]
  Vector3f *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  (*(*a2 + 28))(a2, *(this + 5));
  Vector3f::write(v4, a2);
  (*(*a2 + 28))(a2, *(v4 + 4));
  for ( i = 0; i < *(v4 + 4); ++i )
    PVWTexGenData::write((*(v4 + 8) + 4 * i), a2);
  (*(*a2 + 28))(a2, *(v4 + 3));
  for ( j = 0; j < *(v4 + 3); ++j )
    PVWTextureData::write((*(v4 + 7) + 156 * j), a2);
}

//----- (1001A950) --------------------------------------------------------
Vector3f *__thiscall PVWTextureInfo::PVWTextureInfo(PVWTextureInfo *this, const struct PVWTextureInfo *a2)
{
  Vector3f *v2; // ST50_4

  v2 = this;
  Vector3f::Vector3f(this, a2);
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  *(v2 + 5) = *(a2 + 5);
  *(v2 + 6) = *(a2 + 6);
  *(v2 + 7) = *(a2 + 7);
  *(v2 + 8) = *(a2 + 8);
  return v2;
}

//----- (1001AA00) --------------------------------------------------------
void *__thiscall PVWTextureInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (1001AA50) --------------------------------------------------------
void __thiscall PVWCombiner::read(PVWCombiner *this, struct RandomAccessStream *a2)
{
  char v2; // al
  char v3; // al
  char v4; // al
  char v5; // al
  char v6; // al
  char v7; // al
  char v8; // al
  char v9; // al
  char v10; // al
  char v11; // al
  char v12; // al
  char v13; // al
  PVWCombiner *v14; // [esp+4Ch] [ebp-4h]

  v14 = this;
  v2 = (*(*a2 + 4))(a2);
  *v14 = v2;
  v3 = (*(*a2 + 4))(a2);
  *(v14 + 1) = v3;
  v4 = (*(*a2 + 4))(a2);
  *(v14 + 2) = v4;
  v5 = (*(*a2 + 4))(a2);
  *(v14 + 3) = v5;
  v6 = (*(*a2 + 4))(a2);
  *(v14 + 4) = v6;
  v7 = (*(*a2 + 4))(a2);
  *(v14 + 5) = v7;
  v8 = (*(*a2 + 4))(a2);
  *(v14 + 6) = v8;
  v9 = (*(*a2 + 4))(a2);
  *(v14 + 7) = v9;
  v10 = (*(*a2 + 4))(a2);
  *(v14 + 8) = v10;
  v11 = (*(*a2 + 4))(a2);
  *(v14 + 9) = v11;
  v12 = (*(*a2 + 4))(a2);
  *(v14 + 10) = v12;
  v13 = (*(*a2 + 4))(a2);
  *(v14 + 11) = v13;
}

//----- (1001AC10) --------------------------------------------------------
void __thiscall PVWCombiner::write(PVWCombiner *this, struct RandomAccessStream *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  PVWCombiner *v13; // [esp+4Ch] [ebp-4h]

  v13 = this;
  LOBYTE(this) = *this;
  (*(*a2 + 32))(a2, this);
  LOBYTE(v2) = *(v13 + 1);
  (*(*a2 + 32))(a2, v2);
  LOBYTE(v3) = *(v13 + 2);
  (*(*a2 + 32))(a2, v3);
  LOBYTE(v4) = *(v13 + 3);
  (*(*a2 + 32))(a2, v4);
  LOBYTE(v5) = *(v13 + 4);
  (*(*a2 + 32))(a2, v5);
  LOBYTE(v6) = *(v13 + 5);
  (*(*a2 + 32))(a2, v6);
  LOBYTE(v7) = *(v13 + 6);
  (*(*a2 + 32))(a2, v7);
  LOBYTE(v8) = *(v13 + 7);
  (*(*a2 + 32))(a2, v8);
  LOBYTE(v9) = *(v13 + 8);
  (*(*a2 + 32))(a2, v9);
  LOBYTE(v10) = *(v13 + 9);
  (*(*a2 + 32))(a2, v10);
  LOBYTE(v11) = *(v13 + 10);
  (*(*a2 + 32))(a2, v11);
  LOBYTE(v12) = *(v13 + 11);
  (*(*a2 + 32))(a2, v12);
}

//----- (1001ADE0) --------------------------------------------------------
_DWORD *__thiscall PVWCombiner::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (1001AE30) --------------------------------------------------------
void __thiscall PVWTevStage::read(PVWTevStage *this, struct RandomAccessStream *a2)
{
  char v2; // al
  char v3; // al
  char v4; // al
  char v5; // al
  char v6; // al
  char v7; // al
  char v8; // [esp+4Ch] [ebp-8h]
  PVWTevStage *v9; // [esp+50h] [ebp-4h]

  v9 = this;
  v2 = (*(*a2 + 4))(a2);
  *v9 = v2;
  v3 = (*(*a2 + 4))(a2);
  *(v9 + 1) = v3;
  v4 = (*(*a2 + 4))(a2);
  *(v9 + 2) = v4;
  v5 = (*(*a2 + 4))(a2);
  *(v9 + 3) = v5;
  v6 = (*(*a2 + 4))(a2);
  *(v9 + 4) = v6;
  v7 = (*(*a2 + 4))(a2);
  *(v9 + 5) = v7;
  v8 = (*(*a2 + 4))(a2);
  v8 = (*(*a2 + 4))(a2);
  PVWCombiner::read((v9 + 6), a2);
  PVWCombiner::read((v9 + 18), a2);
}

//----- (1001AF90) --------------------------------------------------------
void __thiscall PVWTevStage::write(PVWTevStage *this, struct RandomAccessStream *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  PVWTevStage *v7; // [esp+4Ch] [ebp-4h]

  v7 = this;
  LOBYTE(this) = *this;
  (*(*a2 + 32))(a2, this);
  LOBYTE(v2) = *(v7 + 1);
  (*(*a2 + 32))(a2, v2);
  LOBYTE(v3) = *(v7 + 2);
  (*(*a2 + 32))(a2, v3);
  LOBYTE(v4) = *(v7 + 3);
  (*(*a2 + 32))(a2, v4);
  LOBYTE(v5) = *(v7 + 4);
  (*(*a2 + 32))(a2, v5);
  LOBYTE(v6) = *(v7 + 5);
  (*(*a2 + 32))(a2, v6);
  (*(*a2 + 32))(a2, 0);
  (*(*a2 + 32))(a2, 0);
  PVWCombiner::write((v7 + 6), a2);
  PVWCombiner::write((v7 + 18), a2);
}

//----- (1001B100) --------------------------------------------------------
void *__thiscall PVWTevStage::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x1Eu);
  return this;
}

//----- (1001B150) --------------------------------------------------------
PVWTevColReg *__thiscall PVWTevColReg::PVWTevColReg(PVWTevColReg *this)
{
  *(this + 8) = 0;
  return this;
}

//----- (1001B190) --------------------------------------------------------
void __userpurge PVWTevColReg::read(PVWTevColReg *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  int v3; // eax
  ShortColour *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  ShortColour::read(this, a3);
  v3 = (**a3)(a3);
  *(v4 + 2) = v3;
  (*(*a3 + 12))(a3);
  *(v4 + 3) = a2;
  sub_100028E2(a3);
  sub_1000138E(a3);
}

//----- (1001B240) --------------------------------------------------------
int __thiscall sub_1001B240(_DWORD *this, struct RandomAccessStream *a2)
{
  int result; // eax
  int v3; // ecx
  int v4; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]
  _DWORD *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  result = (**a2)(a2);
  *v6 = result;
  if ( *v6 )
  {
    v4 = sub_10001AC3(40 * *v6);
    v6[1] = v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *v6 )
        break;
      v3 = v6[1];
      sub_100017AD(a2);
    }
  }
  return result;
}

//----- (1001B310) --------------------------------------------------------
unsigned int __thiscall sub_1001B310(unsigned int *this, struct RandomAccessStream *a2)
{
  unsigned int result; // eax
  unsigned int v3; // ecx
  int v4; // [esp+4Ch] [ebp-Ch]
  unsigned int i; // [esp+50h] [ebp-8h]
  unsigned int *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  result = (**a2)(a2);
  *v6 = result;
  if ( *v6 )
  {
    v4 = sub_10001AC3(16 * *v6);
    v6[1] = v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *v6 )
        break;
      v3 = v6[1];
      sub_1000207C(a2);
    }
  }
  return result;
}

//----- (1001B3E0) --------------------------------------------------------
void __thiscall sub_1001B3E0(int *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v2 = (**a2)(a2);
  *v3 = v2;
  PVWKeyInfoS10::read((v3 + 1), a2);
  PVWKeyInfoS10::read((v3 + 4), a2);
  PVWKeyInfoS10::read((v3 + 7), a2);
}

//----- (1001B480) --------------------------------------------------------
void __thiscall sub_1001B480(int *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v2 = (**a2)(a2);
  *v3 = v2;
  PVWKeyInfoS10::read((v3 + 1), a2);
}

//----- (1001B4F0) --------------------------------------------------------
bool __thiscall PVWTevColReg::isSame(PVWTevColReg *this, struct PVWTevColReg *a2)
{
  if ( *this != *a2 || *(this + 1) != *(a2 + 1) || *(this + 2) != *(a2 + 2) || *(this + 3) != *(a2 + 3) )
    return 0;
  if ( *(this + 2) != *(a2 + 2) )
    return 0;
  if ( sub_1000295F(a2 + 16) )
    return sub_10002D83(a2 + 24) != 0;
  return 0;
}
// 1000295F: using guessed type _DWORD __stdcall sub_1000295F(_DWORD);
// 10002D83: using guessed type _DWORD __stdcall sub_10002D83(_DWORD);

//----- (1001B5F0) --------------------------------------------------------
char __thiscall sub_1001B5F0(unsigned int *this, _DWORD *a2)
{
  unsigned int v3; // ecx
  unsigned int i; // [esp+4Ch] [ebp-8h]
  unsigned int *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  if ( *this != *a2 )
    return 0;
  for ( i = 0; i < *v5; ++i )
  {
    v3 = v5[1];
    if ( !sub_10001DA7(40 * i + a2[1]) )
      return 0;
  }
  return 1;
}
// 10001DA7: using guessed type _DWORD __stdcall sub_10001DA7(_DWORD);

//----- (1001B6B0) --------------------------------------------------------
char __thiscall sub_1001B6B0(unsigned int *this, _DWORD *a2)
{
  unsigned int v3; // ecx
  unsigned int i; // [esp+4Ch] [ebp-8h]
  unsigned int *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  if ( *this != *a2 )
    return 0;
  for ( i = 0; i < *v5; ++i )
  {
    v3 = v5[1];
    if ( !sub_100022B6(16 * i + a2[1]) )
      return 0;
  }
  return 1;
}
// 100022B6: using guessed type _DWORD __stdcall sub_100022B6(_DWORD);

//----- (1001B770) --------------------------------------------------------
bool __thiscall sub_1001B770(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  return *this == *a2
      && PVWKeyInfoS10::isSame((this + 1), (a2 + 1))
      && PVWKeyInfoS10::isSame((v3 + 4), (a2 + 4))
      && PVWKeyInfoS10::isSame((v3 + 7), (a2 + 7));
}

//----- (1001B830) --------------------------------------------------------
bool __thiscall sub_1001B830(_DWORD *this, _DWORD *a2)
{
  return *this == *a2 && PVWKeyInfoS10::isSame((this + 1), (a2 + 1));
}

//----- (1001B8B0) --------------------------------------------------------
void __thiscall PVWTevColReg::write(PVWTevColReg *this, struct RandomAccessStream *a2)
{
  ShortColour *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  ShortColour::write(this, a2);
  (*(*a2 + 28))(a2, *(v2 + 2));
  (*(*a2 + 40))(a2, *(v2 + 3));
  sub_100028F6(a2);
  sub_100021D5(a2);
}

//----- (1001B970) --------------------------------------------------------
int __thiscall sub_1001B970(_DWORD *this, struct RandomAccessStream *a2)
{
  int result; // eax
  int v3; // ecx
  int i; // [esp+4Ch] [ebp-8h]
  _DWORD *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  (*(*a2 + 28))(a2, *this);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *v5 )
      break;
    v3 = v5[1];
    sub_1000293C(a2);
  }
  return result;
}

//----- (1001BA10) --------------------------------------------------------
int __thiscall sub_1001BA10(_DWORD *this, struct RandomAccessStream *a2)
{
  int result; // eax
  int v3; // ecx
  int i; // [esp+4Ch] [ebp-8h]
  _DWORD *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  (*(*a2 + 28))(a2, *this);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *v5 )
      break;
    v3 = v5[1];
    sub_100023F1(a2);
  }
  return result;
}

//----- (1001BAB0) --------------------------------------------------------
void __thiscall sub_1001BAB0(_DWORD *this, struct RandomAccessStream *a2)
{
  _DWORD *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
  PVWKeyInfoS10::write((v2 + 1), a2);
  PVWKeyInfoS10::write((v2 + 4), a2);
  PVWKeyInfoS10::write((v2 + 7), a2);
}

//----- (1001BB50) --------------------------------------------------------
void __thiscall sub_1001BB50(_DWORD *this, struct RandomAccessStream *a2)
{
  _DWORD *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, *this);
  PVWKeyInfoS10::write((v2 + 1), a2);
}

//----- (1001BBC0) --------------------------------------------------------
void *__thiscall PVWTevColReg::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (1001BC10) --------------------------------------------------------
void __thiscall PVWTevInfo::read(PVWTevInfo *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // [esp+4Ch] [ebp-Ch]
  unsigned int i; // [esp+50h] [ebp-8h]
  PVWTevColReg *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  PVWTevColReg::read(this, a2);
  PVWTevColReg::read((v5 + 36), a2);
  PVWTevColReg::read((v5 + 72), a2);
  Colour::read((v5 + 108), a2);
  Colour::read((v5 + 112), a2);
  Colour::read((v5 + 116), a2);
  Colour::read((v5 + 120), a2);
  v2 = (**a2)(a2);
  *(v5 + 31) = v2;
  if ( *(v5 + 31) )
  {
    v3 = sub_10001AC3(30 * *(v5 + 31));
    *(v5 + 32) = v3;
    for ( i = 0; i < *(v5 + 31); ++i )
      PVWTevStage::read((30 * i + *(v5 + 32)), a2);
  }
}

//----- (1001BD70) --------------------------------------------------------
void __thiscall PVWTevInfo::write(PVWTevInfo *this, struct RandomAccessStream *a2)
{
  unsigned int i; // [esp+4Ch] [ebp-8h]
  PVWTevColReg *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  PVWTevColReg::write(this, a2);
  PVWTevColReg::write((v3 + 36), a2);
  PVWTevColReg::write((v3 + 72), a2);
  Colour::write((v3 + 108), a2);
  Colour::write((v3 + 112), a2);
  Colour::write((v3 + 116), a2);
  Colour::write((v3 + 120), a2);
  (*(*a2 + 28))(a2, *(v3 + 31));
  for ( i = 0; i < *(v3 + 31); ++i )
    PVWTevStage::write((*(v3 + 32) + 30 * i), a2);
}

//----- (1001BEA0) --------------------------------------------------------
PVWTevInfo *__thiscall PVWTevInfo::PVWTevInfo(PVWTevInfo *this)
{
  PVWTevInfo *v1; // ST5C_4

  v1 = this;
  sub_1000291E(this, 36, 3, PVWTevColReg::PVWTevColReg);
  sub_1000291E(v1 + 108, 4, 4, Colour::Colour);
  return v1;
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1001BF10) --------------------------------------------------------
void *__thiscall PVWTevInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x84u);
  return this;
}

//----- (1001BF60) --------------------------------------------------------
Material *__thiscall Material::Material(Material *this)
{
  Material *v1; // ST5C_4
  Colour *v2; // eax

  v1 = this;
  CoreNode::CoreNode(this, "material");
  PVWPolygonColourInfo::PVWPolygonColourInfo((v1 + 44));
  PVWLightingInfo::PVWLightingInfo((v1 + 76));
  PVWTextureInfo::PVWTextureInfo((v1 + 104));
  *v1 = &Material::`vftable';
  *(v1 + 5) = 0;
  *(v1 + 10) = 0;
  *(v1 + 9) = 0;
  *(v1 + 8) = 0;
  *(v1 + 10) = 0;
  *(v1 + 6) = 256;
  v2 = Material::Colour(v1);
  Colour::set(v2, 255, 255, 255, 0xFFu);
  *(v1 + 35) = 0;
  *(v1 + 38) = 0;
  return v1;
}
// 101ADC50: using guessed type void *Material::`vftable';

//----- (1001C080) --------------------------------------------------------
void __thiscall Material::setColour(Material *this, struct Colour *a2)
{
  if ( *(this + 19) & 2 )
  {
    **(this + 36) = *a2;
    *(*(this + 36) + 2) = *(a2 + 1);
    *(*(this + 36) + 4) = *(a2 + 2);
    *(*(this + 36) + 6) = *(a2 + 3);
  }
  else
  {
    *(this + 11) = *a2;
  }
}

//----- (1001C140) --------------------------------------------------------
void __thiscall Material::getColour(Material *this, struct Colour *a2)
{
  if ( *(this + 19) & 2 )
  {
    *a2 = **(this + 36);
    *(a2 + 1) = *(*(this + 36) + 2);
    *(a2 + 2) = *(*(this + 36) + 4);
    *(a2 + 3) = *(*(this + 36) + 6);
  }
  else
  {
    *a2 = *(this + 11);
  }
}

//----- (1001C1F0) --------------------------------------------------------
struct Colour *__thiscall Material::Colour(Material *this)
{
  return (this + 44);
}

//----- (1001C230) --------------------------------------------------------
Material *__thiscall Material::Material(Material *this, const struct Material *a2)
{
  Material *v2; // ST50_4
  int v3; // edx
  _DWORD *v4; // eax

  v2 = this;
  CoreNode::CoreNode(this, a2);
  *(v2 + 5) = *(a2 + 5);
  *(v2 + 6) = *(a2 + 6);
  *(v2 + 7) = *(a2 + 7);
  *(v2 + 8) = *(a2 + 8);
  *(v2 + 9) = *(a2 + 9);
  *(v2 + 10) = *(a2 + 10);
  qmemcpy(v2 + 44, a2 + 44, 0x24u);
  v3 = v2 + 76;
  *(v3 + 4) = *(a2 + 20);
  *(v3 + 8) = *(a2 + 21);
  v4 = (v2 + 88);
  *v4 = *(a2 + 22);
  v4[1] = *(a2 + 23);
  v4[2] = *(a2 + 24);
  v4[3] = *(a2 + 25);
  PVWTextureInfo::PVWTextureInfo((v2 + 104), (a2 + 104));
  *(v2 + 35) = *(a2 + 35);
  *(v2 + 36) = *(a2 + 36);
  *(v2 + 37) = *(a2 + 37);
  *(v2 + 38) = *(a2 + 38);
  *v2 = &Material::`vftable';
  return v2;
}
// 101ADC50: using guessed type void *Material::`vftable';

//----- (1001C3C0) --------------------------------------------------------
_DWORD *__thiscall Material::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  int v3; // edx
  _DWORD *v4; // eax

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  v2[10] = a2[10];
  qmemcpy(v2 + 11, a2 + 11, 0x24u);
  v3 = (v2 + 19);
  *(v3 + 4) = a2[20];
  *(v3 + 8) = a2[21];
  v4 = v2 + 22;
  *v4 = a2[22];
  v4[1] = a2[23];
  v4[2] = a2[24];
  v4[3] = a2[25];
  qmemcpy(v2 + 26, a2 + 26, 0x34u);
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001C540) --------------------------------------------------------
LodInfo *__thiscall LodInfo::LodInfo(LodInfo *this)
{
  *(this + 2) = 0;
  *(this + 4) = 0;
  return this;
}

//----- (1001C590) --------------------------------------------------------
void *__thiscall LodInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x14u);
  return this;
}

//----- (1001C5E0) --------------------------------------------------------
BoundBox *__thiscall GfxInfo::GfxInfo(GfxInfo *this)
{
  BoundBox *v1; // ST50_4

  v1 = this;
  BoundBox::BoundBox(this);
  *(v1 + 9) = 0;
  *(v1 + 10) = 0;
  *(v1 + 7) = 0;
  return v1;
}

//----- (1001C650) --------------------------------------------------------
BoundBox *__thiscall GfxInfo::GfxInfo(GfxInfo *this, const struct GfxInfo *a2)
{
  BoundBox *v2; // ST50_4

  v2 = this;
  BoundBox::BoundBox(this, a2);
  *(v2 + 12) = *(a2 + 12);
  *(v2 + 13) = *(a2 + 13);
  *(v2 + 7) = *(a2 + 7);
  *(v2 + 8) = *(a2 + 8);
  *(v2 + 9) = *(a2 + 9);
  *(v2 + 10) = *(a2 + 10);
  return v2;
}

//----- (1001C700) --------------------------------------------------------
void *__thiscall GfxInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x2Cu);
  return this;
}

//----- (1001C750) --------------------------------------------------------
AnimJoint *__thiscall AnimJoint::AnimJoint(AnimJoint *this)
{
  return this;
}

//----- (1001C780) --------------------------------------------------------
void *__thiscall AnimJoint::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (1001C7D0) --------------------------------------------------------
AnimPalette *__thiscall AnimPalette::AnimPalette(AnimPalette *this, int a2, int a3)
{
  HGLOBAL v4; // [esp+4Ch] [ebp-20h]
  HGLOBAL hMem; // [esp+50h] [ebp-1Ch]
  AnimPalette *v6; // [esp+5Ch] [ebp-10h]

  v6 = this;
  *this = a2;
  *(this + 1) = a3;
  hMem = sub_10001AC3(36 * a3);
  if ( hMem )
  {
    sub_1000291E(hMem, 36, a3, AnimJoint::AnimJoint);
    v4 = hMem;
  }
  else
  {
    v4 = 0;
  }
  *(v6 + 2) = v4;
  return v6;
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1001C8D0) --------------------------------------------------------
void *__thiscall AnimPalette::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x24u);
  return this;
}

//----- (1001C920) --------------------------------------------------------
String *__thiscall String::String(String *this)
{
  String *v1; // ST50_4

  v1 = this;
  String::init(this, 64);
  return v1;
}

//----- (1001C970) --------------------------------------------------------
String *__thiscall String::String(String *this, int a2)
{
  String *v2; // ST50_4

  v2 = this;
  String::init(this, a2);
  return v2;
}

//----- (1001C9C0) --------------------------------------------------------
String *__thiscall String::String(String *this, char *a2, int a3)
{
  String *v3; // ST54_4

  v3 = this;
  String::init(this, a2, a3);
  return v3;
}

//----- (1001CA20) --------------------------------------------------------
void __thiscall String::init(String *this, char *a2)
{
  *(this + 1) = a2;
}

//----- (1001CA60) --------------------------------------------------------
void __thiscall String::init(String *this, int a2)
{
  int v2; // [esp+4Ch] [ebp-Ch]
  String *v3; // [esp+54h] [ebp-4h]

  v3 = this;
  if ( a2 )
    v2 = sub_10001AC3(a2 + 1);
  else
    v2 = 0;
  *(v3 + 1) = v2;
  *v3 = a2;
}

//----- (1001CAF0) --------------------------------------------------------
void __thiscall String::init(String *this, char *a2, int a3)
{
  *(this + 1) = a2;
  *this = a3;
}

//----- (1001CB40) --------------------------------------------------------
bool __cdecl String::equals(char *a1, char *a2)
{
  return String::isSame(a1, a2);
}

//----- (1001CB90) --------------------------------------------------------
bool __thiscall String::isSame(String *this, struct String *a2)
{
  return String::isSame(this, *(a2 + 1));
}

//----- (1001CBE0) --------------------------------------------------------
bool __cdecl String::contains(char *a1, char a2)
{
  char v3; // [esp+4Ch] [ebp-4h]
  char v4; // [esp+4Dh] [ebp-3h]

  v3 = a2;
  v4 = 0;
  return String::contains(a1, &v3);
}

//----- (1001CC40) --------------------------------------------------------
bool __thiscall String::contains(String *this, char *a2)
{
  return String::contains(*(this + 1), a2);
}

//----- (1001CCA0) --------------------------------------------------------
char *__thiscall String::dup(String *this)
{
  return String::dup(*(this + 1));
}

//----- (1001CCF0) --------------------------------------------------------
bool __cdecl String::isWhiteSpace(char a1)
{
  return a1 == 32 || a1 == 9 || a1 == 13 || a1 == 10 || a1 < 32;
}

//----- (1001CD70) --------------------------------------------------------
_DWORD *__thiscall String::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (1001CDC0) --------------------------------------------------------
Envelope *__thiscall Envelope::Envelope(Envelope *this)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  return this;
}

//----- (1001CE20) --------------------------------------------------------
_DWORD *__thiscall Envelope::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (1001CE70) --------------------------------------------------------
void __thiscall VtxMatrix::read(VtxMatrix *this, struct RandomAccessStream *a2)
{
  int v2; // [esp+4Ch] [ebp-8h]
  VtxMatrix *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  v2 = (*(*a2 + 8))(a2);
  *v3 = v2 >= 0;
  if ( *v3 )
    *(v3 + 1) = v2;
  else
    *(v3 + 1) = -v2 - 1;
}

//----- (1001CF10) --------------------------------------------------------
void __thiscall VtxMatrix::write(VtxMatrix *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  VtxMatrix *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  HIWORD(v2) = HIWORD(this);
  if ( *this )
  {
    LOWORD(v2) = *(v3 + 2);
    (*(*a2 + 36))(a2, v2);
  }
  else
  {
    (*(*a2 + 36))(a2, -(*(v3 + 1) + 1));
  }
}

//----- (1001CFB0) --------------------------------------------------------
_DWORD *__thiscall VtxMatrix::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (1001D000) --------------------------------------------------------
CoreNode *__thiscall FaceNode::FaceNode(FaceNode *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "face");
  v1->vtblPointer = &FaceNode::`vftable';
  return v1;
}
// 101ADC78: using guessed type void *FaceNode::`vftable';

//----- (1001D060) --------------------------------------------------------
CoreNode *__thiscall FaceNode::FaceNode(FaceNode *this, int a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, "face");
  v2->vtblPointer = &FaceNode::`vftable';
  v2[1].vtblPointer = a2;
  v2[1].name = 0;
  v2[1].Parent = 0;
  v2[1].Next = 0;
  v2[1].Child = 0;
  v2[2].vtblPointer = 0;
  v2[2].name = 0;
  v2[2].Parent = 0;
  v2[2].Next = 0;
  v2[2].Child = 0;
  v2[3].vtblPointer = 0;
  v2[3].name = 0;
  v2[3].Parent = 0;
  return v2;
}
// 101ADC78: using guessed type void *FaceNode::`vftable';

//----- (1001D160) --------------------------------------------------------
CoreNode *__thiscall FaceNode::FaceNode(FaceNode *this, const struct FaceNode *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  qmemcpy(&v2[2], a2 + 40, 0x20u);
  v2->vtblPointer = &FaceNode::`vftable';
  return v2;
}
// 101ADC78: using guessed type void *FaceNode::`vftable';

//----- (1001D220) --------------------------------------------------------
_DWORD *__thiscall FaceNode::operator=(_DWORD *this, _DWORD *a2)
{
  unsigned int i; // [esp+4Ch] [ebp-8h]
  _DWORD *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  CoreNode::operator=(a2);
  v4[5] = a2[5];
  v4[6] = a2[6];
  v4[7] = a2[7];
  v4[8] = a2[8];
  v4[9] = a2[9];
  for ( i = 0; i < 8; ++i )
    v4[i + 10] = a2[i + 10];
  return v4;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001D300) --------------------------------------------------------
CoreNode *__thiscall DispList::DispList(DispList *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "CoreNode");
  FaceNode::FaceNode(&v1[2].name);
  v1->vtblPointer = &DispList::`vftable';
  CoreNode::initCore((v1 + 44), `string');
  v1[1].Child = 0;
  v1[2].vtblPointer = 0;
  v1[1].vtblPointer = 0;
  v1[1].Next = -1;
  return v1;
}
// 101ADC98: using guessed type void *DispList::`vftable';

//----- (1001D3B0) --------------------------------------------------------
CoreNode *__thiscall DispList::DispList(DispList *this, int a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, "CoreNode");
  FaceNode::FaceNode(&v2[2].name);
  v2->vtblPointer = &DispList::`vftable';
  CoreNode::initCore((v2 + 44), `string');
  v2[1].Child = 0;
  v2[2].vtblPointer = 0;
  v2[1].vtblPointer = a2 & 3;
  v2[1].Next = -1;
  return v2;
}
// 101ADC98: using guessed type void *DispList::`vftable';

//----- (1001D470) --------------------------------------------------------
CoreNode *__thiscall DispList::DispList(DispList *this, const struct DispList *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  v2[2].vtblPointer = *(a2 + 10);
  FaceNode::FaceNode(&v2[2].name, (a2 + 44));
  v2->vtblPointer = &DispList::`vftable';
  return v2;
}
// 101ADC98: using guessed type void *DispList::`vftable';

//----- (1001D540) --------------------------------------------------------
_DWORD *__thiscall DispList::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  v2[10] = a2[10];
  FaceNode::operator=(a2 + 11);
  return v2;
}
// 1000277F: using guessed type _DWORD __stdcall FaceNode::operator=(_DWORD);
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001D600) --------------------------------------------------------
GfxobjInfo *__thiscall MatobjInfo::MatobjInfo(MatobjInfo *this)
{
  GfxobjInfo *v1; // ST50_4

  v1 = this;
  GfxobjInfo::GfxobjInfo(this);
  *v1 = &MatobjInfo::`vftable';
  *(v1 + 8) = 0;
  *(v1 + 3) = "material";
  ID32::setID((v1 + 16), 0x5F676678u);
  return v1;
}
// 101ADCB0: using guessed type void *MatobjInfo::`vftable';

//----- (1001D680) --------------------------------------------------------
void __thiscall MatobjInfo::attach(MatobjInfo *this)
{
  MatobjInfo *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(**(this + 8) + 20))(*(this + 8));
}

//----- (1001D6E0) --------------------------------------------------------
void MatobjInfo::detach()
{
  ;
}

//----- (1001D710) --------------------------------------------------------
GfxobjInfo *__thiscall MatobjInfo::MatobjInfo(MatobjInfo *this, const struct MatobjInfo *a2)
{
  GfxobjInfo *v2; // ST50_4

  v2 = this;
  GfxobjInfo::GfxobjInfo(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *v2 = &MatobjInfo::`vftable';
  return v2;
}
// 101ADCB0: using guessed type void *MatobjInfo::`vftable';

//----- (1001D780) --------------------------------------------------------
_DWORD *__thiscall MatobjInfo::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  GfxobjInfo::operator=(a2);
  v2[8] = *(a2 + 32);
  return v2;
}
// 10001D2A: using guessed type _DWORD __stdcall GfxobjInfo::operator=(_DWORD);

//----- (1001D7E0) --------------------------------------------------------
GfxobjInfo *__thiscall DlobjInfo::DlobjInfo(DlobjInfo *this)
{
  GfxobjInfo *v1; // ST50_4

  v1 = this;
  GfxobjInfo::GfxobjInfo(this);
  *v1 = &DlobjInfo::`vftable';
  *(v1 + 8) = 0;
  *(v1 + 3) = "displaylist";
  ID32::setID((v1 + 16), 0x5F676678u);
  return v1;
}
// 101ADCCC: using guessed type void *DlobjInfo::`vftable';

//----- (1001D860) --------------------------------------------------------
void DlobjInfo::attach()
{
  ;
}

//----- (1001D890) --------------------------------------------------------
void __thiscall DlobjInfo::detach(DlobjInfo *this)
{
  *(*(this + 8) + 32) = -1;
}

//----- (1001D8D0) --------------------------------------------------------
GfxobjInfo *__thiscall DlobjInfo::DlobjInfo(DlobjInfo *this, const struct DlobjInfo *a2)
{
  GfxobjInfo *v2; // ST50_4

  v2 = this;
  GfxobjInfo::GfxobjInfo(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *v2 = &DlobjInfo::`vftable';
  return v2;
}
// 101ADCCC: using guessed type void *DlobjInfo::`vftable';

//----- (1001D940) --------------------------------------------------------
_DWORD *__thiscall DlobjInfo::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  GfxobjInfo::operator=(a2);
  v2[8] = *(a2 + 32);
  return v2;
}
// 10001D2A: using guessed type _DWORD __stdcall GfxobjInfo::operator=(_DWORD);

//----- (1001D9A0) --------------------------------------------------------
MtxGroup *__thiscall MtxGroup::MtxGroup(MtxGroup *this)
{
  *this = 0;
  *(this + 2) = 0;
  *(this + 3) = 0;
  return this;
}

//----- (1001DA00) --------------------------------------------------------
_DWORD *__thiscall MtxGroup::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (1001DA60) --------------------------------------------------------
CoreNode *__thiscall Mesh::Mesh(Mesh *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "mesh");
  v1->vtblPointer = &Mesh::`vftable';
  v1[2].vtblPointer = 0;
  v1[1].name = -1;
  v1[2].name = 1;
  return v1;
}
// 101ADCD8: using guessed type void *Mesh::`vftable';

//----- (1001DAE0) --------------------------------------------------------
CoreNode *__thiscall Mesh::Mesh(Mesh *this, const struct Mesh *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  v2[2].vtblPointer = *(a2 + 10);
  v2[2].name = *(a2 + 11);
  v2->vtblPointer = &Mesh::`vftable';
  return v2;
}
// 101ADCD8: using guessed type void *Mesh::`vftable';

//----- (1001DBB0) --------------------------------------------------------
_DWORD *__thiscall Mesh::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  v2[10] = a2[10];
  v2[11] = a2[11];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001DC70) --------------------------------------------------------
CoreNode *__thiscall ObjCollInfo::ObjCollInfo(ObjCollInfo *this)
{
  float v2; // [esp+4Ch] [ebp-10h]
  float v3; // [esp+50h] [ebp-Ch]
  float v4; // [esp+54h] [ebp-8h]
  CoreNode *v5; // [esp+58h] [ebp-4h]

  v5 = this;
  CoreNode::CoreNode(this, `string');
  ID32::ID32(&v5[1]);
  ID32::ID32(&v5[1].Next);
  Vector3f::Vector3f(&v5[2].Next);
  v5->vtblPointer = &ObjCollInfo::`vftable';
  ID32::setID(&v5[1], 0x6E6F6E65u);
  ID32::setID(&v5[1].Next, 0x6E6F6E65u);
  v5[2].Parent = -1;
  v5[2].name = 1;
  v5[3].name = 1092616192;
  v4 = 0.0;
  v3 = 0.0;
  v2 = 0.0;
  Vector3f::set(&v5[2].Next, &v2, &v3, &v4);
  v5[3].Parent = 0;
  v5[3].Child = 0;
  v5[3].Next = 0;
  v5[4].vtblPointer = 0;
  return v5;
}
// 101ADCF8: using guessed type void *ObjCollInfo::`vftable';

//----- (1001DDB0) --------------------------------------------------------
CoreNode *__thiscall ObjCollInfo::ObjCollInfo(ObjCollInfo *this, const struct ObjCollInfo *a2)
{
  CoreNode *v2; // ST50_4
  CoreNode *v3; // edx
  CoreNode **v4; // eax

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v3 = v2 + 1;
  v3->vtblPointer = *(a2 + 5);
  v3->name = *(a2 + 6);
  v3->Parent = *(a2 + 7);
  v4 = &v2[1].Next;
  *v4 = *(a2 + 8);
  v4[1] = *(a2 + 9);
  v4[2] = *(a2 + 10);
  v2[2].name = *(a2 + 11);
  v2[2].Parent = *(a2 + 12);
  Vector3f::Vector3f(&v2[2].Next, (a2 + 52));
  v2[3].name = *(a2 + 16);
  v2[3].Parent = *(a2 + 17);
  v2[3].Next = *(a2 + 18);
  v2[3].Child = *(a2 + 19);
  v2[4].vtblPointer = *(a2 + 20);
  v2->vtblPointer = &ObjCollInfo::`vftable';
  return v2;
}
// 101ADCF8: using guessed type void *ObjCollInfo::`vftable';

//----- (1001DED0) --------------------------------------------------------
_DWORD *__thiscall ObjCollInfo::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // edx
  _DWORD *v4; // eax
  _DWORD *v5; // ecx

  v2 = this;
  CoreNode::operator=(a2);
  v3 = v2 + 5;
  *v3 = a2[5];
  v3[1] = a2[6];
  v3[2] = a2[7];
  v4 = v2 + 8;
  *v4 = a2[8];
  v4[1] = a2[9];
  v4[2] = a2[10];
  v2[11] = a2[11];
  v2[12] = a2[12];
  v5 = v2 + 13;
  *v5 = a2[13];
  v5[1] = a2[14];
  v5[2] = a2[15];
  v2[16] = a2[16];
  v2[17] = a2[17];
  v2[18] = a2[18];
  v2[19] = a2[19];
  v2[20] = a2[20];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001DFF0) --------------------------------------------------------
CoreNode *__thiscall Joint::MatPoly::MatPoly(Joint::MatPoly *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "matpoly");
  v1->vtblPointer = &Joint::MatPoly::`vftable';
  v1[1].Child = 0;
  return v1;
}
// 101ADD10: using guessed type void *Joint::MatPoly::`vftable';

//----- (1001E060) --------------------------------------------------------
CoreNode *__thiscall Joint::MatPoly::MatPoly(Joint::MatPoly *this, struct Material *a2, struct Mesh *a3)
{
  CoreNode *v3; // ST50_4

  v3 = this;
  CoreNode::CoreNode(this, "matpoly");
  v3->vtblPointer = &Joint::MatPoly::`vftable';
  v3[1].vtblPointer = a2;
  v3[1].name = a3;
  v3[1].Child = 0;
  return v3;
}
// 101ADD10: using guessed type void *Joint::MatPoly::`vftable';

//----- (1001E0E0) --------------------------------------------------------
CoreNode *__thiscall Joint::Joint(Joint *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, 0);
  Vector3f::Vector3f(&v1[1].Child);
  Vector3f::Vector3f(&v1[2].Parent);
  Vector3f::Vector3f(&v1[3]);
  Matrix4f::Matrix4f(&v1[3].Next);
  Matrix4f::Matrix4f(&v1[6].Child);
  BoundBox::BoundBox(&v1[10].name);
  Joint::MatPoly::MatPoly(&v1[11].Parent);
  v1->vtblPointer = &Joint::`vftable';
  v1[1].Next = 1;
  v1[13].Parent = 0;
  return v1;
}
// 101ADD34: using guessed type void *Joint::`vftable';

//----- (1001E1C0) --------------------------------------------------------
CoreNode *__thiscall Joint::MatPoly::MatPoly(Joint::MatPoly *this, const struct Joint::MatPoly *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  v2->vtblPointer = &Joint::MatPoly::`vftable';
  return v2;
}
// 101ADD10: using guessed type void *Joint::MatPoly::`vftable';

//----- (1001E270) --------------------------------------------------------
_DWORD *__thiscall Joint::MatPoly::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001E310) --------------------------------------------------------
CoreNode *__thiscall Joint::Joint(Joint *this, const struct Joint *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  Vector3f::Vector3f(&v2[1].Child, (a2 + 36));
  Vector3f::Vector3f(&v2[2].Parent, (a2 + 48));
  Vector3f::Vector3f(&v2[3], (a2 + 60));
  qmemcpy(&v2[3].Next, a2 + 72, 0x40u);
  qmemcpy(&v2[6].Child, a2 + 136, 0x43u);
  BoundBox::BoundBox(&v2[10].name, (a2 + 204));
  Joint::MatPoly::MatPoly(&v2[11].Parent, (a2 + 228));
  v2[13].Parent = *(a2 + 67);
  v2[13].Next = *(a2 + 68);
  v2[13].Child = *(a2 + 69);
  v2[14].vtblPointer = *(a2 + 70);
  v2->vtblPointer = &Joint::`vftable';
  return v2;
}
// 101ADD34: using guessed type void *Joint::`vftable';

//----- (1001E500) --------------------------------------------------------
_DWORD *__thiscall Joint::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // edx
  _DWORD *v4; // eax
  _DWORD *v5; // ecx

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v3 = v2 + 9;
  *v3 = a2[9];
  v3[1] = a2[10];
  v3[2] = a2[11];
  v4 = v2 + 12;
  *v4 = a2[12];
  v4[1] = a2[13];
  v4[2] = a2[14];
  v5 = v2 + 15;
  *v5 = a2[15];
  v5[1] = a2[16];
  v5[2] = a2[17];
  qmemcpy(v2 + 18, a2 + 18, 0x40u);
  qmemcpy(v2 + 34, a2 + 34, 0x43u);
  qmemcpy(v2 + 51, a2 + 51, 0x18u);
  Joint::MatPoly::operator=(a2 + 57);
  v2[67] = a2[67];
  v2[68] = a2[68];
  v2[69] = a2[69];
  v2[70] = a2[70];
  return v2;
}
// 100026DF: using guessed type _DWORD __stdcall Joint::MatPoly::operator=(_DWORD);
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001E710) --------------------------------------------------------
DataChunk *__thiscall DataChunk::DataChunk(DataChunk *this)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  return this;
}

//----- (1001E770) --------------------------------------------------------
void __thiscall DataChunk::setDataSize(DataChunk *this, int a2)
{
  DataChunk *v2; // ST54_4

  v2 = this;
  *(this + 2) = sub_10001AC3(4 * a2);
  *(v2 + 1) = a2;
}

//----- (1001E7E0) --------------------------------------------------------
void __thiscall DataChunk::addData(DataChunk *this, float a2)
{
  void *Dst; // [esp+54h] [ebp-8h]
  DataChunk *v3; // [esp+58h] [ebp-4h]

  v3 = this;
  if ( *this >= *(this + 1) )
  {
    *(this + 1) = *this + 2048;
    Dst = sub_10001AC3(4 * *(this + 1));
    if ( *v3 )
      memcpy(Dst, *(v3 + 2), 4 * *v3);
    sub_10001938(*(v3 + 2));
    *(v3 + 2) = Dst;
  }
  *(*(v3 + 2) + 4 * (*v3)++) = a2;
}

//----- (1001E8E0) --------------------------------------------------------
void __thiscall DataChunk::getData(DataChunk *this, struct CmdStream *a2)
{
  const char *v2; // eax
  const char *v3; // eax
  float v4; // [esp+4Ch] [ebp-10h]
  int v5; // [esp+50h] [ebp-Ch]
  int v6; // [esp+54h] [ebp-8h]
  DataChunk *v7; // [esp+58h] [ebp-4h]

  v7 = this;
  CmdStream::getToken(a2, 1);
  v6 = 0;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    if ( !(v6 & 7) )
    {
      CmdStream::getToken(a2, 1);
      if ( CmdStream::isToken(a2, "size") )
      {
        v2 = CmdStream::getToken(a2, 1);
        sscanf(v2, "%d", &v5);
        DataChunk::setDataSize(v7, v5);
        CmdStream::getToken(a2, 1);
      }
    }
    v3 = CmdStream::getToken(a2, 1);
    sscanf(v3, "%f", &v4);
    DataChunk::addData(v7, v4);
    ++v6;
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}

//----- (1001EA60) --------------------------------------------------------
void __userpurge DataChunk::read(DataChunk *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  int i; // [esp+4Ch] [ebp-Ch]
  int v4; // [esp+50h] [ebp-8h]
  DataChunk *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  v4 = (**a3)(a3);
  DataChunk::setDataSize(v5, v4);
  for ( i = 0; i < v4; ++i )
  {
    (*(*a3 + 12))(a3);
    *(*(v5 + 2) + 4 * i) = a2;
  }
}

//----- (1001EB20) --------------------------------------------------------
void __thiscall DataChunk::write(DataChunk *this, struct RandomAccessStream *a2)
{
  int i; // [esp+4Ch] [ebp-8h]
  DataChunk *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  (*(*a2 + 28))(a2, *this);
  for ( i = 0; i < *v3; ++i )
    (*(*a2 + 40))(a2, *(*(v3 + 2) + 4 * i));
}

//----- (1001EBD0) --------------------------------------------------------
_DWORD *__thiscall DataChunk::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (1001EC20) --------------------------------------------------------
_DWORD *__thiscall InterpKeyInfo::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (1001EC80) --------------------------------------------------------
Vector3f *__thiscall CamDataInfo::CamDataInfo(CamDataInfo *this, const struct CamDataInfo *a2)
{
  Vector3f *v2; // ST50_4
  int v3; // ecx
  _DWORD *v4; // edx
  _DWORD *v5; // eax
  _DWORD *v6; // ecx

  v2 = this;
  Vector3f::Vector3f(this, a2);
  Vector3f::Vector3f((v2 + 12), (a2 + 12));
  Vector3f::Vector3f((v2 + 24), (a2 + 24));
  *(v2 + 9) = *(a2 + 9);
  *(v2 + 10) = *(a2 + 10);
  *(v2 + 44) = *(a2 + 44);
  qmemcpy(v2 + 48, a2 + 48, 0x24u);
  qmemcpy(v2 + 84, a2 + 84, 0x28u);
  v3 = v2 + 120;
  *(v3 + 4) = *(a2 + 31);
  *(v3 + 8) = *(a2 + 32);
  v4 = (v2 + 132);
  *v4 = *(a2 + 33);
  v4[1] = *(a2 + 34);
  v4[2] = *(a2 + 35);
  v5 = (v2 + 144);
  *v5 = *(a2 + 36);
  v5[1] = *(a2 + 37);
  v5[2] = *(a2 + 38);
  v6 = (v2 + 156);
  *v6 = *(a2 + 39);
  v6[1] = *(a2 + 40);
  v6[2] = *(a2 + 41);
  Camera::Camera((v2 + 168), (a2 + 168));
  *(v2 + 252) = *(a2 + 252);
  *(v2 + 253) = *(a2 + 253);
  return v2;
}

//----- (1001EE50) --------------------------------------------------------
void *__thiscall CamDataInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x3F8u);
  return this;
}

//----- (1001EEA0) --------------------------------------------------------
LightDataInfo *__thiscall LightDataInfo::LightDataInfo(LightDataInfo *this)
{
  LightDataInfo *v1; // ST50_4

  v1 = this;
  Light::Light((this + 88));
  *(v1 + 28) = 1148846080;
  return v1;
}

//----- (1001EF00) --------------------------------------------------------
LightDataInfo *__thiscall LightDataInfo::LightDataInfo(LightDataInfo *this, const struct LightDataInfo *a2)
{
  LightDataInfo *v2; // ST50_4
  char *v3; // ecx

  v2 = this;
  qmemcpy(this, a2, 0x24u);
  qmemcpy(this + 36, a2 + 36, 0x28u);
  v3 = this + 72;
  *(v3 + 1) = *(a2 + 19);
  *(v3 + 2) = *(a2 + 20);
  *(v2 + 21) = *(a2 + 21);
  Light::Light((v2 + 88), (a2 + 88));
  *(v2 + 203) = *(a2 + 203);
  *(v2 + 204) = *(a2 + 204);
  return v2;
}

//----- (1001EFE0) --------------------------------------------------------
_DWORD *__thiscall LightDataInfo::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // edx
  _DWORD *v3; // ecx
  _DWORD *v4; // ecx
  _DWORD *v5; // edx
  unsigned int j; // [esp+4Ch] [ebp-Ch]
  unsigned int i; // [esp+50h] [ebp-8h]
  _DWORD *v9; // [esp+54h] [ebp-4h]

  v9 = this;
  for ( i = 0; i < 3; ++i )
  {
    v2 = &a2[3 * i];
    v3 = &v9[3 * i];
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
  }
  for ( j = 0; j < 3; ++j )
  {
    v4 = &v9[3 * j + 9];
    *v4 = a2[3 * j + 9];
    v4[1] = a2[3 * j + 10];
    v4[2] = a2[3 * j + 11];
  }
  v5 = v9 + 18;
  *v5 = a2[18];
  v5[1] = a2[19];
  v5[2] = a2[20];
  v9[21] = a2[21];
  Light::operator=(a2 + 22);
  v9[203] = a2[203];
  v9[204] = a2[204];
  return v9;
}
// 1000233D: using guessed type _DWORD __stdcall Light::operator=(_DWORD);

//----- (1001F140) --------------------------------------------------------
CoreNode *__thiscall SceneData::SceneData(SceneData *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, `string');
  v1->vtblPointer = &SceneData::`vftable';
  v1[1].Child = 0;
  v1[2].vtblPointer = 0;
  v1[2].name = 0;
  return v1;
}
// 101ADD5C: using guessed type void *SceneData::`vftable';

//----- (1001F1C0) --------------------------------------------------------
CoreNode *__thiscall SceneData::SceneData(SceneData *this, const struct SceneData *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  v2[2].vtblPointer = *(a2 + 10);
  v2[2].name = *(a2 + 11);
  v2->vtblPointer = &SceneData::`vftable';
  return v2;
}
// 101ADD5C: using guessed type void *SceneData::`vftable';

//----- (1001F290) --------------------------------------------------------
_DWORD *__thiscall SceneData::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  v2[10] = a2[10];
  v2[11] = a2[11];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001F350) --------------------------------------------------------
CoreNode *__thiscall AnimData::AnimData(AnimData *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, `string');
  v1->vtblPointer = &AnimData::`vftable';
  v1[1].Child = 0;
  v1[2].Child = 0;
  return v1;
}
// 101ADD74: using guessed type void *AnimData::`vftable';

//----- (1001F3D0) --------------------------------------------------------
CoreNode *__thiscall AnimData::AnimData(AnimData *this, char *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2->vtblPointer = &AnimData::`vftable';
  v2[1].Child = 0;
  v2[2].Child = 0;
  return v2;
}
// 101ADD74: using guessed type void *AnimData::`vftable';

//----- (1001F450) --------------------------------------------------------
void __stdcall AnimData::writeType(struct RandomAccessStream *a2)
{
  ;
}

//----- (1001F480) --------------------------------------------------------
CoreNode *__thiscall AnimData::AnimData(AnimData *this, const struct AnimData *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  v2[2].vtblPointer = *(a2 + 10);
  v2[2].name = *(a2 + 11);
  v2[2].Parent = *(a2 + 12);
  v2[2].Next = *(a2 + 13);
  v2[2].Child = *(a2 + 14);
  v2[3].vtblPointer = *(a2 + 15);
  v2[3].name = *(a2 + 16);
  v2->vtblPointer = &AnimData::`vftable';
  return v2;
}
// 101ADD74: using guessed type void *AnimData::`vftable';

//----- (1001F590) --------------------------------------------------------
_DWORD *__thiscall AnimData::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  v2[10] = a2[10];
  v2[11] = a2[11];
  v2[12] = a2[12];
  v2[13] = a2[13];
  v2[14] = a2[14];
  v2[15] = a2[15];
  v2[16] = a2[16];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001F6A0) --------------------------------------------------------
AnimData *__thiscall AnimDca::AnimDca(AnimDca *this, struct BaseShape *a2, int a3)
{
  AnimData *v3; // ST50_4

  v3 = this;
  AnimData::AnimData(this);
  *v3 = &AnimDca::`vftable';
  return v3;
}
// 101ADDA0: using guessed type void *AnimDca::`vftable';

//----- (1001F700) --------------------------------------------------------
AnimDca *__thiscall AnimDca::AnimDca(AnimDca *this, char *Str)
{
  AnimDca *v2; // ST50_4
  char *v3; // eax

  v2 = this;
  v3 = StdSystem::stringDup(Str);
  AnimData::AnimData(v2, v3);
  *v2 = &AnimDca::`vftable';
  return v2;
}
// 101ADDA0: using guessed type void *AnimDca::`vftable';

//----- (1001F770) --------------------------------------------------------
AnimData *__thiscall AnimDca::AnimDca(AnimDca *this, const struct AnimDca *a2)
{
  AnimData *v2; // ST50_4

  v2 = this;
  AnimData::AnimData(this, a2);
  *v2 = &AnimDca::`vftable';
  return v2;
}
// 101ADDA0: using guessed type void *AnimDca::`vftable';

//----- (1001F7D0) --------------------------------------------------------
void *__thiscall AnimDca::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  AnimData::operator=(a2);
  return v2;
}
// 10001AE1: using guessed type _DWORD __stdcall AnimData::operator=(_DWORD);

//----- (1001F820) --------------------------------------------------------
AnimData *__thiscall AnimDck::AnimDck(AnimDck *this)
{
  AnimData *v1; // ST50_4

  v1 = this;
  AnimData::AnimData(this, "animDck");
  *v1 = &AnimDck::`vftable';
  return v1;
}
// 101ADDCC: using guessed type void *AnimDck::`vftable';

//----- (1001F880) --------------------------------------------------------
AnimDck *__thiscall AnimDck::AnimDck(AnimDck *this, char *Str)
{
  AnimDck *v2; // ST50_4
  char *v3; // eax

  v2 = this;
  v3 = StdSystem::stringDup(Str);
  AnimData::AnimData(v2, v3);
  *v2 = &AnimDck::`vftable';
  return v2;
}
// 101ADDCC: using guessed type void *AnimDck::`vftable';

//----- (1001F8F0) --------------------------------------------------------
AnimData *__thiscall AnimDck::AnimDck(AnimDck *this, const struct AnimDck *a2)
{
  AnimData *v2; // ST50_4

  v2 = this;
  AnimData::AnimData(this, a2);
  *v2 = &AnimDck::`vftable';
  return v2;
}
// 101ADDCC: using guessed type void *AnimDck::`vftable';

//----- (1001F950) --------------------------------------------------------
void *__thiscall AnimDck::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  AnimData::operator=(a2);
  return v2;
}
// 10001AE1: using guessed type _DWORD __stdcall AnimData::operator=(_DWORD);

//----- (1001F9A0) --------------------------------------------------------
AnimCacheInfo *__thiscall AnimCacheInfo::AnimCacheInfo(AnimCacheInfo *this)
{
  AnimCacheInfo *v1; // ST50_4

  v1 = this;
  AnimCacheInfo::initData(this);
  return v1;
}

//----- (1001F9F0) --------------------------------------------------------
void __thiscall AnimCacheInfo::initData(AnimCacheInfo *this)
{
  *(this + 5) = 0;
  *(this + 4) = 0;
}

//----- (1001FA40) --------------------------------------------------------
void *__thiscall AnimCacheInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x1Cu);
  return this;
}

//----- (1001FA90) --------------------------------------------------------
void *__thiscall AnimFrameCacher::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x18u);
  return this;
}

//----- (1001FAE0) --------------------------------------------------------
AnimContext *__thiscall AnimContext::AnimContext(AnimContext *this)
{
  *this = &AnimContext::`vftable';
  *(this + 1) = 0;
  *(this + 2) = 0;
  *(this + 3) = 1106247680;
  return this;
}
// 101ADE04: using guessed type void *AnimContext::`vftable';

//----- (1001FB50) --------------------------------------------------------
AnimContext *__thiscall AnimContext::AnimContext(AnimContext *this, struct AnimData *a2)
{
  *this = &AnimContext::`vftable';
  *(this + 1) = a2;
  *(this + 2) = 0;
  *(this + 3) = 1106247680;
  return this;
}
// 101ADE04: using guessed type void *AnimContext::`vftable';

//----- (1001FBC0) --------------------------------------------------------
void __thiscall AnimContext::setState(AnimContext *this, struct AnimData *a2, float a3)
{
  *(this + 1) = a2;
  *(this + 2) = a3;
}

//----- (1001FC10) --------------------------------------------------------
AnimContext *__thiscall AnimContext::AnimContext(AnimContext *this, const struct AnimContext *a2)
{
  *(this + 1) = *(a2 + 1);
  *(this + 2) = *(a2 + 2);
  *(this + 3) = *(a2 + 3);
  *this = &AnimContext::`vftable';
  return this;
}
// 101ADE04: using guessed type void *AnimContext::`vftable';

//----- (1001FC80) --------------------------------------------------------
_DWORD *__thiscall AnimContext::operator=(_DWORD *this, _DWORD *a2)
{
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (1001FCE0) --------------------------------------------------------
TexImg *__thiscall TexImg::TexImg(TexImg *this)
{
  TexImg *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "texImg");
  *v1 = &TexImg::`vftable';
  *(v1 + 9) = 1;
  *(v1 + 12) = 0;
  return v1;
}
// 101ADE08: using guessed type void *TexImg::`vftable';

//----- (1001FD60) --------------------------------------------------------
TexImg *__thiscall TexImg::TexImg(TexImg *this, const struct TexImg *a2)
{
  TexImg *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  *(v2 + 5) = *(a2 + 5);
  *(v2 + 6) = *(a2 + 6);
  *(v2 + 7) = *(a2 + 7);
  *(v2 + 8) = *(a2 + 8);
  *(v2 + 9) = *(a2 + 9);
  *(v2 + 10) = *(a2 + 10);
  *(v2 + 11) = *(a2 + 11);
  *(v2 + 12) = *(a2 + 12);
  *v2 = &TexImg::`vftable';
  return v2;
}
// 101ADE08: using guessed type void *TexImg::`vftable';

//----- (1001FE40) --------------------------------------------------------
_DWORD *__thiscall TexImg::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  v2[10] = a2[10];
  v2[11] = a2[11];
  v2[12] = a2[12];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (1001FF10) --------------------------------------------------------
CoreNode *__thiscall TexAttr::TexAttr(TexAttr *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "texattr");
  v1->vtblPointer = &TexAttr::`vftable';
  v1[2].vtblPointer = 0;
  v1[2].name = 0;
  v1[2].Parent = 0;
  LOWORD(v1[1].Parent) = 0;
  LOWORD(v1[1].Next) = 0;
  v1[1].Child = 0;
  return v1;
}
// 101ADE28: using guessed type void *TexAttr::`vftable';

//----- (1001FFC0) --------------------------------------------------------
CoreNode *__thiscall TexAttr::TexAttr(TexAttr *this, const struct TexAttr *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  LOWORD(v2[1].Parent) = *(a2 + 14);
  HIWORD(v2[1].Parent) = *(a2 + 15);
  LOWORD(v2[1].Next) = *(a2 + 16);
  HIWORD(v2[1].Next) = *(a2 + 17);
  v2[1].Child = *(a2 + 9);
  v2[2].vtblPointer = *(a2 + 10);
  v2[2].name = *(a2 + 11);
  v2[2].Parent = *(a2 + 12);
  v2->vtblPointer = &TexAttr::`vftable';
  return v2;
}
// 101ADE28: using guessed type void *TexAttr::`vftable';

//----- (100200C0) --------------------------------------------------------
_DWORD *__thiscall TexAttr::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = *(a2 + 20);
  v2[6] = *(a2 + 24);
  *(v2 + 14) = *(a2 + 28);
  *(v2 + 15) = *(a2 + 30);
  *(v2 + 16) = *(a2 + 32);
  *(v2 + 17) = *(a2 + 34);
  v2[9] = *(a2 + 36);
  v2[10] = *(a2 + 40);
  v2[11] = *(a2 + 44);
  v2[12] = *(a2 + 48);
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (100201B0) --------------------------------------------------------
CoreNode *__thiscall RouteLink::RouteLink(RouteLink *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "rp");
  v1->vtblPointer = &RouteLink::`vftable';
  v1[1].vtblPointer = 0;
  return v1;
}
// 101ADE4C: using guessed type void *RouteLink::`vftable';

//----- (10020220) --------------------------------------------------------
CoreNode *__thiscall RouteLink::RouteLink(RouteLink *this, const struct RouteLink *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2->vtblPointer = &RouteLink::`vftable';
  return v2;
}
// 101ADE4C: using guessed type void *RouteLink::`vftable';

//----- (10020290) --------------------------------------------------------
_DWORD *__thiscall RouteLink::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = *(a2 + 20);
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (100202F0) --------------------------------------------------------
CoreNode *__thiscall RoutePoint::RoutePoint(RoutePoint *this, const struct RoutePoint *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  Vector3f::Vector3f(&v2[2], (a2 + 40));
  v2[2].Next = *(a2 + 13);
  v2[2].Child = *(a2 + 14);
  RouteLink::RouteLink(&v2[3], (a2 + 60));
  v2->vtblPointer = &RoutePoint::`vftable';
  return v2;
}
// 101ADE68: using guessed type void *RoutePoint::`vftable';

//----- (100203E0) --------------------------------------------------------
_DWORD *__thiscall RoutePoint::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // edx

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  v3 = v2 + 10;
  *v3 = a2[10];
  v3[1] = a2[11];
  v3[2] = a2[12];
  v2[13] = a2[13];
  v2[14] = a2[14];
  RouteLink::operator=(a2 + 15);
  return v2;
}
// 10001811: using guessed type _DWORD __stdcall RouteLink::operator=(_DWORD);
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (100204E0) --------------------------------------------------------
void __thiscall RouteGroup::setID(RouteGroup *this, unsigned __int32 a2)
{
  signed int i; // [esp+4Ch] [ebp-Ch]

  *(this + 22) = a2;
  for ( i = 0; i < 4; ++i )
    *(this + i + 92) = *(this + 3 - i + 88);
  *(this + 96) = 0;
}

//----- (10020570) --------------------------------------------------------
void __thiscall RouteGroup::updateID(RouteGroup *this)
{
  signed int i; // [esp+4Ch] [ebp-Ch]

  for ( i = 0; i < 4; ++i )
    *(this + i + 88) = *(this + 3 - i + 92);
}

//----- (100205F0) --------------------------------------------------------
EditNode *__thiscall RouteGroup::RouteGroup(RouteGroup *this, const struct RouteGroup *a2)
{
  EditNode *v2; // ST50_4

  v2 = this;
  EditNode::EditNode(this, a2);
  *(v2 + 5) = *(a2 + 5);
  qmemcpy(v2 + 24, a2 + 24, 0x49u);
  *(v2 + 25) = *(a2 + 25);
  RoutePoint::RoutePoint((v2 + 104), (a2 + 104));
  *(v2 + 47) = *(a2 + 47);
  *v2 = &RouteGroup::`vftable';
  return v2;
}
// 101ADE80: using guessed type void *RouteGroup::`vftable';

//----- (100206E0) --------------------------------------------------------
_DWORD *__thiscall RouteGroup::operator=(_DWORD *this, _DWORD *a2)
{
  unsigned int j; // [esp+4Ch] [ebp-Ch]
  unsigned int i; // [esp+50h] [ebp-8h]
  _DWORD *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  EditNode::operator=(a2);
  v5[5] = a2[5];
  for ( i = 0; i < 0x40; ++i )
    *(v5 + i + 24) = *(a2 + i + 24);
  v5[22] = a2[22];
  for ( j = 0; j < 5; ++j )
    *(v5 + j + 92) = *(a2 + j + 92);
  v5[25] = a2[25];
  RoutePoint::operator=(a2 + 26);
  v5[47] = a2[47];
  return v5;
}
// 100023B5: using guessed type _DWORD __stdcall EditNode::operator=(_DWORD);
// 100027D4: using guessed type _DWORD __stdcall RoutePoint::operator=(_DWORD);

//----- (10020800) --------------------------------------------------------
ShapeDynMaterials *__thiscall ShapeDynMaterials::ShapeDynMaterials(ShapeDynMaterials *this)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  *(this + 3) = 0;
  return this;
}

//----- (10020870) --------------------------------------------------------
_DWORD *__thiscall ShapeDynMaterials::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return this;
}

//----- (100208D0) --------------------------------------------------------
struct CollGroup *__thiscall BaseShape::getCollTris(BaseShape *this, struct Vector3f *a2)
{
  struct CollGroup *result; // eax
  int v3; // [esp+4Ch] [ebp-Ch]
  int v4; // [esp+50h] [ebp-8h]

  v4 = ((*a2 - *(this + 97)) / *(this + 103));
  v3 = ((*(a2 + 2) - *(this + 99)) / *(this + 103));
  if ( v4 >= 0 && v3 >= 0 && v4 < *(this + 104) && v3 < *(this + 105) )
    result = *(*(this + 106) + 4 * (v4 + *(this + 104) * v3));
  else
    result = 0;
  return result;
}

//----- (100209B0) --------------------------------------------------------
void BaseShape::optimize()
{
  ;
}

//----- (100209E0) --------------------------------------------------------
void __thiscall BaseShape::removeMtxDependancy(BaseShape *this)
{
  int j; // [esp+50h] [ebp-10h]
  int v2; // [esp+54h] [ebp-Ch]
  int i; // [esp+58h] [ebp-8h]

  for ( i = 0; i < *(this + 20); ++i )
  {
    v2 = 48 * i + *(this + 21);
    for ( j = 0; j < *(v2 + 32); ++j )
      *(16 * j + *(v2 + 36)) = 0;
  }
}

//----- (10020A90) --------------------------------------------------------
void BaseShape::update()
{
  ;
}

//----- (10020AC0) --------------------------------------------------------
void __stdcall BaseShape::render(struct Graphics *a2)
{
  ;
}

//----- (10020AF0) --------------------------------------------------------
void __stdcall BaseShape::render2d(struct Graphics *a2)
{
  ;
}

//----- (10020B20) --------------------------------------------------------
void __stdcall BaseShape::msgCommand(struct DataMsg *a2)
{
  ;
}

//----- (10020B50) --------------------------------------------------------
void __stdcall BaseShape::checkMouseEvent(int a2, int a3, int a4, int a5, int a6, int a7)
{
  ;
}

//----- (10020B80) --------------------------------------------------------
struct RouteGroup *__thiscall BaseShape::makeRouteGroup(BaseShape *this)
{
  int v2; // [esp+4Ch] [ebp-20h]
  RouteGroup *hMem; // [esp+50h] [ebp-1Ch]
  BaseShape *v4; // [esp+5Ch] [ebp-10h]

  v4 = this;
  hMem = sub_10002A81(0xC0u);
  if ( hMem )
    v2 = RouteGroup::RouteGroup(hMem);
  else
    v2 = 0;
  *(v2 + 100) = v4;
  return v2;
}

//----- (10020C50) --------------------------------------------------------
CoreNode *__thiscall BaseShape::BaseShape(BaseShape *this, const struct BaseShape *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  v2[2].vtblPointer = *(a2 + 10);
  v2[2].name = *(a2 + 11);
  v2[2].Parent = *(a2 + 12);
  v2[2].Next = *(a2 + 13);
  v2[2].Child = *(a2 + 14);
  v2[3].vtblPointer = *(a2 + 15);
  v2[3].name = *(a2 + 16);
  v2[3].Parent = *(a2 + 17);
  v2[3].Next = *(a2 + 18);
  v2[3].Child = *(a2 + 19);
  v2[4].vtblPointer = *(a2 + 20);
  v2[4].name = *(a2 + 21);
  v2[4].Parent = *(a2 + 22);
  v2[4].Next = *(a2 + 23);
  v2[4].Child = *(a2 + 24);
  v2[5].vtblPointer = *(a2 + 25);
  v2[5].name = *(a2 + 26);
  v2[5].Parent = *(a2 + 27);
  v2[5].Next = *(a2 + 28);
  v2[5].Child = *(a2 + 29);
  v2[6].vtblPointer = *(a2 + 30);
  AnimData::AnimData(&v2[6].name, (a2 + 124));
  LightGroup::LightGroup(&v2[9].Next, (a2 + 192));
  ObjCollInfo::ObjCollInfo(&v2[15], (a2 + 300));
  v2[19].name = *(a2 + 96);
  BoundBox::BoundBox(&v2[19].Parent, (a2 + 388));
  v2[20].Next = *(a2 + 103);
  v2[20].Child = *(a2 + 104);
  v2[21].vtblPointer = *(a2 + 105);
  v2[21].name = *(a2 + 106);
  v2[21].Parent = *(a2 + 107);
  v2[21].Next = *(a2 + 108);
  v2[21].Child = *(a2 + 109);
  v2[22].vtblPointer = *(a2 + 110);
  RouteGroup::RouteGroup(&v2[22].name, (a2 + 444));
  v2[31].Child = *(a2 + 159);
  v2[32].vtblPointer = *(a2 + 160);
  v2[32].name = *(a2 + 161);
  v2[32].Parent = *(a2 + 162);
  v2[32].Next = *(a2 + 163);
  qmemcpy(&v2[32].Child, a2 + 656, 0x20u);
  qmemcpy(&v2[34].Parent, a2 + 688, 0x41u);
  v2->vtblPointer = &BaseShape::`vftable';
  return v2;
}
// 101ADEA4: using guessed type void *BaseShape::`vftable';

//----- (10021110) --------------------------------------------------------
_DWORD *__thiscall BaseShape::operator=(_DWORD *this, int a2)
{
  unsigned int j; // [esp+4Ch] [ebp-Ch]
  unsigned int i; // [esp+50h] [ebp-8h]
  _DWORD *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  CoreNode::operator=(a2);
  v5[5] = *(a2 + 20);
  v5[6] = *(a2 + 24);
  v5[7] = *(a2 + 28);
  v5[8] = *(a2 + 32);
  v5[9] = *(a2 + 36);
  v5[10] = *(a2 + 40);
  v5[11] = *(a2 + 44);
  v5[12] = *(a2 + 48);
  v5[13] = *(a2 + 52);
  v5[14] = *(a2 + 56);
  v5[15] = *(a2 + 60);
  v5[16] = *(a2 + 64);
  v5[17] = *(a2 + 68);
  v5[18] = *(a2 + 72);
  v5[19] = *(a2 + 76);
  v5[20] = *(a2 + 80);
  v5[21] = *(a2 + 84);
  v5[22] = *(a2 + 88);
  v5[23] = *(a2 + 92);
  v5[24] = *(a2 + 96);
  v5[25] = *(a2 + 100);
  v5[26] = *(a2 + 104);
  v5[27] = *(a2 + 108);
  v5[28] = *(a2 + 112);
  v5[29] = *(a2 + 116);
  v5[30] = *(a2 + 120);
  AnimData::operator=(a2 + 124);
  LightGroup::operator=(a2 + 192);
  ObjCollInfo::operator=(a2 + 300);
  v5[96] = *(a2 + 384);
  qmemcpy(v5 + 97, (a2 + 388), 0x38u);
  RouteGroup::operator=(a2 + 444);
  v5[159] = *(a2 + 636);
  v5[160] = *(a2 + 640);
  v5[161] = *(a2 + 644);
  v5[162] = *(a2 + 648);
  v5[163] = *(a2 + 652);
  for ( i = 0; i < 8; ++i )
    v5[i + 164] = *(a2 + 4 * i + 656);
  for ( j = 0; j < 8; ++j )
    v5[j + 172] = *(a2 + 4 * j + 688);
  v5[180] = *(a2 + 720);
  v5[181] = *(a2 + 724);
  v5[182] = *(a2 + 728);
  v5[183] = *(a2 + 732);
  v5[184] = *(a2 + 736);
  v5[185] = *(a2 + 740);
  v5[186] = *(a2 + 744);
  v5[187] = *(a2 + 748);
  *(v5 + 752) = *(a2 + 752);
  return v5;
}
// 10001AE1: using guessed type _DWORD __stdcall AnimData::operator=(_DWORD);
// 10002009: using guessed type _DWORD __stdcall ObjCollInfo::operator=(_DWORD);
// 100025C2: using guessed type _DWORD __stdcall LightGroup::operator=(_DWORD);
// 10002A36: using guessed type _DWORD __stdcall RouteGroup::operator=(_DWORD);
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10021600) --------------------------------------------------------
BaseShape *__thiscall Shape::Shape(Shape *this)
{
  BaseShape *v1; // ST50_4

  v1 = this;
  BaseShape::BaseShape(this);
  *v1 = &Shape::`vftable';
  return v1;
}
// 101ADEE0: using guessed type void *Shape::`vftable';

//----- (10021660) --------------------------------------------------------
BaseShape *__thiscall Shape::Shape(Shape *this, const struct Shape *a2)
{
  BaseShape *v2; // ST50_4

  v2 = this;
  BaseShape::BaseShape(this, a2);
  *v2 = &Shape::`vftable';
  return v2;
}
// 101ADEE0: using guessed type void *Shape::`vftable';

//----- (100216C0) --------------------------------------------------------
void *__thiscall Shape::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  BaseShape::operator=(a2);
  return v2;
}
// 10002842: using guessed type _DWORD __stdcall BaseShape::operator=(_DWORD);

//----- (10021710) --------------------------------------------------------
GfxObject *__thiscall Texture::Texture(Texture *this)
{
  GfxObject *v1; // ST50_4

  v1 = this;
  GfxObject::GfxObject(this);
  *v1 = &Texture::`vftable';
  *(v1 + 11) = 0;
  *(v1 + 6) = -1;
  *(v1 + 9) = 0;
  *(v1 + 10) = 0;
  return v1;
}
// 101ADF1C: using guessed type void *Texture::`vftable';

//----- (100217A0) --------------------------------------------------------
void Texture::makeResident()
{
  ;
}

//----- (100217D0) --------------------------------------------------------
GfxObject *__thiscall Texture::Texture(Texture *this, const struct Texture *a2)
{
  GfxObject *v2; // ST50_4

  v2 = this;
  GfxObject::GfxObject(this, a2);
  *(v2 + 2) = *(a2 + 2);
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  *(v2 + 5) = *(a2 + 5);
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  *(v2 + 5) = *(a2 + 5);
  *(v2 + 6) = *(a2 + 6);
  *(v2 + 7) = *(a2 + 7);
  *(v2 + 8) = *(a2 + 8);
  *(v2 + 9) = *(a2 + 9);
  *(v2 + 10) = *(a2 + 10);
  *(v2 + 11) = *(a2 + 11);
  *(v2 + 12) = *(a2 + 12);
  *v2 = &Texture::`vftable';
  return v2;
}
// 101ADF1C: using guessed type void *Texture::`vftable';

//----- (10021910) --------------------------------------------------------
_WORD *__thiscall Texture::operator=(_WORD *this, int a2)
{
  _WORD *v2; // ST50_4

  v2 = this;
  GfxObject::operator=(a2);
  v2[2] = *(a2 + 4);
  v2[3] = *(a2 + 6);
  v2[4] = *(a2 + 8);
  v2[5] = *(a2 + 10);
  *(v2 + 3) = *(a2 + 12);
  *(v2 + 4) = *(a2 + 16);
  *(v2 + 5) = *(a2 + 20);
  *(v2 + 6) = *(a2 + 24);
  *(v2 + 7) = *(a2 + 28);
  *(v2 + 8) = *(a2 + 32);
  *(v2 + 9) = *(a2 + 36);
  *(v2 + 10) = *(a2 + 40);
  *(v2 + 11) = *(a2 + 44);
  *(v2 + 12) = *(a2 + 48);
  return v2;
}
// 100025D6: using guessed type _DWORD __stdcall GfxObject::operator=(_DWORD);

//----- (10021A40) --------------------------------------------------------
Texture *__thiscall CacheTexture::CacheTexture(CacheTexture *this)
{
  Texture *v1; // ST50_4

  v1 = this;
  Texture::Texture(this);
  *v1 = &CacheTexture::`vftable';
  *(v1 + 13) = 0;
  *(v1 + 15) = 0;
  *(v1 + 14) = 0;
  return v1;
}
// 101ADF2C: using guessed type void *CacheTexture::`vftable';

//----- (10021AC0) --------------------------------------------------------
Texture *__thiscall CacheTexture::CacheTexture(CacheTexture *this, const struct CacheTexture *a2)
{
  Texture *v2; // ST50_4

  v2 = this;
  Texture::Texture(this, a2);
  *(v2 + 13) = *(a2 + 13);
  *(v2 + 14) = *(a2 + 14);
  *(v2 + 15) = *(a2 + 15);
  *(v2 + 16) = *(a2 + 16);
  *v2 = &CacheTexture::`vftable';
  return v2;
}
// 101ADF2C: using guessed type void *CacheTexture::`vftable';

//----- (10021B60) --------------------------------------------------------
_DWORD *__thiscall CacheTexture::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  Texture::operator=(a2);
  v2[13] = a2[13];
  v2[14] = a2[14];
  v2[15] = a2[15];
  v2[16] = a2[16];
  return v2;
}
// 10002AEF: using guessed type _DWORD __stdcall Texture::operator=(_DWORD);

//----- (10021BF0) --------------------------------------------------------
DrawInfo *__thiscall DrawInfo::DrawInfo(DrawInfo *this)
{
  *(this + 2) = 0;
  return this;
}

//----- (10021C30) --------------------------------------------------------
_DWORD *__thiscall DrawInfo::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (10021C80) --------------------------------------------------------
MaterialHandler *__thiscall MaterialHandler::MaterialHandler(MaterialHandler *this)
{
  *this = &MaterialHandler::`vftable';
  *(this + 1) = 0;
  return this;
}
// 101ADF3C: using guessed type void *MaterialHandler::`vftable';

//----- (10021CD0) --------------------------------------------------------
MaterialHandler *__thiscall MaterialHandler::MaterialHandler(MaterialHandler *this, const struct MaterialHandler *a2)
{
  *(this + 1) = *(a2 + 1);
  *this = &MaterialHandler::`vftable';
  return this;
}
// 101ADF3C: using guessed type void *MaterialHandler::`vftable';

//----- (10021D20) --------------------------------------------------------
_DWORD *__thiscall MaterialHandler::operator=(_DWORD *this, int a2)
{
  this[1] = *(a2 + 4);
  return this;
}

//----- (10021D70) --------------------------------------------------------
Colour *__thiscall LFInfo::LFInfo(LFInfo *this)
{
  Colour *v1; // ST50_4

  v1 = this;
  Colour::Colour(this);
  Vector3f::Vector3f((v1 + 4));
  Vector2f::Vector2f((v1 + 16));
  Vector2f::Vector2f((v1 + 24));
  Vector2f::Vector2f((v1 + 32));
  *(v1 + 10) = 0;
  return v1;
}

//----- (10021E00) --------------------------------------------------------
LFInfo *__thiscall LFInfo::LFInfo(LFInfo *this, const struct LFInfo *a2)
{
  LFInfo *v2; // ST50_4
  int v3; // eax
  int v4; // ecx
  int v5; // edx

  v2 = this;
  *this = *a2;
  Vector3f::Vector3f((this + 4), (a2 + 4));
  v3 = *(a2 + 5);
  *(v2 + 4) = *(a2 + 4);
  *(v2 + 5) = v3;
  v4 = *(a2 + 7);
  *(v2 + 6) = *(a2 + 6);
  *(v2 + 7) = v4;
  v5 = *(a2 + 9);
  *(v2 + 8) = *(a2 + 8);
  *(v2 + 9) = v5;
  *(v2 + 10) = *(a2 + 10);
  return v2;
}

//----- (10021EC0) --------------------------------------------------------
void *__thiscall LFInfo::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x2Cu);
  return this;
}

//----- (10021F10) --------------------------------------------------------
CoreNode *__thiscall LFlareGroup::LFlareGroup(LFlareGroup *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "lfgroup");
  v1->vtblPointer = &LFlareGroup::`vftable';
  v1[1].name = 0;
  v1[1].Parent = 0;
  v1[1].Next = 0;
  v1[1].Child = 1;
  return v1;
}
// 101ADF48: using guessed type void *LFlareGroup::`vftable';

//----- (10021FA0) --------------------------------------------------------
void __thiscall LFlareGroup::addLFlare(LFlareGroup *this, struct Colour *a2, struct Vector3f *a3, struct Vector2f *a4, struct Vector2f *a5, struct Vector2f *a6)
{
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  struct LFInfo *v10; // [esp+4Ch] [ebp-8h]
  LFlareGroup *v11; // [esp+50h] [ebp-4h]

  v11 = this;
  v10 = StdSystem::getLFlareInfo(gsys);
  if ( v10 )
  {
    *v10 = *a2;
    v6 = (v10 + 4);
    *v6 = *a3;
    v6[1] = *(a3 + 1);
    v6[2] = *(a3 + 2);
    v7 = *(a4 + 1);
    *(v10 + 4) = *a4;
    *(v10 + 5) = v7;
    if ( a5 && a6 )
    {
      v8 = *(a5 + 1);
      *(v10 + 6) = *a5;
      *(v10 + 7) = v8;
      v9 = *(a6 + 1);
      *(v10 + 8) = *a6;
      *(v10 + 9) = v9;
    }
    else
    {
      Vector2f::set((v10 + 24), 0.0, 0.0);
      Vector2f::set((v10 + 32), 1.0, 1.0);
    }
    *(v10 + 10) = *(v11 + 8);
    *(v11 + 8) = v10;
  }
}

//----- (100220C0) --------------------------------------------------------
CoreNode *__thiscall LFlareGroup::LFlareGroup(LFlareGroup *this, const struct LFlareGroup *a2)
{
  CoreNode *v2; // ST50_4

  v2 = this;
  CoreNode::CoreNode(this, a2);
  v2[1].vtblPointer = *(a2 + 5);
  v2[1].name = *(a2 + 6);
  v2[1].Parent = *(a2 + 7);
  v2[1].Next = *(a2 + 8);
  v2[1].Child = *(a2 + 9);
  v2->vtblPointer = &LFlareGroup::`vftable';
  return v2;
}
// 101ADF48: using guessed type void *LFlareGroup::`vftable';

//----- (10022170) --------------------------------------------------------
_DWORD *__thiscall LFlareGroup::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  CoreNode::operator=(a2);
  v2[5] = a2[5];
  v2[6] = a2[6];
  v2[7] = a2[7];
  v2[8] = a2[8];
  v2[9] = a2[9];
  return v2;
}
// 10002D29: using guessed type _DWORD __stdcall CoreNode::operator=(_DWORD);

//----- (10022210) --------------------------------------------------------
void __thiscall CachedShape::insertAfter(CachedShape *this, struct CachedShape *a2)
{
  *(a2 + 1) = *(this + 1);
  *a2 = this;
  **(this + 1) = a2;
  *(this + 1) = a2;
}

//----- (10022280) --------------------------------------------------------
void __thiscall CachedShape::remove(CachedShape *this)
{
  **(this + 1) = *this;
  *(*this + 4) = *(this + 1);
}

//----- (100222D0) --------------------------------------------------------
CachedShape *__thiscall CachedShape::CachedShape(CachedShape *this)
{
  *(this + 1) = this;
  *this = this;
  return this;
}

//----- (10022320) --------------------------------------------------------
void *__thiscall CachedShape::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x18u);
  return this;
}

//----- (10022370) --------------------------------------------------------
void Graphics::videoReset()
{
  ;
}

//----- (100223A0) --------------------------------------------------------
void __stdcall Graphics::setVerticalFilter(unsigned __int8 *a2)
{
  ;
}

//----- (100223D0) --------------------------------------------------------
void __stdcall Graphics::getVerticalFilter(unsigned __int8 *a2)
{
  ;
}

//----- (10022400) --------------------------------------------------------
unsigned __int8 *Graphics::getDListPtr()
{
  return 0;
}

//----- (10022430) --------------------------------------------------------
unsigned __int32 Graphics::getDListRemainSize()
{
  return 0;
}

//----- (10022460) --------------------------------------------------------
unsigned __int32 __stdcall Graphics::compileMaterial(struct Material *a2)
{
  return 0;
}

//----- (100224A0) --------------------------------------------------------
void __stdcall Graphics::useDList(unsigned __int32 a2)
{
  ;
}

//----- (100224D0) --------------------------------------------------------
void __thiscall Graphics::resetLights(Graphics *this)
{
  CoreNode::initCore(this + 1, `string');
}

//----- (10022520) --------------------------------------------------------
void __thiscall Graphics::addLight(Graphics *this, struct Light *a2)
{
  Graphics *v2; // ST50_4

  v2 = this;
  CoreNode::initCore(a2, `string');
  ++*(gsys + 108);
  CoreNode::add(v2 + 1, a2);
}

//----- (100225A0) --------------------------------------------------------
void Graphics::setAmbient()
{
  ;
}

//----- (100225D0) --------------------------------------------------------
void __thiscall Graphics::setLightcam(Graphics *this, struct LightCamera *a2)
{
  *(this + 207) = a2;
}

//----- (10022610) --------------------------------------------------------
void __stdcall Graphics::setBlendMode(unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  ;
}

//----- (10022640) --------------------------------------------------------
void __thiscall Graphics::setMatHandler(Graphics *this, struct MaterialHandler *a2)
{
  struct MaterialHandler *v2; // [esp+4Ch] [ebp-8h]
  Graphics *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  if ( *(this + 213) && !a2 )
    (***(v3 + 213))(*(v3 + 213), 0);
  if ( a2 )
    v2 = a2;
  else
    v2 = *(v3 + 212);
  *(v3 + 213) = v2;
  *(*(v3 + 213) + 4) = v3;
}

//----- (10022700) --------------------------------------------------------
void __thiscall Graphics::useMaterial(Graphics *this, struct Material *a2)
{
  Graphics *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (***(this + 213))(*(this + 213), a2);
}

//----- (10022770) --------------------------------------------------------
void __stdcall Graphics::testRectangle(struct RectArea *a2)
{
  ;
}

//----- (100227A0) --------------------------------------------------------
void __stdcall Graphics::genAge(struct AgeServer *a2)
{
  ;
}

//----- (100227D0) --------------------------------------------------------
Graphics *__thiscall Graphics::Graphics(Graphics *this, const struct Graphics *a2)
{
  Graphics *v2; // ST50_4

  v2 = this;
  *(this + 1) = *(a2 + 1);
  *(this + 2) = *(a2 + 2);
  *(this + 3) = *(a2 + 3);
  *(this + 4) = *(a2 + 4);
  Light::Light((this + 20), (a2 + 20));
  *(v2 + 186) = *(a2 + 186);
  qmemcpy(v2 + 748, a2 + 748, 0x3Au);
  *(v2 + 202) = *(a2 + 202);
  *(v2 + 203) = *(a2 + 203);
  *(v2 + 204) = *(a2 + 204);
  *(v2 + 205) = *(a2 + 205);
  *(v2 + 206) = *(a2 + 206);
  *(v2 + 207) = *(a2 + 207);
  Vector3f::Vector3f((v2 + 832), (a2 + 832));
  *(v2 + 211) = *(a2 + 211);
  *(v2 + 212) = *(a2 + 212);
  *(v2 + 213) = *(a2 + 213);
  *(v2 + 214) = *(a2 + 214);
  *(v2 + 215) = *(a2 + 215);
  *(v2 + 216) = *(a2 + 216);
  *(v2 + 217) = *(a2 + 217);
  *(v2 + 218) = *(a2 + 218);
  *(v2 + 219) = *(a2 + 219);
  *(v2 + 220) = *(a2 + 220);
  *(v2 + 221) = *(a2 + 221);
  *(v2 + 222) = *(a2 + 222);
  *(v2 + 223) = *(a2 + 223);
  *(v2 + 224) = *(a2 + 224);
  *(v2 + 225) = *(a2 + 225);
  *(v2 + 226) = *(a2 + 226);
  *(v2 + 227) = *(a2 + 227);
  *(v2 + 228) = *(a2 + 228);
  qmemcpy(v2 + 916, a2 + 916, 0x24u);
  *v2 = &Graphics::`vftable';
  return v2;
}
// 101AD464: using guessed type void *Graphics::`vftable';

//----- (10022C00) --------------------------------------------------------
_DWORD *__thiscall Graphics::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // eax
  unsigned int i; // [esp+4Ch] [ebp-8h]
  _DWORD *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  this[1] = *(a2 + 4);
  this[2] = *(a2 + 8);
  this[3] = *(a2 + 12);
  this[4] = *(a2 + 16);
  Light::operator=(a2 + 20);
  v5[186] = *(a2 + 744);
  for ( i = 0; i < 8; ++i )
    v5[i + 187] = *(a2 + 4 * i + 748);
  v5[195] = *(a2 + 780);
  v5[196] = *(a2 + 784);
  v5[197] = *(a2 + 788);
  v5[198] = *(a2 + 792);
  v5[199] = *(a2 + 796);
  v5[200] = *(a2 + 800);
  *(v5 + 804) = *(a2 + 804);
  *(v5 + 805) = *(a2 + 805);
  v5[202] = *(a2 + 808);
  v5[203] = *(a2 + 812);
  v5[204] = *(a2 + 816);
  v5[205] = *(a2 + 820);
  v5[206] = *(a2 + 824);
  v5[207] = *(a2 + 828);
  v2 = v5 + 208;
  *v2 = *(a2 + 832);
  v2[1] = *(a2 + 836);
  v2[2] = *(a2 + 840);
  v5[211] = *(a2 + 844);
  v5[212] = *(a2 + 848);
  v5[213] = *(a2 + 852);
  v5[214] = *(a2 + 856);
  v5[215] = *(a2 + 860);
  v5[216] = *(a2 + 864);
  v5[217] = *(a2 + 868);
  v5[218] = *(a2 + 872);
  v5[219] = *(a2 + 876);
  v5[220] = *(a2 + 880);
  v5[221] = *(a2 + 884);
  v5[222] = *(a2 + 888);
  v5[223] = *(a2 + 892);
  v5[224] = *(a2 + 896);
  v5[225] = *(a2 + 900);
  v5[226] = *(a2 + 904);
  v5[227] = *(a2 + 908);
  v5[228] = *(a2 + 912);
  qmemcpy(v5 + 229, (a2 + 916), 0x24u);
  return v5;
}
// 1000233D: using guessed type _DWORD __stdcall Light::operator=(_DWORD);

//----- (10023050) --------------------------------------------------------
AtxStream *__thiscall AgeServer::AgeServer(AgeServer *this)
{
  AtxStream *v1; // ST50_4

  v1 = this;
  AtxStream::AtxStream(this);
  *v1 = &AgeServer::`vftable';
  return v1;
}
// 101ADF6C: using guessed type void *AgeServer::`vftable';

//----- (100230B0) --------------------------------------------------------
AtxStream *__thiscall AgeServer::AgeServer(AgeServer *this, const struct AgeServer *a2)
{
  AtxStream *v2; // ST50_4

  v2 = this;
  AtxStream::AtxStream(this, a2);
  *(v2 + 16) = *(a2 + 16);
  *v2 = &AgeServer::`vftable';
  return v2;
}
// 101ADF6C: using guessed type void *AgeServer::`vftable';

//----- (10023120) --------------------------------------------------------
_BYTE *__thiscall AgeServer::operator=(_BYTE *this, int a2)
{
  _BYTE *v2; // ST50_4

  v2 = this;
  AtxStream::operator=(a2);
  v2[16] = *(a2 + 16);
  return v2;
}
// 100025D1: using guessed type _DWORD __stdcall AtxStream::operator=(_DWORD);

//----- (10023180) --------------------------------------------------------
TimerInf *__thiscall TimerInf::TimerInf(TimerInf *this, char *a2)
{
  *(this + 9) = 0;
  *this = a2;
  *(this + 2) = 0;
  *(this + 3) = 0;
  *(this + 4) = 0;
  *(this + 5) = 0;
  *(this + 6) = 0;
  *(this + 7) = -1;
  *(this + 32) = 0;
  return this;
}

//----- (10023220) --------------------------------------------------------
void *__thiscall TimerInf::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x28u);
  return this;
}

//----- (10023270) --------------------------------------------------------
Timers *__thiscall Timers::Timers(Timers *this)
{
  *this = 0;
  *(this + 2) = 0;
  *(this + 1) = -1;
  return this;
}

//----- (100232D0) --------------------------------------------------------
void __thiscall Timers::~Timers(Timers *this)
{
  Timers::reset(this);
}

//----- (10023320) --------------------------------------------------------
void __stdcall Timers::start(char *a2, bool a3)
{
  ;
}

//----- (10023350) --------------------------------------------------------
void __stdcall Timers::stop(char *a2)
{
  ;
}

//----- (10023380) --------------------------------------------------------
_DWORD *__thiscall Timers::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  return this;
}

//----- (100233D0) --------------------------------------------------------
Light *__thiscall Light::Light(Light *this)
{
  float v2; // [esp+4Ch] [ebp-1Ch]
  float v3; // [esp+50h] [ebp-18h]
  float v4; // [esp+54h] [ebp-14h]
  float v5; // [esp+58h] [ebp-10h]
  float v6; // [esp+5Ch] [ebp-Ch]
  float v7; // [esp+60h] [ebp-8h]
  Light *v8; // [esp+64h] [ebp-4h]

  v8 = this;
  CoreNode::CoreNode(this, "light");
  Vector3f::Vector3f((v8 + 84));
  Vector3f::Vector3f((v8 + 96));
  Colour::Colour((v8 + 108));
  CullFrustum::CullFrustum((v8 + 116));
  *v8 = &Light::`vftable';
  *(v8 + 5) = 770;
  *(v8 + 9) = 3;
  *(v8 + 6) = 1161547776;
  *(v8 + 7) = 1057025006;
  *(v8 + 10) = 2;
  *(v8 + 8) = 1110704128;
  *(v8 + 11) = 0;
  *(v8 + 12) = 0;
  *(v8 + 13) = 1065279396;
  *(v8 + 14) = 1065353216;
  *(v8 + 15) = 0;
  *(v8 + 16) = 0;
  *(v8 + 18) = 1041865114;
  *(v8 + 17) = 1028443341;
  v7 = 0.0;
  v6 = 100.0;
  v5 = 0.0;
  Vector3f::set((v8 + 84), &v5, &v6, &v7);
  v4 = 0.0;
  v3 = -1.0;
  v2 = 0.0;
  Vector3f::set((v8 + 96), &v2, &v3, &v4);
  Colour::set((v8 + 108), 255, 255, 255, 0xFFu);
  Light::setLightDistAttn(v8, *(v8 + 6), *(v8 + 7), *(v8 + 9));
  return v8;
}
// 101ADBE0: using guessed type void *Light::`vftable';

//----- (100235D0) --------------------------------------------------------
void __thiscall Light::setLightDistAttn(Light *this, float a2, float a3, int a4)
{
  float v4; // [esp+50h] [ebp-10h]
  float v5; // [esp+54h] [ebp-Ch]

  *(this + 6) = a2;
  *(this + 7) = a3;
  *(this + 9) = a4;
  if ( a2 < 0.0 )
    a4 = 0;
  if ( a3 <= 0.0 || a3 >= 1.0 )
    a4 = 0;
  switch ( a4 )
  {
    case 1:
      v5 = (1.0 - a3) / (a3 * a2);
      v4 = 0.0;
      break;
    case 2:
      v5 = (1.0 - a3) * 0.5 / (a3 * a2);
      v4 = (1.0 - a3) * 0.5 / (a3 * a2 * a2);
      break;
    case 3:
      v5 = 0.0;
      v4 = (1.0 - a3) / (a3 * a2 * a2);
      break;
    default:
      v5 = 0.0;
      v4 = 0.0;
      break;
  }
  *(this + 11) = 1065353216;
  *(this + 12) = v5;
  *(this + 13) = v4;
  *(this + 28) = 1;
}

//----- (10023790) --------------------------------------------------------
void __thiscall Light::setLightSpot(Light *this, float a2, int a3)
{
  double v3; // st7
  float v4; // ST5C_4
  float v5; // ST58_4
  float v6; // ST58_4
  float v7; // ST58_4
  float v8; // [esp+50h] [ebp-1Ch]
  float v9; // [esp+5Ch] [ebp-10h]
  float v10; // [esp+60h] [ebp-Ch]
  float v11; // [esp+64h] [ebp-8h]
  Light *v12; // [esp+68h] [ebp-4h]

  v12 = this;
  if ( a2 <= 0.0 || a2 > 90.0 )
    a3 = 0;
  v3 = a2 * 3.1415927 / 180.0;
  v4 = v3;
  sub_10002D47(v4);
  v8 = v3;
  switch ( a3 )
  {
    case 1:
      v11 = -1000.0 * v8;
      v10 = 1000.0;
      v9 = 0.0;
      break;
    case 2:
      v11 = -v8 / (1.0 - v8);
      v10 = 1.0 / (1.0 - v8);
      v9 = 0.0;
      break;
    case 3:
      v11 = 0.0;
      v10 = -v8 / (1.0 - v8);
      v9 = 1.0 / (1.0 - v8);
      break;
    case 4:
      v5 = (1.0 - v8) * (1.0 - v8);
      v11 = (v8 - 2.0) * v8 / v5;
      v10 = 2.0 / v5;
      v9 = -1.0 / v5;
      break;
    case 5:
      v6 = (1.0 - v8) * (1.0 - v8);
      v11 = -4.0 * v8 / v6;
      v10 = (v8 + 1.0) * 4.0 / v6;
      v9 = -4.0 / v6;
      break;
    case 6:
      v7 = (1.0 - v8) * (1.0 - v8);
      v11 = 1.0 - 2.0 * v8 * v8 / v7;
      v10 = 4.0 * v8 / v7;
      v9 = -2.0 / v7;
      break;
    default:
      v11 = 1.0;
      v10 = 0.0;
      v9 = 0.0;
      break;
  }
  *(v12 + 14) = v11;
  *(v12 + 15) = v10;
  *(v12 + 16) = v9;
  *(v12 + 28) = 1;
}

//----- (10023A70) --------------------------------------------------------
void __thiscall Light::setLightParallel(Light *this)
{
  *(this + 11) = 1065353216;
  *(this + 13) = 0;
  *(this + 12) = 0;
  *(this + 14) = 1065353216;
  *(this + 16) = 0;
  *(this + 15) = 0;
  *(this + 28) = 1;
}

//----- (10023B00) --------------------------------------------------------
void __thiscall Light::calcLightSizes(Light *this)
{
  float v1; // [esp+4Ch] [ebp-Ch]
  signed int i; // [esp+50h] [ebp-8h]

  if ( *(this + 28) )
  {
    *(this + 19) = -1082130432;
    *(this + 20) = -1082130432;
    for ( i = 0; i < 0x4000; i += 8 )
    {
      v1 = 1.0 / (*(this + 11) + i * *(this + 12) + i * *(this + 13) * i);
      if ( *(this + 19) == -1.0 && *(this + 18) > v1 )
        *(this + 19) = i;
      if ( *(this + 20) == -1.0 && *(this + 17) > v1 )
        *(this + 20) = i;
    }
    if ( *(this + 19) == -1.0 )
      *(this + 19) = i;
    if ( *(this + 20) == -1.0 )
      *(this + 20) = i;
    *(this + 28) = 0;
  }
}

//----- (10023C80) --------------------------------------------------------
double __thiscall Light::calcLightMapRadius(Light *this)
{
  Light *v1; // ST50_4

  v1 = this;
  Light::calcLightSizes(this);
  return *(v1 + 20);
}

//----- (10023CD0) --------------------------------------------------------
double __thiscall Light::calcLightObjRadius(Light *this)
{
  Light *v1; // ST50_4

  v1 = this;
  Light::calcLightSizes(this);
  return *(v1 + 19);
}

//----- (10023D20) --------------------------------------------------------
void __thiscall Light::refresh(Light *this, struct Graphics *a2, struct LFlareGroup *a3)
{
  int v3; // ecx
  struct Vector2f *v4; // eax
  int v5; // [esp+4Ch] [ebp-30h]
  float v6; // [esp+50h] [ebp-2Ch]
  float v7; // [esp+54h] [ebp-28h]
  char v8; // [esp+58h] [ebp-24h]
  char v9; // [esp+60h] [ebp-1Ch]
  char v10; // [esp+6Ch] [ebp-10h]
  float v11; // [esp+70h] [ebp-Ch]
  float v12; // [esp+74h] [ebp-8h]
  Light *v13; // [esp+78h] [ebp-4h]

  v13 = this;
  v5 = *(this + 5) & 0xFF;
  if ( v5 == 2 )
  {
    v12 = Light::calcLightMapRadius(v13);
    v11 = Light::calcLightObjRadius(v13);
    (*(*a2 + 160))(a2, v13 + 108, 1);
    (*(*a2 + 196))(a2, 0, 0);
    v10 = (*(*a2 + 40))(a2, 0, 0);
    Graphics::drawSphere(a2, (v13 + 84), v12, (*(a2 + 186) + 480));
    LOBYTE(v3) = v10;
    (*(*a2 + 40))(a2, v3, 0);
    if ( a3 )
    {
      Vector3f::Vector3f(&v9, (v13 + 84));
      Vector3f::multMatrix(&v9, (*(a2 + 186) + 480));
      v7 = v12 / 4.0;
      v6 = v12 / 4.0;
      v4 = Vector2f::Vector2f(&v8, &v6, &v7);
      LFlareGroup::addLFlare(a3, (v13 + 108), &v9, v4, 0, 0);
    }
  }
  else if ( v5 == 3 )
  {
    CullFrustum::draw((v13 + 116), a2);
  }
}

//----- (10023F00) --------------------------------------------------------
void __thiscall Light::update(Light *this)
{
  int v1; // [esp+4Ch] [ebp-8h]
  Light *v2; // [esp+50h] [ebp-4h]

  v2 = this;
  v1 = *(this + 5) & 0xFF;
  switch ( v1 )
  {
    case 1:
      Light::setLightParallel(this);
      break;
    case 2:
      Light::setLightDistAttn(this, *(this + 6), *(this + 7), *(this + 9));
      *(v2 + 14) = 1065353216;
      *(v2 + 16) = 0;
      *(v2 + 15) = 0;
      break;
    case 3:
      Light::setLightSpot(this, *(this + 8), *(this + 10));
      *(v2 + 11) = 1065353216;
      *(v2 + 13) = 0;
      *(v2 + 12) = 0;
      break;
  }
}

//----- (10024000) --------------------------------------------------------
void __thiscall Light::recalcLighting(Light *this, struct AgeServer *a2)
{
  Light::update(this);
}

//----- (10024050) --------------------------------------------------------
void __stdcall Light::refreshSection(struct AgeServer *a2)
{
  AgeServer::RefreshSection(a2);
}

//----- (100240A0) --------------------------------------------------------
void __thiscall Light::updAge(Light *this, struct AgeServer *a2)
{
  int v2; // [esp+4Ch] [ebp-2Ch]
  int v3; // [esp+50h] [ebp-28h]
  int v4; // [esp+54h] [ebp-24h]
  Light *v5; // [esp+68h] [ebp-10h]

  v5 = this;
  AgeServer::StartGroup(a2, "light info");
  if ( sub_10002A81(0xCu) )
    v4 = sub_10002AE5(v5, Light::refreshSection);
  else
    v4 = 0;
  AgeServer::setOnChange(v4);
  AgeServer::StartOptionBox(a2, "LightType", v5 + 5, 333);
  AgeServer::NewOption(a2, "PARALLEL", 1);
  AgeServer::NewOption(a2, "POINT", 2);
  AgeServer::NewOption(a2, "SPOT", 3);
  AgeServer::EndOptionBox(a2);
  AgeServer::setOnChange(a2, 0);
  v3 = *(v5 + 5) & 0xFF;
  if ( v3 == 2 )
  {
    AgeServer::StartOptionBox(a2, "slope", v5 + 9, 333);
    AgeServer::NewOption(a2, "GENTLE", 1);
    AgeServer::NewOption(a2, "MEDIUM", 2);
    AgeServer::NewOption(a2, "STEEP", 3);
    AgeServer::EndOptionBox(a2);
    AgeServer::NewEditor(a2, "refDist", v5 + 6, 1.0, 5000.0, 320);
    AgeServer::NewEditor(a2, "refBrightness", v5 + 7, 0.0099999998, 0.99000001, 320);
  }
  else if ( v3 == 3 )
  {
    AgeServer::StartOptionBox(a2, "slope", v5 + 10, 333);
    AgeServer::NewOption(a2, "FLAT", 1);
    AgeServer::NewOption(a2, "COS", 2);
    AgeServer::NewOption(a2, "COS2", 3);
    AgeServer::NewOption(a2, "SHARP", 4);
    AgeServer::NewOption(a2, "RING1", 5);
    AgeServer::NewOption(a2, "RING2", 6);
    AgeServer::EndOptionBox(a2);
    AgeServer::NewEditor(a2, "refAngle", v5 + 8, 1.0, 180.0, 320);
  }
  if ( sub_10002A81(0xCu) )
    v2 = sub_10002AE5(v5, Light::recalcLighting);
  else
    v2 = 0;
  AgeServer::NewButton("SET!", v2, 444);
  AgeServer::NewEditor(a2, "lcutoff", v5 + 17, 0.0, 1.0, 320);
  AgeServer::NewEditor(a2, "pos.x", v5 + 21, -1500.0, 1500.0, 320);
  AgeServer::NewEditor(a2, "pos.y", v5 + 22, -1500.0, 1500.0, 320);
  AgeServer::NewEditor(a2, "pos.z", v5 + 23, -1500.0, 1500.0, 320);
  Colour::genAge((v5 + 108), a2, "colour");
  AgeServer::EndGroup(a2);
}
// 10001451: using guessed type _DWORD __stdcall AgeServer::NewButton(_DWORD, _DWORD, _DWORD);
// 10002AE5: using guessed type _DWORD __stdcall sub_10002AE5(_DWORD, _DWORD);
// 10002BAD: using guessed type _DWORD __stdcall AgeServer::setOnChange(_DWORD);

//----- (100244E0) --------------------------------------------------------
void __thiscall Light::genAge(Light *this, struct AgeServer *a2)
{
  int v2; // [esp+4Ch] [ebp-11Ch]
  HGLOBAL hMem; // [esp+50h] [ebp-118h]
  int v4; // [esp+54h] [ebp-114h]
  char Dest; // [esp+58h] [ebp-110h]
  Light *v6; // [esp+158h] [ebp-10h]
  int v7; // [esp+164h] [ebp-4h]

  v6 = this;
  sprintf(&Dest, "light %08x", this);
  AgeServer::StartSection(a2, &Dest, 1);
  hMem = sub_10002A81(0xCu);
  v7 = 0;
  if ( hMem )
    v2 = sub_10002AE5(v6, sub_10001B2C);
  else
    v2 = 0;
  v4 = v2;
  v7 = -1;
  AgeServer::setSectionRefresh(v2);
  AgeServer::EndSection(a2);
}
// 10001B2C: using guessed type int sub_10001B2C();
// 10001DE3: using guessed type _DWORD __stdcall AgeServer::setSectionRefresh(_DWORD);
// 10002AE5: using guessed type _DWORD __stdcall sub_10002AE5(_DWORD, _DWORD);

//----- (10024620) --------------------------------------------------------
_DWORD *__thiscall sub_10024620(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10001D43(this);
  *v3 = &off_101AE0D8;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10001D43: using guessed type int __thiscall sub_10001D43(_DWORD);
// 101AE0D8: using guessed type int (__stdcall *off_101AE0D8)(int);

//----- (10024690) --------------------------------------------------------
int __thiscall sub_10024690(int this, int a2)
{
  int v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  return (*(this + 8))(*(this + 4), a2);
}

//----- (100246F0) --------------------------------------------------------
_DWORD *__thiscall sub_100246F0(_DWORD *this)
{
  *this = &off_101AE0DC;
  return this;
}
// 101AE0DC: using guessed type void *off_101AE0DC;

//----- (10024730) --------------------------------------------------------
int __thiscall sub_10024730(void *this)
{
  return (*(*this + 20))();
}

//----- (10024740) --------------------------------------------------------
void __userpurge Envelope::read(Envelope *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // [esp+4Ch] [ebp-10h]
  int i; // [esp+50h] [ebp-Ch]
  int v7; // [esp+54h] [ebp-8h]
  Envelope *v8; // [esp+58h] [ebp-4h]

  v8 = this;
  v3 = (*(*a3 + 8))(a3);
  *v8 = v3;
  v5 = sub_10001AC3(8 * *v8);
  v7 = v5;
  *(v8 + 1) = v5;
  *(v8 + 2) = v7 + 4 * *v8;
  for ( i = 0; i < *v8; ++i )
  {
    v4 = (*(*a3 + 8))(a3);
    *(*(v8 + 1) + 4 * i) = v4;
    (*(*a3 + 12))(a3);
    *(*(v8 + 2) + 4 * i) = a2;
  }
}

//----- (10024860) --------------------------------------------------------
void __thiscall Envelope::write(Envelope *this, struct RandomAccessStream *a2)
{
  int v2; // ecx
  int i; // [esp+4Ch] [ebp-8h]
  Envelope *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  LOWORD(this) = *this;
  (*(*a2 + 36))(a2, this);
  for ( i = 0; i < *v4; ++i )
  {
    HIWORD(v2) = HIWORD(v4);
    LOWORD(v2) = *(*(v4 + 1) + 4 * i);
    (*(*a2 + 36))(a2, v2);
    (*(*a2 + 40))(a2, *(*(v4 + 2) + 4 * i));
  }
}

//----- (10024940) --------------------------------------------------------
void __thiscall DispList::read(DispList *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // [esp+4Ch] [ebp-8h]
  DispList *v6; // [esp+50h] [ebp-4h]

  v6 = this;
  v2 = (**a2)(a2);
  *(v6 + 5) = v2;
  v3 = (**a2)(a2);
  *(v6 + 10) = v3;
  v4 = (**a2)(a2);
  *(v6 + 6) = v4;
  RandomAccessStream::skipPadding(a2, 0x20u);
  v5 = sub_100011A4(*(v6 + 6), 32);
  *(v6 + 7) = v5;
  (*(*a2 + 52))(a2, *(v6 + 7), *(v6 + 6));
}
// 100011A4: using guessed type _DWORD __cdecl sub_100011A4(_DWORD, _DWORD);

//----- (10024A40) --------------------------------------------------------
void __thiscall DispList::prepareTriList(DispList *this, struct TriStripifier *a2)
{
  HGLOBAL hMem; // ST6C_4
  HGLOBAL v3; // ST64_4
  int v4; // ST0C_4
  int v5; // ST08_4
  int v6; // eax
  int v7; // [esp+4Ch] [ebp-94h]
  int v8; // [esp+50h] [ebp-90h]
  int l; // [esp+64h] [ebp-7Ch]
  char v10; // [esp+68h] [ebp-78h]
  signed int k; // [esp+6Ch] [ebp-74h]
  int v12; // [esp+70h] [ebp-70h]
  int v13; // [esp+74h] [ebp-6Ch]
  int v14; // [esp+78h] [ebp-68h]
  int v15; // [esp+7Ch] [ebp-64h]
  int v16; // [esp+80h] [ebp-60h]
  int v17; // [esp+84h] [ebp-5Ch]
  int v18; // [esp+88h] [ebp-58h]
  int v19; // [esp+8Ch] [ebp-54h]
  int v20; // [esp+90h] [ebp-50h]
  int v21; // [esp+94h] [ebp-4Ch]
  int v22; // [esp+98h] [ebp-48h]
  int v23; // [esp+9Ch] [ebp-44h]
  int v24; // [esp+A0h] [ebp-40h]
  int v25; // [esp+A4h] [ebp-3Ch]
  int v26; // [esp+A8h] [ebp-38h]
  int j; // [esp+ACh] [ebp-34h]
  int *v28; // [esp+B0h] [ebp-30h]
  int *v29; // [esp+B4h] [ebp-2Ch]
  _DWORD *v30; // [esp+B8h] [ebp-28h]
  int v31; // [esp+BCh] [ebp-24h]
  int *v32; // [esp+C0h] [ebp-20h]
  _DWORD *i; // [esp+C4h] [ebp-1Ch]
  struct TriStripifier *v34; // [esp+C8h] [ebp-18h]
  struct TriStripifier *v35; // [esp+CCh] [ebp-14h]
  DispList *v36; // [esp+D0h] [ebp-10h]
  int v37; // [esp+DCh] [ebp-4h]

  v36 = this;
  v35 = a2;
  v34 = (a2 + 12);
  for ( i = *(this + 15); i; i = i[3] )
  {
    v32 = i[7];
    v31 = i[8];
    v30 = i[6];
    v29 = i[9];
    v28 = i[10];
    *(a2 + 9) += i[5];
    *(a2 + 10) += 3 * (i[5] - 2);
    for ( j = 0; j < i[5] - 2; ++j )
    {
      if ( v30 )
      {
        v24 = 3 * *v30;
        v25 = 3 * v30[j + 1];
        v26 = 3 * v30[j + 2];
      }
      else
      {
        v26 = 0;
        v25 = 0;
        v24 = 0;
      }
      v21 = *v32;
      v22 = v32[j + 1];
      v23 = v32[j + 2];
      if ( v29 )
      {
        v18 = *v29;
        v19 = v29[j + 1];
        v20 = v29[j + 2];
      }
      else
      {
        v20 = 0;
        v19 = 0;
        v18 = 0;
      }
      if ( v28 )
      {
        v15 = *v28;
        v16 = v28[j + 1];
        v17 = v28[j + 2];
      }
      else
      {
        v17 = 0;
        v16 = 0;
        v15 = 0;
      }
      for ( k = 0; k < 3; ++k )
      {
        hMem = sub_10002A81(0x10u);
        v37 = 0;
        if ( hMem )
          v8 = sub_10002ADB(*(&v24 + k), *(&v21 + k), *(&v18 + k), *(&v15 + k));
        else
          v8 = 0;
        v37 = -1;
        *(&v12 + k) = v8;
        v10 = 0;
        for ( l = 0; l < *(v35 + 1); ++l )
        {
          if ( **sub_10002504(l) == **(&v12 + k)
            && *(*sub_10002504(l) + 4) == *(*(&v12 + k) + 4)
            && *(*sub_10002504(l) + 8) == *(*(&v12 + k) + 8)
            && *(*sub_10002504(l) + 12) == *(*(&v12 + k) + 12) )
          {
            *(&v12 + k) = *sub_10002504(l);
            v10 = 1;
            break;
          }
        }
        if ( !v10 )
          sub_100011EF(*(&v12 + k));
      }
      v3 = sub_10002A81(0x18u);
      v37 = 1;
      if ( v3 )
      {
        v4 = sub_100023D8(v14);
        v5 = sub_100023D8(v13);
        v6 = sub_100023D8(v12);
        v7 = sub_100013A7(v6, v5, v4);
      }
      else
      {
        v7 = 0;
      }
      v37 = -1;
      sub_1000110E(v7);
    }
  }
}
// 1000110E: using guessed type _DWORD __stdcall sub_1000110E(_DWORD);
// 100011EF: using guessed type _DWORD __stdcall sub_100011EF(_DWORD);
// 100013A7: using guessed type _DWORD __stdcall sub_100013A7(_DWORD, _DWORD, _DWORD);
// 100023D8: using guessed type _DWORD __stdcall sub_100023D8(_DWORD);
// 10002504: using guessed type _DWORD __stdcall sub_10002504(_DWORD);
// 10002ADB: using guessed type _DWORD __stdcall sub_10002ADB(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10024F20) --------------------------------------------------------
void __thiscall DispList::outputTriData(DispList *this, struct RandomAccessStream *a2, unsigned __int32 a3, bool a4)
{
  const char *v4; // [esp+4Ch] [ebp-18h]
  int k; // [esp+50h] [ebp-14h]
  int v6; // [esp+54h] [ebp-10h]
  int j; // [esp+58h] [ebp-Ch]
  _DWORD *i; // [esp+5Ch] [ebp-8h]
  DispList *v9; // [esp+60h] [ebp-4h]

  v9 = this;
  if ( a4 )
    v4 = "STRIPPED";
  else
    v4 = "FANNED";
  for ( i = *(v9 + 15); i; i = i[3] )
  {
    if ( a4 )
      (*(*a2 + 32))(a2, 152);
    else
      (*(*a2 + 32))(a2, 160);
    (*(*a2 + 32))(a2, i[5] >> 8);
    (*(*a2 + 32))(a2, i[5] & 0xFF);
    for ( j = 0; j < i[5]; ++j )
    {
      if ( i[6] )
      {
        if ( a3 & 1 )
          (*(*a2 + 32))(a2, 3 * *(i[6] + 4 * j));
        if ( a3 & 2 )
          (*(*a2 + 32))(a2, 3 * *(i[6] + 4 * j) + 30);
      }
      else
      {
        if ( a3 & 1 )
          (*(*a2 + 32))(a2, 0);
        if ( a3 & 2 )
          (*(*a2 + 32))(a2, 30);
      }
      (*(*a2 + 32))(a2, *(i[7] + 4 * j) >> 8);
      (*(*a2 + 32))(a2, *(i[7] + 4 * j) & 0xFF);
      if ( i[9] )
      {
        (*(*a2 + 32))(a2, *(i[9] + 4 * j) >> 8);
        (*(*a2 + 32))(a2, *(i[9] + 4 * j) & 0xFF);
      }
      else
      {
        (*(*a2 + 32))(a2, 0);
        (*(*a2 + 32))(a2, 0);
      }
      if ( i[8] )
      {
        (*(*a2 + 32))(a2, *(i[8] + 4 * j) >> 8);
        (*(*a2 + 32))(a2, *(i[8] + 4 * j) & 0xFF);
      }
      LOBYTE(v6) = 0;
      for ( k = 0; k < 8; ++k )
      {
        if ( i[k + 10] )
        {
          (*(*a2 + 32))(a2, *(i[k + 10] + 4 * j) >> 8);
          (*(*a2 + 32))(a2, *(i[k + 10] + 4 * j) & 0xFF);
        }
        LOBYTE(v6) = 1;
      }
      if ( !v6 )
      {
        (*(*a2 + 32))(a2, 0);
        (*(*a2 + 32))(a2, 0);
      }
    }
  }
}

//----- (100253A0) --------------------------------------------------------
void __thiscall DispList::exportData(DispList *this, struct RandomAccessStream *a2, unsigned __int32 a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // [esp+4Ch] [ebp-64h]
  int j; // [esp+50h] [ebp-60h]
  int v7; // [esp+54h] [ebp-5Ch]
  int v8; // [esp+58h] [ebp-58h]
  int v9; // [esp+90h] [ebp-20h]
  int v10; // [esp+94h] [ebp-1Ch]
  int i; // [esp+98h] [ebp-18h]
  int v12; // [esp+9Ch] [ebp-14h]
  DispList *v13; // [esp+A0h] [ebp-10h]

  v13 = this;
  (*(*a2 + 28))(a2, *(this + 5));
  v12 = 0;
  for ( i = *(v13 + 15); i; i = *(i + 12) )
    v12 = v12 + *(i + 20) - 2;
  (*(*a2 + 28))(a2, v12);
  v10 = (*(*a2 + 80))(a2);
  (*(*a2 + 28))(a2, 0);
  RandomAccessStream::padFile(a2, 0x20u);
  v9 = (*(*a2 + 80))(a2);
  DispList::outputTriData(v13, a2, a3, (*(v13 + 5) & 0x1000000) != 0);
  v3 = (*(*a2 + 80))(a2);
  v8 = v3 - v9;
  v4 = v3 - v9 + 31;
  LOBYTE(v4) = v4 & 0xE0;
  v7 = v4 - v8;
  for ( j = 0; j < v7; ++j )
    (*(*a2 + 32))(a2, 0);
  v5 = (*(*a2 + 80))(a2);
  (*(*a2 + 84))(a2, v10);
  (*(*a2 + 28))(a2, v7 + v8);
  (*(*a2 + 84))(a2, v5);
}
// 1000185C: using guessed type _DWORD __stdcall sub_1000185C(_DWORD);
// 10001CD0: using guessed type int __thiscall sub_10001CD0(_DWORD);
// 10001D98: using guessed type int __thiscall sub_10001D98(_DWORD);
// 10002C98: using guessed type int __thiscall sub_10002C98(_DWORD);

//----- (10025670) --------------------------------------------------------
int __thiscall sub_10025670(char *this)
{
  char *v1; // ST50_4

  v1 = this;
  sub_10001370(this + 24);
  sub_1000137A(v1 + 12);
  return sub_10001E9C(v1);
}
// 10001370: using guessed type int __thiscall sub_10001370(_DWORD);
// 1000137A: using guessed type int __thiscall sub_1000137A(_DWORD);
// 10001E9C: using guessed type int __thiscall sub_10001E9C(_DWORD);

//----- (10025710) --------------------------------------------------------
void __thiscall MtxGroup::read(MtxGroup *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  __int16 v3; // ax
  int v4; // eax
  _DWORD *v5; // [esp+4Ch] [ebp-3Ch]
  HGLOBAL v6; // [esp+50h] [ebp-38h]
  HGLOBAL v7; // [esp+54h] [ebp-34h]
  _DWORD *v8; // [esp+58h] [ebp-30h]
  HGLOBAL hMem; // [esp+5Ch] [ebp-2Ch]
  HGLOBAL v10; // [esp+60h] [ebp-28h]
  int v11; // [esp+64h] [ebp-24h]
  struct GfxobjInfo *v12; // [esp+68h] [ebp-20h]
  int j; // [esp+6Ch] [ebp-1Ch]
  int v14; // [esp+70h] [ebp-18h]
  int i; // [esp+74h] [ebp-14h]
  MtxGroup *v16; // [esp+78h] [ebp-10h]
  int v17; // [esp+84h] [ebp-4h]

  v16 = this;
  v2 = (**a2)(a2);
  *v16 = v2;
  if ( *v16 )
  {
    v11 = sub_10001AC3(4 * *v16);
    *(v16 + 1) = v11;
    for ( i = 0; i < *v16; ++i )
    {
      v3 = (*(*a2 + 8))(a2);
      *(*(v16 + 1) + 4 * i) = v3;
    }
  }
  v4 = (**a2)(a2);
  *(v16 + 2) = v4;
  if ( *(v16 + 2) )
  {
    v14 = *(v16 + 2);
    hMem = sub_10001AC3(116 * v14);
    v17 = 0;
    if ( hMem )
    {
      sub_1000291E(hMem, 116, v14, DispList::DispList);
      v6 = hMem;
    }
    else
    {
      v6 = 0;
    }
    v10 = v6;
    v17 = -1;
    *(v16 + 3) = v6;
    for ( j = 0; j < *(v16 + 2); ++j )
    {
      (*(*(*(v16 + 3) + 116 * j) + 16))(116 * j + *(v16 + 3), a2);
      v7 = sub_10002A81(0x24u);
      v17 = 1;
      if ( v7 )
        v5 = DlobjInfo::DlobjInfo(v7);
      else
        v5 = 0;
      v8 = v5;
      v17 = -1;
      v12 = v5;
      v5[8] = 116 * j + *(v16 + 3);
      StdSystem::addGfxObject(gsys, v12);
    }
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100259A0) --------------------------------------------------------
void __thiscall MtxGroup::exportData(MtxGroup *this, struct RandomAccessStream *a2, unsigned __int32 a3)
{
  int v3; // ecx
  int j; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]
  MtxGroup *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  (*(*a2 + 28))(a2, *this);
  for ( i = 0; i < *v6; ++i )
  {
    HIWORD(v3) = HIWORD(v6);
    LOWORD(v3) = *(*(v6 + 1) + 4 * i);
    (*(*a2 + 36))(a2, v3);
  }
  (*(*a2 + 28))(a2, *(v6 + 2));
  for ( j = 0; j < *(v6 + 2); ++j )
    DispList::exportData((116 * j + *(v6 + 3)), a2, a3);
}

//----- (10025AC0) --------------------------------------------------------
void __thiscall Mesh::read(Mesh *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  HGLOBAL v5; // [esp+4Ch] [ebp-24h]
  HGLOBAL hMem; // [esp+50h] [ebp-20h]
  HGLOBAL v7; // [esp+54h] [ebp-1Ch]
  int i; // [esp+58h] [ebp-18h]
  int v9; // [esp+5Ch] [ebp-14h]
  Mesh *v10; // [esp+60h] [ebp-10h]
  int v11; // [esp+6Ch] [ebp-4h]

  v10 = this;
  v2 = (**a2)(a2);
  *(v10 + 6) = v2;
  v3 = (**a2)(a2);
  *(v10 + 11) = v3;
  v4 = (**a2)(a2);
  *(v10 + 8) = v4;
  if ( *(v10 + 8) )
  {
    v9 = *(v10 + 8);
    hMem = sub_10001AC3(16 * v9);
    v11 = 0;
    if ( hMem )
    {
      sub_1000291E(hMem, 16, v9, MtxGroup::MtxGroup);
      v5 = hMem;
    }
    else
    {
      v5 = 0;
    }
    v7 = v5;
    v11 = -1;
    *(v10 + 9) = v5;
    *(v10 + 7) = 0;
    for ( i = 0; i < *(v10 + 8); ++i )
    {
      MtxGroup::read((16 * i + *(v10 + 9)), a2);
      if ( *(*(v10 + 9) + 16 * i) > *(v10 + 7) )
        *(v10 + 7) = *(*(v10 + 9) + 16 * i);
    }
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10025CA0) --------------------------------------------------------
void __thiscall Mesh::exportData(Mesh *this, struct RandomAccessStream *a2)
{
  int v2; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]
  Mesh *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  if ( *(this + 10) )
    v2 = *(*(v4 + 10) + 20);
  else
    v2 = -1;
  (*(*a2 + 28))(a2, v2);
  (*(*a2 + 28))(a2, *(v4 + 11));
  (*(*a2 + 28))(a2, *(v4 + 8));
  for ( i = 0; i < *(v4 + 8); ++i )
    MtxGroup::exportData((*(v4 + 9) + 16 * i), a2, *(v4 + 11));
}

//----- (10025DB0) --------------------------------------------------------
void __thiscall Joint::recShowHierarchy(Joint *this)
{
  Joint *i; // [esp+50h] [ebp-8h]

  for ( i = this; i; i = *(i + 3) )
  {
    sub_10025E40("got joint %08x\n", i);
    if ( *(i + 4) )
      Joint::recShowHierarchy(*(i + 4));
  }
}

//----- (10025E40) --------------------------------------------------------
char *__cdecl sub_10025E40(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "shapeBase" )
      Stream::print(sysCon, "%s: ", "shapeBase");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10025F50) --------------------------------------------------------
void __thiscall Joint::overrideAnim(Joint *this, struct AnimContext *a2)
{
  *(*(*(this + 70) + 28) + 4 * *(this + 5)) = a2;
}

//----- (10025FA0) --------------------------------------------------------
void __thiscall Joint::recOverrideAnim(Joint *this, struct AnimContext *a2)
{
  Joint *i; // [esp+50h] [ebp-8h]

  for ( i = this; i; i = *(i + 3) )
  {
    Joint::overrideAnim(i, a2);
    if ( *(i + 4) )
      Joint::recOverrideAnim(*(i + 4), a2);
  }
}

//----- (10026030) --------------------------------------------------------
void __userpurge Joint::read(Joint *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  int v3; // eax
  int v4; // eax
  __int16 v5; // ax
  __int16 v6; // ax
  struct CoreNode *v7; // [esp+4Ch] [ebp-2Ch]
  HGLOBAL hMem; // [esp+50h] [ebp-28h]
  struct CoreNode *v9; // [esp+54h] [ebp-24h]
  struct CoreNode *v10; // [esp+58h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-1Ch]
  float v12; // [esp+60h] [ebp-18h]
  int v13; // [esp+64h] [ebp-14h]
  Joint *v14; // [esp+68h] [ebp-10h]
  int v15; // [esp+74h] [ebp-4h]

  v14 = this;
  v3 = (**a3)(a3);
  *(v14 + 6) = v3;
  LOWORD(v13) = (**a3)(a3);
  *(v14 + 201) = (v13 & 1) != 0;
  *(v14 + 202) = (v13 & 0x4000) != 0;
  Vector3f::read((v14 + 204), a3);
  Vector3f::read((v14 + 216), a3);
  (*(*a3 + 12))(a3);
  v12 = a2;
  Vector3f::read((v14 + 36), a3);
  Vector3f::read((v14 + 48), a3);
  Vector3f::read((v14 + 60), a3);
  v4 = (**a3)(a3);
  *(v14 + 68) = v4;
  CoreNode::initCore((v14 + 228), `string');
  for ( i = 0; i < *(v14 + 68); ++i )
  {
    hMem = sub_10002A81(0x28u);
    v15 = 0;
    if ( hMem )
      v7 = Joint::MatPoly::MatPoly(hMem);
    else
      v7 = 0;
    v9 = v7;
    v15 = -1;
    v10 = v7;
    v5 = (*(*a3 + 8))(a3);
    v10[1].Parent = v5;
    v6 = (*(*a3 + 8))(a3);
    v10[1].Next = v6;
    CoreNode::add((v14 + 228), v10);
  }
}

//----- (100262C0) --------------------------------------------------------
void __thiscall Joint::write(Joint *this, struct RandomAccessStream *a2)
{
  int v2; // edx
  int v3; // ecx
  int i; // [esp+4Ch] [ebp-10h]
  int v5; // [esp+50h] [ebp-Ch]
  int v6; // [esp+54h] [ebp-8h]
  Joint *v7; // [esp+58h] [ebp-4h]

  v7 = this;
  (*(*a2 + 28))(a2, *(this + 6));
  v6 = *(v7 + 201) != 0;
  v6 |= *(v7 + 202) != 0 ? 0x4000 : 0;
  (*(*a2 + 28))(a2, v6);
  Vector3f::write((v7 + 204), a2);
  Vector3f::write((v7 + 216), a2);
  (*(*a2 + 40))(a2, 0);
  Vector3f::write((v7 + 36), a2);
  Vector3f::write((v7 + 48), a2);
  Vector3f::write((v7 + 60), a2);
  (*(*a2 + 28))(a2, *(v7 + 68));
  v5 = 0;
  for ( i = *(v7 + 61); i; i = *(i + 12) )
  {
    LOWORD(v2) = *(i + 28);
    (*(*a2 + 36))(a2, v2);
    LOWORD(v3) = *(i + 32);
    (*(*a2 + 36))(a2, v3);
    ++v5;
    HIWORD(v2) = HIWORD(i);
  }
}

//----- (100264A0) --------------------------------------------------------
int sub_100264A0()
{
  return sub_100264E0();
}

//----- (100264E0) --------------------------------------------------------
int sub_100264E0()
{
  sub_1000291E(&unk_101C8B68, 12, 512, Vector3f::Vector3f);
  return sub_1000291E(&unk_101C7368, 12, 512, Vector3f::Vector3f);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10026550) --------------------------------------------------------
int sub_10026550()
{
  return sub_10026590();
}

//----- (10026590) --------------------------------------------------------
int sub_10026590()
{
  return sub_1000291E(&unk_101C6368, 8, 512, Vector2f::Vector2f);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100265E0) --------------------------------------------------------
void __thiscall Joint::render(Joint *this, struct Graphics *a2)
{
  struct Matrix4f *v2; // eax
  struct Vector3f *v3; // ST10_4
  struct Matrix4f *v4; // ST0C_4
  struct Vector3f *v5; // ST10_4
  struct Matrix4f *v6; // ST0C_4
  struct Vector3f *v7; // ST10_4
  struct Vector3f *v8; // ST10_4
  int v9; // eax
  _DWORD *v10; // ecx
  char v11; // [esp+0h] [ebp-268h]
  Vector3f *v12; // [esp+4Ch] [ebp-21Ch]
  struct Vector3f *v13; // [esp+50h] [ebp-218h]
  Vector3f *v14; // [esp+54h] [ebp-214h]
  struct Vector3f *v15; // [esp+58h] [ebp-210h]
  Vector3f *v16; // [esp+5Ch] [ebp-20Ch]
  struct Vector3f *v17; // [esp+60h] [ebp-208h]
  Vector3f *v18; // [esp+64h] [ebp-204h]
  struct Vector3f *v19; // [esp+68h] [ebp-200h]
  int v20; // [esp+6Ch] [ebp-1FCh]
  int n; // [esp+194h] [ebp-D4h]
  _DWORD *v22; // [esp+198h] [ebp-D0h]
  _DWORD *v23; // [esp+19Ch] [ebp-CCh]
  _DWORD *v24; // [esp+1A0h] [ebp-C8h]
  _DWORD *v25; // [esp+1A4h] [ebp-C4h]
  _DWORD *v26; // [esp+1A8h] [ebp-C0h]
  struct Vector3f *v27; // [esp+1ACh] [ebp-BCh]
  struct Vector3f *v28; // [esp+1B0h] [ebp-B8h]
  _DWORD *m; // [esp+1B4h] [ebp-B4h]
  int v30; // [esp+1B8h] [ebp-B0h]
  int l; // [esp+1BCh] [ebp-ACh]
  int v32; // [esp+1C0h] [ebp-A8h]
  int v33; // [esp+1C4h] [ebp-A4h]
  int v34; // [esp+1C8h] [ebp-A0h]
  int v35; // [esp+1CCh] [ebp-9Ch]
  int v36; // [esp+1D0h] [ebp-98h]
  int v37; // [esp+1D4h] [ebp-94h]
  int v38; // [esp+1D8h] [ebp-90h]
  int k; // [esp+1DCh] [ebp-8Ch]
  _DWORD *v40; // [esp+1E0h] [ebp-88h]
  int j; // [esp+1E4h] [ebp-84h]
  _DWORD *v42; // [esp+1E8h] [ebp-80h]
  _DWORD *i; // [esp+1ECh] [ebp-7Ch]
  int v44; // [esp+1F0h] [ebp-78h]
  struct Matrix4f *v45[10]; // [esp+1F4h] [ebp-74h]
  Joint *v46; // [esp+264h] [ebp-4h]

  v46 = this;
  if ( *(this + 8) != 0 )
  {
    v44 = 0;
    for ( i = *(v46 + 61); i; i = i[3] )
    {
      v42 = i[6];
      ++v44;
      if ( *(a2 + 2) & *(i[5] + 24) )
      {
        (*(*a2 + 192))(a2, i[5]);
        for ( j = 0; j < v42[8]; ++j )
        {
          v40 = (16 * j + v42[9]);
          if ( !*v40 )
            v45[0] = &Matrix4f::ident;
          for ( k = 0; k < *v40; ++k )
          {
            v38 = *(v40[1] + 4 * k);
            if ( v38 != -1 )
            {
              v37 = *(*(v46 + 70) + 60) + 8 * v38;
              if ( *(*(*(v46 + 70) + 24) + 4) )
              {
                if ( *v37 )
                  v2 = BaseShape::getAnimMatrix(*(v46 + 70), *(v37 + 4));
                else
                  v2 = BaseShape::getAnimMatrix(*(v46 + 70), *(v37 + 4) + *(*(v46 + 70) + 88));
                v45[k] = v2;
              }
              else
              {
                v45[k] = (*(*(v46 + 70) + 92) + 284 * *(v37 + 4) + 72);
              }
            }
          }
          v36 = *(*(v46 + 70) + 640);
          v35 = *(*(v46 + 70) + 688);
          if ( v42[11] & 0x10000 )
            v20 = *(*(v46 + 70) + 732);
          else
            v20 = *(*(v46 + 70) + 724);
          v34 = v20;
          v33 = (v42[11] & 0x10000) != 0 ? 3 : 1;
          v32 = v40[3];
          for ( l = 0; l < v40[2]; ++l )
          {
            v30 = (*(*a2 + 80))(a2, *(a2 + 206) ^ *(v32 + 20) & 3);
            for ( m = *(v32 + 60); m; m = m[3] )
            {
              v28 = &unk_101C8B68;
              v27 = &unk_101C7368;
              v26 = &unk_101C6368;
              v25 = m[7];
              v24 = m[6];
              v23 = m[9];
              v22 = m[10];
              if ( m[5] > 511 )
                sub_10025E40("too many vertices!!\n", v11);
              for ( n = 0; n < m[5]; ++n )
              {
                if ( v24 )
                {
                  v19 = v28;
                  v3 = v28;
                  v4 = v45[*v24];
                  v28 = (v28 + 12);
                  v18 = (12 * *v25 + v36);
                  ++v25;
                  Vector3f::multMatrixTo(v18, v4, v3);
                  if ( v23 )
                  {
                    v17 = v27;
                    v5 = v27;
                    v6 = v45[*v24];
                    v27 = (v27 + 12);
                    v16 = (12 * v33 * *v23 + v34);
                    ++v23;
                    Vector3f::rotateTo(v16, v6, v5);
                  }
                  ++v24;
                }
                else
                {
                  v15 = v28;
                  v7 = v28;
                  v28 = (v28 + 12);
                  v14 = (12 * *v25 + v36);
                  ++v25;
                  Vector3f::multMatrixTo(v14, v45[0], v7);
                  if ( v23 )
                  {
                    v13 = v27;
                    v8 = v27;
                    v27 = (v27 + 12);
                    v12 = (12 * v33 * *v23 + v34);
                    ++v23;
                    Vector3f::rotateTo(v12, v45[0], v8);
                  }
                }
                if ( v22 )
                {
                  v9 = *(v35 + 8 * *v22 + 4);
                  v10 = v26;
                  *v26 = *(v35 + 8 * *v22);
                  v10[1] = v9;
                  v26 += 2;
                  ++v22;
                }
              }
              if ( *(v32 + 20) & 0x1000000 )
                (*(*a2 + 156))(a2, &unk_101C8B68, m[9] != 0 ? &unk_101C7368 : 0, m[10] != 0 ? &unk_101C6368 : 0, m[5]);
              else
                (*(*a2 + 152))(a2, &unk_101C8B68, m[9] != 0 ? &unk_101C7368 : 0, m[10] != 0 ? &unk_101C6368 : 0, m[5]);
            }
            v32 += 116;
          }
        }
      }
    }
    (*(*a2 + 192))(a2, 0);
  }
}

//----- (100274C0) --------------------------------------------------------
void __thiscall Joint::sectionJoint(Joint *this, struct AgeServer *a2)
{
  Joint *v2; // ST58_4

  v2 = this;
  AgeServer::StartGroup(a2, "Info");
  AgeServer::StartBitGroup(a2, "flags", v2 + 8, 120);
  AgeServer::NewBit(a2, "displays", 1u, 0);
  AgeServer::EndBitGroup(a2);
  AgeServer::EndGroup(a2);
}

//----- (10027560) --------------------------------------------------------
void __thiscall Joint::genAge(Joint *this, struct AgeServer *a2)
{
  char *v2; // eax
  int v3; // [esp+4Ch] [ebp-20h]
  HGLOBAL hMem; // [esp+50h] [ebp-1Ch]
  int v5; // [esp+54h] [ebp-18h]
  CoreNode *i; // [esp+58h] [ebp-14h]
  CoreNode *v7; // [esp+5Ch] [ebp-10h]
  int v8; // [esp+68h] [ebp-4h]

  v7 = this;
  v2 = CoreNode::Name(this);
  AgeServer::StartSection(a2, v2, 1);
  hMem = sub_10002A81(0xCu);
  v8 = 0;
  if ( hMem )
    v3 = sub_100017BC(v7, Joint::sectionJoint);
  else
    v3 = 0;
  v5 = v3;
  v8 = -1;
  AgeServer::setSectionRefresh(v3);
  for ( i = CoreNode::Child(v7); i; i = CoreNode::Next(i) )
    (*i->vtblPointer)(i, a2);
  AgeServer::EndSection(a2);
}
// 100017BC: using guessed type _DWORD __stdcall sub_100017BC(_DWORD, _DWORD);
// 10001DE3: using guessed type _DWORD __stdcall AgeServer::setSectionRefresh(_DWORD);

//----- (10027690) --------------------------------------------------------
void __thiscall AnimContext::animate(AnimContext *this, float a2)
{
  AnimContext *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  *(v2 + 2) = System::getFrameTime(gsys) * a2 + *(v2 + 2);
  if ( *(v2 + 2) >= *(*(v2 + 1) + 48) )
    *(v2 + 2) = 0;
}
// 10001410: using guessed type double __thiscall System::getFrameTime(_DWORD);

//----- (10027720) --------------------------------------------------------
Vector3f *__thiscall CamDataInfo::CamDataInfo(CamDataInfo *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  Vector3f::Vector3f((v1 + 12));
  Vector3f::Vector3f((v1 + 24));
  Camera::Camera((v1 + 168));
  *(v1 + 158) = 1065353216;
  *(v1 + 159) = 1181376512;
  *(v1 + 155) = 1068149419;
  *(v1 + 44) = 0;
  return v1;
}

//----- (100277D0) --------------------------------------------------------
void __thiscall CamDataInfo::update(CamDataInfo *this, float a2, struct Matrix4f *a3)
{
  int v3; // eax
  _DWORD *v4; // ecx
  _DWORD *v5; // [esp+5Ch] [ebp-4Ch]
  signed int l; // [esp+60h] [ebp-48h]
  int v7; // [esp+64h] [ebp-44h]
  _DWORD *v8; // [esp+6Ch] [ebp-3Ch]
  signed int k; // [esp+70h] [ebp-38h]
  int v10; // [esp+74h] [ebp-34h]
  _DWORD *v11; // [esp+7Ch] [ebp-2Ch]
  signed int j; // [esp+80h] [ebp-28h]
  int v13; // [esp+84h] [ebp-24h]
  int v14; // [esp+88h] [ebp-20h]
  char *v15; // [esp+8Ch] [ebp-1Ch]
  signed int i; // [esp+90h] [ebp-18h]
  char *v17; // [esp+94h] [ebp-14h]
  char *v18; // [esp+98h] [ebp-10h]
  int v19; // [esp+9Ch] [ebp-Ch]
  char v20[4]; // [esp+A0h] [ebp-8h]
  CamDataInfo *v21; // [esp+A4h] [ebp-4h]

  v21 = this;
  v18 = this + 524;
  v17 = this + 48;
  for ( i = 0; i < 3; ++i )
  {
    v15 = &v17[12 * i];
    if ( *v15 )
    {
      if ( *v15 == 1 )
        *&v18[4 * i] = *(*(*(*(v21 + 253) + 20) + 8) + 4 * *(v15 + 1));
      else
        *&v18[4 * i] = sub_10027DA0(a2, v15, *(*(v21 + 253) + 20));
    }
    else
    {
      *&v18[4 * i] = 0;
    }
  }
  v14 = v21 + 536;
  v13 = v21 + 84;
  for ( j = 0; j < 3; ++j )
  {
    v11 = (12 * j + v13);
    if ( *v11 )
    {
      if ( *v11 == 1 )
        *(v14 + 4 * j) = *(*(*(*(v21 + 253) + 20) + 8) + 4 * v11[1]);
      else
        *(v14 + 4 * j) = sub_10027DA0(a2, v11, *(*(v21 + 253) + 20));
    }
    else
    {
      *(v14 + 4 * j) = 0;
    }
  }
  v10 = v21 + 120;
  for ( k = 0; k < 1; ++k )
  {
    v8 = (12 * k + v10);
    if ( *v8 )
    {
      if ( *v8 == 1 )
        *&v20[4 * k] = *(*(*(*(v21 + 253) + 20) + 8) + 4 * v8[1]);
      else
        *&v20[4 * k] = sub_10027DA0(a2, v8, *(*(v21 + 253) + 20));
    }
    else
    {
      *&v20[4 * k] = 1065353216;
    }
  }
  v7 = v21 + 132;
  for ( l = 0; l < 1; ++l )
  {
    v5 = (12 * l + v7);
    if ( *v5 )
    {
      if ( *v5 == 1 )
        *(&v19 + l) = *(*(*(*(v21 + 253) + 20) + 8) + 4 * v5[1]);
      else
        *(&v19 + l) = sub_10027DA0(a2, v5, *(*(v21 + 253) + 20));
    }
    else
    {
      *(&v19 + l) = 1065353216;
    }
  }
  Vector3f::multMatrix((v21 + 524), a3);
  Vector3f::multMatrix((v21 + 536), a3);
  *(v21 + 157) = v19;
  if ( *(v21 + 10) <= 0.0 )
  {
    if ( *(v21 + 44) )
    {
      v3 = v21 + 24;
      v4 = (v21 + 536);
      *v4 = *(v21 + 6);
      v4[1] = *(v3 + 4);
      v4[2] = *(v3 + 8);
    }
  }
  else
  {
    *(v21 + 157) = (*(v21 + 9) - *(v21 + 157)) * *(v21 + 10) + *(v21 + 157);
    *(v21 + 131) = (*v21 - *(v21 + 131)) * *(v21 + 10) + *(v21 + 131);
    *(v21 + 132) = (*(v21 + 1) - *(v21 + 132)) * *(v21 + 10) + *(v21 + 132);
    *(v21 + 133) = (*(v21 + 2) - *(v21 + 133)) * *(v21 + 10) + *(v21 + 133);
    *(v21 + 134) = (*(v21 + 3) - *(v21 + 134)) * *(v21 + 10) + *(v21 + 134);
    *(v21 + 135) = (*(v21 + 4) - *(v21 + 135)) * *(v21 + 10) + *(v21 + 135);
    *(v21 + 136) = (*(v21 + 5) - *(v21 + 136)) * *(v21 + 10) + *(v21 + 136);
  }
  CullFrustum::calcLookAt((v21 + 168), (v21 + 524), (v21 + 536), 0);
}
// 100277D0: using guessed type char var_8[4];

//----- (10027DA0) --------------------------------------------------------
double __cdecl sub_10027DA0(float a1, int a2, int a3)
{
  int v4; // ST94_4
  int v5; // ST88_4
  int v6; // ST94_4
  int v7; // eax
  float v8; // ST68_4
  float v9; // ST64_4
  float v10; // ST60_4
  float v11; // ST5C_4
  float v12; // ST58_4
  float v13; // ST54_4
  float v14; // ST50_4
  float v15; // [esp+70h] [ebp-30h]
  float v16; // [esp+74h] [ebp-2Ch]
  float v17; // [esp+78h] [ebp-28h]
  float v18; // [esp+80h] [ebp-20h]
  float v19; // [esp+84h] [ebp-1Ch]
  float v20; // [esp+8Ch] [ebp-14h]
  int i; // [esp+90h] [ebp-10h]
  int v22; // [esp+94h] [ebp-Ch]
  char v23; // [esp+98h] [ebp-8h]
  int v24; // [esp+9Ch] [ebp-4h]

  v24 = (*(a2 + 8) != 0) + 3;
  v23 = 0;
  v22 = *(a2 + 4);
  for ( i = 0; i < *a2 - 1; ++i )
  {
    if ( *(*(a3 + 8) + 4 * v22) <= a1 && *(*(a3 + 8) + 4 * (v24 + v22)) >= a1 )
    {
      v23 = 1;
      break;
    }
    v22 += v24;
  }
  if ( !v23 )
    return *(*(a3 + 8) + 4 * ((*a2 - 1) * v24 + *(a2 + 4)) + 4);
  if ( v24 == 3 )
  {
    v18 = *(*(a3 + 8) + 4 * v22);
    v19 = *(*(a3 + 8) + 4 * v22 + 4);
    v20 = *(*(a3 + 8) + 4 * v22 + 8);
    v4 = v22 + 3;
    v15 = *(*(a3 + 8) + 4 * v4);
    v16 = *(*(a3 + 8) + 4 * v4 + 4);
    v17 = *(*(a3 + 8) + 4 * v4 + 8);
  }
  else
  {
    v18 = *(*(a3 + 8) + 4 * v22);
    v19 = *(*(a3 + 8) + 4 * v22 + 4);
    v5 = *(*(a3 + 8) + 4 * v22 + 8);
    v20 = *(*(a3 + 8) + 4 * v22 + 12);
    v6 = v24 + v22;
    v15 = *(*(a3 + 8) + 4 * v6);
    v16 = *(*(a3 + 8) + 4 * v6 + 4);
    v17 = *(*(a3 + 8) + 4 * v6 + 8);
    v7 = *(*(a3 + 8) + 4 * v6 + 12);
  }
  v8 = 1.0 / 30.0;
  v9 = (a1 - v18) * v8;
  v10 = 30.0 / (v15 - v18);
  v11 = v9 * v9;
  v12 = v10 * v10;
  v13 = v11 * v9;
  v14 = v12 * v10;
  return (2.0 * v13 * v14 - 3.0 * v11 * v12 + 1.0) * v19
       + (-2.0 * v13 * v14 + 3.0 * v11 * v12) * v16
       + (v13 * v12 - 2.0 * v11 * v10 + v9) * v20
       + (v13 * v12 - v11 * v10) * v17;
}

//----- (100280F0) --------------------------------------------------------
void __thiscall LightDataInfo::update(LightDataInfo *this, float a2)
{
  _DWORD *v2; // [esp+5Ch] [ebp-50h]
  signed int k; // [esp+60h] [ebp-4Ch]
  int v4; // [esp+64h] [ebp-48h]
  _DWORD *v5; // [esp+6Ch] [ebp-40h]
  signed int j; // [esp+70h] [ebp-3Ch]
  int v7; // [esp+74h] [ebp-38h]
  _DWORD *v8; // [esp+7Ch] [ebp-30h]
  signed int i; // [esp+80h] [ebp-2Ch]
  LightDataInfo *v10; // [esp+84h] [ebp-28h]
  int v11; // [esp+8Ch] [ebp-20h]
  float v12; // [esp+90h] [ebp-1Ch]
  float v13; // [esp+94h] [ebp-18h]
  float v14; // [esp+98h] [ebp-14h]
  float v15; // [esp+9Ch] [ebp-10h]
  float v16; // [esp+A0h] [ebp-Ch]
  float v17; // [esp+A4h] [ebp-8h]
  LightDataInfo *v18; // [esp+A8h] [ebp-4h]

  v18 = this;
  Vector3f::Vector3f(&v15);
  Vector3f::Vector3f(&v12);
  v10 = v18;
  for ( i = 0; i < 3; ++i )
  {
    v8 = (v10 + 12 * i);
    if ( *v8 )
    {
      if ( *v8 == 1 )
        *(&v15 + i) = *(*(*(*(v18 + 204) + 24) + 8) + 4 * v8[1]);
      else
        *(&v15 + i) = sub_10027DA0(a2, v8, *(*(v18 + 204) + 24));
    }
    else
    {
      *(&v15 + i) = 1.0;
    }
  }
  v7 = v18 + 36;
  for ( j = 0; j < 3; ++j )
  {
    v5 = (12 * j + v7);
    if ( *v5 )
    {
      if ( *v5 == 1 )
        *(&v12 + j) = *(*(*(*(v18 + 204) + 24) + 8) + 4 * v5[1]);
      else
        *(&v12 + j) = sub_10027DA0(a2, v5, *(*(v18 + 204) + 24));
    }
    else
    {
      *(&v12 + j) = 1.0;
    }
  }
  v4 = v18 + 72;
  for ( k = 0; k < 1; ++k )
  {
    v2 = (12 * k + v4);
    if ( *v2 )
    {
      if ( *v2 == 1 )
        *(&v11 + k) = *(*(*(*(v18 + 204) + 24) + 8) + 4 * v2[1]);
      else
        *(&v11 + k) = sub_10027DA0(a2, v2, *(*(v18 + 204) + 24));
    }
    else
    {
      *(&v11 + k) = 1065353216;
    }
  }
  *(v18 + 21) = v11 == 1065353216;
  if ( *(v18 + 21) )
  {
    Colour::set((v18 + 196), v12, v13, v14, 0xFFu);
    Vector3f::set((v18 + 172), &v15, &v16, &v17);
    *(v18 + 28) = 1148846080;
    Light::update((v18 + 88));
  }
}

//----- (10028480) --------------------------------------------------------
void __stdcall SceneData::genAge(struct AgeServer *a2)
{
  AgeServer::StartGroup(a2, "commands");
  AgeServer::EndGroup(a2);
}

//----- (100284E0) --------------------------------------------------------
void __thiscall SceneData::parse(SceneData *this, struct CmdStream *a2)
{
  const char *v2; // eax
  int v3; // edx
  int v4; // ST08_4
  const char *v5; // eax
  int v6; // ST08_4
  const char *v7; // eax
  int v8; // ST08_4
  const char *v9; // eax
  int v10; // eax
  int v11; // ST08_4
  const char *v12; // eax
  int v13; // ST08_4
  const char *v14; // eax
  int v15; // ST08_4
  const char *v16; // eax
  int v17; // ST08_4
  const char *v18; // eax
  int v19; // ST08_4
  const char *v20; // eax
  int v21; // ST08_4
  const char *v22; // eax
  int v23; // edx
  int v24; // ST08_4
  const char *v25; // eax
  int v26; // ST08_4
  const char *v27; // eax
  int v28; // ST08_4
  const char *v29; // eax
  int v30; // eax
  int v31; // ST08_4
  const char *v32; // eax
  int v33; // ST08_4
  const char *v34; // eax
  int v35; // ST08_4
  const char *v36; // eax
  int v37; // ST08_4
  const char *v38; // eax
  int v39; // ST08_4
  const char *v40; // eax
  int v41; // ST08_4
  const char *v42; // eax
  int v43; // edx
  int v44; // ST08_4
  const char *v45; // eax
  int v46; // ST08_4
  const char *v47; // eax
  int v48; // ST08_4
  const char *v49; // eax
  int v50; // eax
  int v51; // ST08_4
  const char *v52; // eax
  int v53; // ST08_4
  const char *v54; // eax
  int v55; // ST08_4
  const char *v56; // eax
  int v57; // ST08_4
  const char *v58; // eax
  int v59; // ST08_4
  const char *v60; // eax
  int v61; // ST08_4
  const char *v62; // eax
  int v63; // edx
  int v64; // ST08_4
  const char *v65; // eax
  int v66; // ST08_4
  const char *v67; // eax
  int v68; // ST08_4
  const char *v69; // eax
  const char *v70; // eax
  int v71; // ST08_4
  const char *v72; // eax
  int v73; // ST08_4
  const char *v74; // eax
  int v75; // ST08_4
  const char *v76; // eax
  int v77; // eax
  int v78; // ST08_4
  const char *v79; // eax
  int v80; // ST08_4
  const char *v81; // eax
  int v82; // ST08_4
  const char *v83; // eax
  int v84; // ST08_4
  const char *v85; // eax
  int v86; // ST08_4
  const char *v87; // eax
  int v88; // ST08_4
  const char *v89; // eax
  int v90; // edx
  int v91; // ST08_4
  const char *v92; // eax
  int v93; // ST08_4
  const char *v94; // eax
  int v95; // ST08_4
  const char *v96; // eax
  int v97; // eax
  int v98; // ST08_4
  const char *v99; // eax
  int v100; // ST08_4
  const char *v101; // eax
  int v102; // ST08_4
  const char *v103; // eax
  int v104; // ST08_4
  const char *v105; // eax
  int v106; // ST08_4
  const char *v107; // eax
  int v108; // ST08_4
  const char *v109; // eax
  int v110; // edx
  int v111; // ST08_4
  const char *v112; // eax
  int v113; // ST08_4
  const char *v114; // eax
  int v115; // ST08_4
  const char *v116; // eax
  int v117; // [esp+4Ch] [ebp-74h]
  int v118; // [esp+50h] [ebp-70h]
  HGLOBAL v119; // [esp+54h] [ebp-6Ch]
  int v120; // [esp+58h] [ebp-68h]
  HGLOBAL hMem; // [esp+5Ch] [ebp-64h]
  int v122; // [esp+60h] [ebp-60h]
  int v123; // [esp+64h] [ebp-5Ch]
  int v124; // [esp+68h] [ebp-58h]
  int v125; // [esp+6Ch] [ebp-54h]
  int v126; // [esp+70h] [ebp-50h]
  int v127; // [esp+74h] [ebp-4Ch]
  int v128; // [esp+78h] [ebp-48h]
  int v129; // [esp+7Ch] [ebp-44h]
  int v130; // [esp+80h] [ebp-40h]
  int v131; // [esp+84h] [ebp-3Ch]
  int v132; // [esp+88h] [ebp-38h]
  int v133; // [esp+8Ch] [ebp-34h]
  int v134; // [esp+90h] [ebp-30h]
  int v135; // [esp+94h] [ebp-2Ch]
  int v136; // [esp+98h] [ebp-28h]
  int v137; // [esp+9Ch] [ebp-24h]
  int v138; // [esp+A0h] [ebp-20h]
  int v139; // [esp+A4h] [ebp-1Ch]
  int v140; // [esp+A8h] [ebp-18h]
  int v141; // [esp+ACh] [ebp-14h]
  SceneData *v142; // [esp+B0h] [ebp-10h]
  int v143; // [esp+BCh] [ebp-4h]

  v142 = this;
  *(this + 5) = 0;
  *(v142 + 6) = 0;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "<SCENE_KEY_ANM_INFO>") )
    {
      CmdStream::getToken(a2, 1);
      SceneData::getAnimInfo(v142, a2);
    }
    else if ( CmdStream::isToken(a2, "<KEY_CAMERA_ANM>") )
    {
      hMem = sub_10002A81(0xCu);
      v143 = 0;
      if ( hMem )
        v118 = DataChunk::DataChunk(hMem);
      else
        v118 = 0;
      v122 = v118;
      v143 = -1;
      *(v142 + 5) = v118;
      DataChunk::getData(*(v142 + 5), a2);
    }
    else if ( CmdStream::isToken(a2, "<KEY_CAMERA_TABLE>") )
    {
      CmdStream::getToken(a2, 1);
      v141 = -1;
      while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
      {
        CmdStream::getToken(a2, 1);
        if ( CmdStream::isToken(a2, "index") )
        {
          v2 = CmdStream::getToken(a2, 1);
          sscanf(v2, "%d", &v141);
        }
        else if ( CmdStream::isToken(a2, "name") )
        {
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "cam_pos_x") )
        {
          v3 = *(v142 + 7);
          v140 = v3 + 1016 * v141 + 48;
          v4 = v3 + 1016 * v141 + 48;
          v5 = CmdStream::getToken(a2, 1);
          sscanf(v5, "%d", v4);
          v6 = v140 + 4;
          v7 = CmdStream::getToken(a2, 1);
          sscanf(v7, "%d", v6);
          v8 = v140 + 8;
          v9 = CmdStream::getToken(a2, 1);
          sscanf(v9, "%d", v8);
        }
        else if ( CmdStream::isToken(a2, "cam_pos_y") )
        {
          v10 = *(v142 + 7);
          v139 = v10 + 1016 * v141 + 60;
          v11 = v10 + 1016 * v141 + 60;
          v12 = CmdStream::getToken(a2, 1);
          sscanf(v12, "%d", v11);
          v13 = v139 + 4;
          v14 = CmdStream::getToken(a2, 1);
          sscanf(v14, "%d", v13);
          v15 = v139 + 8;
          v16 = CmdStream::getToken(a2, 1);
          sscanf(v16, "%d", v15);
        }
        else if ( CmdStream::isToken(a2, "cam_pos_z") )
        {
          v138 = *(v142 + 7) + 1016 * v141 + 72;
          v17 = v138;
          v18 = CmdStream::getToken(a2, 1);
          sscanf(v18, "%d", v17);
          v19 = v138 + 4;
          v20 = CmdStream::getToken(a2, 1);
          sscanf(v20, "%d", v19);
          v21 = v138 + 8;
          v22 = CmdStream::getToken(a2, 1);
          sscanf(v22, "%d", v21);
        }
        else if ( CmdStream::isToken(a2, "cam_lat_x") )
        {
          v23 = *(v142 + 7);
          v137 = v23 + 1016 * v141 + 84;
          v24 = v23 + 1016 * v141 + 84;
          v25 = CmdStream::getToken(a2, 1);
          sscanf(v25, "%d", v24);
          v26 = v137 + 4;
          v27 = CmdStream::getToken(a2, 1);
          sscanf(v27, "%d", v26);
          v28 = v137 + 8;
          v29 = CmdStream::getToken(a2, 1);
          sscanf(v29, "%d", v28);
        }
        else if ( CmdStream::isToken(a2, "cam_lat_y") )
        {
          v30 = *(v142 + 7);
          v136 = v30 + 1016 * v141 + 96;
          v31 = v30 + 1016 * v141 + 96;
          v32 = CmdStream::getToken(a2, 1);
          sscanf(v32, "%d", v31);
          v33 = v136 + 4;
          v34 = CmdStream::getToken(a2, 1);
          sscanf(v34, "%d", v33);
          v35 = v136 + 8;
          v36 = CmdStream::getToken(a2, 1);
          sscanf(v36, "%d", v35);
        }
        else if ( CmdStream::isToken(a2, "cam_lat_z") )
        {
          v135 = *(v142 + 7) + 1016 * v141 + 108;
          v37 = v135;
          v38 = CmdStream::getToken(a2, 1);
          sscanf(v38, "%d", v37);
          v39 = v135 + 4;
          v40 = CmdStream::getToken(a2, 1);
          sscanf(v40, "%d", v39);
          v41 = v135 + 8;
          v42 = CmdStream::getToken(a2, 1);
          sscanf(v42, "%d", v41);
        }
        else if ( CmdStream::isToken(a2, "cam_twist") )
        {
          v43 = *(v142 + 7);
          v134 = v43 + 1016 * v141 + 120;
          v44 = v43 + 1016 * v141 + 120;
          v45 = CmdStream::getToken(a2, 1);
          sscanf(v45, "%d", v44);
          v46 = v134 + 4;
          v47 = CmdStream::getToken(a2, 1);
          sscanf(v47, "%d", v46);
          v48 = v134 + 8;
          v49 = CmdStream::getToken(a2, 1);
          sscanf(v49, "%d", v48);
        }
        else if ( CmdStream::isToken(a2, "cam_fovy") )
        {
          v50 = *(v142 + 7);
          v133 = v50 + 1016 * v141 + 132;
          v51 = v50 + 1016 * v141 + 132;
          v52 = CmdStream::getToken(a2, 1);
          sscanf(v52, "%d", v51);
          v53 = v133 + 4;
          v54 = CmdStream::getToken(a2, 1);
          sscanf(v54, "%d", v53);
          v55 = v133 + 8;
          v56 = CmdStream::getToken(a2, 1);
          sscanf(v56, "%d", v55);
        }
        else if ( CmdStream::isToken(a2, "cam_near") )
        {
          v132 = *(v142 + 7) + 1016 * v141 + 144;
          v57 = v132;
          v58 = CmdStream::getToken(a2, 1);
          sscanf(v58, "%d", v57);
          v59 = v132 + 4;
          v60 = CmdStream::getToken(a2, 1);
          sscanf(v60, "%d", v59);
          v61 = v132 + 8;
          v62 = CmdStream::getToken(a2, 1);
          sscanf(v62, "%d", v61);
        }
        else if ( CmdStream::isToken(a2, "cam_far") )
        {
          v63 = *(v142 + 7);
          v131 = v63 + 1016 * v141 + 156;
          v64 = v63 + 1016 * v141 + 156;
          v65 = CmdStream::getToken(a2, 1);
          sscanf(v65, "%d", v64);
          v66 = v131 + 4;
          v67 = CmdStream::getToken(a2, 1);
          sscanf(v67, "%d", v66);
          v68 = v131 + 8;
          v69 = CmdStream::getToken(a2, 1);
          sscanf(v69, "%d", v68);
        }
      }
      if ( !CmdStream::endOfCmds(a2) )
        CmdStream::getToken(a2, 1);
    }
    else if ( CmdStream::isToken(a2, "<KEY_DIFFUSE_LIGHT_ANM>") )
    {
      v119 = sub_10002A81(0xCu);
      v143 = 1;
      if ( v119 )
        v117 = DataChunk::DataChunk(v119);
      else
        v117 = 0;
      v120 = v117;
      v143 = -1;
      *(v142 + 6) = v117;
      DataChunk::getData(*(v142 + 6), a2);
    }
    else if ( CmdStream::isToken(a2, "<KEY_DIFFUSE_LIGHT_TABLE>") )
    {
      CmdStream::getToken(a2, 1);
      v130 = -1;
      while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
      {
        CmdStream::getToken(a2, 1);
        if ( CmdStream::isToken(a2, "index") )
        {
          v70 = CmdStream::getToken(a2, 1);
          sscanf(v70, "%d", &v130);
        }
        else if ( CmdStream::isToken(a2, "name") )
        {
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "light_pos_x") )
        {
          v129 = 820 * v130 + *(v142 + 8);
          v71 = v129;
          v72 = CmdStream::getToken(a2, 1);
          sscanf(v72, "%d", v71);
          v73 = v129 + 4;
          v74 = CmdStream::getToken(a2, 1);
          sscanf(v74, "%d", v73);
          v75 = v129 + 8;
          v76 = CmdStream::getToken(a2, 1);
          sscanf(v76, "%d", v75);
        }
        else if ( CmdStream::isToken(a2, "light_pos_y") )
        {
          v77 = *(v142 + 8);
          v128 = v77 + 820 * v130 + 12;
          v78 = v77 + 820 * v130 + 12;
          v79 = CmdStream::getToken(a2, 1);
          sscanf(v79, "%d", v78);
          v80 = v128 + 4;
          v81 = CmdStream::getToken(a2, 1);
          sscanf(v81, "%d", v80);
          v82 = v128 + 8;
          v83 = CmdStream::getToken(a2, 1);
          sscanf(v83, "%d", v82);
        }
        else if ( CmdStream::isToken(a2, "light_pos_z") )
        {
          v127 = *(v142 + 8) + 820 * v130 + 24;
          v84 = v127;
          v85 = CmdStream::getToken(a2, 1);
          sscanf(v85, "%d", v84);
          v86 = v127 + 4;
          v87 = CmdStream::getToken(a2, 1);
          sscanf(v87, "%d", v86);
          v88 = v127 + 8;
          v89 = CmdStream::getToken(a2, 1);
          sscanf(v89, "%d", v88);
        }
        else if ( CmdStream::isToken(a2, "light_r_param") )
        {
          v90 = *(v142 + 8);
          v126 = v90 + 820 * v130 + 36;
          v91 = v90 + 820 * v130 + 36;
          v92 = CmdStream::getToken(a2, 1);
          sscanf(v92, "%d", v91);
          v93 = v126 + 4;
          v94 = CmdStream::getToken(a2, 1);
          sscanf(v94, "%d", v93);
          v95 = v126 + 8;
          v96 = CmdStream::getToken(a2, 1);
          sscanf(v96, "%d", v95);
        }
        else if ( CmdStream::isToken(a2, "light_g_param") )
        {
          v97 = *(v142 + 8);
          v125 = v97 + 820 * v130 + 48;
          v98 = v97 + 820 * v130 + 48;
          v99 = CmdStream::getToken(a2, 1);
          sscanf(v99, "%d", v98);
          v100 = v125 + 4;
          v101 = CmdStream::getToken(a2, 1);
          sscanf(v101, "%d", v100);
          v102 = v125 + 8;
          v103 = CmdStream::getToken(a2, 1);
          sscanf(v103, "%d", v102);
        }
        else if ( CmdStream::isToken(a2, "light_b_param") )
        {
          v124 = *(v142 + 8) + 820 * v130 + 60;
          v104 = v124;
          v105 = CmdStream::getToken(a2, 1);
          sscanf(v105, "%d", v104);
          v106 = v124 + 4;
          v107 = CmdStream::getToken(a2, 1);
          sscanf(v107, "%d", v106);
          v108 = v124 + 8;
          v109 = CmdStream::getToken(a2, 1);
          sscanf(v109, "%d", v108);
        }
        else if ( CmdStream::isToken(a2, "light_visible") )
        {
          v110 = *(v142 + 8);
          v123 = v110 + 820 * v130 + 72;
          v111 = v110 + 820 * v130 + 72;
          v112 = CmdStream::getToken(a2, 1);
          sscanf(v112, "%d", v111);
          v113 = v123 + 4;
          v114 = CmdStream::getToken(a2, 1);
          sscanf(v114, "%d", v113);
          v115 = v123 + 8;
          v116 = CmdStream::getToken(a2, 1);
          sscanf(v116, "%d", v115);
        }
      }
      if ( !CmdStream::endOfCmds(a2) )
        CmdStream::getToken(a2, 1);
    }
    else
    {
      CmdStream::getToken(a2, 1);
      while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
        CmdStream::getToken(a2, 1);
      if ( !CmdStream::endOfCmds(a2) )
        CmdStream::getToken(a2, 1);
    }
  }
}

//----- (10029810) --------------------------------------------------------
void __thiscall SceneData::getAnimInfo(SceneData *this, struct CmdStream *a2)
{
  int v2; // ST0C_4
  const char *v3; // eax
  int v4; // ST0C_4
  const char *v5; // eax
  int v6; // ST0C_4
  const char *v7; // eax
  HGLOBAL v8; // [esp+4Ch] [ebp-38h]
  HGLOBAL v9; // [esp+50h] [ebp-34h]
  HGLOBAL v10; // [esp+54h] [ebp-30h]
  HGLOBAL v11; // [esp+58h] [ebp-2Ch]
  HGLOBAL hMem; // [esp+5Ch] [ebp-28h]
  HGLOBAL v13; // [esp+60h] [ebp-24h]
  int j; // [esp+64h] [ebp-20h]
  int v15; // [esp+68h] [ebp-1Ch]
  int i; // [esp+6Ch] [ebp-18h]
  int v17; // [esp+70h] [ebp-14h]
  SceneData *v18; // [esp+74h] [ebp-10h]
  int v19; // [esp+80h] [ebp-4h]

  v18 = this;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "numcameras") )
    {
      v2 = v18 + 40;
      v3 = CmdStream::getToken(a2, 1);
      sscanf(v3, "%d", v2);
      v17 = *(v18 + 10);
      hMem = sub_10001AC3(1016 * v17);
      v19 = 0;
      if ( hMem )
      {
        sub_1000291E(hMem, 1016, v17, CamDataInfo::CamDataInfo);
        v9 = hMem;
      }
      else
      {
        v9 = 0;
      }
      v13 = v9;
      v19 = -1;
      *(v18 + 7) = v9;
      for ( i = 0; i < *(v18 + 10); ++i )
      {
        *(*(v18 + 7) + 1016 * i + 1012) = v18;
        *(*(v18 + 7) + 1016 * i + 1008) = i;
      }
    }
    else if ( CmdStream::isToken(a2, "numDifLights") )
    {
      v4 = v18 + 44;
      v5 = CmdStream::getToken(a2, 1);
      sscanf(v5, "%d", v4);
      v15 = *(v18 + 11);
      v10 = sub_10001AC3(820 * v15);
      v19 = 1;
      if ( v10 )
      {
        sub_1000291E(v10, 820, v15, LightDataInfo::LightDataInfo);
        v8 = v10;
      }
      else
      {
        v8 = 0;
      }
      v11 = v8;
      v19 = -1;
      *(v18 + 8) = v8;
      for ( j = 0; j < *(v18 + 11); ++j )
      {
        *(*(v18 + 8) + 820 * j + 816) = v18;
        *(*(v18 + 8) + 820 * j + 812) = j;
      }
    }
    else if ( CmdStream::isToken(a2, "numframes") )
    {
      v6 = v18 + 36;
      v7 = CmdStream::getToken(a2, 1);
      sscanf(v7, "%d", v6);
    }
    else
    {
      CmdStream::skipLine(a2);
    }
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10029BC0) --------------------------------------------------------
void __thiscall AnimData::extractSRT(AnimData *this, struct SRT *a2, int a3, struct AnimDataInfo *a4, float a5)
{
  __int16 v5; // cx
  __int16 v6; // ax
  __int16 v7; // ax
  int v8; // [esp+4Ch] [ebp-40h]
  int v9; // [esp+50h] [ebp-3Ch]
  int v10; // [esp+54h] [ebp-38h]
  signed int k; // [esp+60h] [ebp-2Ch]
  _DWORD *v12; // [esp+64h] [ebp-28h]
  signed int j; // [esp+70h] [ebp-1Ch]
  _DWORD *v14; // [esp+74h] [ebp-18h]
  _DWORD *v15; // [esp+7Ch] [ebp-10h]
  signed int i; // [esp+80h] [ebp-Ch]
  struct SRT *v17; // [esp+84h] [ebp-8h]
  AnimData *v18; // [esp+88h] [ebp-4h]

  v18 = this;
  if ( !(*(a4 + 108) & 0x8000) )
  {
    if ( !(*(a4 + 108) & 8) )
    {
      v17 = a2;
      for ( i = 0; i < 3; ++i )
      {
        v15 = (a4 + 12 * i);
        if ( a5 >= *v15 )
          v10 = v15[1] + *v15 - 1;
        else
          v10 = a5 + v15[1];
        *v17 = *(*(*(this + 5) + 8) + 4 * v10);
        v17 = (v17 + 4);
      }
      if ( (*(a4 + 108) & 7) == 7 )
      {
        v5 = *(a4 + 108);
        LOBYTE(v5) = v5 | 8;
        *(a4 + 108) = v5;
      }
    }
    if ( !(*(a4 + 108) & 0x80) )
    {
      v14 = (a2 + 12);
      for ( j = 0; j < 3; ++j )
      {
        if ( a5 >= *(a4 + 3 * j + 9) )
          v9 = *(a4 + 3 * j + 10) + *(a4 + 3 * j + 9) - 1;
        else
          v9 = a5 + *(a4 + 3 * j + 10);
        *v14 = *(*(*(v18 + 6) + 8) + 4 * v9);
        ++v14;
      }
      if ( (*(a4 + 108) & 0x70) == 112 )
      {
        v6 = *(a4 + 108);
        LOBYTE(v6) = v6 | 0x80;
        *(a4 + 108) = v6;
      }
    }
    if ( !(*(a4 + 108) & 0x800) )
    {
      v12 = (a2 + 24);
      for ( k = 0; k < 3; ++k )
      {
        if ( a5 >= *(a4 + 3 * k + 18) )
          v8 = *(a4 + 3 * k + 19) + *(a4 + 3 * k + 18) - 1;
        else
          v8 = a5 + *(a4 + 3 * k + 19);
        *v12 = *(*(*(v18 + 7) + 8) + 4 * v8);
        ++v12;
      }
      if ( (*(a4 + 108) & 0x700) == 1792 )
      {
        v7 = *(a4 + 108);
        HIBYTE(v7) |= 8u;
        *(a4 + 108) = v7;
      }
    }
  }
}

//----- (10029F20) --------------------------------------------------------
void __thiscall AnimData::makeAnimSRT(AnimData *this, int a2, struct Matrix4f *a3, struct Matrix4f *a4, struct AnimDataInfo *a5, float a6)
{
  __int16 v6; // cx
  struct SRT *v7; // [esp+54h] [ebp-58h]
  int v8; // [esp+58h] [ebp-54h]
  int v9; // [esp+5Ch] [ebp-50h]
  struct Matrix4f *v10; // [esp+60h] [ebp-4Ch]
  char v11; // [esp+64h] [ebp-48h]
  char v12[4]; // [esp+A4h] [ebp-8h]
  AnimData *v13; // [esp+A8h] [ebp-4h]

  v13 = this;
  *v12 = a6;
  if ( *v12 < 0 || *v12 >= *(v13 + 12) )
    sub_1002A170("makeSRT too large a frame number : %d / %d : %f\n", *v12, *(v13 + 12), a6);
  Matrix4f::Matrix4f(&v11);
  LOBYTE(v9) = 1;
  if ( (*(a5 + 108) & 0x777) != 1911 && *(*(v13 + 16) + 28 * *v12 + 16) )
  {
    v8 = *(*(v13 + 16) + 28 * *v12 + 16);
    if ( *(*(v8 + 24) + 4 * a2) )
      LOBYTE(v9) = 0;
    else
      *(*(v8 + 24) + 4 * a2) = (a2 << 6) + *(v8 + 20);
    v10 = *(*(v8 + 24) + 4 * a2);
  }
  else
  {
    v10 = &v11;
  }
  if ( v9 )
  {
    v7 = (a5 + 180);
    (*(*v13 + 20))(v13, a5 + 180, a2, a5, LODWORD(a6));
    if ( (*(a5 + 108) & 0x777) != 1911 )
    {
      Matrix4f::makeConcatSRT(a4, a3, v10, v7);
      return;
    }
    v10 = (a5 + 116);
    if ( !(*(a5 + 108) & 0x8000) )
    {
      Matrix4f::makeSRT(v10, v7, (v7 + 12), (v7 + 24));
      v6 = *(a5 + 108);
      HIBYTE(v6) |= 0x80u;
      *(a5 + 108) = v6;
    }
  }
  Matrix4f::multiplyTo(a3, v10, a4);
}

//----- (1002A170) --------------------------------------------------------
void __noreturn sub_1002A170(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscommon\\shapebase.cpp", 23, &Dest);
}

//----- (1002A210) --------------------------------------------------------
void __thiscall AnimData::detach(AnimData *this)
{
  int i; // [esp+4Ch] [ebp-8h]
  AnimData *v2; // [esp+50h] [ebp-4h]

  v2 = this;
  for ( i = 0; i < *(v2 + 12); ++i )
    AnimCacheInfo::initData((28 * i + *(v2 + 16)));
}

//----- (1002A290) --------------------------------------------------------
void __thiscall AnimData::initData(AnimData *this)
{
  HGLOBAL v1; // [esp+4Ch] [ebp-20h]
  HGLOBAL hMem; // [esp+50h] [ebp-1Ch]
  int v3; // [esp+58h] [ebp-14h]
  AnimData *v4; // [esp+5Ch] [ebp-10h]

  v4 = this;
  v3 = *(this + 12);
  hMem = sub_10001AC3(28 * v3);
  if ( hMem )
  {
    sub_1000291E(hMem, 28, v3, AnimCacheInfo::AnimCacheInfo);
    v1 = hMem;
  }
  else
  {
    v1 = 0;
  }
  *(v4 + 16) = v1;
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002A370) --------------------------------------------------------
void __thiscall AnimData::checkMask(AnimData *this)
{
  int m; // [esp+50h] [ebp-1Ch]
  int v2; // [esp+54h] [ebp-18h]
  int v3; // [esp+58h] [ebp-14h]
  signed int j; // [esp+5Ch] [ebp-10h]
  signed int k; // [esp+5Ch] [ebp-10h]
  signed int l; // [esp+5Ch] [ebp-10h]
  char v7; // [esp+60h] [ebp-Ch]
  char v8; // [esp+60h] [ebp-Ch]
  char v9; // [esp+60h] [ebp-Ch]
  int i; // [esp+64h] [ebp-8h]
  AnimData *v11; // [esp+68h] [ebp-4h]

  v11 = this;
  for ( i = 0; i < *(this + 10); ++i )
  {
    *(*(this + 15) + 220 * i + 216) = 0;
    v7 = 0;
    for ( j = 0; j < 3; ++j )
    {
      if ( *(220 * i + *(this + 15) + 12 * j) == 1 )
        *(*(this + 15) + 220 * i + 216) |= 1 << v7;
      ++v7;
    }
    v8 = v7 + 1;
    for ( k = 0; k < 3; ++k )
    {
      if ( *(220 * i + *(this + 15) + 12 * k + 36) == 1 )
        *(*(this + 15) + 220 * i + 216) |= 1 << v8;
      ++v8;
    }
    v9 = v8 + 1;
    for ( l = 0; l < 3; ++l )
    {
      if ( *(220 * i + *(this + 15) + 12 * l + 72) == 1 )
        *(*(this + 15) + 220 * i + 216) |= 1 << v9;
      ++v9;
    }
  }
  *(this + 8) = sub_10001AC3(2 * *(this + 10));
  v3 = 0;
  v2 = 0;
  for ( m = 0; m < *(v11 + 10); ++m )
  {
    if ( m < *(*(v11 + 13) + 88) )
    {
      if ( (*(*(v11 + 15) + 220 * m + 216) & 0x777) == 1911 )
      {
        *(*(v11 + 8) + 2 * m) = 0;
        ++v2;
      }
      else
      {
        *(*(v11 + 8) + 2 * m) = v3++;
      }
    }
  }
  *(v11 + 11) = *(v11 + 10) - v2;
}

//----- (1002A6F0) --------------------------------------------------------
void __thiscall AnimData::genAge(AnimData *this, struct AgeServer *a2)
{
  char *v2; // eax
  float v3; // ST0C_4
  int v4; // [esp+58h] [ebp-28h]
  int v5; // [esp+5Ch] [ebp-24h]
  CoreNode *v6; // [esp+70h] [ebp-10h]

  v6 = this;
  v2 = CoreNode::Name(this);
  AgeServer::StartGroup(a2, v2);
  if ( sub_10002A81(0xCu) )
    v5 = sub_10002A68(v6, AnimData::playAnim);
  else
    v5 = 0;
  AgeServer::NewButton("play/pause Anim", v5, 222);
  if ( strcmp(v6->name, "Null Anim") )
  {
    if ( sub_10002A81(0xCu) )
      v4 = sub_10002A68(v6, AnimData::delAnim);
    else
      v4 = 0;
    AgeServer::NewButton("Delete", v4, 222);
  }
  v3 = (*(*(v6[2].Next[1].name + 1) + 48) - 1);
  AgeServer::NewEditor(a2, "Frame", v6[2].Next[1].name + 2, 0.0, v3, 320);
  AgeServer::EndGroup(a2);
}
// 10001451: using guessed type _DWORD __stdcall AgeServer::NewButton(_DWORD, _DWORD, _DWORD);
// 10002A68: using guessed type _DWORD __stdcall sub_10002A68(_DWORD, _DWORD);

//----- (1002A8C0) --------------------------------------------------------
void __thiscall AnimData::playAnim(AnimData *this, struct AgeServer *a2)
{
  if ( *(*(*(this + 13) + 24) + 4) == this )
  {
    if ( *(*(*(this + 13) + 24) + 12) == 0.0 )
      *(*(*(this + 13) + 24) + 12) = 1106247680;
    else
      *(*(*(this + 13) + 24) + 12) = 0;
  }
  else
  {
    *(*(*(this + 13) + 24) + 8) = 0;
    *(*(*(this + 13) + 24) + 4) = this;
  }
}

//----- (1002A980) --------------------------------------------------------
void __thiscall AnimData::delAnim(AnimData *this, struct AgeServer *a2)
{
  CoreNode *v2; // eax
  CoreNode *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  if ( *(*(*(this + 13) + 24) + 4) == this )
  {
    v2 = CoreNode::Parent(this);
    *(v3[2].Next[1].name + 1) = CoreNode::Child(v2);
  }
  CoreNode::del(v3);
  AgeServer::RefreshSection(a2);
}

//----- (1002AA10) --------------------------------------------------------
void __thiscall AnimDca::read(AnimDca *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // [esp+4Ch] [ebp-60h]
  HGLOBAL v12; // [esp+50h] [ebp-5Ch]
  int v13; // [esp+54h] [ebp-58h]
  int v14; // [esp+58h] [ebp-54h]
  int v15; // [esp+5Ch] [ebp-50h]
  HGLOBAL v16; // [esp+60h] [ebp-4Ch]
  HGLOBAL v17; // [esp+64h] [ebp-48h]
  HGLOBAL v18; // [esp+68h] [ebp-44h]
  int v19; // [esp+6Ch] [ebp-40h]
  HGLOBAL v20; // [esp+70h] [ebp-3Ch]
  int v21; // [esp+74h] [ebp-38h]
  HGLOBAL hMem; // [esp+78h] [ebp-34h]
  int v23; // [esp+7Ch] [ebp-30h]
  int *v24; // [esp+80h] [ebp-2Ch]
  int *v25; // [esp+84h] [ebp-28h]
  int *v26; // [esp+88h] [ebp-24h]
  int j; // [esp+8Ch] [ebp-20h]
  int v28; // [esp+90h] [ebp-1Ch]
  int i; // [esp+94h] [ebp-18h]
  int v30; // [esp+98h] [ebp-14h]
  AnimData *v31; // [esp+9Ch] [ebp-10h]
  int v32; // [esp+A8h] [ebp-4h]

  v31 = this;
  v2 = (**a2)(a2);
  *(v31 + 10) = v2;
  v3 = (**a2)(a2);
  *(v31 + 12) = v3;
  hMem = sub_10002A81(0xCu);
  v32 = 0;
  if ( hMem )
    v15 = DataChunk::DataChunk(hMem);
  else
    v15 = 0;
  v23 = v15;
  v32 = -1;
  *(v31 + 5) = v15;
  DataChunk::read(*(v31 + 5), a2);
  v20 = sub_10002A81(0xCu);
  v32 = 1;
  if ( v20 )
    v14 = DataChunk::DataChunk(v20);
  else
    v14 = 0;
  v21 = v14;
  v32 = -1;
  *(v31 + 6) = v14;
  DataChunk::read(*(v31 + 6), a2);
  v18 = sub_10002A81(0xCu);
  v32 = 2;
  if ( v18 )
    v13 = DataChunk::DataChunk(v18);
  else
    v13 = 0;
  v19 = v13;
  v32 = -1;
  *(v31 + 7) = v13;
  DataChunk::read(*(v31 + 7), a2);
  v30 = *(v31 + 10);
  v16 = sub_10001AC3(220 * v30);
  v32 = 3;
  if ( v16 )
  {
    sub_1000291E(v16, 220, v30, sub_100022A2);
    v12 = v16;
  }
  else
  {
    v12 = 0;
  }
  v17 = v12;
  v32 = -1;
  *(v31 + 15) = v12;
  for ( i = 0; i < *(v31 + 10); ++i )
  {
    v4 = (**a2)(a2);
    *(*(v31 + 15) + 220 * i + 108) = v4;
    v28 = (**a2)(a2);
    if ( v28 == -1 )
      v11 = 0;
    else
      v11 = 220 * v28 + *(v31 + 15);
    *(*(v31 + 15) + 220 * i + 112) = v11;
    for ( j = 0; j < 3; ++j )
    {
      v26 = (12 * j + 220 * i + *(v31 + 15));
      v5 = (**a2)(a2);
      *v26 = v5;
      v6 = (**a2)(a2);
      v26[1] = v6;
    }
    for ( j = 0; j < 3; ++j )
    {
      v25 = (220 * i + *(v31 + 15) + 12 * j + 36);
      v7 = (**a2)(a2);
      *v25 = v7;
      v8 = (**a2)(a2);
      v25[1] = v8;
    }
    for ( j = 0; j < 3; ++j )
    {
      v24 = (220 * i + *(v31 + 15) + 12 * j + 72);
      v9 = (**a2)(a2);
      *v24 = v9;
      v10 = (**a2)(a2);
      v24[1] = v10;
    }
  }
  AnimData::checkMask(v31);
  AnimData::initData(v31);
}
// 100022A2: using guessed type int sub_100022A2();
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002AEE0) --------------------------------------------------------
void __thiscall AnimDca::writeType(AnimDca *this, struct RandomAccessStream *a2)
{
  AnimDca *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, 2);
}

//----- (1002AF40) --------------------------------------------------------
void __thiscall AnimDca::write(AnimDca *this, struct RandomAccessStream *a2)
{
  char v2; // [esp+0h] [ebp-58h]
  int v3; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]
  AnimDca *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  sub_10025E40("Writing animdca!\n", v2);
  (*(*a2 + 28))(a2, *(v5 + 10));
  (*(*a2 + 28))(a2, *(v5 + 12));
  DataChunk::write(*(v5 + 5), a2);
  DataChunk::write(*(v5 + 6), a2);
  DataChunk::write(*(v5 + 7), a2);
  for ( i = 0; i < *(v5 + 10); ++i )
  {
    (*(*a2 + 28))(a2, i);
    if ( *(*(v5 + 15) + 220 * i + 112) )
      v3 = *(*(*(v5 + 15) + 220 * i + 112) + 108);
    else
      v3 = -1;
    (*(*a2 + 28))(a2, v3);
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 4));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 12));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 16));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 24));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 28));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 36));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 40));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 48));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 52));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 60));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 64));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 72));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 76));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 84));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 88));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 96));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 100));
  }
}

//----- (1002B440) --------------------------------------------------------
void __thiscall AnimDca::parse(AnimDca *this, struct CmdStream *a2)
{
  const char *v2; // eax
  const char *v3; // eax
  int v4; // ecx
  int v5; // ST08_4
  const char *v6; // eax
  int v7; // ST08_4
  const char *v8; // eax
  int v9; // eax
  int v10; // ST08_4
  const char *v11; // eax
  int v12; // ST08_4
  const char *v13; // eax
  int v14; // eax
  int v15; // ST08_4
  const char *v16; // eax
  int v17; // ST08_4
  const char *v18; // eax
  int v19; // eax
  int v20; // ST08_4
  const char *v21; // eax
  int v22; // ST08_4
  const char *v23; // eax
  int v24; // eax
  int v25; // ST08_4
  const char *v26; // eax
  int v27; // ST08_4
  const char *v28; // eax
  int v29; // eax
  int v30; // ST08_4
  const char *v31; // eax
  int v32; // ST08_4
  const char *v33; // eax
  int v34; // eax
  int v35; // ST08_4
  const char *v36; // eax
  int v37; // ST08_4
  const char *v38; // eax
  int v39; // eax
  int v40; // ST08_4
  const char *v41; // eax
  int v42; // ST08_4
  const char *v43; // eax
  int v44; // eax
  int v45; // ST08_4
  const char *v46; // eax
  int v47; // ST08_4
  const char *v48; // eax
  int v49; // [esp+4Ch] [ebp-68h]
  int v50; // [esp+50h] [ebp-64h]
  int v51; // [esp+54h] [ebp-60h]
  int v52; // [esp+58h] [ebp-5Ch]
  HGLOBAL v53; // [esp+5Ch] [ebp-58h]
  int v54; // [esp+60h] [ebp-54h]
  HGLOBAL v55; // [esp+64h] [ebp-50h]
  int v56; // [esp+68h] [ebp-4Ch]
  HGLOBAL hMem; // [esp+6Ch] [ebp-48h]
  int v58; // [esp+70h] [ebp-44h]
  int v59; // [esp+74h] [ebp-40h]
  int v60; // [esp+78h] [ebp-3Ch]
  int v61; // [esp+7Ch] [ebp-38h]
  int v62; // [esp+80h] [ebp-34h]
  int v63; // [esp+84h] [ebp-30h]
  int v64; // [esp+88h] [ebp-2Ch]
  int v65; // [esp+8Ch] [ebp-28h]
  int v66; // [esp+90h] [ebp-24h]
  int v67; // [esp+94h] [ebp-20h]
  int v68; // [esp+98h] [ebp-1Ch]
  int v69; // [esp+9Ch] [ebp-18h]
  int i; // [esp+A0h] [ebp-14h]
  AnimData *v71; // [esp+A4h] [ebp-10h]
  int v72; // [esp+B0h] [ebp-4h]

  v71 = this;
  *(this + 7) = 0;
  *(v71 + 6) = 0;
  *(v71 + 5) = 0;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "<ANM_INFO>") )
    {
      CmdStream::getToken(a2, 1);
      AnimDca::getAnimInfo(v71, a2);
    }
    else if ( CmdStream::isToken(a2, "<SCALING>") )
    {
      hMem = sub_10002A81(0xCu);
      v72 = 0;
      if ( hMem )
        v52 = DataChunk::DataChunk(hMem);
      else
        v52 = 0;
      v58 = v52;
      v72 = -1;
      *(v71 + 5) = v52;
      DataChunk::getData(*(v71 + 5), a2);
      if ( *(*(v71 + 5) + 4) != **(v71 + 5) )
        sub_10025E40("got %d scaling values\n", **(v71 + 5));
    }
    else if ( CmdStream::isToken(a2, "<ROTATION>") )
    {
      v55 = sub_10002A81(0xCu);
      v72 = 1;
      if ( v55 )
        v51 = DataChunk::DataChunk(v55);
      else
        v51 = 0;
      v56 = v51;
      v72 = -1;
      *(v71 + 6) = v51;
      DataChunk::getData(*(v71 + 6), a2);
      for ( i = 0; i < **(v71 + 6); ++i )
        *(*(*(v71 + 6) + 8) + 4 * i) = *(*(*(v71 + 6) + 8) + 4 * i) * 3.1415927 / 180.0;
      if ( *(*(v71 + 6) + 4) != **(v71 + 6) )
        sub_10025E40("got %d rotation values\n", **(v71 + 6));
    }
    else if ( CmdStream::isToken(a2, "<TRANSLATION>") )
    {
      v53 = sub_10002A81(0xCu);
      v72 = 2;
      if ( v53 )
        v50 = DataChunk::DataChunk(v53);
      else
        v50 = 0;
      v54 = v50;
      v72 = -1;
      *(v71 + 7) = v50;
      DataChunk::getData(*(v71 + 7), a2);
      if ( *(*(v71 + 7) + 4) != **(v71 + 7) )
        sub_10025E40("got %d translate values\n", **(v71 + 7));
    }
    else if ( CmdStream::isToken(a2, "<JOINT>") )
    {
      CmdStream::getToken(a2, 1);
      v69 = -1;
      while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
      {
        CmdStream::getToken(a2, 1);
        if ( CmdStream::isToken(a2, "index") )
        {
          v2 = CmdStream::getToken(a2, 1);
          sscanf(v2, "%d", &v69);
        }
        else if ( CmdStream::isToken(a2, "name") )
        {
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "kind") )
        {
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "parent") )
        {
          v3 = CmdStream::getToken(a2, 1);
          sscanf(v3, "%d", &v68);
          CmdStream::getToken(a2, 1);
          if ( v68 == -1 )
            v49 = 0;
          else
            v49 = 220 * v68 + *(v71 + 15);
          *(*(v71 + 15) + 220 * v69 + 112) = v49;
        }
        else if ( CmdStream::isToken(a2, "child") )
        {
          CmdStream::getToken(a2, 1);
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "brother_next") )
        {
          CmdStream::getToken(a2, 1);
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "brother_prev") )
        {
          CmdStream::getToken(a2, 1);
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "sx_param") )
        {
          v4 = *(v71 + 15);
          v67 = 220 * v69 + v4;
          v5 = 220 * v69 + v4;
          v6 = CmdStream::getToken(a2, 1);
          sscanf(v6, "%d", v5);
          v7 = v67 + 4;
          v8 = CmdStream::getToken(a2, 1);
          sscanf(v8, "%d", v7);
        }
        else if ( CmdStream::isToken(a2, "sy_param") )
        {
          v9 = *(v71 + 15);
          v66 = v9 + 220 * v69 + 12;
          v10 = v9 + 220 * v69 + 12;
          v11 = CmdStream::getToken(a2, 1);
          sscanf(v11, "%d", v10);
          v12 = v66 + 4;
          v13 = CmdStream::getToken(a2, 1);
          sscanf(v13, "%d", v12);
        }
        else if ( CmdStream::isToken(a2, "sz_param") )
        {
          v14 = *(v71 + 15);
          v65 = v14 + 220 * v69 + 24;
          v15 = v14 + 220 * v69 + 24;
          v16 = CmdStream::getToken(a2, 1);
          sscanf(v16, "%d", v15);
          v17 = v65 + 4;
          v18 = CmdStream::getToken(a2, 1);
          sscanf(v18, "%d", v17);
        }
        else if ( CmdStream::isToken(a2, "rx_param") )
        {
          v19 = *(v71 + 15);
          v64 = v19 + 220 * v69 + 36;
          v20 = v19 + 220 * v69 + 36;
          v21 = CmdStream::getToken(a2, 1);
          sscanf(v21, "%d", v20);
          v22 = v64 + 4;
          v23 = CmdStream::getToken(a2, 1);
          sscanf(v23, "%d", v22);
        }
        else if ( CmdStream::isToken(a2, "ry_param") )
        {
          v24 = *(v71 + 15);
          v63 = v24 + 220 * v69 + 48;
          v25 = v24 + 220 * v69 + 48;
          v26 = CmdStream::getToken(a2, 1);
          sscanf(v26, "%d", v25);
          v27 = v63 + 4;
          v28 = CmdStream::getToken(a2, 1);
          sscanf(v28, "%d", v27);
        }
        else if ( CmdStream::isToken(a2, "rz_param") )
        {
          v29 = *(v71 + 15);
          v62 = v29 + 220 * v69 + 60;
          v30 = v29 + 220 * v69 + 60;
          v31 = CmdStream::getToken(a2, 1);
          sscanf(v31, "%d", v30);
          v32 = v62 + 4;
          v33 = CmdStream::getToken(a2, 1);
          sscanf(v33, "%d", v32);
        }
        else if ( CmdStream::isToken(a2, "tx_param") )
        {
          v34 = *(v71 + 15);
          v61 = v34 + 220 * v69 + 72;
          v35 = v34 + 220 * v69 + 72;
          v36 = CmdStream::getToken(a2, 1);
          sscanf(v36, "%d", v35);
          v37 = v61 + 4;
          v38 = CmdStream::getToken(a2, 1);
          sscanf(v38, "%d", v37);
        }
        else if ( CmdStream::isToken(a2, "ty_param") )
        {
          v39 = *(v71 + 15);
          v60 = v39 + 220 * v69 + 84;
          v40 = v39 + 220 * v69 + 84;
          v41 = CmdStream::getToken(a2, 1);
          sscanf(v41, "%d", v40);
          v42 = v60 + 4;
          v43 = CmdStream::getToken(a2, 1);
          sscanf(v43, "%d", v42);
        }
        else if ( CmdStream::isToken(a2, "tz_param") )
        {
          v44 = *(v71 + 15);
          v59 = v44 + 220 * v69 + 96;
          v45 = v44 + 220 * v69 + 96;
          v46 = CmdStream::getToken(a2, 1);
          sscanf(v46, "%d", v45);
          v47 = v59 + 4;
          v48 = CmdStream::getToken(a2, 1);
          sscanf(v48, "%d", v47);
        }
      }
      if ( !CmdStream::endOfCmds(a2) )
        CmdStream::getToken(a2, 1);
    }
    else
    {
      CmdStream::getToken(a2, 1);
      while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
        CmdStream::getToken(a2, 1);
      if ( !CmdStream::endOfCmds(a2) )
        CmdStream::getToken(a2, 1);
    }
  }
  AnimData::checkMask(v71);
  AnimData::initData(v71);
}

//----- (1002C0B0) --------------------------------------------------------
void __thiscall AnimDca::getAnimInfo(AnimDca *this, struct CmdStream *a2)
{
  int v2; // ST0C_4
  const char *v3; // eax
  int v4; // ST0C_4
  const char *v5; // eax
  HGLOBAL v6; // [esp+4Ch] [ebp-24h]
  HGLOBAL hMem; // [esp+50h] [ebp-20h]
  HGLOBAL v8; // [esp+54h] [ebp-1Ch]
  int i; // [esp+58h] [ebp-18h]
  int v10; // [esp+5Ch] [ebp-14h]
  AnimDca *v11; // [esp+60h] [ebp-10h]
  int v12; // [esp+6Ch] [ebp-4h]

  v11 = this;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "numjoints") )
    {
      v2 = v11 + 40;
      v3 = CmdStream::getToken(a2, 1);
      sscanf(v3, "%d", v2);
      v10 = *(v11 + 10);
      hMem = sub_10001AC3(220 * v10);
      v12 = 0;
      if ( hMem )
      {
        sub_1000291E(hMem, 220, v10, sub_100022A2);
        v6 = hMem;
      }
      else
      {
        v6 = 0;
      }
      v8 = v6;
      v12 = -1;
      *(v11 + 15) = v6;
      for ( i = 0; i < *(v11 + 10); ++i )
        *(*(v11 + 15) + 220 * i + 108) = i;
    }
    else if ( CmdStream::isToken(a2, "numframes") )
    {
      v4 = v11 + 48;
      v5 = CmdStream::getToken(a2, 1);
      sscanf(v5, "%d", v4);
    }
    else
    {
      CmdStream::skipLine(a2);
    }
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}
// 100022A2: using guessed type int sub_100022A2();
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002C2F0) --------------------------------------------------------
AnimData *__thiscall AnimDck::AnimDck(AnimDck *this, struct BaseShape *a2, int a3)
{
  int v4; // [esp+4Ch] [ebp-28h]
  HGLOBAL v5; // [esp+50h] [ebp-24h]
  HGLOBAL hMem; // [esp+54h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-18h]
  int v8; // [esp+60h] [ebp-14h]
  AnimData *v9; // [esp+64h] [ebp-10h]

  v9 = this;
  AnimData::AnimData(this);
  *v9 = &AnimDck::`vftable';
  *(v9 + 13) = a2;
  *(v9 + 10) = a3;
  *(v9 + 12) = 0;
  v8 = *(v9 + 10);
  hMem = sub_10001AC3(220 * v8);
  if ( hMem )
  {
    sub_1000291E(hMem, 220, v8, sub_100022A2);
    v5 = hMem;
  }
  else
  {
    v5 = 0;
  }
  *(v9 + 15) = v5;
  for ( i = 0; i < a3; ++i )
  {
    if ( *(*(a2 + 23) + 284 * i + 24) == -1 )
      v4 = 0;
    else
      v4 = 220 * *(*(a2 + 23) + 284 * i + 24) + *(v9 + 15);
    *(*(v9 + 15) + 220 * i + 112) = v4;
  }
  return v9;
}
// 100022A2: using guessed type int sub_100022A2();
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);
// 101ADDCC: using guessed type void *AnimDck::`vftable';

//----- (1002C4B0) --------------------------------------------------------
void __thiscall AnimDck::read(AnimDck *this, struct RandomAccessStream *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // [esp+4Ch] [ebp-60h]
  HGLOBAL v15; // [esp+50h] [ebp-5Ch]
  int v16; // [esp+54h] [ebp-58h]
  int v17; // [esp+58h] [ebp-54h]
  int v18; // [esp+5Ch] [ebp-50h]
  HGLOBAL v19; // [esp+60h] [ebp-4Ch]
  HGLOBAL v20; // [esp+64h] [ebp-48h]
  HGLOBAL v21; // [esp+68h] [ebp-44h]
  int v22; // [esp+6Ch] [ebp-40h]
  HGLOBAL v23; // [esp+70h] [ebp-3Ch]
  int v24; // [esp+74h] [ebp-38h]
  HGLOBAL hMem; // [esp+78h] [ebp-34h]
  int v26; // [esp+7Ch] [ebp-30h]
  int *v27; // [esp+80h] [ebp-2Ch]
  int *v28; // [esp+84h] [ebp-28h]
  int *v29; // [esp+88h] [ebp-24h]
  int j; // [esp+8Ch] [ebp-20h]
  int v31; // [esp+90h] [ebp-1Ch]
  int i; // [esp+94h] [ebp-18h]
  int v33; // [esp+98h] [ebp-14h]
  AnimData *v34; // [esp+9Ch] [ebp-10h]
  int v35; // [esp+A8h] [ebp-4h]

  v34 = this;
  v2 = (**a2)(a2);
  *(v34 + 10) = v2;
  v3 = (**a2)(a2);
  *(v34 + 12) = v3;
  hMem = sub_10002A81(0xCu);
  v35 = 0;
  if ( hMem )
    v18 = DataChunk::DataChunk(hMem);
  else
    v18 = 0;
  v26 = v18;
  v35 = -1;
  *(v34 + 5) = v18;
  DataChunk::read(*(v34 + 5), a2);
  v23 = sub_10002A81(0xCu);
  v35 = 1;
  if ( v23 )
    v17 = DataChunk::DataChunk(v23);
  else
    v17 = 0;
  v24 = v17;
  v35 = -1;
  *(v34 + 6) = v17;
  DataChunk::read(*(v34 + 6), a2);
  v21 = sub_10002A81(0xCu);
  v35 = 2;
  if ( v21 )
    v16 = DataChunk::DataChunk(v21);
  else
    v16 = 0;
  v22 = v16;
  v35 = -1;
  *(v34 + 7) = v16;
  DataChunk::read(*(v34 + 7), a2);
  v33 = *(v34 + 10);
  v19 = sub_10001AC3(220 * v33);
  v35 = 3;
  if ( v19 )
  {
    sub_1000291E(v19, 220, v33, sub_100022A2);
    v15 = v19;
  }
  else
  {
    v15 = 0;
  }
  v20 = v15;
  v35 = -1;
  *(v34 + 15) = v15;
  for ( i = 0; i < *(v34 + 10); ++i )
  {
    v4 = (**a2)(a2);
    *(*(v34 + 15) + 220 * i + 108) = v4;
    v31 = (**a2)(a2);
    if ( v31 == -1 )
      v14 = 0;
    else
      v14 = 220 * v31 + *(v34 + 15);
    *(*(v34 + 15) + 220 * i + 112) = v14;
    for ( j = 0; j < 3; ++j )
    {
      v29 = (12 * j + 220 * i + *(v34 + 15));
      v5 = (**a2)(a2);
      *v29 = v5;
      v6 = (**a2)(a2);
      v29[1] = v6;
      v7 = (**a2)(a2);
      v29[2] = v7;
    }
    for ( j = 0; j < 3; ++j )
    {
      v28 = (220 * i + *(v34 + 15) + 12 * j + 36);
      v8 = (**a2)(a2);
      *v28 = v8;
      v9 = (**a2)(a2);
      v28[1] = v9;
      v10 = (**a2)(a2);
      v28[2] = v10;
    }
    for ( j = 0; j < 3; ++j )
    {
      v27 = (220 * i + *(v34 + 15) + 12 * j + 72);
      v11 = (**a2)(a2);
      *v27 = v11;
      v12 = (**a2)(a2);
      v27[1] = v12;
      v13 = (**a2)(a2);
      v27[2] = v13;
    }
  }
  AnimData::checkMask(v34);
  AnimData::initData(v34);
}
// 100022A2: using guessed type int sub_100022A2();
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002C9D0) --------------------------------------------------------
void __thiscall AnimDck::writeType(AnimDck *this, struct RandomAccessStream *a2)
{
  AnimDck *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*a2 + 28))(a2, 3);
}

//----- (1002CA30) --------------------------------------------------------
void __thiscall AnimDck::write(AnimDck *this, struct RandomAccessStream *a2)
{
  char v2; // [esp+0h] [ebp-58h]
  int v3; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]
  AnimDck *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  sub_10025E40("Writing animdck!\n", v2);
  (*(*a2 + 28))(a2, *(v5 + 10));
  (*(*a2 + 28))(a2, *(v5 + 12));
  DataChunk::write(*(v5 + 5), a2);
  DataChunk::write(*(v5 + 6), a2);
  DataChunk::write(*(v5 + 7), a2);
  for ( i = 0; i < *(v5 + 10); ++i )
  {
    (*(*a2 + 28))(a2, i);
    if ( *(*(v5 + 15) + 220 * i + 112) )
      v3 = *(*(*(v5 + 15) + 220 * i + 112) + 108);
    else
      v3 = -1;
    (*(*a2 + 28))(a2, v3);
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 4));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 8));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 12));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 16));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 20));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 24));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 28));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 32));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 36));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 40));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 44));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 48));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 52));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 56));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 60));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 64));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 68));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 72));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 76));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 80));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 84));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 88));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 92));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 96));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 100));
    (*(*a2 + 28))(a2, *(*(v5 + 15) + 220 * i + 104));
  }
}

//----- (1002D0F0) --------------------------------------------------------
void __thiscall AnimDck::parse(AnimDck *this, struct CmdStream *a2)
{
  const char *v2; // eax
  const char *v3; // eax
  int v4; // ecx
  int v5; // ST08_4
  const char *v6; // eax
  int v7; // ST08_4
  const char *v8; // eax
  int v9; // ST08_4
  const char *v10; // eax
  int v11; // ST08_4
  const char *v12; // eax
  int v13; // ST08_4
  const char *v14; // eax
  int v15; // ST08_4
  const char *v16; // eax
  int v17; // edx
  int v18; // ST08_4
  const char *v19; // eax
  int v20; // ST08_4
  const char *v21; // eax
  int v22; // ST08_4
  const char *v23; // eax
  int v24; // eax
  int v25; // ST08_4
  const char *v26; // eax
  int v27; // ST08_4
  const char *v28; // eax
  int v29; // ST08_4
  const char *v30; // eax
  int v31; // ST08_4
  const char *v32; // eax
  int v33; // ST08_4
  const char *v34; // eax
  int v35; // ST08_4
  const char *v36; // eax
  int v37; // edx
  int v38; // ST08_4
  const char *v39; // eax
  int v40; // ST08_4
  const char *v41; // eax
  int v42; // ST08_4
  const char *v43; // eax
  int v44; // eax
  int v45; // ST08_4
  const char *v46; // eax
  int v47; // ST08_4
  const char *v48; // eax
  int v49; // ST08_4
  const char *v50; // eax
  int v51; // ST08_4
  const char *v52; // eax
  int v53; // ST08_4
  const char *v54; // eax
  int v55; // ST08_4
  const char *v56; // eax
  int v57; // edx
  int v58; // ST08_4
  const char *v59; // eax
  int v60; // ST08_4
  const char *v61; // eax
  int v62; // ST08_4
  const char *v63; // eax
  int v64; // [esp+4Ch] [ebp-8Ch]
  int v65; // [esp+50h] [ebp-88h]
  int v66; // [esp+54h] [ebp-84h]
  int v67; // [esp+58h] [ebp-80h]
  int v68; // [esp+5Ch] [ebp-7Ch]
  int v69; // [esp+60h] [ebp-78h]
  HGLOBAL v70; // [esp+64h] [ebp-74h]
  int v71; // [esp+68h] [ebp-70h]
  HGLOBAL v72; // [esp+6Ch] [ebp-6Ch]
  int v73; // [esp+70h] [ebp-68h]
  HGLOBAL hMem; // [esp+74h] [ebp-64h]
  int v75; // [esp+78h] [ebp-60h]
  int l; // [esp+7Ch] [ebp-5Ch]
  int v77; // [esp+80h] [ebp-58h]
  int v78; // [esp+84h] [ebp-54h]
  int *v79; // [esp+88h] [ebp-50h]
  int k; // [esp+8Ch] [ebp-4Ch]
  int j; // [esp+90h] [ebp-48h]
  int i; // [esp+94h] [ebp-44h]
  int v83; // [esp+98h] [ebp-40h]
  int v84; // [esp+9Ch] [ebp-3Ch]
  int v85; // [esp+A0h] [ebp-38h]
  int v86; // [esp+A4h] [ebp-34h]
  int v87; // [esp+A8h] [ebp-30h]
  int v88; // [esp+ACh] [ebp-2Ch]
  int v89; // [esp+B0h] [ebp-28h]
  int v90; // [esp+B4h] [ebp-24h]
  int v91; // [esp+B8h] [ebp-20h]
  int v92; // [esp+BCh] [ebp-1Ch]
  int v93; // [esp+C0h] [ebp-18h]
  int v94; // [esp+C4h] [ebp-14h]
  AnimData *v95; // [esp+C8h] [ebp-10h]
  int v96; // [esp+D4h] [ebp-4h]

  v95 = this;
  *(this + 7) = 0;
  *(v95 + 6) = 0;
  *(v95 + 5) = 0;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "<KEY_ANM_INFO>") )
    {
      CmdStream::getToken(a2, 1);
      AnimDck::getAnimInfo(v95, a2);
    }
    else if ( CmdStream::isToken(a2, "<KEY_SCALING>") )
    {
      hMem = sub_10002A81(0xCu);
      v96 = 0;
      if ( hMem )
        v68 = DataChunk::DataChunk(hMem);
      else
        v68 = 0;
      v75 = v68;
      v96 = -1;
      *(v95 + 5) = v68;
      DataChunk::getData(*(v95 + 5), a2);
      if ( *(*(v95 + 5) + 4) != **(v95 + 5) )
        sub_10025E40("got %d scaling values\n", **(v95 + 5));
    }
    else if ( CmdStream::isToken(a2, "<KEY_ROTATION>") )
    {
      v72 = sub_10002A81(0xCu);
      v96 = 1;
      if ( v72 )
        v67 = DataChunk::DataChunk(v72);
      else
        v67 = 0;
      v73 = v67;
      v96 = -1;
      *(v95 + 6) = v67;
      DataChunk::getData(*(v95 + 6), a2);
      if ( *(*(v95 + 6) + 4) != **(v95 + 6) )
        sub_10025E40("got %d rotation values\n", **(v95 + 6));
    }
    else if ( CmdStream::isToken(a2, "<KEY_TRANSLATION>") )
    {
      v70 = sub_10002A81(0xCu);
      v96 = 2;
      if ( v70 )
        v66 = DataChunk::DataChunk(v70);
      else
        v66 = 0;
      v71 = v66;
      v96 = -1;
      *(v95 + 7) = v66;
      DataChunk::getData(*(v95 + 7), a2);
      if ( *(*(v95 + 7) + 4) != **(v95 + 7) )
        sub_10025E40("got %d translate values\n", **(v95 + 7));
    }
    else if ( CmdStream::isToken(a2, "<JOINT>") )
    {
      CmdStream::getToken(a2, 1);
      v94 = -1;
      while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
      {
        CmdStream::getToken(a2, 1);
        if ( CmdStream::isToken(a2, "index") )
        {
          v2 = CmdStream::getToken(a2, 1);
          sscanf(v2, "%d", &v94);
        }
        else if ( CmdStream::isToken(a2, "name") )
        {
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "kind") )
        {
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "parent") )
        {
          v3 = CmdStream::getToken(a2, 1);
          sscanf(v3, "%d", &v93);
          CmdStream::getToken(a2, 1);
          if ( v93 == -1 )
            v65 = 0;
          else
            v65 = 220 * v93 + *(v95 + 15);
          *(*(v95 + 15) + 220 * v94 + 112) = v65;
        }
        else if ( CmdStream::isToken(a2, "child") )
        {
          CmdStream::getToken(a2, 1);
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "brother_next") )
        {
          CmdStream::getToken(a2, 1);
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "brother_prev") )
        {
          CmdStream::getToken(a2, 1);
          CmdStream::getToken(a2, 1);
        }
        else if ( CmdStream::isToken(a2, "sx_param") )
        {
          v4 = *(v95 + 15);
          v92 = 220 * v94 + v4;
          v5 = 220 * v94 + v4;
          v6 = CmdStream::getToken(a2, 1);
          sscanf(v6, "%d", v5);
          v7 = v92 + 4;
          v8 = CmdStream::getToken(a2, 1);
          sscanf(v8, "%d", v7);
          v9 = v92 + 8;
          v10 = CmdStream::getToken(a2, 1);
          sscanf(v10, "%d", v9);
        }
        else if ( CmdStream::isToken(a2, "sy_param") )
        {
          v91 = *(v95 + 15) + 220 * v94 + 12;
          v11 = v91;
          v12 = CmdStream::getToken(a2, 1);
          sscanf(v12, "%d", v11);
          v13 = v91 + 4;
          v14 = CmdStream::getToken(a2, 1);
          sscanf(v14, "%d", v13);
          v15 = v91 + 8;
          v16 = CmdStream::getToken(a2, 1);
          sscanf(v16, "%d", v15);
        }
        else if ( CmdStream::isToken(a2, "sz_param") )
        {
          v17 = *(v95 + 15);
          v90 = v17 + 220 * v94 + 24;
          v18 = v17 + 220 * v94 + 24;
          v19 = CmdStream::getToken(a2, 1);
          sscanf(v19, "%d", v18);
          v20 = v90 + 4;
          v21 = CmdStream::getToken(a2, 1);
          sscanf(v21, "%d", v20);
          v22 = v90 + 8;
          v23 = CmdStream::getToken(a2, 1);
          sscanf(v23, "%d", v22);
        }
        else if ( CmdStream::isToken(a2, "rx_param") )
        {
          v24 = *(v95 + 15);
          v89 = v24 + 220 * v94 + 36;
          v25 = v24 + 220 * v94 + 36;
          v26 = CmdStream::getToken(a2, 1);
          sscanf(v26, "%d", v25);
          v27 = v89 + 4;
          v28 = CmdStream::getToken(a2, 1);
          sscanf(v28, "%d", v27);
          v29 = v89 + 8;
          v30 = CmdStream::getToken(a2, 1);
          sscanf(v30, "%d", v29);
        }
        else if ( CmdStream::isToken(a2, "ry_param") )
        {
          v88 = *(v95 + 15) + 220 * v94 + 48;
          v31 = v88;
          v32 = CmdStream::getToken(a2, 1);
          sscanf(v32, "%d", v31);
          v33 = v88 + 4;
          v34 = CmdStream::getToken(a2, 1);
          sscanf(v34, "%d", v33);
          v35 = v88 + 8;
          v36 = CmdStream::getToken(a2, 1);
          sscanf(v36, "%d", v35);
        }
        else if ( CmdStream::isToken(a2, "rz_param") )
        {
          v37 = *(v95 + 15);
          v87 = v37 + 220 * v94 + 60;
          v38 = v37 + 220 * v94 + 60;
          v39 = CmdStream::getToken(a2, 1);
          sscanf(v39, "%d", v38);
          v40 = v87 + 4;
          v41 = CmdStream::getToken(a2, 1);
          sscanf(v41, "%d", v40);
          v42 = v87 + 8;
          v43 = CmdStream::getToken(a2, 1);
          sscanf(v43, "%d", v42);
        }
        else if ( CmdStream::isToken(a2, "tx_param") )
        {
          v44 = *(v95 + 15);
          v86 = v44 + 220 * v94 + 72;
          v45 = v44 + 220 * v94 + 72;
          v46 = CmdStream::getToken(a2, 1);
          sscanf(v46, "%d", v45);
          v47 = v86 + 4;
          v48 = CmdStream::getToken(a2, 1);
          sscanf(v48, "%d", v47);
          v49 = v86 + 8;
          v50 = CmdStream::getToken(a2, 1);
          sscanf(v50, "%d", v49);
        }
        else if ( CmdStream::isToken(a2, "ty_param") )
        {
          v85 = *(v95 + 15) + 220 * v94 + 84;
          v51 = v85;
          v52 = CmdStream::getToken(a2, 1);
          sscanf(v52, "%d", v51);
          v53 = v85 + 4;
          v54 = CmdStream::getToken(a2, 1);
          sscanf(v54, "%d", v53);
          v55 = v85 + 8;
          v56 = CmdStream::getToken(a2, 1);
          sscanf(v56, "%d", v55);
        }
        else if ( CmdStream::isToken(a2, "tz_param") )
        {
          v57 = *(v95 + 15);
          v84 = v57 + 220 * v94 + 96;
          v58 = v57 + 220 * v94 + 96;
          v59 = CmdStream::getToken(a2, 1);
          sscanf(v59, "%d", v58);
          v60 = v84 + 4;
          v61 = CmdStream::getToken(a2, 1);
          sscanf(v61, "%d", v60);
          v62 = v84 + 8;
          v63 = CmdStream::getToken(a2, 1);
          sscanf(v63, "%d", v62);
        }
      }
      if ( !CmdStream::endOfCmds(a2) )
        CmdStream::getToken(a2, 1);
    }
    else
    {
      CmdStream::getToken(a2, 1);
      while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
        CmdStream::getToken(a2, 1);
      if ( !CmdStream::endOfCmds(a2) )
        CmdStream::getToken(a2, 1);
    }
  }
  AnimData::checkMask(v95);
  AnimData::initData(v95);
  v69 = sub_10001AC3(**(v95 + 6));
  v83 = v69;
  for ( i = 0; i < **(v95 + 6); ++i )
    *(i + v83) = 0;
  for ( j = 0; j < *(v95 + 10); ++j )
  {
    for ( k = 0; k < 3; ++k )
    {
      v79 = (220 * j + *(v95 + 15) + 12 * k + 36);
      v64 = *v79;
      if ( v64 )
      {
        if ( v64 == 1 )
        {
          if ( !*(v83 + v79[1]) )
          {
            *(*(*(v95 + 6) + 8) + 4 * v79[1]) = *(*(*(v95 + 6) + 8) + 4 * v79[1]) * 3.1415927 / 180.0;
            *(v83 + v79[1]) = 1;
          }
        }
        else
        {
          v78 = (v79[2] != 0) + 3;
          v77 = v79[1] + 1;
          for ( l = 0; l < *v79; ++l )
          {
            if ( !*(v77 + v83) )
            {
              *(*(*(v95 + 6) + 8) + 4 * v77) = *(*(*(v95 + 6) + 8) + 4 * v77) * 3.1415927 / 180.0;
              *(*(*(v95 + 6) + 8) + 4 * v77 + 4) = *(*(*(v95 + 6) + 8) + 4 * v77 + 4) * 3.1415927 / 180.0;
              if ( v78 == 4 )
                *(*(*(v95 + 6) + 8) + 4 * v77 + 8) = *(*(*(v95 + 6) + 8) + 4 * v77 + 8) * 3.1415927 / 180.0;
              *(v77 + v83) = 1;
            }
            v77 += v78;
          }
        }
      }
    }
  }
}

//----- (1002E1B0) --------------------------------------------------------
void __thiscall AnimDck::getAnimInfo(AnimDck *this, struct CmdStream *a2)
{
  int v2; // ST0C_4
  const char *v3; // eax
  int v4; // ST0C_4
  const char *v5; // eax
  HGLOBAL v6; // [esp+4Ch] [ebp-24h]
  HGLOBAL hMem; // [esp+50h] [ebp-20h]
  HGLOBAL v8; // [esp+54h] [ebp-1Ch]
  int i; // [esp+58h] [ebp-18h]
  int v10; // [esp+5Ch] [ebp-14h]
  AnimDck *v11; // [esp+60h] [ebp-10h]
  int v12; // [esp+6Ch] [ebp-4h]

  v11 = this;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "numjoints") )
    {
      v2 = v11 + 40;
      v3 = CmdStream::getToken(a2, 1);
      sscanf(v3, "%d", v2);
      v10 = *(v11 + 10);
      hMem = sub_10001AC3(220 * v10);
      v12 = 0;
      if ( hMem )
      {
        sub_1000291E(hMem, 220, v10, sub_100022A2);
        v6 = hMem;
      }
      else
      {
        v6 = 0;
      }
      v8 = v6;
      v12 = -1;
      *(v11 + 15) = v6;
      for ( i = 0; i < *(v11 + 10); ++i )
        *(*(v11 + 15) + 220 * i + 108) = i;
    }
    else if ( CmdStream::isToken(a2, "numframes") )
    {
      v4 = v11 + 48;
      v5 = CmdStream::getToken(a2, 1);
      sscanf(v5, "%d", v4);
    }
    else
    {
      CmdStream::skipLine(a2);
    }
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}
// 100022A2: using guessed type int sub_100022A2();
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002E3F0) --------------------------------------------------------
void __thiscall AnimDck::extractSRT(AnimDck *this, struct SRT *a2, int a3, struct AnimDataInfo *a4, float a5)
{
  __int16 v5; // dx
  __int16 v6; // cx
  __int16 v7; // ax
  _DWORD *v8; // [esp+58h] [ebp-34h]
  signed int k; // [esp+5Ch] [ebp-30h]
  char *v10; // [esp+64h] [ebp-28h]
  _DWORD *v11; // [esp+68h] [ebp-24h]
  signed int j; // [esp+6Ch] [ebp-20h]
  char *v13; // [esp+74h] [ebp-18h]
  _DWORD *v14; // [esp+78h] [ebp-14h]
  signed int i; // [esp+7Ch] [ebp-10h]
  int *v16; // [esp+88h] [ebp-4h]

  v16 = this;
  if ( !(*(a4 + 108) & 0x8000) )
  {
    if ( !(*(a4 + 108) & 8) )
    {
      for ( i = 0; i < 3; ++i )
      {
        v14 = (a4 + 12 * i);
        if ( *v14 )
        {
          if ( *v14 == 1 )
            *(a2 + i) = *(*(v16[5] + 8) + 4 * v14[1]);
          else
            *(a2 + i) = sub_10027DA0(a5, v14, v16[5]);
        }
        else
        {
          *(a2 + i) = 1065353216;
        }
      }
      if ( (*(a4 + 108) & 7) == 7 )
      {
        v5 = *(a4 + 108);
        LOBYTE(v5) = v5 | 8;
        *(a4 + 108) = v5;
      }
    }
    if ( !(*(a4 + 108) & 0x80) )
    {
      v13 = a2 + 12;
      for ( j = 0; j < 3; ++j )
      {
        v11 = (a4 + 12 * j + 36);
        if ( *v11 )
        {
          if ( *v11 == 1 )
            *&v13[4 * j] = *(*(v16[6] + 8) + 4 * v11[1]);
          else
            *&v13[4 * j] = sub_10027DA0(a5, v11, v16[6]);
        }
        else
        {
          *&v13[4 * j] = 0;
        }
      }
      if ( (*(a4 + 108) & 0x70) == 112 )
      {
        v6 = *(a4 + 108);
        LOBYTE(v6) = v6 | 0x80;
        *(a4 + 108) = v6;
      }
    }
    if ( !(*(a4 + 108) & 0x800) )
    {
      v10 = a2 + 24;
      for ( k = 0; k < 3; ++k )
      {
        v8 = (a4 + 12 * k + 72);
        if ( *v8 )
        {
          if ( *v8 == 1 )
            *&v10[4 * k] = *(*(v16[7] + 8) + 4 * v8[1]);
          else
            *&v10[4 * k] = sub_10027DA0(a5, v8, v16[7]);
        }
        else
        {
          *&v10[4 * k] = 1065353216;
        }
      }
      if ( (*(a4 + 108) & 0x700) == 1792 )
      {
        v7 = *(a4 + 108);
        HIBYTE(v7) |= 8u;
        *(a4 + 108) = v7;
      }
    }
  }
}

//----- (1002E7B0) --------------------------------------------------------
void __thiscall AnimDck::makeAnimSRT(AnimDck *this, int a2, struct Matrix4f *a3, struct Matrix4f *a4, struct AnimDataInfo *a5, float a6)
{
  __int16 v6; // ax
  char v7; // [esp+4Ch] [ebp-48h]
  struct SRT *v8; // [esp+8Ch] [ebp-8h]
  AnimDck *v9; // [esp+90h] [ebp-4h]

  v9 = this;
  v8 = (a5 + 180);
  (*(*this + 20))(this, a5 + 180, a2, a5, LODWORD(a6));
  if ( (*(a5 + 108) & 0x777) == 1911 )
  {
    if ( !(*(a5 + 108) & 0x8000) )
    {
      Matrix4f::makeSRT((a5 + 116), v8, (v8 + 12), (v8 + 24));
      v6 = *(a5 + 108);
      HIBYTE(v6) |= 0x80u;
      *(a5 + 108) = v6;
    }
    Matrix4f::multiplyTo(a3, (a5 + 116), a4);
  }
  else
  {
    Matrix4f::Matrix4f(&v7);
    Matrix4f::makeConcatSRT(a4, a3, &v7, v8);
  }
}

//----- (1002E8F0) --------------------------------------------------------
void __thiscall BaseShape::exportIni(BaseShape *this, struct RandomAccessStream *a2, bool a3)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char v6; // [esp+0h] [ebp-5Ch]
  ObjCollInfo *k; // [esp+4Ch] [ebp-10h]
  LightGroup *j; // [esp+50h] [ebp-Ch]
  RouteGroup *i; // [esp+54h] [ebp-8h]
  CoreNode *v10; // [esp+58h] [ebp-4h]

  v10 = this;
  sub_10025E40("*---------------------------- exporting ini!!!!!!!!!!!\n", v6);
  if ( CoreNode::Child((v10 + 444)) )
  {
    v3 = CoreNode::Name(v10);
    Stream::print(a2, "// Route info file for %s", v3);
    for ( i = CoreNode::Child((v10 + 444)); i; i = *(i + 3) )
      RouteGroup::saveini(i, `string', a2);
    Stream::print(a2, "\n");
  }
  if ( !a3 && CoreNode::Child((v10 + 192)) )
  {
    v4 = CoreNode::Name(v10);
    Stream::print(a2, "// LightGroups info file for %s", v4);
    for ( j = CoreNode::Child((v10 + 192)); j; j = *(j + 3) )
      LightGroup::saveini(j, `string', a2);
    Stream::print(a2, "\n");
  }
  if ( CoreNode::Child(v10 + 15) )
  {
    v5 = CoreNode::Name(v10);
    Stream::print(a2, "// Collision info file for %s", v5);
    for ( k = CoreNode::Child(v10 + 15); k; k = *(k + 3) )
      ObjCollInfo::saveini(k, `string', a2);
    Stream::print(a2, "\n");
  }
}

//----- (1002EB00) --------------------------------------------------------
void __thiscall BaseShape::importIni(BaseShape *this, struct RandomAccessStream *a2)
{
  const char *v2; // eax
  const char *v3; // eax
  struct CoreNode *v4; // [esp+4Ch] [ebp-4Ch]
  struct CoreNode *v5; // [esp+50h] [ebp-48h]
  CmdStream *v6; // [esp+54h] [ebp-44h]
  HGLOBAL v7; // [esp+58h] [ebp-40h]
  struct CoreNode *v8; // [esp+5Ch] [ebp-3Ch]
  HGLOBAL v9; // [esp+60h] [ebp-38h]
  struct CoreNode *v10; // [esp+64h] [ebp-34h]
  HGLOBAL hMem; // [esp+68h] [ebp-30h]
  CmdStream *v12; // [esp+6Ch] [ebp-2Ch]
  struct CoreNode *v13; // [esp+70h] [ebp-28h]
  struct CoreNode *v14; // [esp+74h] [ebp-24h]
  CoreNode *v15; // [esp+78h] [ebp-20h]
  struct CoreNode *v16; // [esp+7Ch] [ebp-1Ch]
  CoreNode *v17; // [esp+80h] [ebp-18h]
  CmdStream *v18; // [esp+84h] [ebp-14h]
  BaseShape *v19; // [esp+88h] [ebp-10h]
  int v20; // [esp+94h] [ebp-4h]

  v19 = this;
  hMem = sub_10002A81(0x11Cu);
  v20 = 0;
  if ( hMem )
    v6 = CmdStream::CmdStream(hMem, a2);
  else
    v6 = 0;
  v12 = v6;
  v20 = -1;
  v18 = v6;
  if ( v6 )
  {
    while ( !CmdStream::endOfCmds(v18) && !CmdStream::endOfSection(v18) )
    {
      CmdStream::getToken(v18, 1);
      if ( CmdStream::isToken(v18, "collinfo") )
      {
        v2 = CmdStream::getToken(v18, 1);
        sscanf(v2, "%d", &v17);
        v9 = sub_10002A81(0x54u);
        v20 = 1;
        if ( v9 )
          v5 = ObjCollInfo::ObjCollInfo(v9);
        else
          v5 = 0;
        v10 = v5;
        v20 = -1;
        v16 = v5;
        v5[2].Parent = v17;
        v16[3].Parent = v19;
        CoreNode::add(v19 + 15, v16);
        CmdStream::getToken(v18, 1);
        ObjCollInfo::loadini(v16, v18);
      }
      else if ( CmdStream::isToken(v18, "lightgroup") )
      {
        v3 = CmdStream::getToken(v18, 1);
        sscanf(v3, "%d", &v15);
        v7 = sub_10002A81(0x6Cu);
        v20 = 2;
        if ( v7 )
          v4 = LightGroup::LightGroup(v7);
        else
          v4 = 0;
        v8 = v4;
        v20 = -1;
        v14 = v4;
        v4[1].Parent = v15;
        v14[5].vtblPointer = v19;
        CoreNode::add((v19 + 192), v14);
        CmdStream::getToken(v18, 1);
        LightGroup::loadini(v14, v18);
      }
      else if ( CmdStream::isToken(v18, "route") )
      {
        v13 = (*(*v19 + 44))(v19);
        CoreNode::add((v19 + 444), v13);
        CmdStream::getToken(v18, 1);
        RouteGroup::loadini(v13, v18);
      }
    }
    if ( !CmdStream::endOfCmds(v18) )
      CmdStream::getToken(v18, 1);
  }
}

//----- (1002EE90) --------------------------------------------------------
void __thiscall ShapeDynMaterials::animate(ShapeDynMaterials *this, float *a2)
{
  struct Colour *v2; // eax
  int k; // [esp+4Ch] [ebp-14h]
  signed int j; // [esp+50h] [ebp-10h]
  Material *v5; // [esp+54h] [ebp-Ch]
  int i; // [esp+58h] [ebp-8h]
  ShapeDynMaterials *v7; // [esp+5Ch] [ebp-4h]

  v7 = this;
  Timers::start(*(gsys + 14), "shpDynMats", 1);
  for ( i = 0; i < *(v7 + 1); ++i )
  {
    v5 = (156 * i + *(v7 + 2));
    if ( *(v5 + 6) & 1 )
    {
      if ( *(v5 + 12) )
      {
        v2 = Material::Colour(v5);
        PVWPolygonColourInfo::animate((v5 + 44), a2, v2);
      }
      for ( j = 0; j < 3; ++j )
      {
        if ( *(*(v5 + 36) + 36 * j + 8) )
          PVWTevColReg::animate((*(v5 + 36) + 36 * j), a2, (36 * j + *(v5 + 36)));
      }
      for ( k = 0; k < *(v5 + 29); ++k )
      {
        if ( *(*(v5 + 33) + 156 * k + 20) != 255 )
          PVWTextureData::animate((156 * k + *(v5 + 33)), a2, (*(v5 + 33) + 156 * k + 92));
      }
    }
  }
  Timers::stop(*(gsys + 14), "shpDynMats");
}

//----- (1002F090) --------------------------------------------------------
void __thiscall ShapeDynMaterials::updateContext(ShapeDynMaterials *this)
{
  int v1; // esi
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // edi
  int v6; // ecx
  int k; // [esp+4Ch] [ebp-14h]
  signed int j; // [esp+50h] [ebp-10h]
  Material *v9; // [esp+54h] [ebp-Ch]
  int i; // [esp+58h] [ebp-8h]
  ShapeDynMaterials *v11; // [esp+5Ch] [ebp-4h]

  v11 = this;
  for ( i = 0; i < *(v11 + 1); ++i )
  {
    v9 = (156 * i + *(v11 + 2));
    if ( *(v9 + 6) & 1 )
    {
      v1 = *Material::Colour(v9);
      *Material::Colour((156 * *(v9 + 5) + *(*(v11 + 3) + 68))) = v1;
      for ( j = 0; j < 3; ++j )
      {
        if ( *(*(v9 + 36) + 36 * j + 8) )
        {
          v2 = *(v9 + 36);
          v3 = *(v2 + 36 * j);
          v4 = *(v2 + 36 * j + 4);
          v5 = 36 * j;
          v6 = *(*(*(v11 + 3) + 68) + 156 * *(v9 + 5) + 144);
          *(v6 + v5) = v3;
          *(v6 + v5 + 4) = v4;
        }
      }
      for ( k = 0; k < *(v9 + 29); ++k )
      {
        if ( *(*(v9 + 33) + 156 * k + 20) != 255 )
          qmemcpy((*(*(*(v11 + 3) + 68) + 156 * *(v9 + 5) + 132) + 156 * k + 92), (*(v9 + 33) + 156 * k + 92), 0x40u);
      }
    }
  }
}

//----- (1002F290) --------------------------------------------------------
CoreNode *__thiscall BaseShape::BaseShape(BaseShape *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "CoreNode");
  AnimData::AnimData(&v1[6].name);
  LightGroup::LightGroup(&v1[9].Next);
  ObjCollInfo::ObjCollInfo(&v1[15]);
  BoundBox::BoundBox(&v1[19].Parent);
  RouteGroup::RouteGroup(&v1[22].name);
  v1->vtblPointer = &BaseShape::`vftable';
  v1->name = "noname";
  v1[2].vtblPointer = 0;
  v1[2].name = 0;
  v1[1].vtblPointer = 0;
  v1[19].name = 0;
  LOBYTE(v1[37].Next) = 1;
  v1[2].Child = 0;
  v1[3].vtblPointer = 0;
  v1[3].name = 0;
  v1[3].Parent = 0;
  v1[3].Next = 0;
  v1[3].Child = 0;
  v1[4].vtblPointer = 0;
  v1[4].name = 0;
  v1[2].Parent = 0;
  v1[2].Next = 0;
  v1[4].Parent = 0;
  v1[4].Next = 0;
  v1[4].Child = 0;
  v1[5].vtblPointer = 0;
  v1[5].name = 0;
  v1[5].Child = 0;
  v1[1].name = 0;
  v1[1].Child = 0;
  CoreNode::initCore((v1 + 124), `string');
  CoreNode::initCore(v1 + 15, `string');
  CoreNode::initCore((v1 + 192), `string');
  CoreNode::initCore((v1 + 444), `string');
  v1[32].Next = 0;
  v1[31].Child = 0;
  v1[32].vtblPointer = 0;
  v1[32].Parent = 0;
  v1[34].Parent = 0;
  v1[34].Next = 0;
  v1[34].Child = 0;
  v1[35].vtblPointer = 0;
  v1[35].name = 0;
  v1[35].Parent = 0;
  v1[35].Next = 0;
  v1[35].Child = 0;
  v1[36].name = 0;
  v1[36].Next = 0;
  v1[36].Child = 0;
  v1[37].name = 0;
  v1[37].vtblPointer = 0;
  v1[37].Parent = 0;
  v1[21].Child = 0;
  v1[22].vtblPointer = 0;
  v1[21].Parent = 0;
  v1[21].Next = 0;
  v1[21].name = 0;
  return v1;
}
// 101ADEA4: using guessed type void *BaseShape::`vftable';

//----- (1002F640) --------------------------------------------------------
void __thiscall BaseShape::countMaterials(BaseShape *this, struct Joint *a2, unsigned __int32 a3)
{
  int l; // [esp+4Ch] [ebp-20h]
  signed int k; // [esp+50h] [ebp-1Ch]
  char v5; // [esp+54h] [ebp-18h]
  _DWORD *v6; // [esp+58h] [ebp-14h]
  int j; // [esp+5Ch] [ebp-10h]
  char v8; // [esp+60h] [ebp-Ch]
  int i; // [esp+64h] [ebp-8h]

  for ( i = 0; i < *(this + 24); ++i )
  {
    if ( *(*(*(this + 25) + 4 * i) + 36) == a2 )
    {
      v8 = 0;
      for ( j = 0; j < dword_101CA368; ++j )
      {
        if ( byte_101C6268[j] == *(*(*(*(this + 25) + 4 * i) + 20) + 20) )
        {
          v8 = 1;
          break;
        }
      }
      if ( !v8 )
      {
        v6 = *(*(*(this + 25) + 4 * i) + 20);
        v5 = 0;
        if ( v6[6] & 1 )
        {
          if ( v6[12] )
            v5 = 1;
          for ( k = 0; k < 3; ++k )
          {
            if ( *(v6[36] + 36 * k + 8) )
              v5 = 1;
          }
          for ( l = 0; l < v6[29]; ++l )
          {
            if ( *(v6[33] + 156 * l + 20) != 255 )
              v5 = 1;
          }
        }
        ++dword_101CA36C;
        if ( v5 )
          byte_101C6268[dword_101CA368++] = *(*(*(*(this + 25) + 4 * i) + 20) + 20);
      }
    }
  }
}
// 101CA368: using guessed type int dword_101CA368;
// 101CA36C: using guessed type int dword_101CA36C;

//----- (1002F860) --------------------------------------------------------
int __thiscall BaseShape::recTraverseMaterials(void *this, int a2, void (__thiscall ***a3)(_DWORD, int, _DWORD))
{
  int result; // eax
  int i; // [esp+4Ch] [ebp-8h]
  void *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  result = a2;
  for ( i = a2; i; i = *(i + 12) )
  {
    (**a3)(a3, i, 0);
    result = i;
    if ( *(i + 16) )
      result = BaseShape::recTraverseMaterials(*(i + 16), a3);
  }
  return result;
}
// 10001D11: using guessed type _DWORD __stdcall BaseShape::recTraverseMaterials(_DWORD, _DWORD);

//----- (1002F900) --------------------------------------------------------
struct ShapeDynMaterials *__thiscall BaseShape::instanceMaterials(BaseShape *this, int a2)
{
  struct ShapeDynMaterials *v3; // [esp+4Ch] [ebp-20h]
  ShapeDynMaterials *hMem; // [esp+50h] [ebp-1Ch]
  BaseShape *v5; // [esp+5Ch] [ebp-10h]

  v5 = this;
  hMem = sub_10002A81(0x10u);
  if ( hMem )
    v3 = ShapeDynMaterials::ShapeDynMaterials(hMem);
  else
    v3 = 0;
  BaseShape::makeInstance(v5, v3, a2);
  return v3;
}

//----- (1002F9D0) --------------------------------------------------------
void __thiscall BaseShape::makeInstance(BaseShape *this, struct ShapeDynMaterials *a2, int a3)
{
  int v3; // eax
  void *v4; // [esp+4Ch] [ebp-48h]
  HGLOBAL v5; // [esp+50h] [ebp-44h]
  PVWTevInfo *v6; // [esp+54h] [ebp-40h]
  HGLOBAL hMem; // [esp+5Ch] [ebp-38h]
  void **Dst; // [esp+70h] [ebp-24h]
  int j; // [esp+74h] [ebp-20h]
  int v10; // [esp+78h] [ebp-1Ch]
  struct Joint *v11; // [esp+7Ch] [ebp-18h]
  signed int i; // [esp+80h] [ebp-14h]
  BaseShape *v13; // [esp+84h] [ebp-10h]

  v13 = this;
  *(a2 + 3) = this;
  for ( i = 0; i < 256; ++i )
    byte_101C6268[i] = 0;
  dword_101CA368 = 0;
  dword_101CA36C = 0;
  v11 = (284 * a3 + *(this + 23));
  BaseShape::countMaterials(this, v11, 0);
  if ( *(v11 + 4) )
  {
    v3 = sub_10001A6E(v13, BaseShape::countMaterials);
    BaseShape::recTraverseMaterials(*(v11 + 4), v3);
  }
  *(a2 + 1) = dword_101CA368;
  v10 = *(a2 + 1);
  hMem = sub_10001AC3(156 * v10);
  if ( hMem )
  {
    sub_1000291E(hMem, 156, v10, Material::Material);
    v5 = hMem;
  }
  else
  {
    v5 = 0;
  }
  *(a2 + 2) = v5;
  for ( j = 0; j < *(a2 + 1); ++j )
  {
    Dst = (156 * j + *(a2 + 2));
    memcpy(Dst, (156 * byte_101C6268[j] + *(v13 + 17)), 0x9Cu);
    if ( Dst[6] & 1 )
    {
      v6 = sub_10002A81(0x84u);
      if ( v6 )
        v4 = PVWTevInfo::PVWTevInfo(v6);
      else
        v4 = 0;
      Dst[36] = v4;
      memcpy(Dst[36], *(*(v13 + 17) + 156 * byte_101C6268[j] + 144), 0x84u);
    }
  }
}
// 10001A6E: using guessed type _DWORD __stdcall sub_10001A6E(_DWORD, _DWORD);
// 10001D11: using guessed type _DWORD __stdcall BaseShape::recTraverseMaterials(_DWORD, _DWORD);
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);
// 101CA368: using guessed type int dword_101CA368;
// 101CA36C: using guessed type int dword_101CA36C;

//----- (1002FCC0) --------------------------------------------------------
void __thiscall BaseShape::drawobjcolls(BaseShape *this, struct Graphics *a2, struct Camera *a3)
{
  struct CoreNode *v3; // eax

  v3 = CoreNode::Child(this + 15);
  sub_1002FD20(a2, v3);
}

//----- (1002FD20) --------------------------------------------------------
struct CoreNode *__cdecl sub_1002FD20(struct Graphics *a1, int a2)
{
  struct CoreNode *result; // eax
  struct CoreNode *v3; // eax
  CoreNode *i; // [esp+4Ch] [ebp-4h]

  result = a2;
  for ( i = a2; i; i = i->Next )
  {
    if ( i[2].name )
      ObjCollInfo::showInfo(i, a1, *(a1 + 4));
    result = CoreNode::Child(i);
    if ( result )
    {
      v3 = CoreNode::Child(i);
      result = sub_1002FD20(a1, v3);
    }
  }
  return result;
}

//----- (1002FDC0) --------------------------------------------------------
void __thiscall BaseShape::drawlights(BaseShape *this, struct Graphics *a2, struct Camera *a3)
{
  LightGroup *i; // [esp+4Ch] [ebp-Ch]
  struct Matrix4f *v4; // [esp+50h] [ebp-8h]
  BaseShape *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  v4 = *(a2 + 4);
  if ( CoreNode::Child((this + 192)) )
  {
    for ( i = CoreNode::Child((v5 + 192)); i; i = *(i + 3) )
      LightGroup::refresh(i, a2, v4);
  }
}

//----- (1002FE60) --------------------------------------------------------
void __thiscall BaseShape::drawroutes(BaseShape *this, struct Graphics *a2, struct Camera *a3)
{
  RouteGroup *i; // [esp+4Ch] [ebp-8h]
  BaseShape *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  for ( i = *(this + 115); i; i = *(i + 3) )
  {
    (*(*a2 + 108))(a2, a3 + 480, 0);
    RouteGroup::refresh(i, a2, i);
  }
}

//----- (1002FF00) --------------------------------------------------------
void __thiscall BaseShape::drawculled(BaseShape *this, struct Graphics *a2, struct Camera *a3, struct ShapeDynMaterials *a4)
{
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  float v9; // [esp+4Ch] [ebp-150h]
  float v10; // [esp+50h] [ebp-14Ch]
  float v11; // [esp+54h] [ebp-148h]
  char v12; // [esp+58h] [ebp-144h]
  char v13; // [esp+5Ch] [ebp-140h]
  char Dest; // [esp+60h] [ebp-13Ch]
  char v15; // [esp+160h] [ebp-3Ch]
  int v16; // [esp+16Ch] [ebp-30h]
  char v17; // [esp+170h] [ebp-2Ch]
  struct BoundBox *v18; // [esp+174h] [ebp-28h]
  char v19; // [esp+178h] [ebp-24h]
  int l; // [esp+17Ch] [ebp-20h]
  int k; // [esp+180h] [ebp-1Ch]
  struct BoundBox *v22; // [esp+184h] [ebp-18h]
  int j; // [esp+188h] [ebp-14h]
  ShapeDynMaterials *i; // [esp+18Ch] [ebp-10h]
  int v25; // [esp+190h] [ebp-Ch]
  int v26; // [esp+194h] [ebp-8h]
  BaseShape *v27; // [esp+198h] [ebp-4h]

  v27 = this;
  v26 = *(a2 + 4);
  (*(*a2 + 116))(a2, this);
  v25 = 0;
  if ( a4 )
  {
    for ( i = a4; i; i = *i )
      ShapeDynMaterials::updateContext(i);
  }
  for ( j = 0; j < *(v27 + 22); ++j )
  {
    v22 = (*(v27 + 23) + 284 * j + 204);
    if ( CullFrustum::isBoundVisible(a3, v22, 32831) )
    {
      for ( k = *(v27 + 24) - 1; k >= 0; --k )
      {
        if ( *(*(*(v27 + 25) + 4 * k) + 36) == 284 * j + *(v27 + 23) )
          (*(*a2 + 120))(a2, v27, *(*(v27 + 25) + 4 * k));
      }
    }
    else
    {
      ++v25;
      *(*(v27 + 23) + 284 * j + 276) = -1;
    }
  }
  if ( *(gsys + 9) )
  {
    for ( l = 0; l < *(v27 + 22); ++l )
    {
      (*(*a2 + 108))(a2, *(a2 + 186) + 480, 0);
      (*(*a2 + 196))(a2, 0, 0);
      v4 = Colour::Colour(&v13, 255, 32, 32, 0xFFu);
      (*(*a2 + 160))(a2, v4, 1);
      v19 = (*(*a2 + 40))(a2, 0, 0);
      BoundBox::draw((*(v27 + 23) + 284 * l + 204), a2);
      LOBYTE(v5) = v19;
      (*(*a2 + 40))(a2, v5, 0);
      (*(*a2 + 108))(a2, v26, 0);
      v18 = (*(v27 + 23) + 284 * l + 204);
      if ( CullFrustum::isBoundVisible(a3, v18, 32831) )
      {
        v17 = (*(*a2 + 40))(a2, 0, 0);
        (*(*a2 + 108))(a2, &Matrix4f::ident, 0);
        v6 = Colour::Colour(&v12, 255, 255, 255, 0xFFu);
        (*(*a2 + 160))(a2, v6, 1);
        v16 = (*(*a2 + 88))(a2, 0);
        v11 = (*(v18 + 5) + *(v18 + 2)) * 0.5;
        v10 = (*(v18 + 4) + *(v18 + 1)) * 0.5 + 10.0;
        v9 = (*(v18 + 3) + *v18) * 0.5;
        Vector3f::Vector3f(&v15, &v9, &v10, &v11);
        Vector3f::multMatrix(&v15, (*(a2 + 186) + 480));
        sprintf(&Dest, "%d", *(*(v27 + 23) + 284 * l + 276));
        v7 = Font::stringWidth(*(gsys + 5), &Dest);
        (*(*a2 + 232))(a2, *(gsys + 5), &v15, v7 / -2, 0, &Dest);
        (*(*a2 + 88))(a2, v16);
        LOBYTE(v8) = v17;
        (*(*a2 + 40))(a2, v8, 0);
      }
    }
  }
}

//----- (100304A0) --------------------------------------------------------
void __thiscall BaseShape::drawshape(BaseShape *this, struct Graphics *a2, struct Camera *a3, struct ShapeDynMaterials *a4)
{
  int v4; // ecx
  int v5; // [esp+4Ch] [ebp-10h]
  ShapeDynMaterials *i; // [esp+50h] [ebp-Ch]
  int v7; // [esp+54h] [ebp-8h]
  struct BaseShape *v8; // [esp+58h] [ebp-4h]

  v8 = this;
  Timers::start(*(gsys + 14), "drawShape", 1);
  v7 = *(a2 + 2);
  if ( *(v8 + 20) )
  {
    if ( !(*(v8 + 5) & 4) && *(v8 + 5) & 2 && *(a2 + 2) & 0x400 )
    {
      Graphics::cacheShape(a2, v8, a4);
      v4 = *(a2 + 2);
      BYTE1(v4) &= 0xFBu;
      *(a2 + 2) = v4;
    }
    if ( *(v8 + 5) & 4 || *(a2 + 2) & 0x8300 )
    {
      if ( a4 )
      {
        for ( i = a4; i; i = *i )
          ShapeDynMaterials::updateContext(i);
      }
      v5 = *(a2 + 4);
      (*(*a2 + 124))(a2, a3, v8);
      (*(*a2 + 108))(a2, v5, 0);
      BaseShape::drawlights(v8, a2, a3);
      if ( *(gsys + 9) && *(a2 + 2) & 0x400 )
      {
        (*(*a2 + 108))(a2, *(a2 + 186) + 480, 0);
        BaseShape::drawroutes(v8, a2, a3);
      }
    }
  }
  *(a2 + 2) = v7;
  Timers::stop(*(gsys + 14), "drawShape");
}

//----- (100306B0) --------------------------------------------------------
void __thiscall BaseShape::resolveTextureNames(BaseShape *this)
{
  struct Texture *v1; // eax
  struct Texture *v2; // eax
  int v3; // ST0C_4
  char v4; // [esp+0h] [ebp-19Ch]
  HGLOBAL v5; // [esp+4Ch] [ebp-150h]
  HGLOBAL v6; // [esp+50h] [ebp-14Ch]
  int v7; // [esp+54h] [ebp-148h]
  HGLOBAL v8; // [esp+58h] [ebp-144h]
  HGLOBAL v9; // [esp+5Ch] [ebp-140h]
  HGLOBAL hMem; // [esp+60h] [ebp-13Ch]
  HGLOBAL v11; // [esp+64h] [ebp-138h]
  int l; // [esp+68h] [ebp-134h]
  int k; // [esp+6Ch] [ebp-130h]
  int v14; // [esp+70h] [ebp-12Ch]
  _DWORD *v15; // [esp+74h] [ebp-128h]
  int j; // [esp+78h] [ebp-124h]
  int v17; // [esp+7Ch] [ebp-120h]
  int v18; // [esp+80h] [ebp-11Ch]
  char Dest; // [esp+84h] [ebp-118h]
  char v20[4]; // [esp+184h] [ebp-18h]
  int i; // [esp+188h] [ebp-14h]
  BaseShape *v22; // [esp+18Ch] [ebp-10h]
  int v23; // [esp+198h] [ebp-4h]

  v22 = this;
  if ( *(this + 187) )
  {
    for ( i = 0; i < *(v22 + 186); ++i )
    {
      *v20 = 32 * i + *(v22 + 187);
      sprintf(&Dest, "%s%s", *(gsys + 126), *v20);
      v1 = StdSystem::loadTexture(gsys, &Dest, 1);
      *(*(v22 + 185) + 4 * i) = v1;
      if ( !*(*(v22 + 185) + 4 * i) )
      {
        sprintf(&Dest, "%s%s", *(gsys + 125), *v20);
        v2 = StdSystem::loadTexture(gsys, &Dest, 1);
        *(*(v22 + 185) + 4 * i) = v2;
      }
      if ( !*(*(v22 + 185) + 4 * i) )
        sub_10025E40("Could not load texture %s\n", v20[0]);
    }
  }
  if ( *(v22 + 184) || *(v22 + 186) )
  {
    v3 = *(v22 + 186);
    sub_10025E40("making tmp attrlist and materials : %d : %d\n", *(v22 + 184));
    if ( *(v22 + 184) )
      v7 = *(v22 + 184);
    else
      v7 = *(v22 + 186);
    v18 = v7;
    v17 = v7;
    hMem = sub_10001AC3(52 * v7);
    v23 = 0;
    if ( hMem )
    {
      sub_1000291E(hMem, 52, v17, TexAttr::TexAttr);
      v6 = hMem;
    }
    else
    {
      v6 = 0;
    }
    v11 = v6;
    v23 = -1;
    *(v22 + 27) = v6;
    for ( j = 0; j < v18; ++j )
    {
      *(*(v22 + 27) + 52 * j + 20) = j;
      *(*(v22 + 27) + 52 * j + 24) = ((*(v22 + 186) != 0) | j) != 0 ? 0x8000 : 0;
      *(*(v22 + 27) + 52 * j + 44) = *(*(v22 + 185) + 4 * j);
    }
    v14 = v18;
    v8 = sub_10001AC3(156 * v18);
    v23 = 1;
    if ( v8 )
    {
      sub_1000291E(v8, 156, v14, Material::Material);
      v5 = v8;
    }
    else
    {
      v5 = 0;
    }
    v9 = v5;
    v23 = -1;
    v15 = v5;
    if ( *(v22 + 16) == v18 )
    {
      sub_10025E40("ALREADY HAS CORRECT NUMBER OF MATERIALS!!!!\n", v4);
      for ( k = 0; k < v18; ++k )
        Material::operator=(156 * k + *(v22 + 17));
    }
    *(v22 + 16) = v18;
    for ( l = 0; l < v18; ++l )
    {
      v15[39 * l + 5] = l;
      v15[39 * l + 7] = l;
    }
    *(v22 + 17) = v15;
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);
// 10002A77: using guessed type _DWORD __stdcall Material::operator=(_DWORD);

//----- (10030C70) --------------------------------------------------------
void __thiscall BaseShape::skipChunk(BaseShape *this, struct RandomAccessStream *a2, unsigned __int32 a3)
{
  unsigned __int32 i; // [esp+4Ch] [ebp-Ch]
  char v4; // [esp+50h] [ebp-8h]
  BaseShape *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  for ( i = 0; i < a3; ++i )
    v4 = (*(*a2 + 4))(a2);
}

//----- (10030CF0) --------------------------------------------------------
void __thiscall BaseShape::recAddMatpoly(BaseShape *this, struct Joint *a2, int a3)
{
  int v3; // [esp+4Ch] [ebp-10h]
  _DWORD *j; // [esp+50h] [ebp-Ch]
  struct Joint *i; // [esp+54h] [ebp-8h]
  BaseShape *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  for ( i = a2; i; i = *(i + 3) )
  {
    if ( *(i + 4) )
      BaseShape::recAddMatpoly(v6, *(i + 4), a3);
    for ( j = *(i + 61); j; j = j[3] )
    {
      v3 = 156 * j[7] + *(v6 + 17);
      if ( a3 & (*(v3 + 24) >> 8) )
      {
        j[5] = v3;
        j[6] = 48 * j[8] + *(v6 + 21);
        *(*(v6 + 25) + 4 * dword_101CA370++) = j;
      }
    }
  }
}
// 101CA370: using guessed type int dword_101CA370;

//----- (10030E20) --------------------------------------------------------
void __userpurge BaseShape::read(BaseShape *this@<ecx>, double a2@<st0>, struct RandomAccessStream *a3)
{
  int v3; // eax
  AyuStack *v4; // eax
  int v5; // eax
  AyuStack *v6; // eax
  AyuStack *v7; // eax
  int v8; // eax
  AyuStack *v9; // eax
  AyuStack *v10; // eax
  int v11; // eax
  AyuStack *v12; // eax
  AyuStack *v13; // eax
  int v14; // eax
  AyuStack *v15; // eax
  AyuStack *v16; // eax
  int v17; // eax
  AyuStack *v18; // eax
  AyuStack *v19; // eax
  int v20; // eax
  AyuStack *v21; // eax
  AyuStack *v22; // eax
  int v23; // eax
  AyuStack *v24; // eax
  AyuStack *v25; // eax
  int v26; // eax
  int v27; // eax
  AyuStack *v28; // eax
  AyuStack *v29; // eax
  int v30; // eax
  AyuStack *v31; // eax
  AyuStack *v32; // eax
  int v33; // eax
  AyuStack *v34; // eax
  AyuStack *v35; // eax
  int v36; // eax
  AyuStack *v37; // eax
  AyuStack *v38; // eax
  int v39; // eax
  AyuStack *v40; // eax
  AyuStack *v41; // eax
  int v42; // eax
  AyuStack *v43; // eax
  int v44; // eax
  int v45; // eax
  AyuStack *v46; // eax
  AyuStack *v47; // eax
  int v48; // eax
  int v49; // eax
  __int16 v50; // ax
  __int16 v51; // ax
  char v52; // al
  struct Vector3f *v53; // eax
  struct Vector3f *v54; // eax
  double v55; // ST04_8
  AyuStack *v56; // eax
  int v57; // eax
  double v58; // ST0C_8
  __int64 v59; // [esp+5Ch] [ebp-240h]
  int v60; // [esp+64h] [ebp-238h]
  HGLOBAL v61; // [esp+68h] [ebp-234h]
  HGLOBAL v62; // [esp+6Ch] [ebp-230h]
  HGLOBAL v63; // [esp+70h] [ebp-22Ch]
  HGLOBAL v64; // [esp+74h] [ebp-228h]
  HGLOBAL v65; // [esp+78h] [ebp-224h]
  _DWORD *v66; // [esp+7Ch] [ebp-220h]
  HGLOBAL v67; // [esp+80h] [ebp-21Ch]
  HGLOBAL v68; // [esp+84h] [ebp-218h]
  HGLOBAL v69; // [esp+88h] [ebp-214h]
  HGLOBAL v70; // [esp+8Ch] [ebp-210h]
  int v71; // [esp+90h] [ebp-20Ch]
  unsigned int v72; // [esp+94h] [ebp-208h]
  float v73; // [esp+98h] [ebp-204h]
  float v74; // [esp+9Ch] [ebp-200h]
  float v75; // [esp+A0h] [ebp-1FCh]
  char v76; // [esp+A4h] [ebp-1F8h]
  float v77; // [esp+B0h] [ebp-1ECh]
  float v78; // [esp+B4h] [ebp-1E8h]
  float v79; // [esp+B8h] [ebp-1E4h]
  char v80; // [esp+BCh] [ebp-1E0h]
  HGLOBAL v81; // [esp+C8h] [ebp-1D4h]
  int v82; // [esp+CCh] [ebp-1D0h]
  int v83; // [esp+D0h] [ebp-1CCh]
  int v84; // [esp+D4h] [ebp-1C8h]
  HGLOBAL v85; // [esp+D8h] [ebp-1C4h]
  HGLOBAL v86; // [esp+DCh] [ebp-1C0h]
  int v87; // [esp+E0h] [ebp-1BCh]
  HGLOBAL v88; // [esp+E4h] [ebp-1B8h]
  HGLOBAL v89; // [esp+E8h] [ebp-1B4h]
  int v90; // [esp+ECh] [ebp-1B0h]
  int v91; // [esp+F0h] [ebp-1ACh]
  HGLOBAL v92; // [esp+F4h] [ebp-1A8h]
  HGLOBAL v93; // [esp+F8h] [ebp-1A4h]
  HGLOBAL v94; // [esp+FCh] [ebp-1A0h]
  HGLOBAL v95; // [esp+100h] [ebp-19Ch]
  HGLOBAL v96; // [esp+104h] [ebp-198h]
  HGLOBAL v97; // [esp+108h] [ebp-194h]
  int v98; // [esp+10Ch] [ebp-190h]
  HGLOBAL v99; // [esp+110h] [ebp-18Ch]
  _DWORD *v100; // [esp+114h] [ebp-188h]
  HGLOBAL v101; // [esp+118h] [ebp-184h]
  HGLOBAL v102; // [esp+11Ch] [ebp-180h]
  HGLOBAL v103; // [esp+120h] [ebp-17Ch]
  HGLOBAL v104; // [esp+124h] [ebp-178h]
  HGLOBAL v105; // [esp+128h] [ebp-174h]
  HGLOBAL v106; // [esp+12Ch] [ebp-170h]
  HGLOBAL hMem; // [esp+130h] [ebp-16Ch]
  HGLOBAL v108; // [esp+134h] [ebp-168h]
  int v109; // [esp+138h] [ebp-164h]
  int v110; // [esp+13Ch] [ebp-160h]
  int v111; // [esp+140h] [ebp-15Ch]
  int v112; // [esp+144h] [ebp-158h]
  int v113; // [esp+148h] [ebp-154h]
  float v114; // [esp+14Ch] [ebp-150h]
  _DWORD *v115; // [esp+150h] [ebp-14Ch]
  int i5; // [esp+154h] [ebp-148h]
  char v117; // [esp+158h] [ebp-144h]
  float v118; // [esp+170h] [ebp-12Ch]
  float v119; // [esp+174h] [ebp-128h]
  float v120; // [esp+178h] [ebp-124h]
  float v121; // [esp+17Ch] [ebp-120h]
  int v122; // [esp+180h] [ebp-11Ch]
  int i4; // [esp+184h] [ebp-118h]
  int i3; // [esp+188h] [ebp-114h]
  float v125; // [esp+18Ch] [ebp-110h]
  int v126; // [esp+190h] [ebp-10Ch]
  int v127; // [esp+194h] [ebp-108h]
  int i2; // [esp+198h] [ebp-104h]
  int v129; // [esp+19Ch] [ebp-100h]
  int i1; // [esp+1A0h] [ebp-FCh]
  int nn; // [esp+1A4h] [ebp-F8h]
  int v132; // [esp+1A8h] [ebp-F4h]
  _WORD *v133; // [esp+1ACh] [ebp-F0h]
  char v134[4]; // [esp+1B0h] [ebp-ECh]
  int v135; // [esp+1B4h] [ebp-E8h]
  int v136; // [esp+1B8h] [ebp-E4h]
  int mm; // [esp+1BCh] [ebp-E0h]
  int v138; // [esp+1C0h] [ebp-DCh]
  int ll; // [esp+1C4h] [ebp-D8h]
  int v140; // [esp+1C8h] [ebp-D4h]
  char v141; // [esp+1CCh] [ebp-D0h]
  char *v142; // [esp+1D0h] [ebp-CCh]
  int kk; // [esp+1D4h] [ebp-C8h]
  int v144; // [esp+1D8h] [ebp-C4h]
  int jj; // [esp+1DCh] [ebp-C0h]
  int ii; // [esp+1E0h] [ebp-BCh]
  int n; // [esp+1E4h] [ebp-B8h]
  int m; // [esp+1E8h] [ebp-B4h]
  int l; // [esp+1ECh] [ebp-B0h]
  int v150; // [esp+1F0h] [ebp-ACh]
  int v151; // [esp+1F4h] [ebp-A8h]
  int k; // [esp+1F8h] [ebp-A4h]
  int v153; // [esp+1FCh] [ebp-A0h]
  int v154; // [esp+200h] [ebp-9Ch]
  int j; // [esp+204h] [ebp-98h]
  int v156; // [esp+208h] [ebp-94h]
  int v157; // [esp+20Ch] [ebp-90h]
  int i; // [esp+210h] [ebp-8Ch]
  int v159; // [esp+214h] [ebp-88h]
  struct GfxobjInfo *v160; // [esp+218h] [ebp-84h]
  int i7; // [esp+21Ch] [ebp-80h]
  int v162; // [esp+220h] [ebp-7Ch]
  int i6; // [esp+224h] [ebp-78h]
  int v164; // [esp+228h] [ebp-74h]
  int v165; // [esp+22Ch] [ebp-70h]
  int i14; // [esp+230h] [ebp-6Ch]
  int v167; // [esp+234h] [ebp-68h]
  int v168; // [esp+238h] [ebp-64h]
  int i13; // [esp+23Ch] [ebp-60h]
  int v170; // [esp+240h] [ebp-5Ch]
  int v171; // [esp+244h] [ebp-58h]
  int i12; // [esp+248h] [ebp-54h]
  int v173; // [esp+24Ch] [ebp-50h]
  unsigned int v174; // [esp+250h] [ebp-4Ch]
  int v175; // [esp+254h] [ebp-48h]
  int i11; // [esp+258h] [ebp-44h]
  int v177; // [esp+25Ch] [ebp-40h]
  int i10; // [esp+260h] [ebp-3Ch]
  int v179; // [esp+264h] [ebp-38h]
  int i9; // [esp+268h] [ebp-34h]
  int v181; // [esp+26Ch] [ebp-30h]
  int i8; // [esp+270h] [ebp-2Ch]
  int v183; // [esp+274h] [ebp-28h]
  int v184; // [esp+278h] [ebp-24h]
  unsigned __int32 v185; // [esp+27Ch] [ebp-20h]
  unsigned int v186; // [esp+280h] [ebp-1Ch]
  char v187[4]; // [esp+284h] [ebp-18h]
  int v188; // [esp+288h] [ebp-14h]
  BaseShape *v189; // [esp+28Ch] [ebp-10h]
  int v190; // [esp+298h] [ebp-4h]

  v189 = this;
  v188 = 0;
  do
  {
    *v187 = (*(*a3 + 80))(a3);
    v186 = (**a3)(a3);
    v185 = (**a3)(a3);
    if ( v187[0] & 0x1F )
      sub_1002A170("chunk start not on boundary %08x!\n", *v187);
    v72 = v186;
    if ( v186 > 0x30 )
    {
      v72 -= 64;
      switch ( v72 )
      {
        case 0u:
          v29 = StdSystem::getHeap(gsys, 2);
          v159 = AyuStack::getFree(v29);
          v30 = (**a3)(a3);
          *(v189 + 14) = v30;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v98 = sub_10001AC3(8 * *(v189 + 14));
          *(v189 + 15) = v98;
          for ( i = 0; i < *(v189 + 14); ++i )
            VtxMatrix::read((*(v189 + 15) + 8 * i), a3);
          v31 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v31);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 1u:
          v32 = StdSystem::getHeap(gsys, 2);
          v157 = AyuStack::getFree(v32);
          v33 = (**a3)(a3);
          *(v189 + 12) = v33;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v156 = *(v189 + 12);
          v96 = sub_10001AC3(12 * v156);
          v190 = 5;
          if ( v96 )
          {
            sub_1000291E(v96, 12, v156, Envelope::Envelope);
            v65 = v96;
          }
          else
          {
            v65 = 0;
          }
          v97 = v65;
          v190 = -1;
          *(v189 + 13) = v65;
          for ( j = 0; j < *(v189 + 12); ++j )
            Envelope::read((12 * j + *(v189 + 13)), a3);
          v34 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v34);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0x10u:
          v35 = StdSystem::getHeap(gsys, 2);
          v154 = AyuStack::getFree(v35);
          v36 = (**a3)(a3);
          *(v189 + 20) = v36;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v153 = *(v189 + 20);
          v94 = sub_10001AC3(48 * v153);
          v190 = 6;
          if ( v94 )
          {
            sub_1000291E(v94, 48, v153, Mesh::Mesh);
            v64 = v94;
          }
          else
          {
            v64 = 0;
          }
          v95 = v64;
          v190 = -1;
          *(v189 + 21) = v64;
          for ( k = 0; k < *(v189 + 20); ++k )
            (*(*(*(v189 + 21) + 48 * k) + 16))(48 * k + *(v189 + 21), a3);
          v37 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v37);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0x20u:
          v38 = StdSystem::getHeap(gsys, 2);
          v151 = AyuStack::getFree(v38);
          v39 = (**a3)(a3);
          *(v189 + 22) = v39;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v150 = *(v189 + 22);
          v92 = sub_10001AC3(284 * v150);
          v190 = 7;
          if ( v92 )
          {
            sub_1000291E(v92, 284, v150, Joint::Joint);
            v63 = v92;
          }
          else
          {
            v63 = 0;
          }
          v93 = v63;
          v190 = -1;
          *(v189 + 23) = v63;
          for ( l = 0; l < *(v189 + 20); ++l )
          {
            if ( *(*(v189 + 21) + 48 * l + 24) != -1 )
              *(*(v189 + 21) + 48 * l + 40) = 284 * *(*(v189 + 21) + 48 * l + 24) + *(v189 + 23);
          }
          for ( m = 0; m < *(v189 + 22); ++m )
          {
            *(*(v189 + 23) + 284 * m + 280) = v189;
            (*(*(*(v189 + 23) + 284 * m) + 16))(284 * m + *(v189 + 23), a3);
            BoundBox::expandBound((v189 + 388), (*(v189 + 23) + 284 * m + 204));
          }
          RandomAccessStream::skipPadding(a3, 0x20u);
          *(v189 + 24) = 0;
          for ( n = 0; n < *(v189 + 22); ++n )
            *(v189 + 24) += *(*(v189 + 23) + 284 * n + 272);
          v91 = sub_10001AC3(4 * *(v189 + 24));
          *(v189 + 25) = v91;
          for ( ii = 0; ii < *(v189 + 22); ++ii )
          {
            *(*(v189 + 23) + 284 * ii + 20) = ii;
            if ( *(*(v189 + 23) + 284 * ii + 24) != -1 )
              CoreNode::add((284 * *(*(v189 + 23) + 284 * ii + 24) + *(v189 + 23)), (284 * ii + *(v189 + 23)));
          }
          dword_101CA370 = 0;
          BaseShape::recAddMatpoly(v189, *(v189 + 23), 4);
          BaseShape::recAddMatpoly(v189, *(v189 + 23), 2);
          BaseShape::recAddMatpoly(v189, *(v189 + 23), 1);
          for ( jj = 0; jj < *(v189 + 24); ++jj )
            *(*(*(v189 + 25) + 4 * jj) + 36) = *(*(*(*(v189 + 25) + 4 * jj) + 24) + 40);
          v40 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v40);
          break;
        case 0x21u:
          v41 = StdSystem::getHeap(gsys, 2);
          v144 = AyuStack::getFree(v41);
          v42 = (**a3)(a3);
          *(v189 + 22) = v42;
          RandomAccessStream::skipPadding(a3, 0x20u);
          for ( kk = 0; kk < *(v189 + 22); ++kk )
          {
            String::String(&v141, 0);
            (*(*a3 + 20))(a3, &v141);
            CoreNode::setName((*(v189 + 23) + 284 * kk), v142);
          }
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0xC0u:
          v43 = StdSystem::getHeap(gsys, 2);
          v140 = AyuStack::getFree(v43);
          v44 = (**a3)(a3);
          *(v189 + 107) = v44;
          v45 = (**a3)(a3);
          *(v189 + 109) = v45;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v90 = sub_10001AC3(4 * *(v189 + 109));
          *(v189 + 110) = v90;
          for ( ll = 0; ll < *(v189 + 109); ++ll )
            BaseRoomInfo::read((*(v189 + 110) + 4 * ll), a3);
          RandomAccessStream::skipPadding(a3, 0x20u);
          v138 = *(v189 + 107);
          v88 = sub_10001AC3(100 * v138);
          v190 = 8;
          if ( v88 )
          {
            sub_1000291E(v88, 100, v138, CollTriInfo::CollTriInfo);
            v62 = v88;
          }
          else
          {
            v62 = 0;
          }
          v89 = v62;
          v190 = -1;
          *(v189 + 108) = v62;
          for ( mm = 0; mm < *(v189 + 107); ++mm )
          {
            BaseCollTriInfo::read((100 * mm + *(v189 + 108)), a3);
            CollTriInfo::init((100 * mm + *(v189 + 108)), *(v189 + 110), *(v189 + 160));
          }
          v46 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v46);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0xD0u:
          v47 = StdSystem::getHeap(gsys, 2);
          v136 = AyuStack::getFree(v47);
          RandomAccessStream::skipPadding(a3, 0x20u);
          BoundBox::read((v189 + 388), a3);
          (*(*a3 + 12))(a3);
          *(v189 + 103) = a2;
          v48 = (**a3)(a3);
          *(v189 + 104) = v48;
          v49 = (**a3)(a3);
          *(v189 + 105) = v49;
          v87 = sub_10001AC3(4 * *(v189 + 105) * *(v189 + 104));
          *(v189 + 106) = v87;
          v135 = (**a3)(a3);
          *v134 = 0;
          v132 = v135;
          v85 = sub_10001AC3(36 * v135);
          v190 = 9;
          if ( v85 )
          {
            sub_1000291E(v85, 36, v132, CollGroup::CollGroup);
            v61 = v85;
          }
          else
          {
            v61 = 0;
          }
          v86 = v61;
          v190 = -1;
          v133 = v61;
          for ( nn = 0; nn < v135; ++nn )
          {
            v50 = (*(*a3 + 8))(a3);
            v133[18 * nn + 3] = v50;
            v51 = (*(*a3 + 8))(a3);
            v133[18 * nn + 2] = v51;
            v84 = sub_10001AC3(4 * v133[18 * nn + 2]);
            *&v133[18 * nn + 4] = v84;
            if ( v133[18 * nn + 2] > *v134 )
              *v134 = v133[18 * nn + 2];
            for ( i1 = 0; i1 < v133[18 * nn + 2]; ++i1 )
            {
              v129 = (**a3)(a3);
              *(*&v133[18 * nn + 4] + 4 * i1) = 100 * v129 + *(v189 + 108);
            }
            if ( v133[18 * nn + 3] )
            {
              v83 = sub_10001AC3(v133[18 * nn + 3]);
              *&v133[18 * nn + 6] = v83;
              for ( i2 = 0; i2 < v133[18 * nn + 3]; ++i2 )
              {
                v52 = (*(*a3 + 4))(a3);
                *(*&v133[18 * nn + 6] + i2) = v52;
              }
            }
          }
          sub_10025E40("got a max of %d col tris in one block!\n", v134[0]);
          v81 = sub_10002A81(0x24u);
          v190 = 10;
          if ( v81 )
            v60 = CollGroup::CollGroup(v81);
          else
            v60 = 0;
          v82 = v60;
          v190 = -1;
          v127 = v60;
          *(v60 + 4) = 0;
          *(v127 + 8) = 0;
          v126 = 0;
          v125 = 0.0;
          for ( i3 = 0; i3 < *(v189 + 105); ++i3 )
          {
            for ( i4 = 0; i4 < *(v189 + 104); ++i4 )
            {
              v122 = (**a3)(a3);
              if ( v122 == -1 )
              {
                *(*(v189 + 106) + 4 * (i4 + *(v189 + 104) * i3)) = v127;
              }
              else
              {
                *(*(v189 + 106) + 4 * (i4 + *(v189 + 104) * i3)) = &v133[18 * v122];
                v121 = 64.0;
                v120 = i4 * 64.0 + *(v189 + 97);
                v119 = i3 * 64.0 + *(v189 + 99);
                v118 = 64.0 * 1.0;
                BoundBox::BoundBox(&v117);
                v79 = v119 - v118;
                v78 = *(v189 + 98) - v118;
                v77 = v120 - v118;
                v53 = Vector3f::Vector3f(&v80, &v77, &v78, &v79);
                BoundBox::expandBound(&v117, v53);
                v75 = v119 + v121 + v118;
                v74 = v118 + *(v189 + 101);
                v73 = v120 + v121 + v118;
                v54 = Vector3f::Vector3f(&v76, &v73, &v74, &v75);
                BoundBox::expandBound(&v117, v54);
                for ( i5 = 0; i5 < v133[18 * v122 + 2]; ++i5 )
                {
                  v115 = *(*&v133[18 * v122 + 4] + 4 * i5);
                  v114 = triRectDistance(
                           (12 * v115[1] + *(v189 + 160)),
                           (12 * v115[2] + *(v189 + 160)),
                           (12 * v115[3] + *(v189 + 160)),
                           &v117,
                           0);
                  if ( v114 >= 0.001 )
                  {
                    ++v126;
                    if ( v114 > v125 )
                      v125 = v114;
                  }
                }
              }
            }
          }
          v55 = v125;
          sub_10025E40("maxDist = %f : got a total of %d col tris in lists mem = %d bytes!\n", SLOBYTE(v55));
          v56 = StdSystem::getHeap(gsys, 2);
          v57 = AyuStack::getFree(v56);
          v59 = (v136 - v57);
          a2 = v59 / 1024.0;
          v58 = a2;
          sub_10025E40("!!!!!!!!!!!!!!!!! COLLGRID USING %.2f kbytes\n", SLOBYTE(v58));
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        default:
LABEL_152:
          BaseShape::skipChunk(v189, a3, v185);
          break;
      }
    }
    else if ( v72 == 48 )
    {
      v25 = StdSystem::getHeap(gsys, 2);
      v165 = AyuStack::getFree(v25);
      v26 = (**a3)(a3);
      *(v189 + 16) = v26;
      v27 = (**a3)(a3);
      *(v189 + 18) = v27;
      RandomAccessStream::skipPadding(a3, 0x20u);
      if ( *(v189 + 18) )
      {
        v164 = *(v189 + 18);
        v103 = sub_10001AC3(132 * v164);
        v190 = 2;
        if ( v103 )
        {
          sub_1000291E(v103, 132, v164, PVWTevInfo::PVWTevInfo);
          v68 = v103;
        }
        else
        {
          v68 = 0;
        }
        v104 = v68;
        v190 = -1;
        *(v189 + 19) = v68;
        for ( i6 = 0; i6 < *(v189 + 18); ++i6 )
          PVWTevInfo::read((*(v189 + 19) + 132 * i6), a3);
      }
      if ( *(v189 + 16) )
      {
        v162 = *(v189 + 16);
        v101 = sub_10001AC3(156 * v162);
        v190 = 3;
        if ( v101 )
        {
          sub_1000291E(v101, 156, v162, Material::Material);
          v67 = v101;
        }
        else
        {
          v67 = 0;
        }
        v102 = v67;
        v190 = -1;
        *(v189 + 17) = v67;
        for ( i7 = 0; i7 < *(v189 + 16); ++i7 )
        {
          *(*(v189 + 17) + 156 * i7 + 20) = i7;
          (*(*(*(v189 + 17) + 156 * i7) + 16))(156 * i7 + *(v189 + 17), a3);
          *(*(v189 + 17) + 156 * i7 + 144) = 132 * *(*(v189 + 17) + 156 * i7 + 140) + *(v189 + 19);
          v99 = sub_10002A81(0x24u);
          v190 = 4;
          if ( v99 )
            v66 = MatobjInfo::MatobjInfo(v99);
          else
            v66 = 0;
          v100 = v66;
          v190 = -1;
          v160 = v66;
          v66[8] = 156 * i7 + *(v189 + 17);
          StdSystem::addGfxObject(gsys, v160);
        }
      }
      v28 = StdSystem::getHeap(gsys, 2);
      AyuStack::getFree(v28);
      RandomAccessStream::skipPadding(a3, 0x20u);
    }
    else
    {
      switch ( v72 )
      {
        case 0u:
          RandomAccessStream::skipPadding(a3, 0x20u);
          v184 = (**a3)(a3);
          v3 = (**a3)(a3);
          *(v189 + 5) = v3;
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0x10u:
          v4 = StdSystem::getHeap(gsys, 2);
          v183 = AyuStack::getFree(v4);
          v5 = (**a3)(a3);
          *(v189 + 159) = v5;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v113 = sub_100011A4(12 * *(v189 + 159), 32);
          *(v189 + 160) = v113;
          for ( i8 = 0; i8 < *(v189 + 159); ++i8 )
            Vector3f::read((*(v189 + 160) + 12 * i8), a3);
          v6 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v6);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0x11u:
          v7 = StdSystem::getHeap(gsys, 2);
          v181 = AyuStack::getFree(v7);
          v8 = (**a3)(a3);
          *(v189 + 180) = v8;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v112 = sub_100011A4(12 * *(v189 + 180), 32);
          *(v189 + 181) = v112;
          for ( i9 = 0; i9 < *(v189 + 180); ++i9 )
            Vector3f::read((*(v189 + 181) + 12 * i9), a3);
          v9 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v9);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0x12u:
          v10 = StdSystem::getHeap(gsys, 2);
          v179 = AyuStack::getFree(v10);
          v11 = (**a3)(a3);
          *(v189 + 182) = v11;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v111 = sub_100011A4(36 * *(v189 + 182), 32);
          *(v189 + 183) = v111;
          for ( i10 = 0; i10 < *(v189 + 182); ++i10 )
          {
            Vector3f::read((*(v189 + 183) + 36 * i10), a3);
            Vector3f::read((12 * (3 * i10 + 1) + *(v189 + 183)), a3);
            Vector3f::read((12 * (3 * i10 + 2) + *(v189 + 183)), a3);
          }
          v12 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v12);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0x13u:
          v13 = StdSystem::getHeap(gsys, 2);
          v177 = AyuStack::getFree(v13);
          v14 = (**a3)(a3);
          *(v189 + 161) = v14;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v110 = sub_100011A4(4 * *(v189 + 161), 32);
          *(v189 + 162) = v110;
          for ( i11 = 0; i11 < *(v189 + 161); ++i11 )
            Colour::read((*(v189 + 162) + 4 * i11), a3);
          v15 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v15);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
          v16 = StdSystem::getHeap(gsys, 2);
          v175 = AyuStack::getFree(v16);
          v174 = v186 - 24;
          v17 = (**a3)(a3);
          *(v189 + v174 + 164) = v17;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v173 = *(v189 + v174 + 164);
          v109 = sub_100011A4(8 * v173, 32);
          if ( v109 )
          {
            sub_1000291E(v109, 8, v173, Vector2f::Vector2f);
            v71 = v109;
          }
          else
          {
            v71 = 0;
          }
          *(v189 + v174 + 172) = v71;
          for ( i12 = 0; i12 < *(v189 + v174 + 164); ++i12 )
            Vector2f::read((*(v189 + v174 + 172) + 8 * i12), a3);
          v18 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v18);
          RandomAccessStream::skipPadding(a3, 0x20u);
          ++*(v189 + 163);
          break;
        case 0x20u:
          v19 = StdSystem::getHeap(gsys, 2);
          v171 = AyuStack::getFree(v19);
          v20 = (**a3)(a3);
          *(v189 + 29) = v20;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v170 = *(v189 + 29);
          hMem = sub_10001AC3(52 * v170);
          v190 = 0;
          if ( hMem )
          {
            sub_1000291E(hMem, 52, v170, TexImg::TexImg);
            v70 = hMem;
          }
          else
          {
            v70 = 0;
          }
          v108 = v70;
          v190 = -1;
          *(v189 + 30) = v70;
          for ( i13 = 0; i13 < *(v189 + 29); ++i13 )
            (*(*(*(v189 + 30) + 52 * i13) + 16))(52 * i13 + *(v189 + 30), a3);
          v21 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v21);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        case 0x22u:
          v22 = StdSystem::getHeap(gsys, 2);
          v168 = AyuStack::getFree(v22);
          v23 = (**a3)(a3);
          *(v189 + 26) = v23;
          RandomAccessStream::skipPadding(a3, 0x20u);
          v167 = *(v189 + 26);
          v105 = sub_10001AC3(52 * v167);
          v190 = 1;
          if ( v105 )
          {
            sub_1000291E(v105, 52, v167, TexAttr::TexAttr);
            v69 = v105;
          }
          else
          {
            v69 = 0;
          }
          v106 = v69;
          v190 = -1;
          *(v189 + 27) = v69;
          for ( i14 = 0; i14 < *(v189 + 26); ++i14 )
            (*(*(*(v189 + 27) + 52 * i14) + 16))(52 * i14 + *(v189 + 27), a3);
          v24 = StdSystem::getHeap(gsys, 2);
          AyuStack::getFree(v24);
          RandomAccessStream::skipPadding(a3, 0x20u);
          break;
        default:
          goto LABEL_152;
      }
    }
  }
  while ( v186 != 0xFFFF );
  if ( (*(*a3 + 60))(a3) )
    BaseShape::importIni(v189, a3);
  *(v189 + 11) = *(v189 + 12) + *(v189 + 22);
}
// 100011A4: using guessed type _DWORD __cdecl sub_100011A4(_DWORD, _DWORD);
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);
// 101CA370: using guessed type int dword_101CA370;

//----- (10033450) --------------------------------------------------------
void __thiscall BaseShape::initIni(BaseShape *this, bool a2)
{
  signed int v2; // eax
  struct Texture *v3; // eax
  struct LFlareGroup *v4; // eax
  CoreNode *v5; // eax
  struct Shape *v6; // eax
  struct Texture *v7; // eax
  struct Texture *v8; // [esp+4Ch] [ebp-2Ch]
  struct Texture *v9; // [esp+50h] [ebp-28h]
  struct CoreNode *m; // [esp+54h] [ebp-24h]
  struct CoreNode *l; // [esp+58h] [ebp-20h]
  CoreNode *k; // [esp+5Ch] [ebp-1Ch]
  int v13; // [esp+60h] [ebp-18h]
  struct Texture *v14; // [esp+64h] [ebp-14h]
  int j; // [esp+68h] [ebp-10h]
  int v16; // [esp+6Ch] [ebp-Ch]
  struct CoreNode *i; // [esp+70h] [ebp-8h]
  BaseShape *v18; // [esp+74h] [ebp-4h]

  v18 = this;
  for ( i = CoreNode::Child((this + 192)); i; i = i->Next )
  {
    if ( i[2].Next )
    {
      v16 = -1;
      if ( i[2].Child )
      {
        for ( j = 0; ; ++j )
        {
          v2 = strlen(i[2].Child);
          if ( j >= v2 )
            break;
          if ( *(&i[2].Child->vtblPointer + j) == 58 )
          {
            sscanf(&i[2].Child->vtblPointer + j + 1, "%d", &v16);
            break;
          }
        }
      }
      if ( v16 == -1 )
      {
        v3 = StdSystem::loadTexture(gsys, i[2].Next, 1);
        i[3].vtblPointer = v3;
      }
      if ( v16 == -1 )
        v9 = 0;
      else
        v9 = (156 * v16 + *(v18 + 17));
      v14 = v9;
      v13 = *(gsys + 102);
      if ( v13 == 4 )
        StdSystem::setHeap(gsys, 2);
      if ( i[3].vtblPointer )
        v8 = i[3].vtblPointer;
      else
        v8 = v14;
      v4 = StdSystem::registerLFlare(gsys, v8);
      i[5].name = v4;
      StdSystem::setHeap(gsys, v13);
      if ( v16 != -1 )
      {
        *(i[5].name + 7) = v14;
        *(i[5].name + 6) = *(v14 + 9);
      }
    }
  }
  for ( k = CoreNode::Child(v18 + 15); k; k = k->Next )
  {
    if ( k[2].name == 2 && a2 )
    {
      v5 = StdSystem::loadShape(gsys, k[3].Child, 1);
      k[3].Next = v5;
      if ( k[3].Next )
        BaseShape::createCollisions(k[3].Next, 32);
      if ( k[4].vtblPointer )
        k[3].Next[1].vtblPointer |= 0x10u;
    }
    for ( l = CoreNode::Child(k); l; l = l->Next )
    {
      if ( l[2].name == 2 && a2 )
      {
        v6 = StdSystem::loadShape(gsys, l[3].Child, 1);
        l[3].Next = v6;
        if ( l[3].Next )
          BaseShape::createCollisions(l[3].Next, 32);
        if ( l[4].vtblPointer )
          l[3].Next[1].vtblPointer |= 0x10u;
      }
    }
  }
  for ( m = CoreNode::Child((v18 + 444)); m; m = m->Next )
  {
    v7 = StdSystem::loadTexture(gsys, "rootRing.txe", 1);
    m[9].Parent = v7;
    HIWORD(m[9].Parent->name) = 257;
  }
}

//----- (10033820) --------------------------------------------------------
void __thiscall BaseShape::initialise(BaseShape *this)
{
  int v1; // ST68_4
  int v2; // [esp+4Ch] [ebp-34h]
  AnimContext *hMem; // [esp+54h] [ebp-2Ch]
  int l; // [esp+5Ch] [ebp-24h]
  int k; // [esp+64h] [ebp-1Ch]
  int j; // [esp+68h] [ebp-18h]
  int i; // [esp+6Ch] [ebp-14h]
  BaseShape *v8; // [esp+70h] [ebp-10h]

  v8 = this;
  for ( i = 0; i < *(v8 + 26); ++i )
  {
    if ( *(*(v8 + 27) + 52 * i + 24) & 0x8000 )
    {
      if ( !*(*(v8 + 27) + 52 * i + 44) )
        *(*(v8 + 27) + 52 * i + 44) = *(*(v8 + 185) + 4 * (*(*(v8 + 27) + 52 * i + 24) & 0x7FFF));
    }
    else
    {
      *(*(v8 + 27) + 52 * i + 48) = 52 * *(*(v8 + 27) + 52 * i + 24) + *(v8 + 30);
      *(*(*(v8 + 27) + 52 * i + 48) + 20) = *(*(v8 + 27) + 52 * i + 24);
      TexAttr::initImage((52 * i + *(v8 + 27)));
    }
  }
  for ( j = 0; j < *(v8 + 16); ++j )
  {
    if ( *(*(v8 + 17) + 156 * j + 24) & 1 )
    {
      for ( k = 0; k < *(*(v8 + 17) + 156 * j + 116); ++k )
      {
        *(*(*(v8 + 17) + 156 * j + 132) + 156 * k + 4) = 52 * *(*(*(v8 + 17) + 156 * j + 132) + 156 * k) + *(v8 + 27);
        *(*(*(v8 + 17) + 156 * j + 132) + 156 * k + 8) = *(*(v8 + 27)
                                                         + 52 * *(*(*(v8 + 17) + 156 * j + 132) + 156 * k)
                                                         + 44);
        v1 = *(*(*(v8 + 17) + 156 * j + 132) + 156 * k + 8);
      }
    }
    else if ( *(*(v8 + 17) + 156 * j + 28) == -1 )
    {
      *(*(v8 + 17) + 156 * j + 36) = 0;
    }
    else
    {
      *(*(v8 + 17) + 156 * j + 32) = 52 * *(*(v8 + 17) + 156 * j + 28) + *(v8 + 27);
      *(*(v8 + 17) + 156 * j + 36) = *(*(v8 + 27) + 52 * *(*(v8 + 17) + 156 * j + 28) + 44);
    }
  }
  hMem = sub_10002A81(0x10u);
  if ( hMem )
    v2 = AnimContext::AnimContext(hMem);
  else
    v2 = 0;
  *(v8 + 6) = v2;
  *(*(v8 + 6) + 4) = 0;
  *(*(v8 + 6) + 8) = 0;
  BaseShape::importDck(v8, 0, 0);
  BaseShape::calcBasePose(v8, &Matrix4f::ident);
  if ( *(v8 + 22) )
  {
    *(v8 + 7) = sub_10001AC3(4 * *(v8 + 22));
    for ( l = 0; l < *(v8 + 22); ++l )
      *(*(v8 + 7) + 4 * l) = *(v8 + 6);
  }
}

//----- (10033CF0) --------------------------------------------------------
void __thiscall BaseShape::createCollisions(BaseShape *this, int a2)
{
  void *v2; // esp
  AyuStack *v3; // eax
  double v4; // st7
  double v5; // st7
  float v6; // ST40_4
  double v7; // st7
  float v8; // ST40_4
  int *v9; // eax
  int *v10; // eax
  double v11; // st7
  float v12; // ST40_4
  double v13; // st7
  float v14; // ST40_4
  int v15; // eax
  int *v16; // eax
  double v17; // st7
  float v18; // ST40_4
  double v19; // st7
  float v20; // ST40_4
  int v21; // eax
  int *v22; // eax
  int v23; // eax
  int *v24; // eax
  int v25; // eax
  int *v26; // eax
  int v27; // ST40_4
  int v28; // ST3C_4
  double v29; // ST34_8
  double v30; // ST2C_8
  double v31; // ST24_8
  double v32; // ST1C_8
  double v33; // ST14_8
  double v34; // ST0C_8
  double v35; // ST04_8
  struct Vector3f *v36; // eax
  struct Vector3f *v37; // eax
  AyuStack *v38; // eax
  int v39; // eax
  double v40; // ST3C_8
  char v41; // [esp+4Ch] [ebp-13ECh]
  __int64 v42; // [esp+8Ch] [ebp-13ACh]
  char *v43; // [esp+94h] [ebp-13A4h]
  int v44; // [esp+98h] [ebp-13A0h]
  float v45; // [esp+9Ch] [ebp-139Ch]
  float v46; // [esp+A0h] [ebp-1398h]
  float v47; // [esp+A4h] [ebp-1394h]
  char v48; // [esp+A8h] [ebp-1390h]
  float v49; // [esp+B4h] [ebp-1384h]
  float v50; // [esp+B8h] [ebp-1380h]
  float v51; // [esp+BCh] [ebp-137Ch]
  char v52; // [esp+C0h] [ebp-1378h]
  HGLOBAL hMem; // [esp+CCh] [ebp-136Ch]
  HGLOBAL v54; // [esp+D0h] [ebp-1368h]
  int v55; // [esp+D4h] [ebp-1364h]
  char v56; // [esp+D8h] [ebp-1360h]
  float v57; // [esp+E4h] [ebp-1354h]
  float v58; // [esp+E8h] [ebp-1350h]
  float v59; // [esp+ECh] [ebp-134Ch]
  char v60; // [esp+F0h] [ebp-1348h]
  char v61; // [esp+FCh] [ebp-133Ch]
  float v62; // [esp+108h] [ebp-1330h]
  float v63; // [esp+10Ch] [ebp-132Ch]
  float v64; // [esp+110h] [ebp-1328h]
  char v65; // [esp+114h] [ebp-1324h]
  char v66; // [esp+120h] [ebp-1318h]
  float v67; // [esp+12Ch] [ebp-130Ch]
  float v68; // [esp+130h] [ebp-1308h]
  float v69; // [esp+134h] [ebp-1304h]
  char v70; // [esp+138h] [ebp-1300h]
  char v71; // [esp+144h] [ebp-12F4h]
  float v72; // [esp+150h] [ebp-12E8h]
  float v73; // [esp+154h] [ebp-12E4h]
  float v74; // [esp+158h] [ebp-12E0h]
  char v75; // [esp+15Ch] [ebp-12DCh]
  char v76; // [esp+168h] [ebp-12D0h]
  char v77; // [esp+174h] [ebp-12C4h]
  float v78; // [esp+180h] [ebp-12B8h]
  float v79; // [esp+184h] [ebp-12B4h]
  float v80; // [esp+188h] [ebp-12B0h]
  float v81; // [esp+18Ch] [ebp-12ACh]
  float v82; // [esp+190h] [ebp-12A8h]
  float v83; // [esp+194h] [ebp-12A4h]
  float v84; // [esp+198h] [ebp-12A0h]
  float v85; // [esp+19Ch] [ebp-129Ch]
  float v86; // [esp+1A0h] [ebp-1298h]
  float v87; // [esp+1A4h] [ebp-1294h]
  float v88; // [esp+1A8h] [ebp-1290h]
  float v89; // [esp+1ACh] [ebp-128Ch]
  float v90; // [esp+1B0h] [ebp-1288h]
  float v91; // [esp+1B4h] [ebp-1284h]
  float v92; // [esp+1B8h] [ebp-1280h]
  float v93; // [esp+1BCh] [ebp-127Ch]
  float v94; // [esp+1C0h] [ebp-1278h]
  float v95; // [esp+1C4h] [ebp-1274h]
  int mm; // [esp+1C8h] [ebp-1270h]
  int v97; // [esp+1CCh] [ebp-126Ch]
  int ll; // [esp+1D0h] [ebp-1268h]
  int v99; // [esp+1D4h] [ebp-1264h]
  int v100; // [esp+1D8h] [ebp-1260h]
  int v101; // [esp+1DCh] [ebp-125Ch]
  int v102; // [esp+1E0h] [ebp-1258h]
  int kk; // [esp+1E4h] [ebp-1254h]
  int v104; // [esp+1E8h] [ebp-1250h]
  char v105; // [esp+1ECh] [ebp-124Ch]
  int jj; // [esp+1F8h] [ebp-1240h]
  int v107; // [esp+1FCh] [ebp-123Ch]
  int v108; // [esp+200h] [ebp-1238h]
  char v109; // [esp+204h] [ebp-1234h]
  int v110; // [esp+288h] [ebp-11B0h]
  int v111; // [esp+28Ch] [ebp-11ACh]
  int v112; // [esp+290h] [ebp-11A8h]
  int v113; // [esp+294h] [ebp-11A4h]
  int v114; // [esp+298h] [ebp-11A0h]
  int v115; // [esp+29Ch] [ebp-119Ch]
  int v116; // [esp+2A0h] [ebp-1198h]
  int v117; // [esp+2A4h] [ebp-1194h]
  int v118; // [esp+2A8h] [ebp-1190h]
  int v119; // [esp+2ACh] [ebp-118Ch]
  int v120; // [esp+2B0h] [ebp-1188h]
  int v121; // [esp+2B4h] [ebp-1184h]
  int v122; // [esp+2B8h] [ebp-1180h]
  int v123; // [esp+2BCh] [ebp-117Ch]
  int v124; // [esp+2C0h] [ebp-1178h]
  int v125; // [esp+2C4h] [ebp-1174h]
  int v126; // [esp+2C8h] [ebp-1170h]
  int v127; // [esp+2CCh] [ebp-116Ch]
  int v128; // [esp+2D0h] [ebp-1168h]
  int v129; // [esp+2D4h] [ebp-1164h]
  int v130; // [esp+2D8h] [ebp-1160h]
  int v131; // [esp+2DCh] [ebp-115Ch]
  int v132; // [esp+2E0h] [ebp-1158h]
  int v133; // [esp+2E4h] [ebp-1154h]
  char *v134; // [esp+2E8h] [ebp-1150h]
  char v135; // [esp+2ECh] [ebp-114Ch]
  int ii; // [esp+304h] [ebp-1134h]
  char v137; // [esp+308h] [ebp-1130h]
  float v138; // [esp+320h] [ebp-1118h]
  float v139; // [esp+324h] [ebp-1114h]
  float v140; // [esp+328h] [ebp-1110h]
  int n; // [esp+32Ch] [ebp-110Ch]
  int m; // [esp+330h] [ebp-1108h]
  char v143[4]; // [esp+334h] [ebp-1104h]
  int v144; // [esp+338h] [ebp-1100h]
  int v145; // [esp+33Ch] [ebp-10FCh]
  int v146[1024]; // [esp+340h] [ebp-10F8h]
  int v147; // [esp+1340h] [ebp-F8h]
  int l; // [esp+1344h] [ebp-F4h]
  int v149; // [esp+1348h] [ebp-F0h]
  char *v150; // [esp+134Ch] [ebp-ECh]
  char v151; // [esp+1350h] [ebp-E8h]
  int k; // [esp+1374h] [ebp-C4h]
  float v153; // [esp+1378h] [ebp-C0h]
  float v154; // [esp+137Ch] [ebp-BCh]
  int v155; // [esp+1380h] [ebp-B8h]
  int v156; // [esp+1384h] [ebp-B4h]
  int v157; // [esp+1388h] [ebp-B0h]
  float v158; // [esp+138Ch] [ebp-ACh]
  float v159; // [esp+1390h] [ebp-A8h]
  int v160; // [esp+1394h] [ebp-A4h]
  float v161; // [esp+1398h] [ebp-A0h]
  float v162; // [esp+139Ch] [ebp-9Ch]
  int v163; // [esp+13A0h] [ebp-98h]
  int v164; // [esp+13A4h] [ebp-94h]
  int v165; // [esp+13A8h] [ebp-90h]
  int v166; // [esp+13ACh] [ebp-8Ch]
  int v167; // [esp+13B0h] [ebp-88h]
  int v168; // [esp+13BCh] [ebp-7Ch]
  int v169; // [esp+13C8h] [ebp-70h]
  int v170; // [esp+13D4h] [ebp-64h]
  float v171; // [esp+13E0h] [ebp-58h]
  float v172; // [esp+13E4h] [ebp-54h]
  float v173; // [esp+13E8h] [ebp-50h]
  int v174; // [esp+13ECh] [ebp-4Ch]
  float v175; // [esp+13F0h] [ebp-48h]
  int v176; // [esp+13F4h] [ebp-44h]
  int v177; // [esp+13F8h] [ebp-40h]
  float v178; // [esp+13FCh] [ebp-3Ch]
  int v179; // [esp+1400h] [ebp-38h]
  int v180; // [esp+1404h] [ebp-34h]
  float v181; // [esp+1408h] [ebp-30h]
  int v182; // [esp+140Ch] [ebp-2Ch]
  int v183; // [esp+1410h] [ebp-28h]
  float v184; // [esp+1414h] [ebp-24h]
  int v185; // [esp+1418h] [ebp-20h]
  int j; // [esp+141Ch] [ebp-1Ch]
  int i; // [esp+1420h] [ebp-18h]
  int v188; // [esp+1424h] [ebp-14h]
  BaseShape *v189; // [esp+1428h] [ebp-10h]
  int v190; // [esp+1434h] [ebp-4h]

  v2 = alloca(5088);
  memset(&v41, 0xCCu, 0x13E0u);
  v189 = this;
  v3 = StdSystem::getHeap(gsys, 2);
  v188 = AyuStack::getFree(v3);
  for ( i = 0; i < *(v189 + 107); ++i )
  {
    for ( j = 0; j < 3; ++j )
    {
      if ( *(100 * i + *(v189 + 108) + 2 * j + 18) < 0 )
      {
        *(100 * i + *(v189 + 108) + 4 * j + 88) = 1065353216;
      }
      else
      {
        sub_1000291E(&v180, 12, 2, Vector3f::Vector3f);
        sub_1000291E(&v174, 12, 2, Vector3f::Vector3f);
        v95 = *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * (j % 3) + 4) + 8)
            - *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * ((j + 1) % 3) + 4) + 8);
        v94 = *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * (j % 3) + 4) + 4)
            - *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * ((j + 1) % 3) + 4) + 4);
        v93 = *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * (j % 3) + 4))
            - *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * ((j + 1) % 3) + 4));
        Vector3f::set(&v180, &v93, &v94, &v95);
        v92 = *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * ((j + 1) % 3) + 4) + 8)
            - *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * (j % 3) + 4) + 8);
        v91 = *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * ((j + 1) % 3) + 4) + 4)
            - *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * (j % 3) + 4) + 4);
        v90 = *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * ((j + 1) % 3) + 4))
            - *(*(v189 + 160) + 12 * *(100 * i + *(v189 + 108) + 4 * (j % 3) + 4));
        Vector3f::set(&v183, &v90, &v91, &v92);
        v174 = v180;
        v175 = v181;
        v176 = v182;
        Vector3f::normalise(&v174);
        Vector3f::CP(&v174, (*(v189 + 108) + 100 * i + 24));
        v177 = v183;
        v178 = v184;
        v179 = v185;
        Vector3f::normalise(&v177);
        Vector3f::CP(&v177, (*(v189 + 108) + 100 * *(100 * i + *(v189 + 108) + 2 * j + 18) + 24));
        v173 = Vector3f::DP(
                 (*(v189 + 108) + 100 * i + 24),
                 (*(v189 + 108) + 100 * *(100 * i + *(v189 + 108) + 2 * j + 18) + 24));
        v4 = Vector3f::DP(&v174, (*(v189 + 108) + 100 * *(100 * i + *(v189 + 108) + 2 * j + 18) + 24));
        v172 = v4;
        sub_10001258(v172);
        v171 = v4;
        if ( v173 < 0.0 )
          v171 = -v171;
        sub_1000291E(&v167, 12, 4, Vector3f::Vector3f);
        v89 = 0.0;
        v5 = v171 + 3.1415927;
        v6 = v5;
        sub_10002D47(v6);
        v88 = v5 * 100.0;
        v7 = v171 + 3.1415927;
        v8 = v7;
        sub_10002635(v8);
        v87 = v7 * 100.0;
        Vector3f::set(&v167, &v87, &v88, &v89);
        v86 = 0.0;
        v85 = 0.0;
        v84 = 0.0;
        Vector3f::set(&v168, &v84, &v85, &v86);
        v83 = 0.0;
        v82 = 0.0;
        v81 = 0.0;
        Vector3f::set(&v169, &v81, &v82, &v83);
        v80 = 0.0;
        v79 = 0.0;
        v78 = 100.0;
        Vector3f::set(&v170, &v78, &v79, &v80);
        v9 = sub_10002E2D(&v77, &v168, &v167);
        v174 = *v9;
        v175 = *(v9 + 1);
        v176 = v9[2];
        Vector3f::normalise(&v174);
        v10 = sub_10002E2D(&v76, &v169, &v170);
        v177 = *v10;
        v178 = *(v10 + 1);
        v179 = v10[2];
        Vector3f::normalise(&v177);
        sub_1000291E(&v155, 12, 4, Vector3f::Vector3f);
        v74 = 0.0;
        v11 = v171 - 1.5707964;
        v12 = v11;
        sub_10002D47(v12);
        v73 = v11;
        v13 = v171 - 1.5707964;
        v14 = v13;
        sub_10002635(v14);
        v72 = v13;
        v15 = Vector3f::Vector3f(&v75, &v72, &v73, &v74);
        v16 = sub_10001A3C(&v71, &v167, v15);
        v155 = *v16;
        v156 = v16[1];
        v157 = v16[2];
        v69 = 0.0;
        v17 = v171 - 1.5707964;
        v18 = v17;
        sub_10002D47(v18);
        v68 = v17;
        v19 = v171 - 1.5707964;
        v20 = v19;
        sub_10002635(v20);
        v67 = v19;
        v21 = Vector3f::Vector3f(&v70, &v67, &v68, &v69);
        v22 = sub_10001A3C(&v66, &v168, v21);
        v158 = *v22;
        v159 = *(v22 + 1);
        v160 = v22[2];
        v64 = 0.0;
        v63 = 1.0;
        v62 = 0.0;
        v23 = Vector3f::Vector3f(&v65, &v62, &v63, &v64);
        v24 = sub_10001A3C(&v61, &v169, v23);
        v161 = *v24;
        v162 = *(v24 + 1);
        v163 = v24[2];
        v59 = 0.0;
        v58 = 1.0;
        v57 = 0.0;
        v25 = Vector3f::Vector3f(&v60, &v57, &v58, &v59);
        v26 = sub_10001A3C(&v56, &v170, v25);
        v164 = *v26;
        v165 = v26[1];
        v166 = v26[2];
        v154 = 0.0;
        v153 = -*&v177 * v175 - -v178 * *&v174;
        if ( v153 != 0.0 )
          v154 = ((v161 - v158) * v178 + (v162 - v159) * -*&v177) / v153;
        *(100 * i + *(v189 + 108) + 4 * j + 88) = v154;
      }
    }
  }
  if ( !*(v189 + 106) )
  {
    BoundBox::resetBound((v189 + 388));
    for ( k = 0; k < *(v189 + 107); ++k )
    {
      BoundBox::expandBound((v189 + 388), (12 * *(*(v189 + 108) + 100 * k + 4) + *(v189 + 160)));
      BoundBox::expandBound((v189 + 388), (12 * *(*(v189 + 108) + 100 * k + 8) + *(v189 + 160)));
      BoundBox::expandBound((v189 + 388), (12 * *(*(v189 + 108) + 100 * k + 12) + *(v189 + 160)));
    }
    CollGroup::CollGroup(&v151);
    *(v189 + 103) = a2;
    *(v189 + 104) = ((*(v189 + 100) - *(v189 + 97) + *(v189 + 103)) / *(v189 + 103));
    *(v189 + 105) = ((*(v189 + 102) - *(v189 + 99) + *(v189 + 103)) / *(v189 + 103));
    v27 = *(v189 + 105);
    v28 = *(v189 + 104);
    v29 = *(v189 + 102);
    v30 = *(v189 + 101);
    v31 = *(v189 + 100);
    v32 = *(v189 + 99);
    v33 = *(v189 + 98);
    v34 = *(v189 + 97);
    v35 = *(v189 + 103);
    sub_10025E40(
      "Gridsize %f : course extents from (%.1f, %.1f, %.1f) - (%.1f, %.1f, %.1f) : grid %d x %d\n",
      SLOBYTE(v35));
    v55 = sub_10001AC3(4 * *(v189 + 105) * *(v189 + 104));
    *(v189 + 106) = v55;
    v149 = *(v189 + 105) * *(v189 + 104);
    hMem = sub_10001AC3(36 * v149);
    v190 = 0;
    if ( hMem )
    {
      sub_1000291E(hMem, 36, v149, CollGroup::CollGroup);
      v43 = hMem;
    }
    else
    {
      v43 = 0;
    }
    v54 = v43;
    v190 = -1;
    v150 = v43;
    for ( l = 0; l < *(v189 + 105) * *(v189 + 104); ++l )
      *(*(v189 + 106) + 4 * l) = &v150[36 * l];
    v147 = 0;
    v145 = 0;
    v144 = 0;
    *v143 = 0;
    for ( m = 0; m < *(v189 + 105); ++m )
    {
      for ( n = 0; n < *(v189 + 104); ++n )
      {
        v140 = n * *(v189 + 103) + *(v189 + 97);
        v139 = m * *(v189 + 103) + *(v189 + 99);
        v138 = *(v189 + 103) * 1.0;
        BoundBox::BoundBox(&v137);
        v51 = v139 - v138;
        v50 = *(v189 + 98) - v138;
        v49 = v140 - v138;
        v36 = Vector3f::Vector3f(&v52, &v49, &v50, &v51);
        BoundBox::expandBound(&v137, v36);
        v47 = v139 + *(v189 + 103) + v138;
        v46 = v138 + *(v189 + 101);
        v45 = v140 + *(v189 + 103) + v138;
        v37 = Vector3f::Vector3f(&v48, &v45, &v46, &v47);
        BoundBox::expandBound(&v137, v37);
        v147 = 0;
        for ( ii = 0; ii < *(v189 + 107); ++ii )
        {
          BoundBox::BoundBox(&v135);
          BoundBox::resetBound(&v135);
          BoundBox::expandBound(&v135, (12 * *(*(v189 + 108) + 100 * ii + 4) + *(v189 + 160)));
          BoundBox::expandBound(&v135, (12 * *(*(v189 + 108) + 100 * ii + 8) + *(v189 + 160)));
          BoundBox::expandBound(&v135, (12 * *(*(v189 + 108) + 100 * ii + 12) + *(v189 + 160)));
          if ( BoundBox::intersects(&v135, &v137) )
          {
            v134 = &v137;
            v110 = 0;
            v111 = 1;
            v112 = 2;
            v113 = 0;
            v114 = 1;
            v115 = 5;
            v116 = 0;
            v117 = 4;
            v118 = 2;
            v119 = 0;
            v120 = 4;
            v121 = 5;
            v122 = 3;
            v123 = 1;
            v124 = 2;
            v125 = 3;
            v126 = 1;
            v127 = 5;
            v128 = 3;
            v129 = 4;
            v130 = 2;
            v131 = 3;
            v132 = 4;
            v133 = 5;
            sub_1000291E(&v109, 44, 3, CullingPlane::CullingPlane);
            LOBYTE(v108) = 1;
            v107 = 0;
            for ( jj = 0; jj < 8; ++jj )
            {
              Vector3f::Vector3f(
                &v105,
                &v134[4 * *(&v110 + 3 * jj)],
                &v134[4 * *(&v111 + 3 * jj)],
                &v134[4 * *(&v112 + 3 * jj)]);
              if ( Plane::dist((*(v189 + 108) + 100 * ii + 24), &v105) < 0.0 )
                ++v107;
            }
            if ( v107 == 8 )
              LOBYTE(v108) = 0;
            if ( v108 )
            {
              v146[v147++] = 100 * ii + *(v189 + 108);
              if ( v147 == 1024 )
                sub_1002A170("Too many tris per block for collision system!!");
            }
          }
        }
        if ( v147 )
        {
          v145 += v147;
          v104 = 0;
          for ( kk = 0; kk < v144; ++kk )
          {
            v102 = kk / *(v189 + 104);
            v101 = kk % *(v189 + 104);
            v100 = *(*(v189 + 106) + 4 * (v101 + *(v189 + 104) * v102));
            if ( *(v100 + 4) == v147 )
            {
              LOBYTE(v99) = 1;
              for ( ll = 0; ll < v147; ++ll )
              {
                if ( *(*(v100 + 8) + 4 * ll) != v146[ll] )
                {
                  LOBYTE(v99) = 0;
                  break;
                }
              }
              if ( v99 )
              {
                v104 = v100;
                break;
              }
            }
          }
          if ( v104 )
          {
            *(*(*(v189 + 106) + 4 * (n + *(v189 + 104) * m)) + 8) = *(v104 + 8);
            *(*(*(v189 + 106) + 4 * (n + *(v189 + 104) * m)) + 4) = *(v104 + 4);
          }
          else
          {
            v97 = *(*(v189 + 106) + 4 * (n + *(v189 + 104) * m));
            *(v97 + 4) = v147;
            v44 = sub_10001AC3(4 * v147);
            *(v97 + 8) = v44;
            for ( mm = 0; mm < v147; ++mm )
              *(*(v97 + 8) + 4 * mm) = v146[mm];
            ++*v143;
          }
        }
        ++v144;
      }
    }
    sub_10025E40("got a total of %d unique groups\n", v143[0]);
    v38 = StdSystem::getHeap(gsys, 2);
    v39 = AyuStack::getFree(v38);
    v42 = (v188 - v39);
    v40 = v42 / 1024.0;
    sub_10025E40("*------------------------------------------- collision data uses %.2fk\n", SLOBYTE(v40));
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);
// 10033CF0: using guessed type int var_10F8[1024];

//----- (10035610) --------------------------------------------------------
void __cdecl sub_10035610(float a1)
{
  float v1; // ST54_4

  v1 = acos(a1);
}

//----- (10035660) --------------------------------------------------------
void __thiscall BaseShape::calcBasePose(BaseShape *this, struct Matrix4f *a2)
{
  int *v2; // eax
  int *v3; // ecx
  int *v4; // edx
  struct Matrix4f *v5; // [esp+4Ch] [ebp-78h]
  char v6; // [esp+54h] [ebp-70h]
  int v7; // [esp+94h] [ebp-30h]
  int v8; // [esp+98h] [ebp-2Ch]
  int v9; // [esp+9Ch] [ebp-28h]
  int v10; // [esp+A0h] [ebp-24h]
  int v11; // [esp+A4h] [ebp-20h]
  int v12; // [esp+A8h] [ebp-1Ch]
  int v13; // [esp+ACh] [ebp-18h]
  int v14; // [esp+B0h] [ebp-14h]
  int v15; // [esp+B4h] [ebp-10h]
  int v16; // [esp+B8h] [ebp-Ch]
  int i; // [esp+BCh] [ebp-8h]
  BaseShape *v18; // [esp+C0h] [ebp-4h]

  v18 = this;
  for ( i = 0; i < *(v18 + 22); ++i )
  {
    SRT::SRT(&v8);
    v2 = (*(v18 + 23) + 284 * i + 36);
    v8 = *v2;
    v9 = v2[1];
    v10 = v2[2];
    v3 = (*(v18 + 23) + 284 * i + 48);
    v11 = *v3;
    v12 = v3[1];
    v13 = v3[2];
    v4 = (*(v18 + 23) + 284 * i + 60);
    v14 = *v4;
    v15 = v4[1];
    v16 = v4[2];
    v7 = *(*(v18 + 23) + 284 * i + 24);
    Matrix4f::Matrix4f(&v6);
    if ( v7 == -1 )
      v5 = a2;
    else
      v5 = (*(v18 + 23) + 284 * v7 + 72);
    Matrix4f::makeConcatSRT((*(v18 + 23) + 284 * i + 72), v5, &v6, &v8);
    Matrix4f::inverse((*(v18 + 23) + 284 * i + 72), (*(v18 + 23) + 284 * i + 136));
  }
}

//----- (10035830) --------------------------------------------------------
struct CoreNode *__thiscall BaseShape::loadDck(BaseShape *this, char *a2, struct RandomAccessStream *a3)
{
  struct CoreNode *v4; // [esp+4Ch] [ebp-20h]
  HGLOBAL hMem; // [esp+50h] [ebp-1Ch]
  struct CoreNode *v6; // [esp+54h] [ebp-18h]
  struct CoreNode *v7; // [esp+58h] [ebp-14h]
  BaseShape *v8; // [esp+5Ch] [ebp-10h]
  int v9; // [esp+68h] [ebp-4h]

  v8 = this;
  hMem = sub_10002A81(0x44u);
  v9 = 0;
  if ( hMem )
    v4 = AnimDck::AnimDck(hMem, a2);
  else
    v4 = 0;
  v6 = v4;
  v9 = -1;
  v7 = v4;
  v4[2].Next = v8;
  (*(v7->vtblPointer + 16))(v7, a3);
  if ( v7[2].vtblPointer != *(v8 + 22) )
    sub_10025E40("(%s) NUMJOINTS DOES NOT MATCH, THINGS MIGHT GO WRONG!!!\n", a2);
  CoreNode::add((v8 + 124), v7);
  *(*(v8 + 6) + 4) = v7;
  *(*(v8 + 6) + 8) = 0;
  return v7;
}

//----- (10035970) --------------------------------------------------------
struct CoreNode *__thiscall BaseShape::importDck(BaseShape *this, char *a2, struct CmdStream *a3)
{
  struct CoreNode *v4; // [esp+4Ch] [ebp-2Ch]
  CoreNode *v5; // [esp+50h] [ebp-28h]
  AnimDck *v6; // [esp+54h] [ebp-24h]
  AnimDck *hMem; // [esp+5Ch] [ebp-1Ch]
  struct CoreNode *v8; // [esp+64h] [ebp-14h]
  BaseShape *v9; // [esp+68h] [ebp-10h]

  v9 = this;
  if ( a2 )
  {
    v6 = sub_10002A81(0x44u);
    if ( v6 )
      v4 = AnimDck::AnimDck(v6, a2);
    else
      v4 = 0;
    v8 = v4;
    v4[2].Next = v9;
    AnimDck::parse(v4, a3);
  }
  else
  {
    hMem = sub_10002A81(0x44u);
    if ( hMem )
      v5 = AnimDck::AnimDck(hMem, v9, *(v9 + 22));
    else
      v5 = 0;
    v8 = v5;
    CoreNode::setName(v5, "Null Anim");
  }
  if ( v8[2].vtblPointer != *(v9 + 22) )
  {
    sub_10025E40("(%s) NUMJOINTS DOES NOT MATCH, THINGS MIGHT GO WRONG!!!\n", a2);
    v8 = 0;
  }
  CoreNode::add((v9 + 124), v8);
  *(*(v9 + 6) + 4) = v8;
  *(*(v9 + 6) + 8) = 0;
  return v8;
}

//----- (10035B30) --------------------------------------------------------
struct CoreNode *__thiscall BaseShape::loadDca(BaseShape *this, char *a2, struct RandomAccessStream *a3)
{
  struct CoreNode *v4; // [esp+4Ch] [ebp-20h]
  HGLOBAL hMem; // [esp+50h] [ebp-1Ch]
  struct CoreNode *v6; // [esp+54h] [ebp-18h]
  struct CoreNode *v7; // [esp+58h] [ebp-14h]
  BaseShape *v8; // [esp+5Ch] [ebp-10h]
  int v9; // [esp+68h] [ebp-4h]

  v8 = this;
  hMem = sub_10002A81(0x44u);
  v9 = 0;
  if ( hMem )
    v4 = AnimDca::AnimDca(hMem, a2);
  else
    v4 = 0;
  v6 = v4;
  v9 = -1;
  v7 = v4;
  v4[2].Next = v8;
  (*(v7->vtblPointer + 16))(v7, a3);
  if ( v7[2].vtblPointer != *(v8 + 22) )
    sub_10025E40("(%s) NUMJOINTS DOES NOT MATCH, THINGS MIGHT GO WRONG!!!\n", a2);
  CoreNode::add((v8 + 124), v7);
  *(*(v8 + 6) + 4) = v7;
  return v7;
}

//----- (10035C60) --------------------------------------------------------
void __thiscall BaseShape::importDca(BaseShape *this, char *a2, struct CmdStream *a3)
{
  char v3; // [esp+0h] [ebp-78h]
  struct CoreNode *v4; // [esp+4Ch] [ebp-2Ch]
  struct CoreNode *v5; // [esp+50h] [ebp-28h]
  AnimDca *v6; // [esp+54h] [ebp-24h]
  AnimDca *hMem; // [esp+5Ch] [ebp-1Ch]
  struct CoreNode *v8; // [esp+64h] [ebp-14h]
  BaseShape *v9; // [esp+68h] [ebp-10h]

  v9 = this;
  if ( a2 )
  {
    v6 = sub_10002A81(0x44u);
    if ( v6 )
      v4 = AnimDca::AnimDca(v6, a2);
    else
      v4 = 0;
    v8 = v4;
    v4[2].Next = v9;
    AnimDca::parse(v4, a3);
  }
  else
  {
    hMem = sub_10002A81(0x44u);
    if ( hMem )
      v5 = AnimDca::AnimDca(hMem, v9, *(v9 + 22));
    else
      v5 = 0;
    v8 = v5;
  }
  if ( v8[2].vtblPointer != *(v9 + 22) )
    sub_10025E40("NUMJOINTS DOES NOT MATCH, THINGS MIGHT GO WRONG!!!\n", v3);
  CoreNode::add((v9 + 124), v8);
  *(*(v9 + 6) + 4) = v8;
}

//----- (10035DF0) --------------------------------------------------------
struct AnimData *__thiscall BaseShape::loadAnimation(BaseShape *this, char *Str, bool a3)
{
  char v4; // [esp+0h] [ebp-74h]
  struct CmdStream *v5; // [esp+4Ch] [ebp-28h]
  HGLOBAL hMem; // [esp+50h] [ebp-24h]
  struct CmdStream *v7; // [esp+54h] [ebp-20h]
  int i; // [esp+58h] [ebp-1Ch]
  struct CmdStream *v9; // [esp+5Ch] [ebp-18h]
  struct Stream *v10; // [esp+60h] [ebp-14h]
  BaseShape *v11; // [esp+64h] [ebp-10h]
  int v12; // [esp+70h] [ebp-4h]

  v11 = this;
  v10 = (*(*gsys + 4))(gsys, Str, a3, 1);
  if ( !v10 )
  {
    sub_10025E40("failed to open %s\n", Str);
    return 0;
  }
  hMem = sub_10002A81(0x11Cu);
  v12 = 0;
  if ( hMem )
    v5 = CmdStream::CmdStream(hMem, v10);
  else
    v5 = 0;
  v7 = v5;
  v12 = -1;
  v9 = v5;
  if ( !v5 )
    return 0;
  for ( i = strlen(Str) - 1; i >= 0 && Str[i] != 46; --i )
    ;
  if ( !strcmp(&Str[i], ".dck") )
  {
    BaseShape::importDck(v11, Str, v9);
  }
  else if ( !strcmp(&Str[i], ".dca") )
  {
    BaseShape::importDca(v11, Str, v9);
  }
  (*(*v10 + 68))(v10);
  if ( !*(*(v11 + 6) + 4) )
    sub_10025E40("returning NULL anim!!\n", v4);
  return *(*(v11 + 6) + 4);
}

//----- (10036000) --------------------------------------------------------
struct Matrix4f *__thiscall BaseShape::getAnimMatrix(BaseShape *this, int a2)
{
  return (*(this + 10) + (a2 << 6));
}

//----- (10036050) --------------------------------------------------------
void __thiscall BaseShape::backupAnimOverrides(BaseShape *this, struct AnimContext **a2)
{
  int i; // [esp+4Ch] [ebp-8h]

  *(this + 8) = a2;
  for ( i = 0; i < *(this + 22); ++i )
    *(*(this + 8) + 4 * i) = *(*(this + 7) + 4 * i);
}

//----- (100360D0) --------------------------------------------------------
void __thiscall BaseShape::restoreAnimOverrides(BaseShape *this)
{
  int i; // [esp+4Ch] [ebp-8h]

  for ( i = 0; i < *(this + 22); ++i )
    *(*(this + 7) + 4 * i) = *(*(this + 8) + 4 * i);
}

//----- (10036150) --------------------------------------------------------
void __thiscall BaseShape::overrideAnim(BaseShape *this, int a2, struct AnimContext *a3)
{
  Joint **v3; // [esp+50h] [ebp-8h]

  v3 = (284 * a2 + *(this + 23));
  Joint::overrideAnim(v3, a3);
  if ( v3[4] )
    Joint::recOverrideAnim(v3[4], a3);
}

//----- (100361E0) --------------------------------------------------------
AnimFrameCacher *__thiscall AnimFrameCacher::AnimFrameCacher(AnimFrameCacher *this, int a2)
{
  int v3; // [esp+4Ch] [ebp-1Ch]
  AyuCache *hMem; // [esp+50h] [ebp-18h]
  AnimFrameCacher *v5; // [esp+58h] [ebp-10h]

  v5 = this;
  hMem = sub_10002A81(0x130u);
  if ( hMem )
    v3 = AyuCache::AyuCache(hMem, a2 << 6);
  else
    v3 = 0;
  *v5 = v3;
  *(v5 + 1) = "root";
  *(v5 + 2) = v5 + 4;
  *(v5 + 3) = *(v5 + 2);
  return v5;
}

//----- (100362E0) --------------------------------------------------------
void __thiscall AnimFrameCacher::updateInfo(AnimFrameCacher *this, struct AnimCacheInfo *a2)
{
  AnimFrameCacher *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  if ( *(this + 3) != *(a2 + 4) )
  {
    CacheInfo::remove(*(a2 + 4));
    CacheInfo::insertAfter((v2 + 4), *(a2 + 4));
  }
}

//----- (10036360) --------------------------------------------------------
void __thiscall AnimFrameCacher::removeOldest(AnimFrameCacher *this)
{
  AyuCache **v1; // ST54_4
  _DWORD **v2; // ST50_4

  v1 = this;
  v2 = *(this + 2);
  CacheInfo::remove(*(this + 2));
  *v2[3] = 0;
  AyuCache::cacheFree(*v1, v2);
}

//----- (100363E0) --------------------------------------------------------
int __thiscall sub_100363E0(int this)
{
  int v1; // ST50_4

  v1 = this;
  Matrix4f::Matrix4f((this + 116));
  SRT::SRT((v1 + 180));
  *(v1 + 216) = 0;
  return v1;
}

//----- (10036450) --------------------------------------------------------
void __thiscall AnimFrameCacher::cacheFrameSpace(AnimFrameCacher *this, int a2, struct AnimCacheInfo *a3)
{
  int i; // [esp+4Ch] [ebp-18h]
  struct CacheInfo *v4; // [esp+50h] [ebp-14h]
  unsigned int v5; // [esp+5Ch] [ebp-8h]
  AnimFrameCacher *v6; // [esp+60h] [ebp-4h]

  v6 = this;
  v5 = (68 * a2 + 59) & 0xFFFFFFE0;
  while ( AyuCache::largestBlockFree(*v6) <= v5 )
    AnimFrameCacher::removeOldest(v6);
  v4 = AyuCache::mallocL(*v6, v5);
  *(v4 + 6) = v4 + 28;
  *(v4 + 5) = v4 + 4 * a2 + 28;
  *(v4 + 3) = a3 + 16;
  for ( i = 0; i < a2; ++i )
    *(*(v4 + 6) + 4 * i) = 0;
  *(a3 + 4) = v4;
  CacheInfo::insertAfter((v6 + 4), v4);
}

//----- (10036590) --------------------------------------------------------
void __thiscall BaseShape::updateAnim(BaseShape *this, struct Graphics *a2, struct Matrix4f *a3, float *a4)
{
  struct Matrix4f *v4; // [esp+58h] [ebp-94h]
  struct Matrix4f *v5; // [esp+5Ch] [ebp-90h]
  float *v6; // [esp+60h] [ebp-8Ch]
  struct Matrix4f *v7; // [esp+64h] [ebp-88h]
  char v8; // [esp+68h] [ebp-84h]
  int v9; // [esp+A8h] [ebp-44h]
  int v10; // [esp+ACh] [ebp-40h]
  int v11; // [esp+B0h] [ebp-3Ch]
  int v12; // [esp+B4h] [ebp-38h]
  int v13; // [esp+B8h] [ebp-34h]
  int v14; // [esp+BCh] [ebp-30h]
  int v15; // [esp+C0h] [ebp-2Ch]
  int v16; // [esp+C4h] [ebp-28h]
  int v17; // [esp+C8h] [ebp-24h]
  int j; // [esp+CCh] [ebp-20h]
  _DWORD *v19; // [esp+D0h] [ebp-1Ch]
  struct Matrix4f *v20; // [esp+D4h] [ebp-18h]
  char v21[4]; // [esp+D8h] [ebp-14h]
  float *v22; // [esp+DCh] [ebp-10h]
  _DWORD *v23; // [esp+E0h] [ebp-Ch]
  int i; // [esp+E4h] [ebp-8h]
  BaseShape *v25; // [esp+E8h] [ebp-4h]

  v25 = this;
  Timers::start(*(gsys + 14), "updateAnim", 1);
  ++*(gsys + 110);
  *(v25 + 10) = Graphics::getMatrices(a2, *(v25 + 11));
  if ( *(*(v25 + 6) + 4) )
  {
    if ( !a4 )
      (***(v25 + 6))(*(v25 + 6), *(*(v25 + 6) + 12));
    for ( i = 0; i < *(v25 + 22); ++i )
    {
      v23 = *(*(*(v25 + 7) + 4 * i) + 4);
      if ( !v23 )
        sub_1002A170("no joint anim!!\n");
      if ( a4 )
        v6 = a4;
      else
        v6 = (*(*(v25 + 7) + 4 * i) + 8);
      v22 = v6;
      if ( *(v25 + 9) && v23[9] & 4 )
      {
        *v21 = *v22;
        if ( *v21 >= v23[12] )
          sub_1002A170("updateAnim: too large a frame number : %d / %d, %f\n", *v21, v23[12], *v22);
        if ( *(v23[16] + 28 * *v21 + 16) )
          AnimFrameCacher::updateInfo(*(v25 + 9), (28 * *v21 + v23[16]));
        else
          AnimFrameCacher::cacheFrameSpace(*(v25 + 9), v23[11], (28 * *v21 + v23[16]));
      }
      if ( v23[12] )
      {
        if ( *(*(v25 + 23) + 284 * i + 24) == -1 )
          v5 = a3;
        else
          v5 = ((*(*(v25 + 23) + 284 * i + 24) << 6) + *(v25 + 10));
        v20 = v5;
        (*(*v23 + 24))(v23, *(v23[8] + 2 * i), v5, (i << 6) + *(v25 + 10), 220 * i + v23[15], *v22);
      }
      else
      {
        Matrix4f::multiplyTo(a3, (*(v25 + 23) + 284 * i + 72), ((i << 6) + *(v25 + 10)));
      }
    }
    BaseShape::calcWeightedMatrices(v25);
  }
  else
  {
    v19 = *(v25 + 23);
    for ( j = 0; j < *(v25 + 22); ++j )
    {
      SRT::SRT(&v9);
      v9 = v19[9];
      v10 = v19[10];
      v11 = v19[11];
      v12 = v19[12];
      v13 = v19[13];
      v14 = v19[14];
      v15 = v19[15];
      v16 = v19[16];
      v17 = v19[17];
      Matrix4f::Matrix4f(&v8);
      if ( v19[6] == -1 )
        v4 = a3;
      else
        v4 = (*(v25 + 23) + 284 * v19[6] + 72);
      v7 = v4;
      Matrix4f::makeConcatSRT((v19 + 18), v4, &v8, &v9);
      v19 += 71;
    }
  }
  Timers::stop(*(gsys + 14), "updateAnim");
}

//----- (10036A40) --------------------------------------------------------
void __thiscall BaseShape::calcWeightedMatrices(BaseShape *this)
{
  struct Matrix4f *v1; // ST04_4
  Matrix4f *v2; // eax
  signed int l; // [esp+4Ch] [ebp-64h]
  float *v4; // [esp+50h] [ebp-60h]
  char v5; // [esp+54h] [ebp-5Ch]
  float v6; // [esp+94h] [ebp-1Ch]
  int v7; // [esp+98h] [ebp-18h]
  int k; // [esp+9Ch] [ebp-14h]
  int j; // [esp+A0h] [ebp-10h]
  float *v10; // [esp+A4h] [ebp-Ch]
  int i; // [esp+A8h] [ebp-8h]
  BaseShape *v12; // [esp+ACh] [ebp-4h]

  v12 = this;
  for ( i = 0; i < *(v12 + 12); ++i )
  {
    v10 = (((i + *(v12 + 22)) << 6) + *(v12 + 10));
    for ( j = 0; j < 16; ++j )
    {
      *v10 = 0.0;
      ++v10;
    }
    for ( k = 0; k < *(*(v12 + 13) + 12 * i); ++k )
    {
      v7 = *(*(*(v12 + 13) + 12 * i + 4) + 4 * k);
      v6 = *(*(*(v12 + 13) + 12 * i + 8) + 4 * k);
      Matrix4f::Matrix4f(&v5);
      v1 = (*(v12 + 23) + 284 * v7 + 136);
      v2 = BaseShape::getAnimMatrix(v12, v7);
      Matrix4f::multiplyTo(v2, v1, &v5);
      v4 = &v5;
      v10 = (((i + *(v12 + 22)) << 6) + *(v12 + 10));
      for ( l = 0; l < 12; ++l )
      {
        *v10 = v6 * *v4 + *v10;
        ++v4;
        ++v10;
      }
    }
  }
}

//----- (10036C40) --------------------------------------------------------
void __thiscall BaseShape::makeNormalIndexes(BaseShape *this, unsigned __int16 *a2)
{
  int v2; // ST64_4
  char v3; // ST58_1
  signed int v4; // [esp+50h] [ebp-3Ch]
  int l; // [esp+58h] [ebp-34h]
  int v6; // [esp+5Ch] [ebp-30h]
  int v7; // [esp+64h] [ebp-28h]
  char *v8; // [esp+68h] [ebp-24h]
  int k; // [esp+6Ch] [ebp-20h]
  int v10; // [esp+70h] [ebp-1Ch]
  int v11; // [esp+74h] [ebp-18h]
  int j; // [esp+78h] [ebp-14h]
  _DWORD *v13; // [esp+7Ch] [ebp-10h]
  int i; // [esp+84h] [ebp-8h]

  for ( i = 0; i < *(this + 24); ++i )
  {
    v13 = (48 * *(*(*(this + 25) + 4 * i) + 32) + *(this + 21));
    for ( j = 0; j < v13[8]; ++j )
    {
      v11 = 16 * j + v13[9];
      v10 = *(v11 + 12);
      for ( k = 0; k < *(v11 + 8); ++k )
      {
        v8 = *(v10 + 28);
        v7 = *(v10 + 24);
        while ( v7 && v8 < v7 + *(v10 + 28) )
        {
          v2 = *v8++;
          if ( v2 )
          {
            v6 = v8[1] | (*v8 << 8);
            v8 += 2;
            for ( l = 0; l < v6; ++l )
            {
              if ( v13[11] & 1 )
                v3 = *v8++;
              if ( v13[11] & 2 )
                ++v8;
              v4 = 6;
              a2[_byteswap_ushort(*v8)] = _byteswap_ushort(*(v8 + 1));
              if ( v13[11] & 4 )
                v4 = 8;
              v8 += v4;
            }
          }
          else
          {
            v7 = 0;
          }
        }
        v10 += 116;
      }
    }
  }
}

//----- (10036EE0) --------------------------------------------------------
double __thiscall BaseShape::calcJointWorldPos(BaseShape *this, struct Graphics *a2, int a3, struct Vector3f *a4)
{
  struct Matrix4f *v5; // ST50_4
  struct Matrix4f *v6; // eax
  BaseShape *v7; // [esp+50h] [ebp-4h]

  v7 = this;
  if ( a3 == -1 )
    return 0.0;
  v5 = BaseShape::getAnimMatrix(this, a3);
  v6 = BaseShape::getAnimMatrix(v7, a3);
  Vector3f::multMatrix(a4, v6);
  Vector3f::multMatrix(a4, (*(a2 + 186) + 544));
  return Vector3f::length(v5);
}

//----- (10036F90) --------------------------------------------------------
void __thiscall BaseShape::calcJointWorldDir(BaseShape *this, struct Graphics *a2, int a3, struct Vector3f *a4)
{
  struct Matrix4f *v4; // eax
  BaseShape *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  if ( a3 != -1 )
  {
    BaseShape::getAnimMatrix(this, a3);
    v4 = BaseShape::getAnimMatrix(v5, a3);
    Vector3f::rotate(a4, v4);
    Vector3f::rotate(a4, (*(a2 + 186) + 544));
  }
}

//----- (10037020) --------------------------------------------------------
void __thiscall BaseShape::calcJointWorldScale(BaseShape *this, struct Graphics *a2, int a3, struct Vector3f *a4)
{
  struct Matrix4f *v4; // eax
  Vector3f *v5; // eax
  char v6; // [esp+4Ch] [ebp-18h]
  float v7; // [esp+58h] [ebp-Ch]
  float *v8; // [esp+5Ch] [ebp-8h]
  BaseShape *v9; // [esp+60h] [ebp-4h]

  v9 = this;
  if ( a3 != -1 )
  {
    v4 = BaseShape::getAnimMatrix(v9, a3);
    v8 = v4;
    v5 = Vector3f::Vector3f(&v6, v4, v4 + 1, v4 + 2);
    v7 = Vector3f::length(v5);
    Vector3f::set(a4, &v7, &v7, &v7);
  }
}

//----- (100370C0) --------------------------------------------------------
struct CollTriInfo *__thiscall BaseShape::findCollTri(BaseShape *this, struct Vector3f *a2, struct Vector3f *a3, struct Vector3f *a4, char *a5)
{
  signed int k; // [esp+4Ch] [ebp-20h]
  int v7; // [esp+50h] [ebp-1Ch]
  signed int j; // [esp+54h] [ebp-18h]
  int i; // [esp+58h] [ebp-14h]
  struct Vector3f *v10; // [esp+5Ch] [ebp-10h]
  struct Vector3f *v11; // [esp+60h] [ebp-Ch]
  struct Vector3f *v12; // [esp+64h] [ebp-8h]
  BaseShape *v13; // [esp+68h] [ebp-4h]

  v13 = this;
  v10 = a2;
  v11 = a3;
  v12 = a4;
  for ( i = 0; i < *(v13 + 107); ++i )
  {
    for ( j = 0; j < 3; ++j )
    {
      v7 = 0;
      for ( k = 0; k < 3; ++k )
      {
        if ( Vector3f::isSame((*(v13 + 160) + 12 * *(100 * i + *(v13 + 108) + 4 * (2 - (k + j) % 3) + 4)), *(&v10 + k)) )
          ++v7;
      }
      if ( v7 == 3 )
        return (100 * i + *(v13 + 108));
    }
  }
  return 0;
}

//----- (10037230) --------------------------------------------------------
int __thiscall sub_10037230(_DWORD *this, int a2)
{
  if ( a2 < 0 || a2 >= this[1] )
    assert("i>=0 && i<num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x21u);
  return *this + 4 * a2;
}

//----- (100372C0) --------------------------------------------------------
_DWORD *__thiscall sub_100372C0(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10001D43(this);
  *v3 = off_101AEAC4;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10001D43: using guessed type int __thiscall sub_10001D43(_DWORD);
// 101AEAC4: using guessed type int (__stdcall *off_101AEAC4[2])(int);

//----- (10037330) --------------------------------------------------------
int __thiscall sub_10037330(int this, int a2)
{
  int v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  return (*(this + 8))(*(this + 4), a2);
}

//----- (10037390) --------------------------------------------------------
_DWORD *__thiscall sub_10037390(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10001D43(this);
  *v3 = &off_101AEAC8;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10001D43: using guessed type int __thiscall sub_10001D43(_DWORD);
// 101AEAC8: using guessed type int (__stdcall *off_101AEAC8)(int);

//----- (10037400) --------------------------------------------------------
int __thiscall sub_10037400(int this, int a2)
{
  int v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  return (*(this + 8))(*(this + 4), a2);
}

//----- (10037460) --------------------------------------------------------
_DWORD *__thiscall sub_10037460(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10002603(this);
  *v3 = &off_101AEACC;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10002603: using guessed type int __thiscall sub_10002603(_DWORD);
// 101AEACC: using guessed type int (__stdcall *off_101AEACC)(int, int);

//----- (100374D0) --------------------------------------------------------
int __thiscall sub_100374D0(int this, int a2, int a3)
{
  int v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  return (*(this + 8))(*(this + 4), a2, a3);
}

//----- (10037530) --------------------------------------------------------
_DWORD *__thiscall sub_10037530(_DWORD *this)
{
  *this = &off_101AEAD0;
  return this;
}
// 101AEAD0: using guessed type void *off_101AEAD0;

//----- (10037570) --------------------------------------------------------
int __thiscall sub_10037570(HGLOBAL *this)
{
  return sub_10001938(*this);
}

//----- (100375D0) --------------------------------------------------------
int __thiscall sub_100375D0(_DWORD *this, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  if ( this[1] > this[2] )
    assert("num<=array_size", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x57u);
  if ( this[1] == this[2] )
  {
    if ( this[2] )
      sub_1000179E(2 * this[2]);
    else
      sub_1000179E(16);
  }
  *(*v3 + 4 * v3[1]) = a2;
  result = v3[1] + 1;
  v3[1] = result;
  return result;
}
// 1000179E: using guessed type _DWORD __stdcall sub_1000179E(_DWORD);

//----- (100376B0) --------------------------------------------------------
int __thiscall sub_100376B0(HGLOBAL *this)
{
  return sub_10001938(*this);
}

//----- (10037710) --------------------------------------------------------
int __thiscall sub_10037710(_DWORD *this, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  if ( this[1] > this[2] )
    assert("num<=array_size", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x57u);
  if ( this[1] == this[2] )
  {
    if ( this[2] )
      sub_10002A2C(2 * this[2]);
    else
      sub_10002A2C(16);
  }
  *(*v3 + 4 * v3[1]) = a2;
  result = v3[1] + 1;
  v3[1] = result;
  return result;
}
// 10002A2C: using guessed type _DWORD __stdcall sub_10002A2C(_DWORD);

//----- (100377F0) --------------------------------------------------------
int __thiscall sub_100377F0(_DWORD *this, int a2)
{
  int i; // [esp+4Ch] [ebp-8h]

  for ( i = 0; i < this[1]; ++i )
  {
    if ( *(*this + 4 * i) == a2 )
      return i;
  }
  return 0;
}

//----- (10037870) --------------------------------------------------------
int __thiscall sub_10037870(HGLOBAL *this)
{
  return sub_10001938(*this);
}

//----- (100378D0) --------------------------------------------------------
int __thiscall sub_100378D0(_DWORD *this, int a2)
{
  int result; // eax
  int i; // [esp+54h] [ebp-Ch]
  _DWORD *v4; // [esp+58h] [ebp-8h]
  _DWORD *v5; // [esp+5Ch] [ebp-4h]

  v5 = this;
  if ( a2 <= 0 )
    assert("s>0", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x35u);
  if ( a2 < this[1] )
    assert("s>=num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x36u);
  v4 = *this;
  this[2] = a2;
  *this = sub_10001AC3(4 * this[2]);
  if ( !*v5 )
    assert("element", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x3Au);
  for ( i = 0; ; ++i )
  {
    result = v5;
    if ( i >= v5[1] )
      break;
    *(*v5 + 4 * i) = v4[i];
  }
  if ( v4 )
    result = sub_10001938(v4);
  return result;
}

//----- (10037A40) --------------------------------------------------------
int __thiscall sub_10037A40(_DWORD *this, int a2)
{
  int result; // eax
  int i; // [esp+54h] [ebp-Ch]
  _DWORD *v4; // [esp+58h] [ebp-8h]
  _DWORD *v5; // [esp+5Ch] [ebp-4h]

  v5 = this;
  if ( a2 <= 0 )
    assert("s>0", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x35u);
  if ( a2 < this[1] )
    assert("s>=num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x36u);
  v4 = *this;
  this[2] = a2;
  *this = sub_10001AC3(4 * this[2]);
  if ( !*v5 )
    assert("element", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x3Au);
  for ( i = 0; ; ++i )
  {
    result = v5;
    if ( i >= v5[1] )
      break;
    *(*v5 + 4 * i) = v4[i];
  }
  if ( v4 )
    result = sub_10001938(v4);
  return result;
}

//----- (10037BB0) --------------------------------------------------------
_DWORD *__thiscall sub_10037BB0(_DWORD *this, int a2, int a3, int a4, int a5)
{
  *this = a2;
  this[1] = a3;
  this[2] = a4;
  this[3] = a5;
  return this;
}

//----- (10037C10) --------------------------------------------------------
_DWORD *__thiscall sub_10037C10(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v4; // ST50_4

  v4 = this;
  sub_10001186(0);
  *v4 = a2;
  v4[1] = a3;
  v4[2] = a4;
  sub_100019F1(0);
  return v4;
}
// 10001186: using guessed type _DWORD __stdcall sub_10001186(_DWORD);
// 100019F1: using guessed type _DWORD __stdcall sub_100019F1(_DWORD);

//----- (10037CD0) --------------------------------------------------------
_DWORD *__thiscall sub_10037CD0(_DWORD *this, int a2)
{
  _DWORD *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  this[1] = 0;
  this[2] = 0;
  *this = 0;
  if ( a2 )
    sub_1000100A(a2);
  return v3;
}
// 1000100A: using guessed type _DWORD __stdcall sub_1000100A(_DWORD);

//----- (10037D50) --------------------------------------------------------
int __thiscall sub_10037D50(HGLOBAL *this)
{
  return sub_10001938(*this);
}

//----- (10037DB0) --------------------------------------------------------
int __thiscall sub_10037DB0(HGLOBAL *this, void *a2)
{
  int result; // eax
  HGLOBAL *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  if ( a2 )
  {
    result = sub_1000100A(a2);
  }
  else
  {
    result = this;
    if ( *this )
    {
      result = sub_10001938(*this);
      *v3 = 0;
    }
    v3[2] = 0;
  }
  v3[1] = a2;
  return result;
}
// 1000100A: using guessed type _DWORD __stdcall sub_1000100A(_DWORD);

//----- (10037E50) --------------------------------------------------------
int __thiscall sub_10037E50(_DWORD *this, int a2)
{
  int result; // eax
  int i; // [esp+54h] [ebp-Ch]
  _DWORD *v4; // [esp+58h] [ebp-8h]
  _DWORD *v5; // [esp+5Ch] [ebp-4h]

  v5 = this;
  if ( a2 <= 0 )
    assert("s>0", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x35u);
  if ( a2 < this[1] )
    assert("s>=num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x36u);
  v4 = *this;
  this[2] = a2;
  *this = sub_10001AC3(4 * this[2]);
  if ( !*v5 )
    assert("element", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x3Au);
  for ( i = 0; ; ++i )
  {
    result = v5;
    if ( i >= v5[1] )
      break;
    *(*v5 + 4 * i) = v4[i];
  }
  if ( v4 )
    result = sub_10001938(v4);
  return result;
}

//----- (10037FC0) --------------------------------------------------------
_DWORD *__thiscall sub_10037FC0(_DWORD *this)
{
  _DWORD *v1; // ST50_4

  v1 = this;
  sub_10001280(0);
  sub_10002D74(0);
  sub_10001532(0);
  v1[11] = 0;
  v1[10] = 0;
  v1[9] = 0;
  v1[12] = 0;
  return v1;
}
// 10001280: using guessed type _DWORD __stdcall sub_10001280(_DWORD);
// 10001532: using guessed type _DWORD __stdcall sub_10001532(_DWORD);
// 10002D74: using guessed type _DWORD __stdcall sub_10002D74(_DWORD);

//----- (100380A0) --------------------------------------------------------
_DWORD *__thiscall sub_100380A0(_DWORD *this, int a2)
{
  _DWORD *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  this[1] = 0;
  this[2] = 0;
  *this = 0;
  if ( a2 )
    sub_1000179E(a2);
  return v3;
}
// 1000179E: using guessed type _DWORD __stdcall sub_1000179E(_DWORD);

//----- (10038120) --------------------------------------------------------
_DWORD *__thiscall sub_10038120(_DWORD *this, int a2)
{
  _DWORD *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  this[1] = 0;
  this[2] = 0;
  *this = 0;
  if ( a2 )
    sub_10002A2C(a2);
  return v3;
}
// 10002A2C: using guessed type _DWORD __stdcall sub_10002A2C(_DWORD);

//----- (100381A0) --------------------------------------------------------
_DWORD *__thiscall sub_100381A0(_DWORD *this, int a2)
{
  _DWORD *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  this[1] = 0;
  this[2] = 0;
  *this = 0;
  if ( a2 )
    sub_10001730(a2);
  return v3;
}
// 10001730: using guessed type _DWORD __stdcall sub_10001730(_DWORD);

//----- (10038220) --------------------------------------------------------
int __thiscall sub_10038220(_DWORD *this, int a2)
{
  int result; // eax
  int i; // [esp+54h] [ebp-Ch]
  _DWORD *v4; // [esp+58h] [ebp-8h]
  _DWORD *v5; // [esp+5Ch] [ebp-4h]

  v5 = this;
  if ( a2 <= 0 )
    assert("s>0", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x35u);
  if ( a2 < this[1] )
    assert("s>=num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x36u);
  v4 = *this;
  this[2] = a2;
  *this = sub_10001AC3(4 * this[2]);
  if ( !*v5 )
    assert("element", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x3Au);
  for ( i = 0; ; ++i )
  {
    result = v5;
    if ( i >= v5[1] )
      break;
    *(*v5 + 4 * i) = v4[i];
  }
  if ( v4 )
    result = sub_10001938(v4);
  return result;
}

//----- (10038390) --------------------------------------------------------
void __thiscall LightFlare::loadini(LightFlare *this, struct CmdStream *a2)
{
  int v2; // ST08_4
  const char *v3; // eax
  int v4; // ST08_4
  const char *v5; // eax
  int v6; // ST08_4
  const char *v7; // eax
  int v8; // ST08_4
  const char *v9; // eax
  LightFlare *v10; // [esp+4Ch] [ebp-4h]

  v10 = this;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "size") )
    {
      v2 = v10 + 20;
      v3 = CmdStream::getToken(a2, 1);
      sscanf(v3, "%f", v2);
    }
    else if ( CmdStream::isToken(a2, "pos") )
    {
      v4 = v10 + 24;
      v5 = CmdStream::getToken(a2, 1);
      sscanf(v5, "%f", v4);
      v6 = v10 + 28;
      v7 = CmdStream::getToken(a2, 1);
      sscanf(v7, "%f", v6);
      v8 = v10 + 32;
      v9 = CmdStream::getToken(a2, 1);
      sscanf(v9, "%f", v8);
    }
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}

//----- (10038540) --------------------------------------------------------
void __thiscall LightFlare::saveini(LightFlare *this, char *a2, struct RandomAccessStream *a3)
{
  float *v3; // ST70_4

  v3 = this;
  Stream::print(a3, "\n%slightflare {\t\t\n", a2);
  Stream::print(a3, "%s\tsize %f\n", a2, v3[5]);
  Stream::print(a3, "%s\tpos\t%f %f %f\n", a2, v3[6], v3[7], v3[8]);
  Stream::print(a3, "%s\t}\n", a2);
}

//----- (10038630) --------------------------------------------------------
void __thiscall LightFlare::ageDel(LightFlare *this, struct AgeServer *a2)
{
  CoreNode::del(this);
  AgeServer::RefreshSection(a2);
}

//----- (10038680) --------------------------------------------------------
void __thiscall LightFlare::genAge(LightFlare *this, struct AgeServer *a2)
{
  int v2; // [esp+4Ch] [ebp-1Ch]
  float *v3; // [esp+58h] [ebp-10h]

  v3 = this;
  AgeServer::StartGroup(a2, "LightFlare");
  AgeServer::NewEditor(a2, "size", v3 + 5, 0.0, 500.0, 320);
  if ( sub_10002A81(0xCu) )
    v2 = sub_10002DC4(v3, LightFlare::ageDel);
  else
    v2 = 0;
  AgeServer::NewButton("Delete", v2, 100);
  AgeServer::NewEditor(a2, "posx", v3 + 6, -500.0, 500.0, 320);
  AgeServer::NewEditor(a2, "posy", v3 + 7, -500.0, 500.0, 320);
  AgeServer::NewEditor(a2, "posz", v3 + 8, -500.0, 500.0, 320);
  AgeServer::EndGroup(a2);
}
// 10001451: using guessed type _DWORD __stdcall AgeServer::NewButton(_DWORD, _DWORD, _DWORD);
// 10002DC4: using guessed type _DWORD __stdcall sub_10002DC4(_DWORD, _DWORD);

//----- (10038820) --------------------------------------------------------
void __thiscall LightGroup::ageAddFlare(LightGroup *this, struct AgeServer *a2)
{
  struct Vector3f *v2; // eax
  float v3; // [esp+4Ch] [ebp-1Ch]
  float v4; // [esp+50h] [ebp-18h]
  float v5; // [esp+54h] [ebp-14h]
  char v6; // [esp+58h] [ebp-10h]
  LightGroup *v7; // [esp+64h] [ebp-4h]

  v7 = this;
  *(this + 15) = StdSystem::loadTexture(gsys, "effects/halowhit.txe", 1);
  v5 = 0.0;
  v4 = 0.0;
  v3 = 0.0;
  v2 = Vector3f::Vector3f(&v6, &v3, &v4, &v5);
  LightGroup::addLight(v7, v2, 1.0);
  AgeServer::RefreshSection(a2);
}

//----- (100388D0) --------------------------------------------------------
void __thiscall LightGroup::ageDel(LightGroup *this, struct AgeServer *a2)
{
  CoreNode::del(this);
  AgeServer::RefreshNode(a2);
}

//----- (10038920) --------------------------------------------------------
void __thiscall LightGroup::ageChangeTexture(LightGroup *this, struct AgeServer *a2)
{
  LightGroup *v2; // ST54_4

  v2 = this;
  sub_100389D0("changing texture to %s\n", *(*(this + 8) + 12));
  *(v2 + 13) = *(*(v2 + 8) + 12);
  *(v2 + 15) = StdSystem::loadTexture(gsys, *(v2 + 13), 1);
  *(v2 + 26) = StdSystem::registerLFlare(gsys, *(v2 + 15));
}

//----- (100389D0) --------------------------------------------------------
char *__cdecl sub_100389D0(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "shpLightFlares" )
      Stream::print(sysCon, "%s: ", "shpLightFlares");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10038AE0) --------------------------------------------------------
void __thiscall LightGroup::genAge(LightGroup *this, struct AgeServer *a2)
{
  char *v2; // eax
  int v3; // [esp+4Ch] [ebp-40h]
  int v4; // [esp+50h] [ebp-3Ch]
  int v5; // [esp+54h] [ebp-38h]
  HGLOBAL v6; // [esp+58h] [ebp-34h]
  int v7; // [esp+5Ch] [ebp-30h]
  HGLOBAL v8; // [esp+60h] [ebp-2Ch]
  int v9; // [esp+64h] [ebp-28h]
  HGLOBAL hMem; // [esp+68h] [ebp-24h]
  int v11; // [esp+6Ch] [ebp-20h]
  struct CoreNode *k; // [esp+70h] [ebp-1Ch]
  int j; // [esp+74h] [ebp-18h]
  int i; // [esp+78h] [ebp-14h]
  LightGroup *v15; // [esp+7Ch] [ebp-10h]
  int v16; // [esp+88h] [ebp-4h]

  v15 = this;
  AgeServer::StartGroup(a2, "Commands");
  hMem = sub_10002A81(0xCu);
  v16 = 0;
  if ( hMem )
    v5 = sub_100027F2(v15, LightGroup::ageAddFlare);
  else
    v5 = 0;
  v11 = v5;
  AgeServer::NewButton("Add LightFlare", v5, 222);
  v8 = sub_10002A81(0xCu);
  v16 = 1;
  if ( v8 )
    v4 = sub_100027F2(v15, LightGroup::ageDel);
  else
    v4 = 0;
  v9 = v4;
  v16 = -1;
  AgeServer::NewButton("Delete LightGroup", v4, 222);
  if ( *(v15 + 25) )
  {
    AgeServer::NewEditor(a2, "type", v15 + 6, 0, 0, 320);
    AgeServer::StartOptionBox(a2, "Joint", v15 + 7, 185);
    AgeServer::NewOption(a2, "NONE", -1);
    for ( i = 0; i < *(*(v15 + 25) + 88); ++i )
    {
      v2 = CoreNode::Name((*(*(v15 + 25) + 92) + 284 * i));
      AgeServer::NewOption(a2, v2, i);
    }
    AgeServer::EndOptionBox(a2);
    v6 = sub_10002A81(0xCu);
    v16 = 2;
    if ( v6 )
      v3 = sub_100027F2(v15, LightGroup::ageChangeTexture);
    else
      v3 = 0;
    v7 = v3;
    v16 = -1;
    AgeServer::setOnChange(v3);
    AgeServer::StartOptionBox(a2, "Texture", v15 + 8, 444);
    for ( j = *(gsys + 118); j != (gsys + 464); j = *(j + 8) )
      AgeServer::NewOption(a2, *(j + 12), j);
    AgeServer::EndOptionBox(a2);
    AgeServer::setOnChange(a2, 0);
    AgeServer::StartBitGroup(a2, "flags", v15 + 5, 75);
    AgeServer::NewBit(a2, "UseDir", 1u, 0);
    AgeServer::EndBitGroup(a2);
    AgeServer::NewEditor(a2, "dirx", v15 + 9, -1.0, 1.0, 320);
    AgeServer::NewEditor(a2, "diry", v15 + 10, -1.0, 1.0, 320);
    AgeServer::NewEditor(a2, "dirz", v15 + 11, -1.0, 1.0, 320);
    Colour::genAge((v15 + 48), a2, "colour");
  }
  AgeServer::EndGroup(a2);
  if ( CoreNode::Child((v15 + 64)) )
  {
    for ( k = CoreNode::Child((v15 + 64)); k; k = k->Next )
      (*k->vtblPointer)(k, a2);
  }
}
// 10001451: using guessed type _DWORD __stdcall AgeServer::NewButton(_DWORD, _DWORD, _DWORD);
// 100027F2: using guessed type _DWORD __stdcall sub_100027F2(_DWORD, _DWORD);
// 10002BAD: using guessed type _DWORD __stdcall AgeServer::setOnChange(_DWORD);

//----- (10038F30) --------------------------------------------------------
void __thiscall LightGroup::saveini(LightGroup *this, char *a2, struct RandomAccessStream *a3)
{
  const char *v3; // [esp+64h] [ebp-10Ch]
  char Dest; // [esp+68h] [ebp-108h]
  LightFlare *i; // [esp+168h] [ebp-8h]
  LightGroup *v6; // [esp+16Ch] [ebp-4h]

  v6 = this;
  if ( *(this + 7) == -1 )
    v3 = "NULL";
  else
    v3 = *(*(*(v6 + 25) + 92) + 284 * *(v6 + 7) + 4);
  Stream::print(a3, "\n%slightgroup %d {\t\t// %s\n", a2, *(v6 + 7), v3);
  Stream::print(a3, "%s\ttype %d\n", a2, *(v6 + 6));
  Stream::print(a3, "%s\tflags %d\n", a2, *(v6 + 5));
  if ( *(v6 + 5) & 1 )
    Stream::print(a3, "%s\tdir\t%f %f %f\n", a2, *(v6 + 9), *(v6 + 10), *(v6 + 11));
  Stream::print(a3, "%s\tcolour\t%d %d %d %d\n", a2, *(v6 + 48), *(v6 + 49), *(v6 + 50), *(v6 + 51));
  Stream::print(a3, "%s\ttexture\t%s\n", a2, *(v6 + 13));
  Stream::print(a3, "%s\tmaterial\t%s\n", a2, *(v6 + 14));
  if ( CoreNode::Child((v6 + 64)) )
  {
    for ( i = CoreNode::Child((v6 + 64)); i; i = *(i + 3) )
    {
      sprintf(&Dest, "%s\t", a2);
      LightFlare::saveini(i, &Dest, a3);
    }
  }
  Stream::print(a3, "%s\t}\n", a2);
}

//----- (100391B0) --------------------------------------------------------
void __thiscall LightGroup::loadini(LightGroup *this, struct CmdStream *a2)
{
  int v2; // ST0C_4
  const char *v3; // eax
  int v4; // ST0C_4
  const char *v5; // eax
  int v6; // ST0C_4
  const char *v7; // eax
  int v8; // ST0C_4
  const char *v9; // eax
  int v10; // ST0C_4
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  struct CoreNode *v18; // [esp+4Ch] [ebp-38h]
  HGLOBAL hMem; // [esp+50h] [ebp-34h]
  struct CoreNode *v20; // [esp+54h] [ebp-30h]
  struct CoreNode *v21; // [esp+58h] [ebp-2Ch]
  char *Str; // [esp+5Ch] [ebp-28h]
  char *Str1; // [esp+60h] [ebp-24h]
  unsigned __int8 v24; // [esp+64h] [ebp-20h]
  char v25; // [esp+68h] [ebp-1Ch]
  char v26; // [esp+6Ch] [ebp-18h]
  char v27; // [esp+70h] [ebp-14h]
  LightGroup *v28; // [esp+74h] [ebp-10h]
  int v29; // [esp+80h] [ebp-4h]

  v28 = this;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "type") )
    {
      v2 = v28 + 24;
      v3 = CmdStream::getToken(a2, 1);
      sscanf(v3, "%d", v2);
    }
    else if ( CmdStream::isToken(a2, "flags") )
    {
      v4 = v28 + 20;
      v5 = CmdStream::getToken(a2, 1);
      sscanf(v5, "%d", v4);
    }
    else if ( CmdStream::isToken(a2, "dir") )
    {
      v6 = v28 + 36;
      v7 = CmdStream::getToken(a2, 1);
      sscanf(v7, "%f", v6);
      v8 = v28 + 40;
      v9 = CmdStream::getToken(a2, 1);
      sscanf(v9, "%f", v8);
      v10 = v28 + 44;
      v11 = CmdStream::getToken(a2, 1);
      sscanf(v11, "%f", v10);
    }
    else if ( CmdStream::isToken(a2, "colour") )
    {
      v12 = CmdStream::getToken(a2, 1);
      sscanf(v12, "%d", &v27);
      v13 = CmdStream::getToken(a2, 1);
      sscanf(v13, "%d", &v26);
      v14 = CmdStream::getToken(a2, 1);
      sscanf(v14, "%d", &v25);
      v15 = CmdStream::getToken(a2, 1);
      sscanf(v15, "%d", &v24);
      Colour::set((v28 + 48), v27, v26, v25, v24);
    }
    else if ( CmdStream::isToken(a2, "texture") )
    {
      Str1 = CmdStream::getToken(a2, 1);
      if ( !strcmp(Str1, "NULL") )
      {
        *(v28 + 13) = 0;
      }
      else
      {
        v16 = StdSystem::stringDup(Str1);
        *(v28 + 13) = v16;
      }
    }
    else if ( CmdStream::isToken(a2, "material") )
    {
      Str = CmdStream::getToken(a2, 1);
      if ( !strcmp(Str, "NULL") )
      {
        *(v28 + 14) = 0;
      }
      else
      {
        v17 = StdSystem::stringDup(Str);
        *(v28 + 14) = v17;
      }
    }
    else if ( CmdStream::isToken(a2, "lightflare") )
    {
      CmdStream::getToken(a2, 1);
      hMem = sub_10002A81(0x24u);
      v29 = 0;
      if ( hMem )
        v18 = LightFlare::LightFlare(hMem);
      else
        v18 = 0;
      v20 = v18;
      v29 = -1;
      v21 = v18;
      LightFlare::loadini(v18, a2);
      CoreNode::add((v28 + 64), v21);
    }
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}

//----- (10039670) --------------------------------------------------------
void __thiscall LightGroup::refresh(LightGroup *this, struct Graphics *a2, struct Matrix4f *a3)
{
  double v3; // st7
  struct Vector2f *v4; // eax
  struct Matrix4f *v5; // [esp+4Ch] [ebp-28h]
  char v6; // [esp+50h] [ebp-24h]
  float v7; // [esp+58h] [ebp-1Ch]
  char v8; // [esp+5Ch] [ebp-18h]
  struct CoreNode *i; // [esp+68h] [ebp-Ch]
  struct Matrix4f *v10; // [esp+6Ch] [ebp-8h]
  LightGroup *v11; // [esp+70h] [ebp-4h]

  v11 = this;
  if ( CoreNode::Child((this + 64)) && *(v11 + 26) )
  {
    if ( *(v11 + 7) == -1 )
      v5 = a3;
    else
      v5 = BaseShape::getAnimMatrix(*(v11 + 25), *(v11 + 7));
    v10 = v5;
    for ( i = CoreNode::Child((v11 + 64)); i; i = i->Next )
    {
      Vector3f::Vector3f(&v8, &i[1].name);
      Vector3f::multMatrix(&v8, v10);
      v3 = Vector3f::length(v10);
      v7 = v3 * *&i[1].vtblPointer;
      v4 = Vector2f::Vector2f(&v6, &v7, &v7);
      LFlareGroup::addLFlare(*(v11 + 26), (v11 + 48), &v8, v4, 0, 0);
    }
  }
}

//----- (100397B0) --------------------------------------------------------
_DWORD *__thiscall sub_100397B0(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10001D43(this);
  *v3 = off_101AECF4;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10001D43: using guessed type int __thiscall sub_10001D43(_DWORD);
// 101AECF4: using guessed type int (__stdcall *off_101AECF4[2])(int);

//----- (10039820) --------------------------------------------------------
int __thiscall sub_10039820(int this, int a2)
{
  int v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  return (*(this + 8))(*(this + 4), a2);
}

//----- (10039880) --------------------------------------------------------
_DWORD *__thiscall sub_10039880(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10001D43(this);
  *v3 = &off_101AECF8;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10001D43: using guessed type int __thiscall sub_10001D43(_DWORD);
// 101AECF8: using guessed type int (__stdcall *off_101AECF8)(int);

//----- (100398F0) --------------------------------------------------------
int __thiscall sub_100398F0(int this, int a2)
{
  int v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  return (*(this + 8))(*(this + 4), a2);
}

//----- (10039950) --------------------------------------------------------
void __thiscall ObjCollInfo::getCentreSize(ObjCollInfo *this, struct Vector3f *a2, float *a3)
{
  struct Matrix4f *v3; // [esp+4Ch] [ebp-8h]
  ObjCollInfo *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  v3 = &Matrix4f::ident;
  if ( *(this + 12) != -1 )
    v3 = BaseShape::getAnimMatrix(*(this + 17), *(this + 12));
  Vector3f::set(a2, v4 + 13, v4 + 14, v4 + 15);
  Vector3f::multMatrix(a2, v3);
  *a3 = Vector3f::length(v3) * *(v4 + 16);
}

//----- (10039A10) --------------------------------------------------------
void __thiscall ObjCollInfo::showInfo(ObjCollInfo *this, struct Graphics *a2, struct Matrix4f *a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // [esp+4Ch] [ebp-14h]
  char v6; // [esp+50h] [ebp-10h]
  char v7; // [esp+54h] [ebp-Ch]
  struct Matrix4f *v8; // [esp+58h] [ebp-8h]
  ObjCollInfo *v9; // [esp+5Ch] [ebp-4h]

  v9 = this;
  v8 = a3;
  if ( *(this + 12) == -1 || (v8 = BaseShape::getAnimMatrix(*(v9 + 17), *(v9 + 12))) != 0 )
  {
    v7 = (*(*a2 + 40))(a2, 0, 0);
    (*(*a2 + 196))(a2, 0, 0);
    v3 = Colour::Colour(&v6, 255, 255, 0, 0xC0u);
    (*(*a2 + 160))(a2, v3, 1);
    v5 = *(v9 + 11);
    if ( v5 == 1 )
    {
      Graphics::drawSphere(a2, (v9 + 52), *(v9 + 16), v8);
    }
    else if ( v5 == 2 )
    {
      (*(*a2 + 108))(a2, v8, 0);
      if ( *(v9 + 18) )
        BaseShape::drawshape(*(v9 + 18), a2, *(a2 + 186), 0);
    }
    LOBYTE(v4) = v7;
    (*(*a2 + 40))(a2, v4, 0);
  }
}

//----- (10039BC0) --------------------------------------------------------
void __stdcall ObjCollInfo::sectionJointsChange(struct AgeServer *a2)
{
  AgeServer::RefreshSection(a2);
}

//----- (10039C10) --------------------------------------------------------
void __thiscall ObjCollInfo::ageDelCollInfo(ObjCollInfo *this, struct AgeServer *a2)
{
  CoreNode::del(this);
  AgeServer::RefreshNode(a2);
}

//----- (10039C60) --------------------------------------------------------
void __thiscall ObjCollInfo::newCollInfoButton(ObjCollInfo *this, struct AgeServer *a2)
{
  char v2; // [esp+0h] [ebp-6Ch]
  struct CoreNode *v3; // [esp+4Ch] [ebp-20h]
  ObjCollInfo *hMem; // [esp+50h] [ebp-1Ch]
  CoreNode *v5; // [esp+5Ch] [ebp-10h]

  v5 = this;
  sub_10039D50("adding new collinfo\n", v2);
  hMem = sub_10002A81(0x54u);
  if ( hMem )
    v3 = ObjCollInfo::ObjCollInfo(hMem);
  else
    v3 = 0;
  v3[3].Parent = v5[3].Parent;
  CoreNode::add(v5, v3);
  AgeServer::RefreshNode(a2);
}

//----- (10039D50) --------------------------------------------------------
char *__cdecl sub_10039D50(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "shpObjColl" )
      Stream::print(sysCon, "%s: ", "shpObjColl");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10039E60) --------------------------------------------------------
void __thiscall ObjCollInfo::ageChangePlatname(ObjCollInfo *this, struct AgeServer *a2)
{
  char *v2; // eax
  struct Shape *v3; // eax
  signed int j; // [esp+4Ch] [ebp-814h]
  signed int i; // [esp+50h] [ebp-810h]
  char v6; // [esp+54h] [ebp-80Ch]
  char *Str; // [esp+58h] [ebp-808h]
  ObjCollInfo *v8; // [esp+85Ch] [ebp-4h]

  v8 = this;
  sub_100013DE(&v6);
  if ( AgeServer::getOpenFilename(a2, &v6, "Mod Files (*.mod)|*.mod|") )
  {
    v2 = StdSystem::stringDup(Str);
    *(v8 + 19) = v2;
    v3 = StdSystem::getShape(gsys, *(v8 + 19), *(v8 + 19), `string', 0);
    *(v8 + 18) = v3;
    for ( i = 0; i < strlen(*(v8 + 19)); ++i )
    {
      if ( !strncmp((i + *(v8 + 19)), "dataDir", 7u) )
      {
        *(v8 + 19) += i + 8;
        for ( j = 0; j < strlen(*(v8 + 19)); ++j )
        {
          if ( *(*(v8 + 19) + j) == 92 )
            *(*(v8 + 19) + j) = 47;
        }
      }
    }
  }
  AgeServer::RefreshSection(a2);
}
// 100013DE: using guessed type int __thiscall sub_100013DE(_DWORD);

//----- (1003A040) --------------------------------------------------------
void __thiscall ObjCollInfo::genAge(ObjCollInfo *this, struct AgeServer *a2)
{
  char *v2; // eax
  int v3; // [esp+4Ch] [ebp-24Ch]
  const char *v4; // [esp+50h] [ebp-248h]
  int v5; // [esp+54h] [ebp-244h]
  int v6; // [esp+58h] [ebp-240h]
  int v7; // [esp+5Ch] [ebp-23Ch]
  int v8; // [esp+60h] [ebp-238h]
  HGLOBAL v9; // [esp+64h] [ebp-234h]
  int v10; // [esp+68h] [ebp-230h]
  HGLOBAL v11; // [esp+6Ch] [ebp-22Ch]
  int v12; // [esp+70h] [ebp-228h]
  HGLOBAL v13; // [esp+74h] [ebp-224h]
  int v14; // [esp+78h] [ebp-220h]
  HGLOBAL hMem; // [esp+7Ch] [ebp-21Ch]
  int v16; // [esp+80h] [ebp-218h]
  char Dest; // [esp+84h] [ebp-214h]
  int i; // [esp+284h] [ebp-14h]
  ObjCollInfo *v19; // [esp+288h] [ebp-10h]
  int v20; // [esp+294h] [ebp-4h]

  v19 = this;
  AgeServer::StartGroup(a2, "ObjCollInfo");
  hMem = sub_10002A81(0xCu);
  v20 = 0;
  if ( hMem )
    v8 = sub_10002AD6(v19, ObjCollInfo::newCollInfoButton);
  else
    v8 = 0;
  v16 = v8;
  AgeServer::NewButton("New CollInfo", v8, 222);
  v13 = sub_10002A81(0xCu);
  v20 = 1;
  if ( v13 )
    v7 = sub_10002AD6(v19, ObjCollInfo::ageDelCollInfo);
  else
    v7 = 0;
  v14 = v7;
  AgeServer::NewButton("Delete CollInfo", v7, 222);
  v11 = sub_10002A81(0xCu);
  v20 = 2;
  if ( v11 )
    v6 = sub_10002AD6(v19, ObjCollInfo::sectionJointsChange);
  else
    v6 = 0;
  v12 = v6;
  v20 = -1;
  AgeServer::setOnChange(v6);
  AgeServer::StartOptionBox(a2, "Colltype", v19 + 11, 142);
  AgeServer::NewOption(a2, "Sphere", 1);
  AgeServer::NewOption(a2, "Platform", 2);
  AgeServer::EndOptionBox(a2);
  AgeServer::setOnChange(a2, 0);
  ID32::genAge((v19 + 20), a2, "id");
  ID32::genAge((v19 + 32), a2, "code");
  if ( *(v19 + 11) && *(v19 + 17) )
  {
    AgeServer::StartOptionBox(a2, "Joint", v19 + 12, 182);
    AgeServer::NewOption(a2, "NONE", -1);
    for ( i = 0; i < *(*(v19 + 17) + 88); ++i )
    {
      v2 = CoreNode::Name((*(*(v19 + 17) + 92) + 284 * i));
      AgeServer::NewOption(a2, v2, i);
    }
    AgeServer::EndOptionBox(a2);
  }
  v5 = *(v19 + 11);
  if ( v5 == 1 )
  {
    AgeServer::NewEditor(a2, "radius", v19 + 16, 0.0, 750.0, 320);
    AgeServer::NewEditor(a2, "centre x", v19 + 13, -750.0, 750.0, 320);
    AgeServer::NewEditor(a2, "centre y", v19 + 14, -750.0, 750.0, 320);
    AgeServer::NewEditor(a2, "centre z", v19 + 15, -750.0, 750.0, 320);
    *(v19 + 20) = 0;
  }
  else if ( v5 == 2 )
  {
    if ( *(v19 + 19) )
      v4 = *(v19 + 19);
    else
      v4 = "CHOOSE";
    sprintf(&Dest, "file: %s", v4);
    v9 = sub_10002A81(0xCu);
    v20 = 3;
    if ( v9 )
      v3 = sub_10002AD6(v19, ObjCollInfo::ageChangePlatname);
    else
      v3 = 0;
    v10 = v3;
    v20 = -1;
    AgeServer::NewButton(&Dest, v3, 444);
    AgeServer::StartBitGroup(a2, "flasgs", v19 + 20, 120);
    AgeServer::NewBit(a2, "getMinY", 1u, 0);
    AgeServer::EndBitGroup(a2);
  }
  AgeServer::EndGroup(a2);
}
// 10001451: using guessed type _DWORD __stdcall AgeServer::NewButton(_DWORD, _DWORD, _DWORD);
// 10002AD6: using guessed type _DWORD __stdcall sub_10002AD6(_DWORD, _DWORD);
// 10002BAD: using guessed type _DWORD __stdcall AgeServer::setOnChange(_DWORD);

//----- (1003A5C0) --------------------------------------------------------
void __thiscall ObjCollInfo::saveini(ObjCollInfo *this, char *a2, struct RandomAccessStream *a3)
{
  char *v3; // [esp+64h] [ebp-10Ch]
  char Dest; // [esp+68h] [ebp-108h]
  ObjCollInfo *i; // [esp+168h] [ebp-8h]
  CoreNode *v6; // [esp+16Ch] [ebp-4h]

  v6 = this;
  Stream::print(a3, "\n%scollinfo %d {\t\t// %s\n", a2, *(this + 12), *(*(*(this + 17) + 92) + 284 * *(this + 12) + 4));
  Stream::print(a3, "%s\tid\t\t%s\n", a2, &v6[1].name);
  Stream::print(a3, "%s\tcode\t\t%s\n", a2, &v6[1].Child);
  Stream::print(a3, "%s\ttype\t%d\n", a2, v6[2].name);
  v3 = v6[2].name;
  if ( v3 == 1 )
  {
    Stream::print(a3, "%s\tradius\t%f\n", a2, *&v6[3].name);
    Stream::print(a3, "%s\tcentre\t%f %f %f\n", a2, *&v6[2].Next, *&v6[2].Child, v6[3].vtblPointer);
  }
  else if ( v3 == 2 )
  {
    Stream::print(a3, "%s\tplatform\t%s\n", a2, v6[3].Child);
  }
  if ( v6[4].vtblPointer )
    Stream::print(a3, "%s\tgetminy\n", a2);
  if ( CoreNode::Child(v6) )
  {
    for ( i = CoreNode::Child(v6); i; i = *(i + 3) )
    {
      sprintf(&Dest, "%s\t", a2);
      ObjCollInfo::saveini(i, &Dest, a3);
    }
  }
  Stream::print(a3, "%s\t}\n", a2);
}

//----- (1003A830) --------------------------------------------------------
void __thiscall ObjCollInfo::loadini(ObjCollInfo *this, struct CmdStream *a2)
{
  char **v2; // ST08_4
  const char *v3; // eax
  char **v4; // ST08_4
  const char *v5; // eax
  CoreNode **v6; // ST08_4
  const char *v7; // eax
  CoreNode **v8; // ST08_4
  const char *v9; // eax
  CoreNode *v10; // ST08_4
  const char *v11; // eax
  char *v12; // eax
  CoreNode *v13; // eax
  const char *v14; // eax
  struct CoreNode *v15; // [esp+4Ch] [ebp-28h]
  char *v16; // [esp+50h] [ebp-24h]
  HGLOBAL hMem; // [esp+54h] [ebp-20h]
  struct CoreNode *v18; // [esp+58h] [ebp-1Ch]
  struct CoreNode *v19; // [esp+5Ch] [ebp-18h]
  CoreNode *v20; // [esp+60h] [ebp-14h]
  CoreNode *v21; // [esp+64h] [ebp-10h]
  int v22; // [esp+70h] [ebp-4h]

  v21 = this;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "id") )
    {
      CmdStream::getToken(a2, 1);
      strncpy(&v21[1].name, a2 + 8, 4u);
      ID32::updateID(&v21[1]);
    }
    else if ( CmdStream::isToken(a2, "code") )
    {
      CmdStream::getToken(a2, 1);
      strncpy(&v21[1].Child, a2 + 8, 4u);
      ID32::updateID(&v21[1].Next);
    }
    else if ( CmdStream::isToken(a2, "type") )
    {
      v2 = &v21[2].name;
      v3 = CmdStream::getToken(a2, 1);
      sscanf(v3, "%d", v2);
      v16 = v21[2].name;
      if ( v16 == 1 )
      {
        CmdStream::getToken(a2, 1);
        v4 = &v21[3].name;
        v5 = CmdStream::getToken(a2, 1);
        sscanf(v5, "%f", v4);
        CmdStream::getToken(a2, 1);
        v6 = &v21[2].Next;
        v7 = CmdStream::getToken(a2, 1);
        sscanf(v7, "%f", v6);
        v8 = &v21[2].Child;
        v9 = CmdStream::getToken(a2, 1);
        sscanf(v9, "%f", v8);
        v10 = v21 + 3;
        v11 = CmdStream::getToken(a2, 1);
        sscanf(v11, "%f", v10);
      }
      else if ( v16 == 2 )
      {
        CmdStream::getToken(a2, 1);
        v12 = CmdStream::getToken(a2, 1);
        v13 = StdSystem::stringDup(v12);
        v21[3].Child = v13;
      }
    }
    else if ( CmdStream::isToken(a2, "getminy") )
    {
      v21[4].vtblPointer = 1;
    }
    else if ( CmdStream::isToken(a2, "collinfo") )
    {
      v14 = CmdStream::getToken(a2, 1);
      sscanf(v14, "%d", &v20);
      hMem = sub_10002A81(0x54u);
      v22 = 0;
      if ( hMem )
        v15 = ObjCollInfo::ObjCollInfo(hMem);
      else
        v15 = 0;
      v18 = v15;
      v22 = -1;
      v19 = v15;
      v15[2].Parent = v20;
      v19[3].Parent = v21[3].Parent;
      CoreNode::add(v21, v19);
      CmdStream::getToken(a2, 1);
      ObjCollInfo::loadini(v19, a2);
    }
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}

//----- (1003AC70) --------------------------------------------------------
char *__thiscall sub_1003AC70(String *this)
{
  char *v1; // ST54_4

  v1 = this;
  String::String(this);
  String::init(v1, v1 + 8, 2048);
  return v1;
}

//----- (1003ACD0) --------------------------------------------------------
_DWORD *__thiscall sub_1003ACD0(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10001D43(this);
  *v3 = &off_101AEEB0;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10001D43: using guessed type int __thiscall sub_10001D43(_DWORD);
// 101AEEB0: using guessed type int (__stdcall *off_101AEEB0)(int);

//----- (1003AD40) --------------------------------------------------------
int __thiscall sub_1003AD40(int this, int a2)
{
  int v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  return (*(this + 8))(*(this + 4), a2);
}

//----- (1003ADA0) --------------------------------------------------------
CoreNode *__thiscall RoutePoint::RoutePoint(RoutePoint *this)
{
  CoreNode *v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode(this, "rp");
  Vector3f::Vector3f(&v1[2]);
  RouteLink::RouteLink(&v1[3]);
  v1->vtblPointer = &RoutePoint::`vftable';
  CoreNode::initCore(v1 + 3, `string');
  v1[1].Next = 1090519040;
  v1[2].Child = 0;
  v1[2].Next = 1;
  v1[1].Child = 1092616192;
  return v1;
}
// 101ADE68: using guessed type void *RoutePoint::`vftable';

//----- (1003AE60) --------------------------------------------------------
void __thiscall RoutePoint::refresh(RoutePoint *this, struct Graphics *a2)
{
  int v2; // ST14_4
  int v3; // eax
  double v4; // st7
  int v5; // eax
  int v6; // eax
  float v7; // [esp+4Ch] [ebp-138h]
  char v8; // [esp+50h] [ebp-134h]
  float v9; // [esp+54h] [ebp-130h]
  float v10; // [esp+58h] [ebp-12Ch]
  char v11; // [esp+5Ch] [ebp-128h]
  char Dest; // [esp+68h] [ebp-11Ch]
  char v13; // [esp+168h] [ebp-1Ch]
  int v14; // [esp+174h] [ebp-10h]
  int v15; // [esp+178h] [ebp-Ch]
  RoutePoint *v16; // [esp+180h] [ebp-4h]

  v16 = this;
  (*(*a2 + 108))(a2, *(a2 + 186) + 480, 0);
  if ( (*(*a2 + 128))(a2, 1) & 0xFF )
  {
    v10 = *(v16 + 11) + 12.0;
    v2 = *(v16 + 8);
    v3 = Vector3f::Vector3f(&v11, v16 + 10, &v10, v16 + 12);
    (*(*a2 + 132))(a2, *(a2 + 186), v3, v2);
  }
  v9 = *(v16 + 11) + 12.0;
  Vector3f::Vector3f(&v14, v16 + 10, &v9, v16 + 12);
  v4 = Camera::projectWorldPoint(*(a2 + 186), a2, &v14);
  *(v16 + 7) = v4;
  *(v16 + 5) = v14;
  *(v16 + 6) = v15;
  (*(*a2 + 108))(a2, &Matrix4f::ident, 0);
  v5 = Colour::Colour(&v8, 255, 255, 255, 0xFFu);
  (*(*a2 + 160))(a2, v5, 1);
  v7 = *(v16 + 11) + 12.0;
  Vector3f::Vector3f(&v13, v16 + 10, &v7, v16 + 12);
  Vector3f::multMatrix(&v13, (*(a2 + 186) + 480));
  sprintf(&Dest, "%d", *(v16 + 14));
  v6 = Font::stringWidth(*(gsys + 5), &Dest);
  (*(*a2 + 232))(a2, *(gsys + 5), &v13, v6 / -2, 0, &Dest);
}

//----- (1003B140) --------------------------------------------------------
void __thiscall RoutePoint::loadini(RoutePoint *this, struct CmdStream *a2)
{
  int v2; // ST08_4
  const char *v3; // eax
  int v4; // ST08_4
  const char *v5; // eax
  int v6; // ST08_4
  const char *v7; // eax
  int v8; // ST08_4
  const char *v9; // eax
  int v10; // ST08_4
  const char *v11; // eax
  int v12; // ST08_4
  const char *v13; // eax
  RoutePoint *v14; // [esp+4Ch] [ebp-4h]

  v14 = this;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "index") )
    {
      v2 = v14 + 56;
      v3 = CmdStream::getToken(a2, 1);
      sscanf(v3, "%d", v2);
    }
    else if ( CmdStream::isToken(a2, "pos") )
    {
      v4 = v14 + 40;
      v5 = CmdStream::getToken(a2, 1);
      sscanf(v5, "%f", v4);
      v6 = v14 + 44;
      v7 = CmdStream::getToken(a2, 1);
      sscanf(v7, "%f", v6);
      v8 = v14 + 48;
      v9 = CmdStream::getToken(a2, 1);
      sscanf(v9, "%f", v8);
    }
    else if ( CmdStream::isToken(a2, "state") )
    {
      v10 = v14 + 52;
      v11 = CmdStream::getToken(a2, 1);
      sscanf(v11, "%d", v10);
    }
    else if ( CmdStream::isToken(a2, "width") )
    {
      v12 = v14 + 36;
      v13 = CmdStream::getToken(a2, 1);
      sscanf(v13, "%f", v12);
    }
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}

//----- (1003B3A0) --------------------------------------------------------
void __stdcall RoutePoint::genAge(struct AgeServer *a2)
{
  AgeServer::StartGroup(a2, "Info");
  AgeServer::EndGroup(a2);
}

//----- (1003B400) --------------------------------------------------------
RouteGroup *__thiscall RouteGroup::RouteGroup(RouteGroup *this)
{
  RouteGroup *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  EditNode::EditNode(this, `string');
  Colour::Colour((v2 + 20));
  RoutePoint::RoutePoint((v2 + 104));
  *v2 = &RouteGroup::`vftable';
  RouteGroup::setID(v2, 0x6E6F6E65u);
  sprintf(v2 + 24, "sample route");
  CoreNode::initCore((v2 + 104), `string');
  Colour::set((v2 + 20), 255, 255, 255, 0xC0u);
  return v2;
}
// 101ADE80: using guessed type void *RouteGroup::`vftable';

//----- (1003B4F0) --------------------------------------------------------
void __thiscall RouteGroup::refresh(RouteGroup *this, struct Graphics *a2, struct EditNode *a3)
{
  int v3; // eax
  int v4; // ST14_4
  int v5; // eax
  int v6; // eax
  int v7; // eax
  const struct Vector3f *v8; // eax
  const struct Vector3f *v9; // eax
  int *v10; // eax
  int *v11; // eax
  int *v12; // eax
  int *v13; // eax
  int v14; // eax
  int v15; // ST14_4
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // ST14_4
  int v22; // eax
  int v23; // eax
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  int v27; // eax
  unsigned __int8 v28; // [esp+0h] [ebp-248h]
  int v29; // [esp+4Ch] [ebp-1FCh]
  int v30; // [esp+50h] [ebp-1F8h]
  int v31; // [esp+54h] [ebp-1F4h]
  float v32; // [esp+58h] [ebp-1F0h]
  char v33; // [esp+5Ch] [ebp-1ECh]
  float v34; // [esp+60h] [ebp-1E8h]
  char v35; // [esp+64h] [ebp-1E4h]
  char v36; // [esp+70h] [ebp-1D8h]
  char v37; // [esp+74h] [ebp-1D4h]
  char v38; // [esp+78h] [ebp-1D0h]
  char v39; // [esp+84h] [ebp-1C4h]
  char v40; // [esp+90h] [ebp-1B8h]
  char v41; // [esp+9Ch] [ebp-1ACh]
  char v42; // [esp+A8h] [ebp-1A0h]
  char v43; // [esp+B4h] [ebp-194h]
  char v44; // [esp+C0h] [ebp-188h]
  char v45; // [esp+CCh] [ebp-17Ch]
  char v46; // [esp+D8h] [ebp-170h]
  char v47; // [esp+DCh] [ebp-16Ch]
  char v48; // [esp+E8h] [ebp-160h]
  char v49; // [esp+F4h] [ebp-154h]
  char v50; // [esp+100h] [ebp-148h]
  float v51; // [esp+10Ch] [ebp-13Ch]
  float v52; // [esp+110h] [ebp-138h]
  float v53; // [esp+114h] [ebp-134h]
  char v54; // [esp+118h] [ebp-130h]
  char v55; // [esp+124h] [ebp-124h]
  char v56; // [esp+130h] [ebp-118h]
  char v57; // [esp+13Ch] [ebp-10Ch]
  int v58; // [esp+148h] [ebp-100h]
  char v59; // [esp+14Ch] [ebp-FCh]
  char v60; // [esp+150h] [ebp-F8h]
  char v61; // [esp+15Ch] [ebp-ECh]
  char v62; // [esp+168h] [ebp-E0h]
  float v63; // [esp+16Ch] [ebp-DCh]
  float v64; // [esp+170h] [ebp-D8h]
  float v65; // [esp+174h] [ebp-D4h]
  float v66; // [esp+178h] [ebp-D0h]
  float v67; // [esp+17Ch] [ebp-CCh]
  char v68; // [esp+180h] [ebp-C8h]
  char v69; // [esp+188h] [ebp-C0h]
  char v70; // [esp+190h] [ebp-B8h]
  char v71; // [esp+198h] [ebp-B0h]
  int v72; // [esp+1A0h] [ebp-A8h]
  int v73; // [esp+1A4h] [ebp-A4h]
  int v74; // [esp+1A8h] [ebp-A0h]
  int v75; // [esp+1ACh] [ebp-9Ch]
  int v76; // [esp+1B0h] [ebp-98h]
  int v77; // [esp+1B4h] [ebp-94h]
  int v78; // [esp+1B8h] [ebp-90h]
  int v79; // [esp+1BCh] [ebp-8Ch]
  int v80; // [esp+1C0h] [ebp-88h]
  int v81; // [esp+1C4h] [ebp-84h]
  int v82; // [esp+1C8h] [ebp-80h]
  int v83; // [esp+1CCh] [ebp-7Ch]
  int v84; // [esp+1D0h] [ebp-78h]
  int v85; // [esp+1DCh] [ebp-6Ch]
  int v86; // [esp+1E8h] [ebp-60h]
  int v87; // [esp+1F4h] [ebp-54h]
  int v88; // [esp+200h] [ebp-48h]
  float v89; // [esp+20Ch] [ebp-3Ch]
  int v90; // [esp+210h] [ebp-38h]
  int v91; // [esp+21Ch] [ebp-2Ch]
  float v92; // [esp+224h] [ebp-24h]
  int v93; // [esp+228h] [ebp-20h]
  float v94; // [esp+230h] [ebp-18h]
  int j; // [esp+234h] [ebp-14h]
  RoutePoint *i; // [esp+238h] [ebp-10h]
  unsigned int v97; // [esp+23Ch] [ebp-Ch]
  char v98; // [esp+240h] [ebp-8h]
  RouteGroup *v99; // [esp+244h] [ebp-4h]

  v99 = this;
  v98 = (*(*a2 + 40))(a2, 0, 0);
  v97 = *(v99 + 23);
  (*(*a2 + 88))(a2, 0);
  for ( i = *(v99 + 30); i; i = *(i + 3) )
  {
    for ( j = *(i + 19); j; j = *(j + 12) )
    {
      v67 = *(i + 11) + 8.0;
      Vector3f::Vector3f(&v93, i + 10, &v67, i + 12);
      v66 = *(*(j + 20) + 44) + 8.0;
      Vector3f::Vector3f(&v91, (*(j + 20) + 40), &v66, (*(j + 20) + 48));
      v65 = 0.0;
      v64 = 4.0;
      v63 = 0.0;
      Vector3f::Vector3f(&v90, &v63, &v64, &v65);
      (*(*a2 + 196))(a2, 0, 0);
      v3 = Colour::Colour(&v62, 255, 255, 255, v97);
      (*(*a2 + 160))(a2, v3, 1);
      v4 = sub_10001A3C(&v61, &v91, &v90);
      v5 = sub_10001A3C(&v60, &v93, &v90);
      (*(*a2 + 144))(a2, v5, v4);
      if ( *(i + 13) && *(j + 20) )
        v32 = 1.0;
      else
        v32 = 0.2;
      v89 = v32;
      v31 = *(v99 + 22);
      v30 = *(v99 + 21);
      v29 = *(v99 + 20);
      *&v28 = Colour::Colour(&v59, (v29 * v32), v97, 1, v28);
      (*(*a2 + 160))(a2);
      v58 = 1056964608;
      v6 = sub_10001A3C(&v57, &v93, &v91);
      v7 = sub_10001CD5(&v56, v6, &v58);
      v8 = sub_10001A3C(&v55, v7, &v90);
      Vector3f::Vector3f(&v88, v8);
      v9 = sub_10002E2D(&v54, &v91, &v93);
      Vector3f::Vector3f(&v87, v9);
      Vector3f::normalise(&v87);
      Vector3f::multiply(&v87, 8.0);
      v53 = *&v91 - *&v93;
      v52 = 0.0;
      v51 = -(v92 - v94);
      Vector3f::Vector3f(&v86, &v51, &v52, &v53);
      Vector3f::normalise(&v86);
      Vector3f::Vector3f(&v85, &v86);
      Vector3f::multiply(&v85, *(i + 9));
      Vector3f::Vector3f(&v84, &v86);
      Vector3f::multiply(&v84, *(*(j + 20) + 36));
      sub_1000291E(&v72, 12, 4, Vector3f::Vector3f);
      sub_1000291E(&v68, 8, 4, Vector2f::Vector2f);
      Vector2f::set(&v68, 0.0, 0.0);
      Vector2f::set(&v69, 0.0, 0.0);
      Vector2f::set(&v70, 0.0, 0.0);
      Vector2f::set(&v71, 0.0, 0.0);
      v10 = sub_10001A3C(&v50, &v93, &v85);
      v72 = *v10;
      v73 = v10[1];
      v74 = v10[2];
      v11 = sub_10002E2D(&v49, &v93, &v85);
      v75 = *v11;
      v76 = v11[1];
      v77 = v11[2];
      v12 = sub_10002E2D(&v48, &v91, &v84);
      v78 = *v12;
      v79 = v12[1];
      v80 = v12[2];
      v13 = sub_10001A3C(&v47, &v91, &v84);
      v81 = *v13;
      v82 = v13[1];
      v83 = v13[2];
      (*(*a2 + 152))(a2, &v72, 0, &v68, 4);
      Vector3f::multiply(&v86, 4.0);
      v14 = Colour::Colour(&v46, 255, 255, 255, 0xFFu);
      (*(*a2 + 160))(a2, v14, 1);
      v15 = sub_10002E2D(&v45, &v88, &v87);
      v16 = sub_10002E2D(&v44, &v88, &v87);
      v17 = sub_10002E2D(&v43, v16, &v87);
      v18 = sub_10002E2D(&v42, v17, &v86);
      (*(*a2 + 144))(a2, v18, v15);
      v19 = sub_10002E2D(&v41, &v88, &v87);
      v20 = sub_10002E2D(&v40, v19, &v87);
      v21 = sub_10001A3C(&v39, v20, &v86);
      v22 = sub_10002E2D(&v38, &v88, &v87);
      (*(*a2 + 144))(a2, v22, v21);
    }
  }
  v23 = Colour::Colour(&v37, *(v99 + 20), *(v99 + 21), *(v99 + 22), v97);
  (*(*a2 + 160))(a2, v23, 1);
  v24 = *(v99 + 30);
  for ( i = *(v99 + 30); i; i = *(i + 3) )
  {
    (*(*a2 + 196))(a2, 0, 0);
    v25 = Colour::Colour(&v36, 255, 255, 0, 0x40u);
    (*(*a2 + 160))(a2, v25, 1);
    v34 = *(i + 11) + 8.0;
    v26 = Vector3f::Vector3f(&v35, i + 10, &v34, i + 12);
    (*(*a2 + 144))(a2, i + 40, v26);
    v27 = Colour::Colour(&v33, 255, 255, 255, v97);
    (*(*a2 + 160))(a2, v27, 1);
    (*(*a2 + 196))(a2, *(v99 + 47), 0);
    RoutePoint::refresh(i, a2);
  }
  LOBYTE(v24) = v98;
  (*(*a2 + 40))(a2, v24, 0);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003BE90) --------------------------------------------------------
void __thiscall RouteGroup::render2d(RouteGroup *this, struct Graphics *a2, int *a3)
{
  RouteGroup *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  *a3 += 12;
  (*(*a2 + 228))(a2, *(gsys + 5), 0, *a3, "route [ %s ]", this + 24);
}

//----- (1003BF30) --------------------------------------------------------
void __thiscall RouteGroup::loadini(RouteGroup *this, struct CmdStream *a2)
{
  const char *v2; // eax
  const char *v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  struct CoreNode *v10; // [esp+4Ch] [ebp-54h]
  struct CoreNode *v11; // [esp+50h] [ebp-50h]
  HGLOBAL v12; // [esp+54h] [ebp-4Ch]
  struct CoreNode *v13; // [esp+58h] [ebp-48h]
  HGLOBAL hMem; // [esp+5Ch] [ebp-44h]
  struct CoreNode *v15; // [esp+60h] [ebp-40h]
  struct CoreNode *v16; // [esp+64h] [ebp-3Ch]
  CoreNode *i; // [esp+68h] [ebp-38h]
  CoreNode *v18; // [esp+6Ch] [ebp-34h]
  CoreNode *v19; // [esp+70h] [ebp-30h]
  CoreNode *v20; // [esp+74h] [ebp-2Ch]
  CoreNode *v21; // [esp+78h] [ebp-28h]
  struct CoreNode *v22; // [esp+7Ch] [ebp-24h]
  char v23; // [esp+80h] [ebp-20h]
  char v24; // [esp+84h] [ebp-1Ch]
  char v25; // [esp+88h] [ebp-18h]
  char v26; // [esp+8Ch] [ebp-14h]
  RouteGroup *v27; // [esp+90h] [ebp-10h]
  int v28; // [esp+9Ch] [ebp-4h]

  v27 = this;
  while ( !CmdStream::endOfCmds(a2) && !CmdStream::endOfSection(a2) )
  {
    CmdStream::getToken(a2, 1);
    if ( CmdStream::isToken(a2, "id") )
    {
      v2 = CmdStream::getToken(a2, 1);
      sprintf(v27 + 92, v2);
      RouteGroup::updateID(v27);
    }
    else if ( CmdStream::isToken(a2, "name") )
    {
      v3 = CmdStream::getToken(a2, 1);
      sprintf(v27 + 24, v3);
    }
    else if ( CmdStream::isToken(a2, "colour") )
    {
      v4 = CmdStream::getToken(a2, 1);
      sscanf(v4, "%d", &v26);
      v5 = CmdStream::getToken(a2, 1);
      sscanf(v5, "%d", &v25);
      v6 = CmdStream::getToken(a2, 1);
      sscanf(v6, "%d", &v24);
      v7 = CmdStream::getToken(a2, 1);
      sscanf(v7, "%d", &v23);
      Colour::set((v27 + 20), v26, v25, v24, 0x61u);
    }
    else if ( CmdStream::isToken(a2, "point") )
    {
      CmdStream::getToken(a2, 1);
      hMem = sub_10002A81(0x54u);
      v28 = 0;
      if ( hMem )
        v11 = RoutePoint::RoutePoint(hMem);
      else
        v11 = 0;
      v15 = v11;
      v28 = -1;
      v22 = v11;
      RoutePoint::loadini(v11, a2);
      CoreNode::add((v27 + 104), v22);
    }
    else if ( CmdStream::isToken(a2, "link") )
    {
      CmdStream::getToken(a2, 1);
      v8 = CmdStream::getToken(a2, 1);
      sscanf(v8, "%d", &v21);
      v9 = CmdStream::getToken(a2, 1);
      sscanf(v9, "%d", &v20);
      if ( v21 != v20 )
      {
        v19 = 0;
        v18 = 0;
        for ( i = *(v27 + 30); i; i = i->Next )
        {
          if ( i[2].Child == v21 )
            v19 = i;
          if ( i[2].Child == v20 )
            v18 = i;
        }
        if ( v19 && v18 )
        {
          v12 = sub_10002A81(0x18u);
          v28 = 1;
          if ( v12 )
            v10 = RouteLink::RouteLink(v12);
          else
            v10 = 0;
          v13 = v10;
          v28 = -1;
          v16 = v10;
          v10[1].vtblPointer = v18;
          CoreNode::add(v19 + 3, v16);
        }
      }
      CmdStream::getToken(a2, 1);
    }
  }
  if ( !CmdStream::endOfCmds(a2) )
    CmdStream::getToken(a2, 1);
}

//----- (1003C3E0) --------------------------------------------------------
void __thiscall RouteGroup::saveini(RouteGroup *this, char *a2, struct RandomAccessStream *a3)
{
  int k; // [esp+64h] [ebp-10h]
  int i; // [esp+68h] [ebp-Ch]
  _DWORD *j; // [esp+68h] [ebp-Ch]
  int v6; // [esp+6Ch] [ebp-8h]
  RouteGroup *v7; // [esp+70h] [ebp-4h]

  v7 = this;
  Stream::print(a3, "\n%sroute {\n", a2);
  Stream::print(a3, "%s\tid\t\t%s\n", a2, v7 + 92);
  Stream::print(a3, "%s\tname\t'%s'\n", a2, v7 + 24);
  Stream::print(a3, "%s\tcolour\t%d %d %d %d\n", a2, *(v7 + 20), *(v7 + 21), *(v7 + 22), *(v7 + 23));
  v6 = 0;
  for ( i = *(v7 + 30); i; i = *(i + 12) )
  {
    *(i + 56) = v6++;
    Stream::print(a3, "\n%s\tpoint {\n", a2);
    Stream::print(a3, "%s\t\tindex\t%d\n", a2, *(i + 56));
    Stream::print(a3, "%s\t\tstate\t%d\n", a2, *(i + 52));
    Stream::print(a3, "%s\t\tpos\t%f %f %f\n", a2, *(i + 40), *(i + 44), *(i + 48));
    Stream::print(a3, "%s\t\twidth\t%f\n", a2, *(i + 36));
    Stream::print(a3, "%s\t\t}\n", a2);
  }
  Stream::print(a3, "\n");
  for ( j = *(v7 + 30); j; j = j[3] )
  {
    for ( k = j[19]; k; k = *(k + 12) )
      Stream::print(a3, "%s\tlink { %d %d }\n", a2, j[14], *(*(k + 20) + 56));
  }
  Stream::print(a3, "%s\t}\n", a2);
}

//----- (1003C6A0) --------------------------------------------------------
void __thiscall CoreNode::add(CoreNode *this, struct CoreNode *a2)
{
  CoreNode *v2; // [esp+4Ch] [ebp-8h]

  v2 = this->Child;
  if ( v2 )
  {
    while ( v2->Next )
      v2 = v2->Next;
    v2->Next = a2;
  }
  else
  {
    this->Child = a2;
  }
  a2->Parent = this;
}

//----- (1003C720) --------------------------------------------------------
void __thiscall CoreNode::del(CoreNode *this)
{
  CoreNode *v1; // [esp+4Ch] [ebp-Ch]
  CoreNode *v2; // [esp+50h] [ebp-8h]

  if ( this->Parent )
  {
    v2 = this->Parent->Child;
    v1 = 0;
    while ( v2 )
    {
      if ( v2 == this )
      {
        if ( v1 )
          v1->Next = v2->Next;
        else
          this->Parent->Child = v2->Next;
        this->Next = 0;
        this->Parent = 0;
        return;
      }
      v1 = v2;
      v2 = v2->Next;
    }
  }
}

//----- (1003C800) --------------------------------------------------------
int __thiscall CoreNode::getChildCount(CoreNode *this)
{
  CoreNode *i; // [esp+4Ch] [ebp-Ch]
  int v3; // [esp+50h] [ebp-8h]

  v3 = 0;
  for ( i = this->Child; i; i = i->Next )
    ++v3;
  return v3;
}

//----- (1003C870) --------------------------------------------------------
void __thiscall CoreNode::load(CoreNode *this, char *a2, char *a3, unsigned __int32 a4)
{
  int v4; // [esp+4Ch] [ebp-154h]
  char v5; // [esp+50h] [ebp-150h]
  char v6; // [esp+7Ch] [ebp-124h]
  char Dest; // [esp+9Ch] [ebp-104h]

  if ( a4 == 2
    && (AtxFileStream::AtxFileStream(&v6), sprintf(&Dest, "%s%s", a2, a3), AtxFileStream::open(&v6, &Dest, 1u)) )
  {
    sub_1003CA60("DISK opened %s for param reading\n", &Dest);
    BufferedStream::BufferedStream(&v5, &v6, 0x2000);
    (*(this->vtblPointer + 16))(this, &v5);
    AtxFileStream::close(&v6);
  }
  else
  {
    sprintf(&Dest, "%s%s", a2, a3);
    v4 = (*(*gsys + 4))(gsys, &Dest, 1, 1);
    if ( v4 )
    {
      (*(this->vtblPointer + 16))(this, v4);
      (*(*v4 + 68))(v4);
    }
    else
    {
      sub_1003CA60("Could not open %s for param reading\n", &Dest);
    }
  }
}

//----- (1003CA60) --------------------------------------------------------
char *__cdecl sub_1003CA60(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "Node" )
      Stream::print(sysCon, "%s: ", "Node");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1003CB70) --------------------------------------------------------
int CoreNode::getAgeNodeType()
{
  return 2;
}

//----- (1003CBB0) --------------------------------------------------------
void __thiscall CoreNode::genAgeNode(CoreNode *this, struct AgeServer *a2)
{
  char *v2; // [esp+4Ch] [ebp-Ch]
  CoreNode *i; // [esp+50h] [ebp-8h]
  CoreNode *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  if ( CoreNode::getName(this) )
    v2 = CoreNode::getName(v4);
  else
    v2 = "NULL";
  AgeServer::NewNode(a2, v2, v4);
  for ( i = v4->Child; i; i = i->Next )
    (*(i->vtblPointer + 4))(i, a2);
  AgeServer::EndNode(a2);
}

//----- (1003CC70) --------------------------------------------------------
void __thiscall CoreNode::genRead(CoreNode *this, struct AgeServer *a2)
{
  char v2; // [esp+0h] [ebp-124h]
  char v3; // [esp+4Ch] [ebp-D8h]
  char v4; // [esp+78h] [ebp-ACh]
  char v5; // [esp+98h] [ebp-8Ch]
  char *v6; // [esp+9Ch] [ebp-88h]
  CoreNode *v7; // [esp+120h] [ebp-4h]

  v7 = this;
  sub_10002B7B(&v5);
  if ( AgeServer::getOpenFilename(a2, &v5, "All Files (*.*)|*.*") )
  {
    AtxFileStream::AtxFileStream(&v4);
    sub_1003CA60("Trying to open file '%s'\n", v6);
    if ( AtxFileStream::open(&v4, v6, 1u) )
    {
      sub_1003CA60("opened file ...\n", v2);
      BufferedStream::BufferedStream(&v3, &v4, 0x8000);
      sub_1003CA60("reading file ...\n", v2);
      (*(v7->vtblPointer + 16))(v7, &v3);
      sub_1003CA60("closing file ...\n", v2);
      AtxFileStream::close(&v4);
      AgeServer::RefreshNode(a2);
    }
    else
    {
      sub_1003CA60("cant open file '%s'\n", v6);
    }
  }
}
// 10002B7B: using guessed type int __thiscall sub_10002B7B(_DWORD);

//----- (1003CDE0) --------------------------------------------------------
void __thiscall CoreNode::genWrite(CoreNode *this, struct AgeServer *a2)
{
  char v2; // [esp+0h] [ebp-F8h]
  char v3; // [esp+4Ch] [ebp-ACh]
  char v4; // [esp+6Ch] [ebp-8Ch]
  char *v5; // [esp+70h] [ebp-88h]
  CoreNode *v6; // [esp+F4h] [ebp-4h]

  v6 = this;
  sub_10002B7B(&v4);
  if ( AgeServer::getSaveFilename(a2, &v4, "All Files (*.*)|*.*") )
  {
    AtxFileStream::AtxFileStream(&v3);
    if ( AtxFileStream::open(&v3, v5, 2u) )
    {
      sub_1003CA60("saving as '%s'\n", v5);
      (*(v6->vtblPointer + 12))(v6, &v3);
      AtxFileStream::close(&v3);
      sub_1003CA60("closed file\n", v2);
    }
    else
    {
      sub_1003CA60("cant save file '%s'\n", v5);
    }
  }
}
// 10002B7B: using guessed type int __thiscall sub_10002B7B(_DWORD);

//----- (1003CF10) --------------------------------------------------------
void __thiscall CoreNode::genAge(CoreNode *this, struct AgeServer *a2)
{
  int v2; // [esp+4Ch] [ebp-28h]
  int v3; // [esp+50h] [ebp-24h]
  CoreNode *v4; // [esp+64h] [ebp-10h]

  v4 = this;
  AgeServer::StartSection(a2, "Node", 1);
  AgeServer::StartGroup(a2, "Node");
  if ( sub_10002A81(0xCu) )
    v3 = sub_10002824(v4, CoreNode::genRead);
  else
    v3 = 0;
  AgeServer::NewButton("Load", v3, 120);
  if ( sub_10002A81(0xCu) )
    v2 = sub_10002824(v4, CoreNode::genWrite);
  else
    v2 = 0;
  AgeServer::NewButton("Save", v2, 120);
  AgeServer::EndGroup(a2);
  AgeServer::EndSection(a2);
}
// 10001451: using guessed type _DWORD __stdcall AgeServer::NewButton(_DWORD, _DWORD, _DWORD);
// 10002824: using guessed type _DWORD __stdcall sub_10002824(_DWORD, _DWORD);

//----- (1003D090) --------------------------------------------------------
void __thiscall Node::init(Node *this, char *a2)
{
  Node *v2; // ST50_4

  v2 = this;
  CoreNode::initCore(this, a2);
  Node::setFlags(v2, 3);
  v2->dword1C = -1;
}

//----- (1003D100) --------------------------------------------------------
void __thiscall Node::update(Node *this)
{
  Node *i; // [esp+4Ch] [ebp-8h]

  for ( i = this->child; i; i = i->next )
  {
    if ( Node::getFlag(i, 1) )
    {
      (*(i->pVtbl + 44))(i);
      (*(i->pVtbl + 20))(i);
    }
  }
}

//----- (1003D1B0) --------------------------------------------------------
void __thiscall Node::draw(Node *this, struct Graphics *a2)
{
  CoreNode *i; // [esp+4Ch] [ebp-8h]
  Node *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  for ( i = this->child; i; i = i->Next )
    (*(i->vtblPointer + 24))(i, a2);
}

//----- (1003D230) --------------------------------------------------------
void __thiscall Node::render(Node *this, struct Graphics *a2)
{
  Node *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(this->pVtbl + 24))(this, a2);
}

//----- (1003D290) --------------------------------------------------------
Node *__thiscall SRTNode::SRTNode(SRTNode *this, char *a2)
{
  struct Vector3f *v2; // eax
  struct Vector3f *v3; // eax
  struct Vector3f *v4; // eax
  float v6; // [esp+4Ch] [ebp-4Ch]
  float v7; // [esp+50h] [ebp-48h]
  float v8; // [esp+54h] [ebp-44h]
  char v9; // [esp+58h] [ebp-40h]
  float v10; // [esp+64h] [ebp-34h]
  float v11; // [esp+68h] [ebp-30h]
  float v12; // [esp+6Ch] [ebp-2Ch]
  char v13; // [esp+70h] [ebp-28h]
  float v14; // [esp+7Ch] [ebp-1Ch]
  float v15; // [esp+80h] [ebp-18h]
  float v16; // [esp+84h] [ebp-14h]
  char v17; // [esp+88h] [ebp-10h]
  Node *v18; // [esp+94h] [ebp-4h]

  v18 = this;
  Node::Node(this, a2);
  Matrix4f::Matrix4f(&v18[1]);
  SRT::SRT(&v18[3]);
  v18->pVtbl = &SRTNode::`vftable';
  v16 = 0.0;
  v15 = 0.0;
  v14 = 0.0;
  v2 = Vector3f::Vector3f(&v17, &v14, &v15, &v16);
  SRTNode::setPosition(v18, v2);
  v12 = 1.0;
  v11 = 1.0;
  v10 = 1.0;
  v3 = Vector3f::Vector3f(&v13, &v10, &v11, &v12);
  SRTNode::setScale(v18, v3);
  v8 = 0.0;
  v7 = 0.0;
  v6 = 0.0;
  v4 = Vector3f::Vector3f(&v9, &v6, &v7, &v8);
  SRTNode::setRotation(v18, v4);
  return v18;
}
// 101AD898: using guessed type void *SRTNode::`vftable';

//----- (1003D3D0) --------------------------------------------------------
void __thiscall SRTNode::update(SRTNode *this)
{
  Node *i; // [esp+4Ch] [ebp-8h]
  SRTNode *v2; // [esp+50h] [ebp-4h]

  v2 = this;
  for ( i = *(this + 4); i; i = i->next )
  {
    if ( Node::getFlag(i, 1) )
    {
      (*(i->pVtbl + 32))(i, v2 + 32);
      (*(i->pVtbl + 20))(i);
    }
  }
}

//----- (1003D480) --------------------------------------------------------
void __thiscall SRTNode::genAge(SRTNode *this, struct AgeServer *a2)
{
  struct Vector3f *v2; // ST0C_4
  struct Vector3f *v3; // eax
  struct Vector3f *v4; // ST0C_4
  struct Vector3f *v5; // eax
  struct Vector3f *v6; // ST0C_4
  struct Vector3f *v7; // eax
  float v8; // [esp+4Ch] [ebp-94h]
  float v9; // [esp+50h] [ebp-90h]
  float v10; // [esp+54h] [ebp-8Ch]
  char v11; // [esp+58h] [ebp-88h]
  float v12; // [esp+64h] [ebp-7Ch]
  float v13; // [esp+68h] [ebp-78h]
  float v14; // [esp+6Ch] [ebp-74h]
  char v15; // [esp+70h] [ebp-70h]
  float v16; // [esp+7Ch] [ebp-64h]
  float v17; // [esp+80h] [ebp-60h]
  float v18; // [esp+84h] [ebp-5Ch]
  char v19; // [esp+88h] [ebp-58h]
  float v20; // [esp+94h] [ebp-4Ch]
  float v21; // [esp+98h] [ebp-48h]
  float v22; // [esp+9Ch] [ebp-44h]
  char v23; // [esp+A0h] [ebp-40h]
  float v24; // [esp+ACh] [ebp-34h]
  float v25; // [esp+B0h] [ebp-30h]
  float v26; // [esp+B4h] [ebp-2Ch]
  char v27; // [esp+B8h] [ebp-28h]
  float v28; // [esp+C4h] [ebp-1Ch]
  float v29; // [esp+C8h] [ebp-18h]
  float v30; // [esp+CCh] [ebp-14h]
  char v31; // [esp+D0h] [ebp-10h]
  CoreNode *v32; // [esp+DCh] [ebp-4h]

  v32 = this;
  AgeServer::StartSection(a2, "SRTNode", 1);
  v30 = 2.0;
  v29 = 2.0;
  v28 = 2.0;
  v26 = 0.0;
  v25 = 0.0;
  v24 = 0.0;
  v2 = Vector3f::Vector3f(&v31, &v28, &v29, &v30);
  v3 = Vector3f::Vector3f(&v27, &v24, &v25, &v26);
  Vector3f::genAge(&v32[4].Child, a2, "S", v3, v2);
  v22 = 3.1415927;
  v21 = 3.1415927;
  v20 = 3.1415927;
  v18 = -3.1415927;
  v17 = -3.1415927;
  v16 = -3.1415927;
  v4 = Vector3f::Vector3f(&v23, &v20, &v21, &v22);
  v5 = Vector3f::Vector3f(&v19, &v16, &v17, &v18);
  Vector3f::genAge(&v32[5].Parent, a2, "R", v5, v4);
  v14 = 1000.0;
  v13 = 1000.0;
  v12 = 1000.0;
  v10 = -1000.0;
  v9 = -1000.0;
  v8 = -1000.0;
  v6 = Vector3f::Vector3f(&v15, &v12, &v13, &v14);
  v7 = Vector3f::Vector3f(&v11, &v8, &v9, &v10);
  Vector3f::genAge(&v32[6], a2, "T", v7, v6);
  AgeServer::EndSection(a2);
  CoreNode::genAge(v32, a2);
}

//----- (1003D6A0) --------------------------------------------------------
void __thiscall NodeMgr::Del(NodeMgr *this, struct Node *a2)
{
  struct CoreNode *v2; // eax
  CoreNode *v3; // [esp+4Ch] [ebp-Ch]
  struct CoreNode *v4; // [esp+50h] [ebp-8h]

  *this = 1;
  if ( a2 && a2->parent )
  {
    v4 = a2->parent->Child;
    v3 = 0;
    while ( v4 )
    {
      if ( v4 == a2 )
      {
        if ( v3 )
        {
          v2 = CoreNode::Next(v4);
          CoreNode::Next(v3, v2);
          return;
        }
        a2->parent->Child = CoreNode::Next(v4);
      }
      v3 = v4;
      v4 = CoreNode::Next(v4);
    }
  }
}

//----- (1003D780) --------------------------------------------------------
void __thiscall NodeMgr::recFindNode(NodeMgr *this, struct CoreNode *a2, char *Str1)
{
  CoreNode *i; // [esp+4Ch] [ebp-8h]

  if ( !byte_101CB084 )
  {
    for ( i = a2; i; i = CoreNode::Next(i) )
    {
      if ( !strcmp(Str1, i->name) )
      {
        byte_101CB084 = 1;
        stru_101CB088.vtblPointer = i;
        return;
      }
      if ( i->Child )
        NodeMgr::recFindNode(this, i->Child, Str1);
    }
  }
}
// 101CB084: using guessed type char byte_101CB084;

//----- (1003D850) --------------------------------------------------------
struct CoreNode *__thiscall NodeMgr::findNode(NodeMgr *this, char *a2, struct CoreNode *a3)
{
  NodeMgr *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  stru_101CB088.vtblPointer = 0;
  byte_101CB084 = 0;
  if ( !a3 )
    a3 = NodeMgr::firstNode(this);
  NodeMgr::recFindNode(v4, a3, a2);
  return stru_101CB088.vtblPointer;
}
// 101CB084: using guessed type char byte_101CB084;

//----- (1003D8D0) --------------------------------------------------------
struct_this *__thiscall NodeMgr::NodeMgr(int this)
{
  int v1; // ST50_4

  v1 = this;
  CoreNode::CoreNode((this + 4), "CoreNode");
  *v1 = 0;
  return v1;
}

//----- (1003D930) --------------------------------------------------------
void NodeMgr::~NodeMgr()
{
  ;
}

//----- (1003D960) --------------------------------------------------------
char *__thiscall sub_1003D960(String *this)
{
  char *v1; // ST54_4

  v1 = this;
  String::String(this);
  String::init(v1, v1 + 8, 128);
  return v1;
}

//----- (1003D9C0) --------------------------------------------------------
_DWORD *__thiscall sub_1003D9C0(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10001D43(this);
  *v3 = &off_101AF0F0;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10001D43: using guessed type int __thiscall sub_10001D43(_DWORD);
// 101AF0F0: using guessed type int (__stdcall *off_101AF0F0)(int);

//----- (1003DA30) --------------------------------------------------------
int __thiscall sub_1003DA30(int this, int a2)
{
  int v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  return (*(this + 8))(*(this + 4), a2);
}

//----- (1003DA90) --------------------------------------------------------
int sub_1003DA90()
{
  return sub_1003DAD0();
}

//----- (1003DAD0) --------------------------------------------------------
int sub_1003DAD0()
{
  return Matrix4f::Matrix4f(&Matrix4f::ident);
}

//----- (1003DB10) --------------------------------------------------------
Matrix4f *__thiscall Matrix4f::Matrix4f(Matrix4f *this, float (*const a2)[4])
{
  signed int j; // [esp+4Ch] [ebp-Ch]
  signed int i; // [esp+50h] [ebp-8h]

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
      *(this + 4 * i + j) = LODWORD((*a2)[4 * i + j]);
  }
  return this;
}

//----- (1003DBB0) --------------------------------------------------------
void __thiscall Matrix4f::makeIdentity(Matrix4f *this)
{
  *this = 1065353216;
  *(this + 1) = 0;
  *(this + 2) = 0;
  *(this + 3) = 0;
  *(this + 4) = 0;
  *(this + 5) = 1065353216;
  *(this + 6) = 0;
  *(this + 7) = 0;
  *(this + 8) = 0;
  *(this + 9) = 0;
  *(this + 10) = 1065353216;
  *(this + 11) = 0;
  *(this + 12) = 0;
  *(this + 13) = 0;
  *(this + 14) = 0;
  *(this + 15) = 1065353216;
}

//----- (1003DCB0) --------------------------------------------------------
void __thiscall Matrix4f::blend(Matrix4f *this, struct Matrix4f *a2, float a3)
{
  signed int j; // [esp+4Ch] [ebp-Ch]
  signed int i; // [esp+50h] [ebp-8h]

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
      *(this + 4 * i + j) = (*(a2 + 4 * i + j) - *(this + 4 * i + j)) * a3 + *(this + 4 * i + j);
  }
}

//----- (1003DD80) --------------------------------------------------------
void __thiscall Matrix4f::makeOrtho(Matrix4f *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  signed int j; // [esp+4Ch] [ebp-Ch]
  signed int i; // [esp+50h] [ebp-8h]
  Matrix4f *v10; // [esp+54h] [ebp-4h]

  v10 = this;
  Matrix4f::makeIdentity(this);
  *v10 = 2.0 / (a3 - a2);
  *(v10 + 5) = 2.0 / (a5 - a4);
  *(v10 + 10) = -2.0 / (a7 - a6);
  *(v10 + 12) = -(a3 + a2) / (a3 - a2);
  *(v10 + 13) = -(a5 + a4) / (a5 - a4);
  *(v10 + 14) = -(a7 + a6) / (a7 - a6);
  *(v10 + 15) = 1065353216;
  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
      *(v10 + 4 * i + j) = a8 * *(v10 + 4 * i + j);
  }
}

//----- (1003DEE0) --------------------------------------------------------
void __thiscall Matrix4f::makePerspective(Matrix4f *this, float a2, float a3, float a4, float a5)
{
  Matrix4f *v5; // ST58_4
  double v6; // st7
  double v7; // st7
  float v8; // ST00_4
  float v9; // ST50_4
  double v10; // st7
  float v11; // ST00_4
  float v12; // ST54_4
  float v13; // [esp+64h] [ebp+8h]

  v5 = this;
  v6 = a2 * 0.017453292;
  v13 = v6;
  v7 = v6 / 2.0;
  v8 = v7;
  sub_10002D47(v8);
  v9 = v7;
  v10 = v13 / 2.0;
  v11 = v10;
  sub_10002635(v11);
  v12 = v9 / v10;
  Matrix4f::makeIdentity(v5);
  *v5 = v12 / a3;
  *(v5 + 5) = v12;
  *(v5 + 10) = (a4 + a5) / (a4 - a5);
  *(v5 + 11) = -1082130432;
  *(v5 + 14) = 2.0 * a4 * a5 / (a4 - a5);
  *(v5 + 15) = 0;
}

//----- (1003DFE0) --------------------------------------------------------
void __thiscall Matrix4f::makeRotate(Matrix4f *this, struct Vector3f *a2, float a3, float a4)
{
  float v4; // ST58_4
  float v5; // ST54_4
  float v6; // ST50_4
  double v7; // st7
  float v8; // ST5C_4

  v4 = *a2;
  v5 = *(a2 + 1);
  v6 = *(a2 + 2);
  v7 = 1.0 - a4;
  v8 = v7;
  *this = v7 * v4 * v4 + a4;
  *(this + 1) = v8 * v4 * v5 + a3 * v6;
  *(this + 2) = v8 * v4 * v6 - a3 * v5;
  *(this + 3) = 0;
  *(this + 4) = v8 * v4 * v5 - a3 * v6;
  *(this + 5) = v8 * v5 * v5 + a4;
  *(this + 6) = v8 * v5 * v6 + a3 * v4;
  *(this + 7) = 0;
  *(this + 8) = v8 * v4 * v6 + a3 * v5;
  *(this + 9) = v8 * v5 * v6 - a3 * v4;
  *(this + 10) = v8 * v6 * v6 + a4;
  *(this + 11) = 0;
  *(this + 12) = 0;
  *(this + 13) = 0;
  *(this + 14) = 0;
  *(this + 15) = 1065353216;
}

//----- (1003E190) --------------------------------------------------------
void __userpurge Matrix4f::makeRotate(Matrix4f *this@<ecx>, double a2@<st0>, struct Vector3f *a3, float a4)
{
  Matrix4f *v4; // ST60_4
  float v5; // ST5C_4
  float v6; // ST58_4

  v4 = this;
  sub_10002635(a4);
  v5 = a2;
  sub_10002D47(a4);
  v6 = a2;
  Matrix4f::makeRotate(v4, a3, v5, v6);
}

//----- (1003E210) --------------------------------------------------------
void __thiscall Matrix4f::makeBallRotate(Matrix4f *this, struct Vector3f *a2)
{
  double v2; // st7
  float v3; // ST08_4
  float v4; // [esp+50h] [ebp-28h]
  float v5; // [esp+54h] [ebp-24h]
  float v6; // [esp+58h] [ebp-20h]
  float v7; // [esp+5Ch] [ebp-1Ch]
  float v8; // [esp+60h] [ebp-18h]
  float v9; // [esp+64h] [ebp-14h]
  float v10; // [esp+68h] [ebp-10h]
  float v11; // [esp+6Ch] [ebp-Ch]
  float v12; // [esp+70h] [ebp-8h]
  Matrix4f *v13; // [esp+74h] [ebp-4h]

  v13 = this;
  v12 = 3.1415927;
  Vector3f::Vector3f(&v5);
  v4 = *a2 * *a2 + *(a2 + 1) * *(a2 + 1) + *(a2 + 2) * *(a2 + 2);
  if ( v4 > 0.01 )
  {
    sub_1000122B(v4);
    v9 = v4;
    v2 = v12 * v12 + v9 * v9;
    v3 = v2;
    sub_1000122B(v3);
    v8 = v2;
    v11 = v12 / v8;
    v10 = v9 / v8;
    v5 = *(a2 + 1) / v9;
    v6 = *a2 / v9;
    v7 = *(a2 + 2) / v9;
    Matrix4f::makeRotate(v13, &v5, v10, v11);
  }
}

//----- (1003E340) --------------------------------------------------------
void __thiscall Matrix4f::rotate(Matrix4f *this, struct Vector3f *a2, float a3)
{
  char v3; // [esp+4Ch] [ebp-44h]
  Matrix4f *v4; // [esp+8Ch] [ebp-4h]

  v4 = this;
  Matrix4f::Matrix4f(&v3);
  Matrix4f::makeRotate(&v3, a2, a3);
  Matrix4f::multiply(v4, &v3);
}

//----- (1003E3C0) --------------------------------------------------------
void __thiscall Matrix4f::rotate(Matrix4f *this, float a2, float a3, float a4)
{
  struct Vector3f *v4; // eax
  struct Vector3f *v5; // eax
  struct Vector3f *v6; // eax
  float v7; // [esp+4Ch] [ebp-4Ch]
  float v8; // [esp+50h] [ebp-48h]
  float v9; // [esp+54h] [ebp-44h]
  char v10; // [esp+58h] [ebp-40h]
  float v11; // [esp+64h] [ebp-34h]
  float v12; // [esp+68h] [ebp-30h]
  float v13; // [esp+6Ch] [ebp-2Ch]
  char v14; // [esp+70h] [ebp-28h]
  float v15; // [esp+7Ch] [ebp-1Ch]
  float v16; // [esp+80h] [ebp-18h]
  float v17; // [esp+84h] [ebp-14h]
  char v18; // [esp+88h] [ebp-10h]
  Matrix4f *v19; // [esp+94h] [ebp-4h]

  v19 = this;
  v17 = 0.0;
  v16 = 0.0;
  v15 = 1.0;
  v4 = Vector3f::Vector3f(&v18, &v15, &v16, &v17);
  Matrix4f::rotate(v19, v4, a2);
  v13 = 0.0;
  v12 = 1.0;
  v11 = 0.0;
  v5 = Vector3f::Vector3f(&v14, &v11, &v12, &v13);
  Matrix4f::rotate(v19, v5, a3);
  v9 = 1.0;
  v8 = 0.0;
  v7 = 0.0;
  v6 = Vector3f::Vector3f(&v10, &v7, &v8, &v9);
  Matrix4f::rotate(v19, v6, a4);
}

//----- (1003E4E0) --------------------------------------------------------
void __thiscall Matrix4f::multiply(Matrix4f *this, struct Matrix4f *a2)
{
  signed int k; // [esp+4Ch] [ebp-50h]
  signed int j; // [esp+50h] [ebp-4Ch]
  signed int i; // [esp+54h] [ebp-48h]
  char v5[64]; // [esp+58h] [ebp-44h]
  Matrix4f *v6; // [esp+98h] [ebp-4h]

  v6 = this;
  Matrix4f::Matrix4f(v5);
  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
    {
      *&v5[16 * i + 4 * j] = 0;
      for ( k = 0; k < 4; ++k )
        *&v5[16 * i + 4 * j] = *(v6 + 4 * i + k) * *(a2 + 4 * k + j) + *&v5[16 * i + 4 * j];
    }
  }
  qmemcpy(v6, v5, 0x40u);
}
// 1003E4E0: using guessed type char var_44[64];

//----- (1003E620) --------------------------------------------------------
void __thiscall Matrix4f::multiplyTo(Matrix4f *this, struct Matrix4f *a2, struct Matrix4f *a3)
{
  signed int k; // [esp+4Ch] [ebp-10h]
  signed int j; // [esp+50h] [ebp-Ch]
  signed int i; // [esp+54h] [ebp-8h]

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
    {
      *(a3 + 4 * i + j) = 0;
      for ( k = 0; k < 4; ++k )
        *(a3 + 4 * i + j) = *(this + 4 * i + k) * *(a2 + 4 * k + j) + *(a3 + 4 * i + j);
    }
  }
}

//----- (1003E730) --------------------------------------------------------
void __userpurge Matrix4f::makeSRT(Matrix4f *this@<ecx>, double a2@<st0>, struct Vector3f *a3, struct Vector3f *a4, struct Vector3f *a5)
{
  Matrix4f *v5; // ST74_4
  float v6; // ST68_4
  float v7; // ST6C_4
  float v8; // ST70_4
  float v9; // ST5C_4
  float v10; // ST60_4
  float v11; // ST64_4
  float v12; // ST58_4
  float v13; // ST54_4
  float v14; // ST50_4

  v5 = this;
  sub_10002635(*a4);
  v6 = a2;
  sub_10002635(*(a4 + 1));
  v7 = a2;
  sub_10002635(*(a4 + 2));
  v8 = a2;
  sub_10002D47(*a4);
  v9 = a2;
  sub_10002D47(*(a4 + 1));
  v10 = a2;
  sub_10002D47(*(a4 + 2));
  v11 = a2;
  v12 = v9 * v11;
  v13 = v6 * v7;
  v14 = v9 * v8;
  *v5 = v10 * v11 * *a3;
  *(v5 + 4) = v10 * v8 * *a3;
  *(v5 + 8) = -v7 * *a3;
  *(v5 + 14) = 0;
  *(v5 + 13) = 0;
  *(v5 + 12) = 0;
  *(v5 + 1) = (v13 * v11 - v14) * *(a3 + 1);
  *(v5 + 5) = (v13 * v8 + v12) * *(a3 + 1);
  *(v5 + 9) = v6 * v10 * *(a3 + 1);
  *(v5 + 2) = (v12 * v7 + v6 * v8) * *(a3 + 2);
  *(v5 + 6) = (v14 * v7 - v6 * v11) * *(a3 + 2);
  *(v5 + 10) = v9 * v10 * *(a3 + 2);
  *(v5 + 3) = *a5;
  *(v5 + 7) = *(a5 + 1);
  *(v5 + 11) = *(a5 + 2);
  *(v5 + 15) = 1065353216;
}

//----- (1003E950) --------------------------------------------------------
void __userpurge Matrix4f::makeConcatSRT(Matrix4f *this@<ecx>, double a2@<st0>, struct Matrix4f *a3, struct Matrix4f *a4, struct SRT *a5)
{
  struct Matrix4f *v5; // ST78_4
  float v6; // ST6C_4
  float v7; // ST70_4
  float v8; // ST74_4
  float v9; // ST60_4
  float v10; // ST64_4
  float v11; // ST68_4
  float v12; // ST5C_4
  float v13; // ST58_4
  float v14; // ST54_4

  v5 = this;
  sub_10002635(*(a5 + 3));
  v6 = a2;
  sub_10002635(*(a5 + 4));
  v7 = a2;
  sub_10002635(*(a5 + 5));
  v8 = a2;
  sub_10002D47(*(a5 + 3));
  v9 = a2;
  sub_10002D47(*(a5 + 4));
  v10 = a2;
  sub_10002D47(*(a5 + 5));
  v11 = a2;
  v12 = v9 * v11;
  v13 = v6 * v7;
  v14 = v9 * v8;
  *a4 = v10 * v11 * *a5;
  *(a4 + 4) = v10 * v8 * *a5;
  *(a4 + 8) = -v7 * *a5;
  *(a4 + 1) = (v13 * v11 - v14) * *(a5 + 1);
  *(a4 + 5) = (v13 * v8 + v12) * *(a5 + 1);
  *(a4 + 9) = v6 * v10 * *(a5 + 1);
  *(a4 + 2) = (v12 * v7 + v6 * v8) * *(a5 + 2);
  *(a4 + 6) = (v14 * v7 - v6 * v11) * *(a5 + 2);
  *(a4 + 10) = v9 * v10 * *(a5 + 2);
  *(a4 + 3) = *(a5 + 6);
  *(a4 + 7) = *(a5 + 7);
  *(a4 + 11) = *(a5 + 8);
  *(a4 + 12) = 0;
  *(a4 + 13) = 0;
  *(a4 + 14) = 0;
  *(a4 + 15) = 1065353216;
  Matrix4f::multiplyTo(a3, a4, v5);
}

//----- (1003EB90) --------------------------------------------------------
void __thiscall Matrix4f::inverse(Matrix4f *this, struct Matrix4f *a2)
{
  float v2; // ST50_4
  float v3; // [esp+4Ch] [ebp-4Ch]
  struct Matrix4f *v4; // [esp+50h] [ebp-48h]
  char v5; // [esp+54h] [ebp-44h]
  float *v6; // [esp+94h] [ebp-4h]

  v6 = this;
  Matrix4f::Matrix4f(&v5);
  if ( a2 == v6 )
    v4 = &v5;
  else
    v4 = a2;
  v3 = *v6 * v6[5] * v6[10]
     + v6[1] * v6[6] * v6[8]
     + v6[2] * v6[4] * v6[9]
     - v6[8] * v6[5] * v6[2]
     - v6[4] * v6[1] * v6[10]
     - *v6 * v6[9] * v6[6];
  if ( v3 == 0.0 )
  {
    Matrix4f::makeIdentity(v4);
    *(v4 + 3) = -v6[3];
    *(v4 + 7) = -v6[7];
    *(v4 + 11) = -v6[11];
  }
  else
  {
    v2 = 1.0 / v3;
    *v4 = (v6[5] * v6[10] - v6[9] * v6[6]) * v2;
    *(v4 + 1) = -(v6[1] * v6[10] - v6[9] * v6[2]) * v2;
    *(v4 + 2) = (v6[1] * v6[6] - v6[5] * v6[2]) * v2;
    *(v4 + 4) = -(v6[4] * v6[10] - v6[8] * v6[6]) * v2;
    *(v4 + 5) = (*v6 * v6[10] - v6[8] * v6[2]) * v2;
    *(v4 + 6) = -(*v6 * v6[6] - v6[4] * v6[2]) * v2;
    *(v4 + 8) = (v6[4] * v6[9] - v6[8] * v6[5]) * v2;
    *(v4 + 9) = -(*v6 * v6[9] - v6[8] * v6[1]) * v2;
    *(v4 + 10) = (*v6 * v6[5] - v6[4] * v6[1]) * v2;
    *(v4 + 3) = -*v4 * v6[3] - *(v4 + 1) * v6[7] - *(v4 + 2) * v6[11];
    *(v4 + 7) = -*(v4 + 4) * v6[3] - *(v4 + 5) * v6[7] - *(v4 + 6) * v6[11];
    *(v4 + 11) = -*(v4 + 8) * v6[3] - *(v4 + 9) * v6[7] - *(v4 + 10) * v6[11];
  }
  *(v4 + 12) = 0;
  *(v4 + 13) = 0;
  *(v4 + 14) = 0;
  *(v4 + 15) = 1065353216;
  if ( v4 == &v5 )
    qmemcpy(a2, &v5, 0x40u);
}

//----- (1003EF50) --------------------------------------------------------
void __thiscall Matrix4f::makeAligned(Matrix4f *this, struct Vector3f *a2, float a3)
{
  double v3; // st7
  float v4; // ST00_4
  float v5; // ST5C_4
  float v6; // [esp+50h] [ebp-14h]
  float v7; // [esp+54h] [ebp-10h]
  float v8; // [esp+58h] [ebp-Ch]
  Matrix4f *v9; // [esp+60h] [ebp-4h]

  v9 = this;
  v3 = *a2 * *a2 + *(a2 + 2) * *(a2 + 2);
  v4 = v3;
  sub_1000122B(v4);
  v8 = v3;
  sub_10002635(a3);
  v6 = v3;
  sub_10002D47(a3);
  v7 = v3;
  if ( v8 <= 0.00001 )
  {
    *v9 = 1065353216;
    *(v9 + 4) = 0;
    *(v9 + 8) = 0;
    *(v9 + 12) = 0;
    *(v9 + 1) = 0;
    *(v9 + 5) = 0;
    *(v9 + 9) = -1082130432;
    *(v9 + 13) = 0;
    *(v9 + 2) = 0;
    *(v9 + 6) = *(a2 + 1);
    *(v9 + 10) = 0;
  }
  else
  {
    v5 = 1.0 / v8;
    *v9 = (v7 * *(a2 + 2) - -*(a2 + 1) * v6 * -*a2) * v5;
    *(v9 + 4) = (-*(a2 + 2) * v6 - -*(a2 + 1) * v7 * -*a2) * v5;
    *(v9 + 8) = *a2;
    *(v9 + 12) = 0;
    *(v9 + 1) = v6 * v8;
    *(v9 + 5) = v7 * v8;
    *(v9 + 9) = *(a2 + 1);
    *(v9 + 13) = 0;
    *(v9 + 2) = (-*a2 * v7 - -*(a2 + 1) * v6 * -*(a2 + 2)) * v5;
    *(v9 + 6) = (-v6 * -*a2 - -*(a2 + 1) * v7 * -*(a2 + 2)) * v5;
    *(v9 + 10) = *(a2 + 2);
  }
  *(v9 + 14) = 0;
  *(v9 + 3) = 0;
  *(v9 + 7) = 0;
  *(v9 + 11) = 0;
  *(v9 + 15) = 1065353216;
}

//----- (1003F250) --------------------------------------------------------
void __thiscall Matrix4f::rotateX(Matrix4f *this, float a2)
{
  float *v2; // ST6C_4
  float v3; // ST68_4
  float v4; // ST64_4
  float v5; // ST60_4
  float v6; // ST5C_4
  float v7; // ST58_4
  float v8; // ST54_4

  v2 = this;
  v3 = sin(a2);
  v4 = cos(a2);
  v5 = v2[4];
  v2[4] = v5 * v4 + -v3 * v2[8];
  v6 = v2[5];
  v2[5] = v6 * v4 + -v3 * v2[9];
  v7 = v2[6];
  v2[6] = v7 * v4 + -v3 * v2[10];
  v8 = v2[7];
  v2[7] = v8 * v4 + -v3 * v2[11];
  v2[8] = v5 * v3 + v4 * v2[8];
  v2[9] = v6 * v3 + v4 * v2[9];
  v2[10] = v7 * v3 + v4 * v2[10];
  v2[11] = v8 * v3 + v4 * v2[11];
}

//----- (1003F3E0) --------------------------------------------------------
void __thiscall Matrix4f::rotateY(Matrix4f *this, float a2)
{
  float *v2; // ST6C_4
  float v3; // ST68_4
  float v4; // ST64_4
  float v5; // ST60_4
  float v6; // ST5C_4
  float v7; // ST58_4
  float v8; // ST54_4

  v2 = this;
  v3 = sin(a2);
  v4 = cos(a2);
  v5 = *v2;
  *v2 = *v2 * v4 + v3 * v2[8];
  v6 = v2[1];
  v2[1] = v6 * v4 + v3 * v2[9];
  v7 = v2[2];
  v2[2] = v7 * v4 + v3 * v2[10];
  v8 = v2[3];
  v2[3] = v8 * v4 + v3 * v2[11];
  v2[10] = -v3 * v5 + v4 * v2[8];
  v2[9] = -v3 * v6 + v4 * v2[9];
  v2[10] = -v3 * v7 + v4 * v2[10];
  v2[11] = -v3 * v8 + v4 * v2[11];
}

//----- (1003F570) --------------------------------------------------------
void __thiscall Matrix4f::rotateZ(Matrix4f *this, float a2)
{
  float *v2; // ST6C_4
  float v3; // ST68_4
  float v4; // ST64_4
  float v5; // ST60_4
  float v6; // ST5C_4
  float v7; // ST58_4
  float v8; // ST54_4

  v2 = this;
  v3 = sin(a2);
  v4 = cos(a2);
  v5 = *v2;
  *v2 = *v2 * v4 + -v3 * v2[4];
  v6 = v2[1];
  v2[1] = v6 * v4 + -v3 * v2[5];
  v7 = v2[2];
  v2[2] = v7 * v4 + -v3 * v2[6];
  v8 = v2[3];
  v2[3] = v8 * v4 + -v3 * v2[7];
  v2[4] = v5 * v3 + v4 * v2[4];
  v2[5] = v6 * v3 + v4 * v2[5];
  v2[6] = v7 * v3 + v4 * v2[6];
  v2[7] = v8 * v3 + v4 * v2[7];
}

//----- (1003F700) --------------------------------------------------------
void __thiscall Matrix4f::translate(Matrix4f *this, float a2, float a3, float a4)
{
  float *v4; // ST50_4

  v4 = this;
  *this = a2 * *(this + 12) + *this;
  v4[1] = a2 * v4[13] + v4[1];
  v4[2] = a2 * v4[14] + v4[2];
  v4[3] = a2 * v4[15] + v4[3];
  v4[4] = a3 * v4[12] + v4[4];
  v4[5] = a3 * v4[13] + v4[5];
  v4[6] = a3 * v4[14] + v4[6];
  v4[7] = a3 * v4[15] + v4[7];
  v4[8] = a4 * v4[12] + v4[8];
  v4[9] = a4 * v4[13] + v4[9];
  v4[10] = a4 * v4[14] + v4[10];
  *(this + 11) = a4 * v4[15] + v4[11];
}

//----- (1003F870) --------------------------------------------------------
void __thiscall Matrix4f::scale(Matrix4f *this, struct Vector3f *a2)
{
  float *v2; // ST50_4

  v2 = this;
  *this = *this * *a2;
  v2[4] = v2[4] * *a2;
  v2[8] = v2[8] * *a2;
  v2[12] = v2[12] * *a2;
  v2[1] = v2[1] * *(a2 + 1);
  v2[5] = v2[5] * *(a2 + 1);
  v2[9] = v2[9] * *(a2 + 1);
  v2[13] = v2[13] * *(a2 + 1);
  v2[2] = v2[2] * *(a2 + 2);
  v2[6] = v2[6] * *(a2 + 2);
  v2[10] = v2[10] * *(a2 + 2);
  v2[14] = v2[14] * *(a2 + 2);
}

//----- (1003F9B0) --------------------------------------------------------
void __thiscall Matrix4f::makeLookfrom(Matrix4f *this, struct Vector3f *a2, struct Vector3f *a3)
{
  Matrix4f *v3; // ST58_4
  float v4; // ST08_4
  float v5; // ST04_4
  float v6; // ST00_4

  v3 = this;
  Matrix4f::makeIdentity(this);
  v4 = -*(a2 + 2);
  v5 = -*(a2 + 1);
  v6 = -*a2;
  Matrix4f::translate(v3, v6, v5, v4);
  Matrix4f::rotateY(v3, *(a3 + 1));
  Matrix4f::rotateX(v3, *a3);
  Matrix4f::rotateZ(v3, *(a3 + 2));
}

//----- (1003FA70) --------------------------------------------------------
void __thiscall Matrix4f::makeLookat(Matrix4f *this, struct Vector3f *a2, struct Vector3f *a3, struct Vector3f *a4)
{
  float v4; // [esp+4Ch] [ebp-30h]
  float v5; // [esp+50h] [ebp-2Ch]
  int v6; // [esp+54h] [ebp-28h]
  int v7; // [esp+58h] [ebp-24h]
  float v8; // [esp+5Ch] [ebp-20h]
  int v9; // [esp+60h] [ebp-1Ch]
  int v10; // [esp+64h] [ebp-18h]
  float v11; // [esp+68h] [ebp-14h]
  int v12; // [esp+6Ch] [ebp-10h]
  int v13; // [esp+70h] [ebp-Ch]
  float v14; // [esp+74h] [ebp-8h]
  Matrix4f *v15; // [esp+78h] [ebp-4h]

  v15 = this;
  Vector3f::Vector3f(&v12);
  Vector3f::Vector3f(&v9);
  Vector3f::Vector3f(&v6);
  *&v12 = *a2 - *a3;
  *&v13 = *(a2 + 1) - *(a3 + 1);
  v14 = *(a2 + 2) - *(a3 + 2);
  Vector3f::normalise(&v12);
  if ( a4 )
  {
    v6 = *a4;
    v7 = *(a4 + 1);
    v8 = *(a4 + 2);
    v9 = v6;
    v10 = v7;
    v11 = v8;
    Vector3f::CP(&v9, &v12);
    Vector3f::normalise(&v9);
  }
  else
  {
    v5 = -*&v12;
    v4 = 0.0;
    Vector3f::set(&v9, &v14, &v4, &v5);
    Vector3f::normalise(&v9);
    v6 = v12;
    v7 = v13;
    v8 = v14;
    Vector3f::CP(&v6, &v9);
    Vector3f::normalise(&v6);
  }
  Matrix4f::makeLookat(v15, a2, &v9, &v6, &v12);
}

//----- (1003FBF0) --------------------------------------------------------
void __thiscall Matrix4f::makeLookat(Matrix4f *this, struct Vector3f *a2, struct Vector3f *a3, struct Vector3f *a4, struct Vector3f *a5)
{
  Matrix4f *v5; // ST50_4

  v5 = this;
  *this = *a3;
  *(this + 1) = *(a3 + 1);
  *(this + 2) = *(a3 + 2);
  *(this + 3) = -Vector3f::DP(a2, a3);
  *(v5 + 4) = *a4;
  *(v5 + 5) = *(a4 + 1);
  *(v5 + 6) = *(a4 + 2);
  *(v5 + 7) = -Vector3f::DP(a2, a4);
  *(v5 + 8) = *a5;
  *(v5 + 9) = *(a5 + 1);
  *(v5 + 10) = *(a5 + 2);
  *(v5 + 11) = -Vector3f::DP(a2, a5);
  *(v5 + 12) = 0;
  *(v5 + 13) = 0;
  *(v5 + 14) = 0;
  *(v5 + 15) = 1065353216;
}

//----- (1003FD30) --------------------------------------------------------
void __thiscall Matrix4f::makeProjection(Matrix4f *this, struct Vector3f *a2, struct Plane *a3)
{
  *this = -*(a3 + 1) * *(a2 + 1) + -*(a3 + 2) * *(a2 + 2);
  *(this + 1) = *a3 * *(a2 + 1);
  *(this + 2) = *a3 * *(a2 + 2);
  *(this + 3) = 0;
  *(this + 4) = *(a3 + 1) * *a2;
  *(this + 5) = -*a3 * *a2 + -*(a3 + 2) * *(a2 + 2);
  *(this + 6) = *(a3 + 1) * *(a2 + 2);
  *(this + 7) = 0;
  *(this + 8) = *(a3 + 2) * *a2;
  *(this + 9) = *(a3 + 2) * *(a2 + 1);
  *(this + 10) = -*a3 * *a2 + -*(a3 + 1) * *(a2 + 1);
  *(this + 11) = 0;
  *(this + 12) = -*(a3 + 3) * *a2;
  *(this + 13) = -*(a3 + 3) * *(a2 + 1);
  *(this + 14) = -*(a3 + 3) * *(a2 + 2);
  *(this + 15) = -*a3 * *a2 + -*(a3 + 1) * *(a2 + 1) + -*(a3 + 2) * *(a2 + 2);
}

//----- (1003FF10) --------------------------------------------------------
void __thiscall Matrix4f::makeReflection(Matrix4f *this, struct Plane *a2)
{
  double v2; // st7
  double v3; // st7
  double v4; // st7
  double v5; // st7
  double v6; // st7
  double v7; // st7
  double v8; // st7
  double v9; // st7
  double v10; // st7
  double v11; // st7
  float v12; // ST50_4
  char v13; // [esp+50h] [ebp-10h]
  Matrix4f *v14; // [esp+5Ch] [ebp-4h]

  v14 = this;
  v2 = *a2 * *a2;
  *this = 1.0 - (v2 + v2);
  v3 = *a2 * *(a2 + 1);
  *(v14 + 1) = 0.0 - (v3 + v3);
  v4 = *a2 * *(a2 + 2);
  *(v14 + 2) = 0.0 - (v4 + v4);
  *(v14 + 3) = 0;
  v5 = *(a2 + 1) * *a2;
  *(v14 + 4) = 0.0 - (v5 + v5);
  v6 = *(a2 + 1) * *(a2 + 1);
  *(v14 + 5) = 1.0 - (v6 + v6);
  v7 = *(a2 + 1) * *(a2 + 2);
  *(v14 + 6) = 0.0 - (v7 + v7);
  *(v14 + 7) = 0;
  v8 = *(a2 + 2) * *a2;
  *(v14 + 8) = 0.0 - (v8 + v8);
  v9 = *(a2 + 2) * *(a2 + 1);
  *(v14 + 9) = 0.0 - (v9 + v9);
  v10 = *(a2 + 2) * *(a2 + 2);
  *(v14 + 10) = 1.0 - (v10 + v10);
  *(v14 + 11) = 0;
  Vector3f::Vector3f(&v13, a2);
  Vector3f::multiply(&v13, *(a2 + 3));
  v11 = Vector3f::DP(&v13, a2);
  v12 = v11 + v11;
  *(v14 + 12) = v12 * *a2;
  *(v14 + 13) = v12 * *(a2 + 1);
  *(v14 + 14) = v12 * *(a2 + 2);
  *(v14 + 15) = 1065353216;
}

//----- (10040110) --------------------------------------------------------
void __thiscall Matrix4f::transposeTo(Matrix4f *this, struct Matrix4f *a2)
{
  signed int j; // [esp+4Ch] [ebp-Ch]
  signed int i; // [esp+50h] [ebp-8h]

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
      *(a2 + 4 * i + j) = *(this + 4 * j + i);
  }
}

//----- (100401B0) --------------------------------------------------------
void __thiscall Matrix4f::makeVQS(Matrix4f *this, struct Vector3f *a2, struct Quat *a3, struct Vector3f *a4)
{
  float v4; // ST70_4
  float v5; // ST6C_4
  float v6; // ST68_4
  float v7; // ST64_4
  float v8; // ST60_4
  float v9; // ST5C_4
  float v10; // ST58_4
  float v11; // ST54_4
  float v12; // ST50_4

  v4 = 2.0 * *(a3 + 1) * *(a3 + 1);
  v5 = 2.0 * *(a3 + 2) * *(a3 + 2);
  v6 = 2.0 * *a3 * *a3;
  v7 = 2.0 * *a3 * *(a3 + 1);
  v8 = 2.0 * *a3 * *(a3 + 2);
  v9 = 2.0 * *(a3 + 1) * *(a3 + 2);
  v10 = 2.0 * *(a3 + 3) * *(a3 + 2);
  v11 = 2.0 * *(a3 + 3) * *a3;
  v12 = 2.0 * *(a3 + 3) * *(a3 + 1);
  *this = (1.0 - v4 - v5) * *a4;
  *(this + 1) = (v7 - v10) * *(a4 + 1);
  *(this + 2) = (v8 + v12) * *(a4 + 2);
  *(this + 4) = (v7 + v10) * *a4;
  *(this + 5) = (1.0 - v6 - v5) * *(a4 + 1);
  *(this + 6) = (v9 - v11) * *(a4 + 2);
  *(this + 8) = (v8 - v12) * *a4;
  *(this + 9) = (v9 + v11) * *(a4 + 1);
  *(this + 10) = (1.0 - v6 - v4) * *(a4 + 2);
  *(this + 3) = *a2;
  *(this + 7) = *(a2 + 1);
  *(this + 11) = *(a2 + 2);
  *(this + 12) = 0;
  *(this + 13) = 0;
  *(this + 14) = 0;
  *(this + 15) = 1065353216;
}

//----- (10040400) --------------------------------------------------------
bool __thiscall Plane::equal(Plane *this, struct Plane *a2)
{
  float *v3; // [esp+54h] [ebp-4h]

  v3 = this;
  return fabs(*a2 - *this) < 0.00001
      && fabs(*(a2 + 1) - v3[1]) < 0.00001
      && fabs(*(a2 + 2) - v3[2]) < 0.00001
      && fabs(*(a2 + 3) - v3[3]) < 0.01;
}

//----- (10040510) --------------------------------------------------------
double __thiscall Plane::calcRadScale(Plane *this)
{
  double v1; // ST6C_8
  double v2; // ST64_8
  double result; // st7
  double v4; // ST5C_8
  double v5; // ST54_8
  float *v6; // [esp+74h] [ebp-4h]

  v6 = this;
  v1 = fabs(*this);
  if ( fabs(v6[1]) >= v1 || (v2 = fabs(*v6), fabs(v6[2]) >= v2) )
  {
    v4 = fabs(v6[1]);
    if ( fabs(*v6) >= v4 || (v5 = fabs(v6[1]), fabs(v6[2]) >= v5) )
    {
      if ( v6[2] >= 0.0 )
        result = 1.0;
      else
        result = -1.0;
    }
    else if ( v6[1] >= 0.0 )
    {
      result = 1.0;
    }
    else
    {
      result = -1.0;
    }
  }
  else if ( *v6 >= 0.0 )
  {
    result = 1.0;
  }
  else
  {
    result = -1.0;
  }
  return result;
}

//----- (100406E0) --------------------------------------------------------
void __thiscall Plane::reflect(Plane *this, struct Vector3f *a2)
{
  float *v2; // ST54_4
  double v3; // st7
  float v4; // ST50_4

  v2 = this;
  v3 = Vector3f::DP(a2, this);
  v4 = v3 - v2[3] + v3 - v2[3];
  *a2 = *a2 - v4 * *v2;
  *(a2 + 1) = *(a2 + 1) - v4 * v2[1];
  *(a2 + 2) = *(a2 + 2) - v4 * v2[2];
}

//----- (10040790) --------------------------------------------------------
void __thiscall Plane::reflectVector(Plane *this, struct Vector3f *a2)
{
  float *v2; // ST54_4
  double v3; // st7
  float v4; // ST50_4

  v2 = this;
  v3 = Vector3f::DP(this, a2);
  v4 = v3 + v3;
  *a2 = *a2 - v4 * *v2;
  *(a2 + 1) = *(a2 + 1) - v4 * v2[1];
  *(a2 + 2) = *(a2 + 2) - v4 * v2[2];
}

//----- (10040830) --------------------------------------------------------
void __thiscall Plane::bounceVector(Plane *this, struct Vector3f *a2, float a3)
{
  float v3; // [esp+4Ch] [ebp-8h]
  float *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  v3 = -Vector3f::DP(a2, this) * a3;
  if ( v3 > 0.0 )
  {
    *a2 = v3 * *v4 + *a2;
    *(a2 + 1) = v3 * v4[1] + *(a2 + 1);
    *(a2 + 2) = v3 * v4[2] + *(a2 + 2);
  }
}

//----- (100408F0) --------------------------------------------------------
void __thiscall Plane::frictionVector(Plane *this, struct Vector3f *a2, float a3)
{
  float v3; // [esp+4Ch] [ebp-10h]
  float v4; // [esp+50h] [ebp-Ch]
  float v5; // [esp+54h] [ebp-8h]
  struct Vector3f *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  Vector3f::Vector3f(&v3, a2);
  Vector3f::project(&v3, v6);
  *a2 = *a2 - v3 * a3;
  *(a2 + 1) = *(a2 + 1) - v4 * a3;
  *(a2 + 2) = *(a2 + 2) - v5 * a3;
}

//----- (10040990) --------------------------------------------------------
void __thiscall CullingPlane::CheckMinMaxDir(CullingPlane *this)
{
  if ( *this >= 0.0 )
  {
    *(this + 4) = 0;
    *(this + 7) = 3;
  }
  else
  {
    *(this + 4) = 3;
    *(this + 7) = 0;
  }
  if ( *(this + 1) >= 0.0 )
  {
    *(this + 5) = 1;
    *(this + 8) = 4;
  }
  else
  {
    *(this + 5) = 4;
    *(this + 8) = 1;
  }
  if ( *(this + 2) >= 0.0 )
  {
    *(this + 6) = 2;
    *(this + 9) = 5;
  }
  else
  {
    *(this + 6) = 5;
    *(this + 9) = 2;
  }
}

//----- (10040AA0) --------------------------------------------------------
void __thiscall Vector3f::rotateTranspose(Vector3f *this, struct Matrix4f *a2)
{
  float *v2; // eax
  float v3; // [esp+4Ch] [ebp-10h]
  float v4; // [esp+50h] [ebp-Ch]
  float v5; // [esp+54h] [ebp-8h]
  float *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  Vector3f::Vector3f(&v3);
  v3 = *a2 * *v6 + *(a2 + 4) * v6[1] + *(a2 + 8) * v6[2];
  v4 = *(a2 + 1) * *v6 + *(a2 + 5) * v6[1] + *(a2 + 9) * v6[2];
  v5 = *(a2 + 2) * *v6 + *(a2 + 6) * v6[1] + *(a2 + 10) * v6[2];
  v2 = v6;
  *v6 = v3;
  v2[1] = v4;
  v2[2] = v5;
}

//----- (10040BA0) --------------------------------------------------------
void __thiscall Vector3f::rotate(Vector3f *this, struct Matrix4f *a2)
{
  float *v2; // eax
  float v3; // [esp+4Ch] [ebp-10h]
  float v4; // [esp+50h] [ebp-Ch]
  float v5; // [esp+54h] [ebp-8h]
  float *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  Vector3f::Vector3f(&v3);
  v3 = *a2 * *v6 + *(a2 + 1) * v6[1] + *(a2 + 2) * v6[2];
  v4 = *(a2 + 4) * *v6 + *(a2 + 5) * v6[1] + *(a2 + 6) * v6[2];
  v5 = *(a2 + 8) * *v6 + *(a2 + 9) * v6[1] + *(a2 + 10) * v6[2];
  v2 = v6;
  *v6 = v3;
  v2[1] = v4;
  v2[2] = v5;
}

//----- (10040CA0) --------------------------------------------------------
void __thiscall Vector3f::rotateTo(Vector3f *this, struct Matrix4f *a2, struct Vector3f *a3)
{
  float *v3; // ST50_4

  v3 = this;
  *a3 = *a2 * *this + *(a2 + 1) * *(this + 1) + *(a2 + 2) * *(this + 2);
  *(a3 + 1) = *(a2 + 4) * *v3 + *(a2 + 5) * v3[1] + *(a2 + 6) * v3[2];
  *(a3 + 2) = *(a2 + 8) * *v3 + *(a2 + 9) * v3[1] + *(a2 + 10) * v3[2];
}

//----- (10040D80) --------------------------------------------------------
void __thiscall Vector3f::multMatrix(Vector3f *this, struct Matrix4f *a2)
{
  float *v2; // eax
  float v3; // [esp+4Ch] [ebp-10h]
  float v4; // [esp+50h] [ebp-Ch]
  float v5; // [esp+54h] [ebp-8h]
  float *v6; // [esp+58h] [ebp-4h]

  v6 = this;
  Vector3f::Vector3f(&v3);
  v3 = *a2 * *v6 + *(a2 + 1) * v6[1] + *(a2 + 2) * v6[2] + *(a2 + 3);
  v4 = *(a2 + 4) * *v6 + *(a2 + 5) * v6[1] + *(a2 + 6) * v6[2] + *(a2 + 7);
  v5 = *(a2 + 8) * *v6 + *(a2 + 9) * v6[1] + *(a2 + 10) * v6[2] + *(a2 + 11);
  v2 = v6;
  *v6 = v3;
  v2[1] = v4;
  v2[2] = v5;
}

//----- (10040EA0) --------------------------------------------------------
void __thiscall Vector3f::multMatrixTo(Vector3f *this, struct Matrix4f *a2, struct Vector3f *a3)
{
  float *v3; // ST50_4

  v3 = this;
  *a3 = *a2 * *this + *(a2 + 1) * *(this + 1) + *(a2 + 2) * *(this + 2) + *(a2 + 3);
  *(a3 + 1) = *(a2 + 4) * *v3 + *(a2 + 5) * v3[1] + *(a2 + 6) * v3[2] + *(a2 + 7);
  *(a3 + 2) = *(a2 + 8) * *v3 + *(a2 + 9) * v3[1] + *(a2 + 10) * v3[2] + *(a2 + 11);
}

//----- (10040F90) --------------------------------------------------------
void __stdcall Vector3f::genAge(struct AgeServer *a2, char *a3, struct Vector3f *a4, struct Vector3f *a5)
{
  ;
}

//----- (10040FC0) --------------------------------------------------------
void __thiscall Vector3f::rotate(Vector3f *this, struct Quat *a2)
{
  float v2; // [esp+4Ch] [ebp-14h]
  float v3; // [esp+50h] [ebp-10h]
  float v4; // [esp+54h] [ebp-Ch]
  float v5; // [esp+58h] [ebp-8h]
  float *v6; // [esp+5Ch] [ebp-4h]

  v6 = this;
  Quat::Quat(&v2);
  v2 = *(a2 + 1) * v6[2] - *(a2 + 2) * v6[1] + *(a2 + 3) * *v6;
  v3 = -*a2 * v6[2] + *(a2 + 2) * *v6 + *(a2 + 3) * v6[1];
  v4 = *a2 * v6[1] - *(a2 + 1) * *v6 + *(a2 + 3) * v6[2];
  v5 = -*a2 * *v6 - *(a2 + 1) * v6[1] - *(a2 + 2) * v6[2];
  *v6 = v2 * *(a2 + 3) + -*(a2 + 2) * v3 - -*(a2 + 1) * v4 + -*a2 * v5;
  v6[1] = -v2 * -*(a2 + 2) + v3 * *(a2 + 3) + -*a2 * v4 + -*(a2 + 1) * v5;
  v6[2] = -*(a2 + 1) * v2 - -*a2 * v3 + v4 * *(a2 + 3) + -*(a2 + 2) * v5;
}

//----- (100411B0) --------------------------------------------------------
void __thiscall Vector3f::rotateInverse(Vector3f *this, struct Quat *a2)
{
  float v2; // ST0C_4
  float v3; // ST08_4
  float v4; // ST04_4
  float v5; // ST00_4
  char v6; // [esp+5Ch] [ebp-14h]
  Vector3f *v7; // [esp+6Ch] [ebp-4h]

  v7 = this;
  v2 = -*(a2 + 3);
  v3 = -*(a2 + 2);
  v4 = -*(a2 + 1);
  v5 = -*a2;
  Quat::Quat(&v6, v5, v4, v3, v2);
  Vector3f::rotate(v7, &v6);
}

//----- (10041240) --------------------------------------------------------
void __thiscall Quat::fromMat3f(Quat *this, struct Matrix3f *a2)
{
  double v2; // st7
  float v3; // ST74_4
  float v4; // ST74_4
  float v5; // ST74_4
  float v6; // ST74_4
  double v7; // st7
  float v8; // ST00_4
  float v9; // ST74_4
  signed int v10; // [esp+54h] [ebp-38h]
  signed int v11; // [esp+58h] [ebp-34h]
  signed int v12; // [esp+5Ch] [ebp-30h]
  signed int v13; // [esp+60h] [ebp-2Ch]
  signed int v14; // [esp+64h] [ebp-28h]
  signed int v15; // [esp+68h] [ebp-24h]
  signed int v16; // [esp+6Ch] [ebp-20h]
  float v17; // [esp+78h] [ebp-14h]
  float v18; // [esp+7Ch] [ebp-10h]
  float v19; // [esp+80h] [ebp-Ch]
  float v20; // [esp+84h] [ebp-8h]
  float *v21; // [esp+88h] [ebp-4h]

  v21 = this;
  v20 = (*a2 + *(a2 + 4) + *(a2 + 8) + 1.0) * 0.25;
  v19 = v20 - (*(a2 + 4) + *(a2 + 8)) * 0.5;
  v18 = v20 - (*(a2 + 8) + *a2) * 0.5;
  v17 = v20 - (*a2 + *(a2 + 4)) * 0.5;
  if ( v20 <= v19 )
  {
    if ( v19 <= v18 )
    {
      v2 = v18;
      if ( v18 <= v17 )
        v10 = 3;
      else
        v10 = 2;
      v11 = v10;
    }
    else
    {
      v2 = v19;
      if ( v19 <= v17 )
        v12 = 3;
      else
        v12 = 1;
      v11 = v12;
    }
    v13 = v11;
  }
  else
  {
    if ( v20 <= v18 )
    {
      v2 = v18;
      if ( v18 <= v17 )
        v14 = 3;
      else
        v14 = 2;
      v15 = v14;
    }
    else
    {
      v2 = v20;
      if ( v20 <= v17 )
        v16 = 3;
      else
        v16 = 0;
      v15 = v16;
    }
    v13 = v15;
  }
  switch ( v13 )
  {
    case 0:
      sub_1000122B(v20);
      v21[3] = v2;
      v3 = 0.25 / v21[3];
      *v21 = (*(a2 + 7) - *(a2 + 5)) * v3;
      v21[1] = (*(a2 + 2) - *(a2 + 6)) * v3;
      v21[2] = (*(a2 + 3) - *(a2 + 1)) * v3;
      break;
    case 1:
      sub_1000122B(v19);
      *v21 = v2;
      v4 = 0.25 / *v21;
      v21[3] = (*(a2 + 7) - *(a2 + 5)) * v4;
      v21[1] = (*(a2 + 1) + *(a2 + 3)) * v4;
      v21[2] = (*(a2 + 2) + *(a2 + 6)) * v4;
      break;
    case 2:
      sub_1000122B(v18);
      v21[1] = v2;
      v5 = 0.25 / v21[1];
      v21[3] = (*(a2 + 2) - *(a2 + 6)) * v5;
      v21[2] = (*(a2 + 5) + *(a2 + 7)) * v5;
      *v21 = (*(a2 + 3) + *(a2 + 1)) * v5;
      break;
    case 3:
      sub_1000122B(v17);
      v21[2] = v2;
      v6 = 0.25 / v21[2];
      v21[3] = (*(a2 + 3) - *(a2 + 1)) * v6;
      *v21 = (*(a2 + 6) + *(a2 + 2)) * v6;
      v21[1] = (*(a2 + 7) + *(a2 + 5)) * v6;
      break;
    default:
      break;
  }
  if ( v21[3] < 0.0 )
  {
    v21[3] = -v21[3];
    *v21 = -*v21;
    v21[1] = -v21[1];
    v21[2] = -v21[2];
  }
  v7 = v21[3] * v21[3] + *v21 * *v21 + v21[1] * v21[1] + v21[2] * v21[2];
  v8 = v7;
  sub_1000122B(v8);
  v9 = 1.0 / v7;
  v21[3] = v9 * v21[3];
  *v21 = v9 * *v21;
  v21[1] = v9 * v21[1];
  v21[2] = v9 * v21[2];
}

//----- (10041720) --------------------------------------------------------
void __thiscall Quat::rotate(Quat *this, struct Vector3f *a2, float a3)
{
  double v3; // st7
  float v4; // ST0C_4
  double v5; // st7
  float v6; // ST0C_4
  float v7; // ST0C_4
  float v8; // ST08_4
  float v9; // ST04_4
  float v10; // ST00_4
  char v11; // [esp+5Ch] [ebp-18h]
  float v12; // [esp+6Ch] [ebp-8h]
  Quat *v13; // [esp+70h] [ebp-4h]

  v13 = this;
  v3 = a3 * 0.5;
  v4 = v3;
  sub_10002635(v4);
  v12 = v3;
  v5 = a3 * 0.5;
  v6 = v5;
  sub_10002D47(v6);
  v7 = v5;
  v8 = v12 * *(a2 + 2);
  v9 = v12 * *(a2 + 1);
  v10 = v12 * *a2;
  Quat::Quat(&v11, v10, v9, v8, v7);
  Quat::multiply(v13, &v11);
}

//----- (100417E0) --------------------------------------------------------
void __thiscall Quat::multiply(Quat *this, struct Quat *a2)
{
  float *v2; // edx
  float v3; // [esp+4Ch] [ebp-14h]
  float v4; // [esp+50h] [ebp-10h]
  float v5; // [esp+54h] [ebp-Ch]
  float v6; // [esp+58h] [ebp-8h]
  float *v7; // [esp+5Ch] [ebp-4h]

  v7 = this;
  Quat::Quat(&v3);
  v6 = *(a2 + 3) * v7[3] - *a2 * *v7 - *(a2 + 1) * v7[1] - *(a2 + 2) * v7[2];
  v3 = *(a2 + 3) * *v7 + *a2 * v7[3] + *(a2 + 1) * v7[2] - *(a2 + 2) * v7[1];
  v4 = *(a2 + 3) * v7[1] + *(a2 + 1) * v7[3] + *(a2 + 2) * *v7 - *a2 * v7[2];
  v5 = *(a2 + 3) * v7[2] + *(a2 + 2) * v7[3] + *a2 * v7[1] - *(a2 + 1) * *v7;
  v2 = v7;
  *v7 = v3;
  v2[1] = v4;
  v2[2] = v5;
  v2[3] = v6;
}

//----- (10041960) --------------------------------------------------------
void __thiscall Quat::multiplyTo(Quat *this, struct Quat *a2, struct Quat *a3)
{
  *(this + 3) = *(a3 + 3) * *(a2 + 3) - *a3 * *a2 - *(a3 + 1) * *(a2 + 1) - *(a3 + 2) * *(a2 + 2);
  *this = *(a3 + 3) * *a2 + *a3 * *(a2 + 3) + *(a3 + 1) * *(a2 + 2) - *(a3 + 2) * *(a2 + 1);
  *(this + 1) = *(a3 + 3) * *(a2 + 1) + *(a3 + 1) * *(a2 + 3) + *(a3 + 2) * *a2 - *a3 * *(a2 + 2);
  *(this + 2) = *(a3 + 3) * *(a2 + 2) + *(a3 + 2) * *(a2 + 3) + *a3 * *(a2 + 1) - *(a3 + 1) * *a2;
}

//----- (10041AB0) --------------------------------------------------------
void __thiscall Quat::normalise(Quat *this)
{
  float *v1; // ST54_4
  double v2; // st7
  float v3; // ST00_4
  float v4; // ST50_4

  v1 = this;
  v2 = *this * *this + *(this + 1) * *(this + 1) + *(this + 2) * *(this + 2) + *(this + 3) * *(this + 3);
  v3 = v2;
  sub_1000122B(v3);
  v4 = 1.0 / v2;
  *v1 = v4 * *v1;
  v1[1] = v4 * v1[1];
  v1[2] = v4 * v1[2];
  v1[3] = v4 * v1[3];
}

//----- (10041B90) --------------------------------------------------------
void __thiscall Quat::genVectorX(Quat *this, struct Vector3f *a2)
{
  float *v2; // ST50_4
  double v3; // st7
  double v4; // st6
  double v5; // st7
  double v6; // st6
  double v7; // st7
  double v8; // st6

  v2 = this;
  v3 = *(this + 1) * *(this + 1);
  v4 = *(this + 2) * *(this + 2);
  *a2 = 1.0 - (v3 + v3) - (v4 + v4);
  v5 = *v2 * v2[1];
  v6 = v2[3] * v2[2];
  *(a2 + 1) = v5 + v5 + v6 + v6;
  v7 = *v2 * v2[2];
  v8 = v2[3] * v2[1];
  *(a2 + 2) = v7 + v7 - (v8 + v8);
}

//----- (10041C50) --------------------------------------------------------
void __thiscall Quat::genVectorY(Quat *this, struct Vector3f *a2)
{
  float *v2; // ST50_4
  double v3; // st7
  double v4; // st6
  double v5; // st7
  double v6; // st6
  double v7; // st7
  double v8; // st6

  v2 = this;
  v3 = *this * *(this + 1);
  v4 = *(this + 3) * *(this + 2);
  *a2 = v3 + v3 - (v4 + v4);
  v5 = *v2 * *v2;
  v6 = v2[2] * v2[2];
  *(a2 + 1) = 1.0 - (v5 + v5) - (v6 + v6);
  v7 = v2[1] * v2[2];
  v8 = v2[3] * *v2;
  *(a2 + 2) = v7 + v7 + v8 + v8;
}

//----- (10041D10) --------------------------------------------------------
void __thiscall Quat::genVectorZ(Quat *this, struct Vector3f *a2)
{
  float *v2; // ST50_4
  double v3; // st7
  double v4; // st6
  double v5; // st7
  double v6; // st6
  double v7; // st7
  double v8; // st6

  v2 = this;
  v3 = *this * *(this + 2);
  v4 = *(this + 3) * *(this + 1);
  *a2 = v3 + v3 + v4 + v4;
  v5 = v2[1] * v2[2];
  v6 = v2[3] * *v2;
  *(a2 + 1) = v5 + v5 - (v6 + v6);
  v7 = *v2 * *v2;
  v8 = v2[1] * v2[1];
  *(a2 + 2) = 1.0 - (v7 + v7) - (v8 + v8);
}

//----- (10041DD0) --------------------------------------------------------
void __thiscall Quat::slerp(Quat *this, struct Quat *a2, float a3, int a4)
{
  double v4; // st7
  float v5; // ST60_4
  float v6; // ST5C_4
  double v7; // st7
  float v8; // ST00_4
  double v9; // st7
  float v10; // ST00_4
  signed int v11; // [esp+50h] [ebp-1Ch]
  float v12; // [esp+58h] [ebp-14h]
  float v13; // [esp+64h] [ebp-8h]
  float *v14; // [esp+68h] [ebp-4h]

  v14 = this;
  v12 = *this * *a2 + *(this + 1) * *(a2 + 1) + *(this + 2) * *(a2 + 2) + *(this + 3) * *(a2 + 3);
  if ( v12 >= 0.0 )
  {
    v11 = 0;
  }
  else
  {
    v12 = -v12;
    v11 = 1;
  }
  v4 = 1.0 - v12;
  if ( v4 >= 0.000001 )
  {
    sub_10001258(v12);
    v5 = v4;
    sub_10002635(v5);
    v6 = v4;
    v7 = v5 - a3 * v5;
    v8 = v7;
    sub_10002635(v8);
    v13 = v7 / v6;
    v9 = a3 * v5;
    v10 = v9;
    sub_10002635(v10);
    a3 = v9 / v6;
  }
  else
  {
    v13 = 1.0 - a3;
  }
  if ( v11 )
    a3 = -a3;
  *v14 = v13 * *v14 + a3 * *a2;
  v14[1] = v13 * v14[1] + a3 * *(a2 + 1);
  v14[2] = v13 * v14[2] + a3 * *(a2 + 2);
  v14[3] = v13 * v14[3] + a3 * *(a2 + 3);
}

//----- (10041FB0) --------------------------------------------------------
void __thiscall Quat::fromEuler(Quat *this, struct Vector3f *a2)
{
  double v2; // st7
  int v3; // [esp+4Ch] [ebp-4Ch]
  int v4; // [esp+50h] [ebp-48h]
  float v5; // [esp+54h] [ebp-44h]
  float v6; // [esp+58h] [ebp-40h]
  int v7; // [esp+5Ch] [ebp-3Ch]
  float v8; // [esp+60h] [ebp-38h]
  int v9; // [esp+64h] [ebp-34h]
  float v10; // [esp+68h] [ebp-30h]
  float v11; // [esp+6Ch] [ebp-2Ch]
  int v12; // [esp+70h] [ebp-28h]
  int v13; // [esp+74h] [ebp-24h]
  float v14; // [esp+78h] [ebp-20h]
  float v15; // [esp+7Ch] [ebp-1Ch]
  float v16; // [esp+80h] [ebp-18h]
  float v17; // [esp+84h] [ebp-14h]
  float v18; // [esp+88h] [ebp-10h]
  float v19; // [esp+8Ch] [ebp-Ch]
  float v20; // [esp+90h] [ebp-8h]
  Quat *v21; // [esp+94h] [ebp-4h]

  v21 = this;
  Quat::Quat(&v11);
  Quat::Quat(&v7);
  Quat::Quat(&v3);
  v20 = *a2;
  v19 = *(a2 + 1);
  v18 = *(a2 + 2);
  v17 = v20 * 0.5;
  v16 = v19 * 0.5;
  v2 = v18 * 0.5;
  v15 = v2;
  sub_10002635(v17);
  v11 = v2;
  v12 = 0;
  v13 = 0;
  sub_10002D47(v17);
  v14 = v2;
  v7 = 0;
  sub_10002635(v16);
  v8 = v2;
  v9 = 0;
  sub_10002D47(v16);
  v10 = v2;
  v3 = 0;
  v4 = 0;
  sub_10002635(v15);
  v5 = v2;
  sub_10002D47(v15);
  v6 = v2;
  Quat::multiplyTo(v21, &v11, &v7);
  Quat::multiplyTo(v21, v21, &v3);
  Quat::normalise(v21);
}

//----- (10042140) --------------------------------------------------------
double __cdecl roundAng(float a1)
{
  if ( a1 < 0.0 )
    a1 = a1 + 6.2831855;
  if ( a1 >= 6.2831855 )
    a1 = a1 - 6.2831855;
  return a1;
}

//----- (100421B0) --------------------------------------------------------
double __cdecl angDist(float a1, float a2)
{
  float v2; // ST00_4
  float v3; // ST00_4
  float v5; // [esp+50h] [ebp-4h]

  v2 = a1 - a2;
  v5 = roundAng(v2);
  if ( v5 >= 3.1415927 )
  {
    v3 = 6.2831855 - v5;
    v5 = -roundAng(v3);
  }
  return v5;
}

//----- (10042240) --------------------------------------------------------
double __cdecl qdist2(float a1, float a2, float a3, float a4)
{
  double v4; // st7
  double v5; // st7
  float v7; // [esp+4Ch] [ebp-4h]
  float v8; // [esp+60h] [ebp+10h]
  float v9; // [esp+64h] [ebp+14h]

  v4 = a3 - a1;
  v8 = v4;
  if ( v4 < 0.0 )
    v8 = -v8;
  v5 = a4 - a2;
  v9 = v5;
  if ( v5 < 0.0 )
    v9 = -v9;
  if ( v8 <= v9 )
    v7 = v8;
  else
    v7 = v9;
  return v8 + v9 - v7 * 0.5;
}

//----- (100422F0) --------------------------------------------------------
double __cdecl qdist3(float a1, float a2, float a3, float a4, float a5, float a6)
{
  double v6; // st7
  double v7; // st7
  double v8; // st7
  float v10; // [esp+4Ch] [ebp-Ch]
  float v11; // [esp+50h] [ebp-8h]
  float v12; // [esp+54h] [ebp-4h]
  float v13; // [esp+6Ch] [ebp+14h]
  float v14; // [esp+70h] [ebp+18h]
  float v15; // [esp+74h] [ebp+1Ch]

  v6 = a4 - a1;
  v13 = v6;
  if ( v6 < 0.0 )
    v13 = -v13;
  v7 = a5 - a2;
  v14 = v7;
  if ( v7 < 0.0 )
    v14 = -v14;
  v8 = a6 - a3;
  v15 = v8;
  if ( v8 < 0.0 )
    v15 = -v15;
  if ( v13 >= v14 )
  {
    v12 = v14;
    v11 = v13;
  }
  else
  {
    v12 = v13;
    v11 = v14;
  }
  if ( v15 >= v11 )
  {
    v10 = v15;
  }
  else
  {
    v10 = v11;
    v11 = v15;
  }
  return (v12 + v11) / 2.0 + v10;
}

//----- (10042400) --------------------------------------------------------
void __thiscall CollTriInfo::init(CollTriInfo *this, struct RoomInfo *a2, struct Vector3f *a3)
{
  const struct Vector3f *v3; // eax
  _DWORD *v4; // eax
  double v5; // st7
  char v6; // [esp+4Ch] [ebp-28h]
  int v7; // [esp+58h] [ebp-1Ch]
  int v8; // [esp+5Ch] [ebp-18h]
  int v9; // [esp+60h] [ebp-14h]
  int v10; // [esp+64h] [ebp-10h]
  struct Vector3f *v11; // [esp+68h] [ebp-Ch]
  int i; // [esp+6Ch] [ebp-8h]
  CollTriInfo *v13; // [esp+70h] [ebp-4h]

  v13 = this;
  for ( i = 0; i < 3; ++i )
  {
    v11 = (a3 + 12 * *(v13 + (i + 1) % 3 + 1));
    v10 = a3 + 12 * *(v13 + i % 3 + 1);
    v3 = sub_10002E2D(&v6, v11, v10);
    Vector3f::Vector3f(&v7, v3);
    Vector3f::normalise(&v7);
    Vector3f::CP(&v7, (v13 + 24));
    v4 = (v13 + 16 * i + 40);
    *v4 = v7;
    v4[1] = v8;
    v4[2] = v9;
    v5 = Vector3f::DP(&v7, v11);
    *(v13 + 4 * i + 13) = v5;
  }
}

//----- (10042540) --------------------------------------------------------
int __thiscall CollTriInfo::behindEdge(CollTriInfo *this, struct Vector3f *a2)
{
  signed int i; // [esp+4Ch] [ebp-8h]
  CollTriInfo *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  for ( i = 0; i < 3; ++i )
  {
    if ( Plane::dist((v4 + 16 * i + 40), a2) < 0.0 )
      return i;
  }
  return -1;
}

//----- (100425E0) --------------------------------------------------------
void __thiscall BoundBox::draw(BoundBox *this, struct Graphics *a2)
{
  int v2; // ST10_4
  int v3; // eax
  int v4; // ST10_4
  int v5; // eax
  int v6; // ST10_4
  int v7; // eax
  int v8; // ST10_4
  int v9; // eax
  int v10; // ST10_4
  int v11; // eax
  int v12; // ST10_4
  int v13; // eax
  int v14; // ST10_4
  int v15; // eax
  int v16; // ST10_4
  int v17; // eax
  int v18; // ST10_4
  int v19; // eax
  int v20; // ST10_4
  int v21; // eax
  int v22; // ST10_4
  int v23; // eax
  int v24; // ST10_4
  int v25; // eax
  int v26; // eax
  char v27; // [esp+4Ch] [ebp-178h]
  char v28; // [esp+50h] [ebp-174h]
  char v29; // [esp+5Ch] [ebp-168h]
  char v30; // [esp+68h] [ebp-15Ch]
  char v31; // [esp+74h] [ebp-150h]
  char v32; // [esp+80h] [ebp-144h]
  char v33; // [esp+8Ch] [ebp-138h]
  char v34; // [esp+98h] [ebp-12Ch]
  char v35; // [esp+A4h] [ebp-120h]
  char v36; // [esp+B0h] [ebp-114h]
  char v37; // [esp+BCh] [ebp-108h]
  char v38; // [esp+C8h] [ebp-FCh]
  char v39; // [esp+D4h] [ebp-F0h]
  char v40; // [esp+E0h] [ebp-E4h]
  char v41; // [esp+ECh] [ebp-D8h]
  char v42; // [esp+F8h] [ebp-CCh]
  char v43; // [esp+104h] [ebp-C0h]
  char v44; // [esp+110h] [ebp-B4h]
  char v45; // [esp+11Ch] [ebp-A8h]
  char v46; // [esp+128h] [ebp-9Ch]
  char v47; // [esp+134h] [ebp-90h]
  char v48; // [esp+140h] [ebp-84h]
  char v49; // [esp+14Ch] [ebp-78h]
  char v50; // [esp+158h] [ebp-6Ch]
  char v51; // [esp+164h] [ebp-60h]
  char v52; // [esp+170h] [ebp-54h]
  char v53; // [esp+190h] [ebp-34h]
  char v54; // [esp+19Ch] [ebp-28h]
  char v55; // [esp+1A8h] [ebp-1Ch]
  char v56; // [esp+1B4h] [ebp-10h]
  float *v57; // [esp+1C0h] [ebp-4h]

  v57 = this;
  v2 = Vector3f::Vector3f(&v51, this + 3, this + 1, this + 2);
  v3 = Vector3f::Vector3f(&v50, v57, v57 + 1, v57 + 2);
  (*(*a2 + 144))(a2, v3, v2);
  v4 = Vector3f::Vector3f(&v49, v57 + 3, v57 + 1, v57 + 5);
  v5 = Vector3f::Vector3f(&v48, v57 + 3, v57 + 1, v57 + 2);
  (*(*a2 + 144))(a2, v5, v4);
  v6 = Vector3f::Vector3f(&v47, v57, v57 + 1, v57 + 5);
  v7 = Vector3f::Vector3f(&v46, v57 + 3, v57 + 1, v57 + 5);
  (*(*a2 + 144))(a2, v7, v6);
  v8 = Vector3f::Vector3f(&v45, v57, v57 + 1, v57 + 2);
  v9 = Vector3f::Vector3f(&v44, v57, v57 + 1, v57 + 5);
  (*(*a2 + 144))(a2, v9, v8);
  v10 = Vector3f::Vector3f(&v43, v57 + 3, v57 + 4, v57 + 2);
  v11 = Vector3f::Vector3f(&v42, v57, v57 + 4, v57 + 2);
  (*(*a2 + 144))(a2, v11, v10);
  v12 = Vector3f::Vector3f(&v41, v57 + 3, v57 + 4, v57 + 5);
  v13 = Vector3f::Vector3f(&v40, v57 + 3, v57 + 4, v57 + 2);
  (*(*a2 + 144))(a2, v13, v12);
  v14 = Vector3f::Vector3f(&v39, v57, v57 + 4, v57 + 5);
  v15 = Vector3f::Vector3f(&v38, v57 + 3, v57 + 4, v57 + 5);
  (*(*a2 + 144))(a2, v15, v14);
  v16 = Vector3f::Vector3f(&v37, v57, v57 + 4, v57 + 2);
  v17 = Vector3f::Vector3f(&v36, v57, v57 + 4, v57 + 5);
  (*(*a2 + 144))(a2, v17, v16);
  v18 = Vector3f::Vector3f(&v35, v57, v57 + 4, v57 + 2);
  v19 = Vector3f::Vector3f(&v34, v57, v57 + 1, v57 + 2);
  (*(*a2 + 144))(a2, v19, v18);
  v20 = Vector3f::Vector3f(&v33, v57 + 3, v57 + 4, v57 + 2);
  v21 = Vector3f::Vector3f(&v32, v57 + 3, v57 + 1, v57 + 2);
  (*(*a2 + 144))(a2, v21, v20);
  v22 = Vector3f::Vector3f(&v31, v57, v57 + 4, v57 + 5);
  v23 = Vector3f::Vector3f(&v30, v57, v57 + 1, v57 + 5);
  (*(*a2 + 144))(a2, v23, v22);
  v24 = Vector3f::Vector3f(&v29, v57 + 3, v57 + 4, v57 + 5);
  v25 = Vector3f::Vector3f(&v28, v57 + 3, v57 + 1, v57 + 5);
  (*(*a2 + 144))(a2, v25, v24);
  sub_1000291E(&v53, 12, 4, Vector3f::Vector3f);
  sub_1000291E(&v52, 8, 4, Vector2f::Vector2f);
  v26 = Colour::Colour(&v27, *(a2 + 796), *(a2 + 797), *(a2 + 798), 0x20u);
  (*(*a2 + 160))(a2, v26, 1);
  Vector3f::set(&v53, v57, v57 + 1, v57 + 5);
  Vector3f::set(&v54, v57, v57 + 4, v57 + 5);
  Vector3f::set(&v55, v57 + 3, v57 + 4, v57 + 5);
  Vector3f::set(&v56, v57 + 3, v57 + 1, v57 + 5);
  (*(*a2 + 152))(a2, &v53, 0, &v52, 4);
  Vector3f::set(&v53, v57 + 3, v57 + 4, v57 + 2);
  Vector3f::set(&v54, v57 + 3, v57 + 1, v57 + 2);
  Vector3f::set(&v55, v57 + 3, v57 + 1, v57 + 5);
  Vector3f::set(&v56, v57 + 3, v57 + 4, v57 + 5);
  (*(*a2 + 152))(a2, &v53, 0, &v52, 4);
  Vector3f::set(&v53, v57 + 3, v57 + 1, v57 + 2);
  Vector3f::set(&v54, v57 + 3, v57 + 4, v57 + 2);
  Vector3f::set(&v55, v57, v57 + 4, v57 + 2);
  Vector3f::set(&v56, v57, v57 + 1, v57 + 2);
  (*(*a2 + 152))(a2, &v53, 0, &v52, 4);
  Vector3f::set(&v53, v57, v57 + 4, v57 + 5);
  Vector3f::set(&v54, v57, v57 + 1, v57 + 5);
  Vector3f::set(&v55, v57, v57 + 1, v57 + 2);
  Vector3f::set(&v56, v57, v57 + 4, v57 + 2);
  (*(*a2 + 152))(a2, &v53, 0, &v52, 4);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10042E80) --------------------------------------------------------
double __cdecl triRectDistance(struct Vector3f *a1, struct Vector3f *a2, struct Vector3f *a3, struct BoundBox *a4)
{
  int v4; // eax
  int v5; // eax
  int *v6; // eax
  int v7; // eax
  int *v8; // eax
  int v9; // eax
  int *v10; // eax
  char v12; // [esp+4Ch] [ebp-120h]
  float v13; // [esp+58h] [ebp-114h]
  char v14; // [esp+5Ch] [ebp-110h]
  char v15; // [esp+68h] [ebp-104h]
  float v16; // [esp+74h] [ebp-F8h]
  float v17; // [esp+78h] [ebp-F4h]
  char v18; // [esp+7Ch] [ebp-F0h]
  char v19; // [esp+88h] [ebp-E4h]
  float v20; // [esp+94h] [ebp-D8h]
  float v21; // [esp+98h] [ebp-D4h]
  char v22; // [esp+9Ch] [ebp-D0h]
  char v23; // [esp+A8h] [ebp-C4h]
  float v24; // [esp+B4h] [ebp-B8h]
  float v25; // [esp+B8h] [ebp-B4h]
  float v26; // [esp+BCh] [ebp-B0h]
  float v27; // [esp+C0h] [ebp-ACh]
  float v28; // [esp+C4h] [ebp-A8h]
  int v29; // [esp+C8h] [ebp-A4h]
  float v30; // [esp+CCh] [ebp-A0h]
  int v31; // [esp+D0h] [ebp-9Ch]
  int v32; // [esp+D4h] [ebp-98h]
  int v33; // [esp+D8h] [ebp-94h]
  int v34; // [esp+DCh] [ebp-90h]
  int v35; // [esp+E0h] [ebp-8Ch]
  int v36; // [esp+E4h] [ebp-88h]
  int v37; // [esp+E8h] [ebp-84h]
  int v38; // [esp+ECh] [ebp-80h]
  int v39; // [esp+F0h] [ebp-7Ch]
  int v40; // [esp+F4h] [ebp-78h]
  int v41; // [esp+F8h] [ebp-74h]
  int v42; // [esp+FCh] [ebp-70h]
  char v43; // [esp+100h] [ebp-6Ch]
  char v44; // [esp+124h] [ebp-48h]
  char v45; // [esp+148h] [ebp-24h]
  int v46; // [esp+14Ch] [ebp-20h]
  char v47; // [esp+154h] [ebp-18h]
  int v48; // [esp+158h] [ebp-14h]
  char v49; // [esp+160h] [ebp-Ch]
  int v50; // [esp+164h] [ebp-8h]

  Vector3f::Vector3f(&v49, a1);
  Vector3f::Vector3f(&v47, a2);
  Vector3f::Vector3f(&v45, a3);
  v46 = 0;
  v48 = 0;
  v50 = 0;
  KTri::KTri(&v44);
  KRect::KRect(&v43);
  KTri::set(&v44, &v49, &v47, &v45);
  Vector3f::Vector3f(&v40);
  Vector3f::Vector3f(&v37);
  Vector3f::Vector3f(&v34);
  Vector3f::Vector3f(&v31);
  Vector3f::Vector3f(&v28);
  v40 = *a4;
  v41 = *(a4 + 1);
  v42 = *(a4 + 2);
  v41 = 0;
  v4 = sub_10002E2D(&v23, a4 + 12, a4);
  v28 = *v4;
  v29 = *(v4 + 4);
  v30 = *(v4 + 8);
  v29 = 0;
  v21 = 0.0;
  v20 = 0.0;
  v5 = Vector3f::Vector3f(&v22, &v28, &v20, &v21);
  v6 = sub_10001A3C(&v19, &v40, v5);
  v37 = *v6;
  v38 = v6[1];
  v39 = v6[2];
  v17 = 0.0;
  v16 = 0.0;
  v7 = Vector3f::Vector3f(&v18, &v16, &v17, &v30);
  v8 = sub_10001A3C(&v15, &v40, v7);
  v34 = *v8;
  v35 = v8[1];
  v36 = v8[2];
  v13 = 0.0;
  v9 = Vector3f::Vector3f(&v14, &v28, &v13, &v30);
  v10 = sub_10001A3C(&v12, &v40, v9);
  v31 = *v10;
  v32 = v10[1];
  v33 = v10[2];
  KTri::set(&v43, &v40, &v37, &v34);
  if ( KRect::inside(&v43, &v49) )
    return 0.0;
  if ( KRect::inside(&v43, &v47) )
    return 0.0;
  if ( KRect::inside(&v43, &v45) )
    return 0.0;
  if ( sub_100432C0(&v44, &v40) )
    return 0.0;
  if ( sub_100432C0(&v44, &v37) )
    return 0.0;
  if ( sub_100432C0(&v44, &v34) )
    return 0.0;
  if ( sub_100432C0(&v44, &v31) )
    return 0.0;
  return distanceTriRect(&v44, &v43, &v27, &v26, &v25, &v24);
}

//----- (100432C0) --------------------------------------------------------
bool __cdecl sub_100432C0(KTri *a1, int a2)
{
  int *v2; // eax
  struct Vector3f *v3; // eax
  int *v4; // eax
  struct Vector3f *v5; // eax
  int *v6; // eax
  const struct Vector3f *v7; // eax
  const struct Vector3f *v8; // eax
  const struct Vector3f *v9; // eax
  const struct Vector3f *v10; // eax
  const struct Vector3f *v12; // eax
  const struct Vector3f *v13; // eax
  char v14; // [esp+4Ch] [ebp-CCh]
  char v15; // [esp+58h] [ebp-C0h]
  char v16; // [esp+64h] [ebp-B4h]
  char v17; // [esp+70h] [ebp-A8h]
  char v18; // [esp+7Ch] [ebp-9Ch]
  char v19; // [esp+88h] [ebp-90h]
  char v20; // [esp+94h] [ebp-84h]
  char v21; // [esp+A0h] [ebp-78h]
  char v22; // [esp+ACh] [ebp-6Ch]
  char v23; // [esp+B8h] [ebp-60h]
  char v24; // [esp+C4h] [ebp-54h]
  char v25; // [esp+D0h] [ebp-48h]
  float v26; // [esp+D4h] [ebp-44h]
  char v27; // [esp+DCh] [ebp-3Ch]
  float v28; // [esp+E0h] [ebp-38h]
  char v29; // [esp+E8h] [ebp-30h]
  float v30; // [esp+ECh] [ebp-2Ch]
  int v31; // [esp+F4h] [ebp-24h]
  int v32; // [esp+F8h] [ebp-20h]
  int v33; // [esp+FCh] [ebp-1Ch]
  int v34; // [esp+100h] [ebp-18h]
  int v35; // [esp+104h] [ebp-14h]
  int v36; // [esp+108h] [ebp-10h]
  int v37; // [esp+10Ch] [ebp-Ch]
  int v38; // [esp+110h] [ebp-8h]
  int v39; // [esp+114h] [ebp-4h]

  Vector3f::Vector3f(&v37);
  Vector3f::Vector3f(&v34);
  Vector3f::Vector3f(&v31);
  v2 = KTri::Origin(a1);
  v37 = *v2;
  v38 = v2[1];
  v39 = v2[2];
  v3 = KTri::Edge0(a1);
  v4 = sub_10001A3C(&v21, &v37, v3);
  v34 = *v4;
  v35 = v4[1];
  v36 = v4[2];
  v5 = KTri::Edge1(a1);
  v6 = sub_10001A3C(&v20, &v37, v5);
  v31 = *v6;
  v32 = v6[1];
  v33 = v6[2];
  v7 = sub_10002E2D(&v19, &v34, &v37);
  Vector3f::Vector3f(&v29, v7);
  v8 = sub_10002E2D(&v18, &v31, &v34);
  Vector3f::Vector3f(&v27, v8);
  v9 = sub_10002E2D(&v17, &v37, &v31);
  Vector3f::Vector3f(&v25, v9);
  v10 = sub_10002E2D(&v16, a2, &v37);
  Vector3f::Vector3f(&v24, v10);
  Vector3f::CP(&v29, &v24);
  if ( v30 > 0.0 )
    return 0;
  v12 = sub_10002E2D(&v15, a2, &v34);
  Vector3f::Vector3f(&v23, v12);
  Vector3f::CP(&v27, &v23);
  if ( v28 > 0.0 )
    return 0;
  v13 = sub_10002E2D(&v14, a2, &v31);
  Vector3f::Vector3f(&v22, v13);
  Vector3f::CP(&v25, &v22);
  return v26 <= 0.0;
}

//----- (10043520) --------------------------------------------------------
double __cdecl distanceTriRect(struct KTri *a1, struct KRect *a2, float *a3, float *a4, float *a5, float *a6)
{
  double result; // st7
  struct Vector3f *v7; // eax
  int v8; // ST14_4
  struct Vector3f *v9; // eax
  int v10; // ST10_4
  struct Vector3f *v11; // eax
  int v12; // eax
  int *v13; // eax
  char v14; // [esp+4Ch] [ebp-40h]
  char v15; // [esp+58h] [ebp-34h]
  char v16; // [esp+64h] [ebp-28h]
  char v17; // [esp+70h] [ebp-1Ch]
  int v18; // [esp+7Ch] [ebp-10h]
  int v19; // [esp+80h] [ebp-Ch]
  int v20; // [esp+84h] [ebp-8h]
  float v21; // [esp+88h] [ebp-4h]

  result = sqrDistance(a1, a2, a3, a4, a5, a6);
  v21 = result;
  Vector3f::Vector3f(&v18);
  v7 = KTri::Edge1(a1);
  v8 = sub_10001CD5(&v17, v7, a4);
  v9 = KTri::Edge0(a1);
  v10 = sub_10001CD5(&v16, v9, a3);
  v11 = KTri::Origin(a1);
  v12 = sub_10001A3C(&v15, v11, v10);
  v13 = sub_10001A3C(&v14, v12, v8);
  v18 = *v13;
  v19 = v13[1];
  v20 = v13[2];
  if ( KRect::inside(a2, &v18) )
    return 0.0;
  sub_1000122B(v21);
  return result;
}

//----- (10043650) --------------------------------------------------------
bool __thiscall KRect::inside(KRect *this, struct Vector3f *a2)
{
  struct Vector3f *v2; // ST0C_4
  struct Vector3f *v3; // eax
  int v4; // eax
  int *v5; // eax
  char v7; // [esp+4Ch] [ebp-34h]
  char v8; // [esp+58h] [ebp-28h]
  float v9; // [esp+64h] [ebp-1Ch]
  int v10; // [esp+68h] [ebp-18h]
  float v11; // [esp+6Ch] [ebp-14h]
  float v12; // [esp+70h] [ebp-10h]
  float v13; // [esp+78h] [ebp-8h]
  struct Vector3f *v14; // [esp+7Ch] [ebp-4h]

  v14 = this;
  Vector3f::Vector3f(&v12, this);
  Vector3f::Vector3f(&v9);
  v2 = KTri::Edge1(v14);
  v3 = KTri::Edge0(v14);
  v4 = sub_10001A3C(&v8, v14, v3);
  v5 = sub_10001A3C(&v7, v4, v2);
  v9 = *v5;
  v10 = v5[1];
  v11 = *(v5 + 2);
  return *a2 >= v12 && *a2 <= v9 && *(a2 + 2) >= v13 && *(a2 + 2) <= v11;
}

//----- (10043750) --------------------------------------------------------
Vector3f *__thiscall KTri::KTri(KTri *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  Vector3f::Vector3f((v1 + 12));
  Vector3f::Vector3f((v1 + 24));
  return v1;
}

//----- (100437C0) --------------------------------------------------------
void __thiscall KTri::set(KTri *this, struct Vector3f *a2, struct Vector3f *a3, struct Vector3f *a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // ecx
  char v8; // [esp+4Ch] [ebp-1Ch]
  char v9; // [esp+58h] [ebp-10h]
  KTri *v10; // [esp+64h] [ebp-4h]

  v10 = this;
  *this = *a2;
  *(this + 1) = *(a2 + 1);
  *(this + 2) = *(a2 + 2);
  v4 = sub_10002E2D(&v9, a3, a2);
  v5 = (v10 + 12);
  *v5 = *v4;
  v5[1] = v4[1];
  v5[2] = v4[2];
  v6 = sub_10002E2D(&v8, a4, a2);
  v7 = (v10 + 24);
  *v7 = *v6;
  v7[1] = v6[1];
  v7[2] = v6[2];
}

//----- (10043880) --------------------------------------------------------
Vector3f *__thiscall KSegment::KSegment(KSegment *this)
{
  Vector3f *v1; // ST50_4

  v1 = this;
  Vector3f::Vector3f(this);
  Vector3f::Vector3f((v1 + 12));
  return v1;
}

//----- (100438E0) --------------------------------------------------------
double __cdecl sqrDistance(struct KSegment *a1, struct KTri *a2, float *a3, float *a4, float *a5)
{
  struct Vector3f *v5; // ST0C_4
  struct Vector3f *v6; // eax
  const struct Vector3f *v7; // eax
  Vector3f *v8; // eax
  struct Vector3f *v9; // ST0C_4
  Vector3f *v10; // eax
  struct Vector3f *v11; // ST0C_4
  Vector3f *v12; // eax
  Vector3f *v13; // eax
  struct Vector3f *v14; // ST0C_4
  Vector3f *v15; // eax
  struct Vector3f *v16; // ST0C_4
  Vector3f *v17; // eax
  struct Vector3f *v18; // eax
  struct Vector3f *v19; // eax
  struct Vector3f *v20; // eax
  double v21; // st7
  struct Vector3f *v22; // esi
  struct Vector3f *v23; // eax
  struct Vector3f *v24; // esi
  struct Vector3f *v25; // eax
  struct Vector3f *v26; // esi
  struct Vector3f *v27; // eax
  struct Vector3f *v28; // esi
  struct Vector3f *v29; // eax
  struct Vector3f *v30; // eax
  double result; // st7
  struct Vector3f *v32; // esi
  struct Vector3f *v33; // eax
  struct Vector3f *v34; // esi
  struct Vector3f *v35; // eax
  struct Vector3f *v36; // eax
  struct Vector3f *v37; // esi
  struct Vector3f *v38; // eax
  struct Vector3f *v39; // esi
  struct Vector3f *v40; // eax
  struct Vector3f *v41; // eax
  struct Vector3f *v42; // eax
  struct Vector3f *v43; // esi
  struct Vector3f *v44; // eax
  struct Vector3f *v45; // esi
  struct Vector3f *v46; // eax
  struct Vector3f *v47; // ST0C_4
  struct Vector3f *v48; // eax
  _DWORD *v49; // esi
  struct Vector3f *v50; // eax
  struct Vector3f *v51; // ST0C_4
  struct Vector3f *v52; // eax
  _DWORD *v53; // esi
  struct Vector3f *v54; // eax
  struct Vector3f *v55; // eax
  struct Vector3f *v56; // esi
  struct Vector3f *v57; // eax
  struct Vector3f *v58; // esi
  struct Vector3f *v59; // eax
  struct Vector3f *v60; // ST0C_4
  struct Vector3f *v61; // eax
  _DWORD *v62; // esi
  struct Vector3f *v63; // eax
  struct Vector3f *v64; // ST0C_4
  struct Vector3f *v65; // eax
  _DWORD *v66; // esi
  struct Vector3f *v67; // eax
  struct Vector3f *v68; // eax
  struct Vector3f *v69; // ST0C_4
  struct Vector3f *v70; // eax
  _DWORD *v71; // esi
  struct Vector3f *v72; // eax
  struct Vector3f *v73; // ST0C_4
  struct Vector3f *v74; // eax
  _DWORD *v75; // esi
  struct Vector3f *v76; // eax
  struct Vector3f *v77; // eax
  struct Vector3f *v78; // esi
  struct Vector3f *v79; // eax
  struct Vector3f *v80; // esi
  struct Vector3f *v81; // eax
  struct Vector3f *v82; // esi
  struct Vector3f *v83; // eax
  struct Vector3f *v84; // esi
  struct Vector3f *v85; // eax
  struct Vector3f *v86; // esi
  struct Vector3f *v87; // eax
  struct Vector3f *v88; // esi
  struct Vector3f *v89; // eax
  struct Vector3f *v90; // esi
  struct Vector3f *v91; // eax
  struct Vector3f *v92; // esi
  struct Vector3f *v93; // eax
  float v94; // ST5C_4
  struct Vector3f *v95; // esi
  struct Vector3f *v96; // eax
  struct Vector3f *v97; // esi
  struct Vector3f *v98; // eax
  struct Vector3f *v99; // ST0C_4
  struct Vector3f *v100; // eax
  _DWORD *v101; // esi
  struct Vector3f *v102; // eax
  struct Vector3f *v103; // ST0C_4
  struct Vector3f *v104; // eax
  _DWORD *v105; // esi
  struct Vector3f *v106; // eax
  struct Vector3f *v107; // esi
  struct Vector3f *v108; // eax
  struct Vector3f *v109; // esi
  struct Vector3f *v110; // eax
  struct Vector3f *v111; // ST0C_4
  struct Vector3f *v112; // eax
  _DWORD *v113; // esi
  struct Vector3f *v114; // eax
  struct Vector3f *v115; // ST0C_4
  struct Vector3f *v116; // eax
  _DWORD *v117; // esi
  struct Vector3f *v118; // eax
  struct Vector3f *v119; // ST0C_4
  struct Vector3f *v120; // eax
  _DWORD *v121; // esi
  struct Vector3f *v122; // eax
  struct Vector3f *v123; // ST0C_4
  struct Vector3f *v124; // eax
  _DWORD *v125; // esi
  struct Vector3f *v126; // eax
  struct Vector3f *v127; // esi
  struct Vector3f *v128; // eax
  struct Vector3f *v129; // esi
  struct Vector3f *v130; // eax
  struct Vector3f *v131; // esi
  struct Vector3f *v132; // eax
  struct Vector3f *v133; // esi
  struct Vector3f *v134; // eax
  struct Vector3f *v135; // ST0C_4
  struct Vector3f *v136; // eax
  int *v137; // eax
  struct Vector3f *v138; // esi
  struct Vector3f *v139; // eax
  struct Vector3f *v140; // esi
  struct Vector3f *v141; // eax
  struct Vector3f *v142; // ST0C_4
  struct Vector3f *v143; // eax
  int *v144; // eax
  struct Vector3f *v145; // esi
  struct Vector3f *v146; // eax
  struct Vector3f *v147; // esi
  struct Vector3f *v148; // eax
  struct Vector3f *v149; // ST0C_4
  struct Vector3f *v150; // eax
  int *v151; // eax
  struct Vector3f *v152; // ST0C_4
  struct Vector3f *v153; // eax
  int *v154; // eax
  struct Vector3f *v155; // esi
  struct Vector3f *v156; // eax
  struct Vector3f *v157; // esi
  struct Vector3f *v158; // eax
  struct Vector3f *v159; // ST0C_4
  struct Vector3f *v160; // eax
  _DWORD *v161; // esi
  struct Vector3f *v162; // eax
  struct Vector3f *v163; // ST0C_4
  struct Vector3f *v164; // eax
  _DWORD *v165; // esi
  struct Vector3f *v166; // eax
  struct Vector3f *v167; // ST0C_4
  struct Vector3f *v168; // eax
  int *v169; // eax
  struct Vector3f *v170; // esi
  struct Vector3f *v171; // eax
  struct Vector3f *v172; // esi
  struct Vector3f *v173; // eax
  struct Vector3f *v174; // ST0C_4
  struct Vector3f *v175; // eax
  _DWORD *v176; // esi
  struct Vector3f *v177; // eax
  struct Vector3f *v178; // ST0C_4
  struct Vector3f *v179; // eax
  _DWORD *v180; // esi
  struct Vector3f *v181; // eax
  struct Vector3f *v182; // ST0C_4
  struct Vector3f *v183; // eax
  int *v184; // eax
  struct Vector3f *v185; // ST0C_4
  struct Vector3f *v186; // eax
  _DWORD *v187; // esi
  struct Vector3f *v188; // eax
  struct Vector3f *v189; // ST0C_4
  struct Vector3f *v190; // eax
  _DWORD *v191; // esi
  struct Vector3f *v192; // eax
  struct Vector3f *v193; // ST0C_4
  struct Vector3f *v194; // eax
  int *v195; // eax
  struct Vector3f *v196; // esi
  struct Vector3f *v197; // eax
  struct Vector3f *v198; // esi
  struct Vector3f *v199; // eax
  struct Vector3f *v200; // esi
  struct Vector3f *v201; // eax
  struct Vector3f *v202; // ST0C_4
  struct Vector3f *v203; // eax
  _DWORD *v204; // esi
  struct Vector3f *v205; // eax
  struct Vector3f *v206; // ST0C_4
  struct Vector3f *v207; // eax
  _DWORD *v208; // esi
  struct Vector3f *v209; // eax
  struct Vector3f *v210; // eax
  struct Vector3f *v211; // ST0C_4
  struct Vector3f *v212; // eax
  int *v213; // eax
  char v214; // [esp+50h] [ebp-1FCh]
  char v215; // [esp+5Ch] [ebp-1F0h]
  char v216; // [esp+68h] [ebp-1E4h]
  char v217; // [esp+74h] [ebp-1D8h]
  char v218; // [esp+80h] [ebp-1CCh]
  char v219; // [esp+8Ch] [ebp-1C0h]
  char v220; // [esp+98h] [ebp-1B4h]
  char v221; // [esp+A4h] [ebp-1A8h]
  char v222; // [esp+B0h] [ebp-19Ch]
  char v223; // [esp+BCh] [ebp-190h]
  char v224; // [esp+C8h] [ebp-184h]
  char v225; // [esp+D4h] [ebp-178h]
  char v226; // [esp+E0h] [ebp-16Ch]
  char v227; // [esp+ECh] [ebp-160h]
  char v228; // [esp+F8h] [ebp-154h]
  char v229; // [esp+104h] [ebp-148h]
  char v230; // [esp+110h] [ebp-13Ch]
  char v231; // [esp+11Ch] [ebp-130h]
  char v232; // [esp+128h] [ebp-124h]
  char v233; // [esp+134h] [ebp-118h]
  char v234; // [esp+140h] [ebp-10Ch]
  char v235; // [esp+14Ch] [ebp-100h]
  char v236; // [esp+158h] [ebp-F4h]
  char v237; // [esp+164h] [ebp-E8h]
  char v238; // [esp+170h] [ebp-DCh]
  char v239; // [esp+17Ch] [ebp-D0h]
  char v240; // [esp+188h] [ebp-C4h]
  char v241; // [esp+194h] [ebp-B8h]
  char v242; // [esp+1A0h] [ebp-ACh]
  float v243; // [esp+1ACh] [ebp-A0h]
  float v244; // [esp+1B0h] [ebp-9Ch]
  float v245; // [esp+1B4h] [ebp-98h]
  float v246; // [esp+1B8h] [ebp-94h]
  float v247; // [esp+1BCh] [ebp-90h]
  float v248; // [esp+1C0h] [ebp-8Ch]
  float v249; // [esp+1C4h] [ebp-88h]
  float v250; // [esp+1C8h] [ebp-84h]
  float v251; // [esp+1CCh] [ebp-80h]
  float v252; // [esp+1D0h] [ebp-7Ch]
  float v253; // [esp+1D4h] [ebp-78h]
  float v254; // [esp+1D8h] [ebp-74h]
  float v255; // [esp+1DCh] [ebp-70h]
  float v256; // [esp+1E0h] [ebp-6Ch]
  float v257; // [esp+1E4h] [ebp-68h]
  int v258; // [esp+1E8h] [ebp-64h]
  int v259; // [esp+1ECh] [ebp-60h]
  int v260; // [esp+1F0h] [ebp-5Ch]
  char v261; // [esp+1F4h] [ebp-58h]
  float v262; // [esp+20Ch] [ebp-40h]
  float v263; // [esp+210h] [ebp-3Ch]
  float v264; // [esp+214h] [ebp-38h]
  float v265; // [esp+218h] [ebp-34h]
  float v266; // [esp+21Ch] [ebp-30h]
  float v267; // [esp+220h] [ebp-2Ch]
  float v268; // [esp+224h] [ebp-28h]
  float v269; // [esp+228h] [ebp-24h]
  float v270; // [esp+22Ch] [ebp-20h]
  float v271; // [esp+230h] [ebp-1Ch]
  float v272; // [esp+234h] [ebp-18h]
  float v273; // [esp+238h] [ebp-14h]
  float v274; // [esp+23Ch] [ebp-10h]
  char v275; // [esp+240h] [ebp-Ch]

  v5 = KSegment::Origin(a1);
  v6 = KTri::Origin(a2);
  v7 = sub_10002E2D(&v242, v6, v5);
  Vector3f::Vector3f(&v275, v7);
  v8 = KSegment::Direction(a1);
  v274 = Vector3f::squaredLength(v8);
  v9 = KTri::Edge0(a2);
  v10 = KSegment::Direction(a1);
  v273 = -Vector3f::DP(v10, v9);
  v11 = KTri::Edge1(a2);
  v12 = KSegment::Direction(a1);
  v272 = -Vector3f::DP(v12, v11);
  v13 = KTri::Edge0(a2);
  v271 = Vector3f::squaredLength(v13);
  v14 = KTri::Edge1(a2);
  v15 = KTri::Edge0(a2);
  v270 = Vector3f::DP(v15, v14);
  v16 = KTri::Edge1(a2);
  v17 = KTri::Edge1(a2);
  v269 = Vector3f::DP(v17, v16);
  v18 = KSegment::Direction(a1);
  v268 = -Vector3f::DP(&v275, v18);
  v19 = KTri::Edge0(a2);
  v267 = Vector3f::DP(&v275, v19);
  v20 = KTri::Edge1(a2);
  v266 = Vector3f::DP(&v275, v20);
  v265 = v271 * v269 - v270 * v270;
  v264 = v272 * v270 - v273 * v269;
  v263 = v273 * v270 - v272 * v271;
  v21 = v274 * v265 + v273 * v264 + v272 * v263;
  v262 = v21;
  KSegment::KSegment(&v261);
  Vector3f::Vector3f(&v258);
  sub_10001136(v262);
  if ( v21 < flt_101C6144 )
  {
    v196 = KTri::Origin(a2);
    v197 = KSegment::Origin(&v261);
    *v197 = *v196;
    *(v197 + 1) = *(v196 + 1);
    *(v197 + 2) = *(v196 + 2);
    v198 = KTri::Edge0(a2);
    v199 = KSegment::Direction(&v261);
    *v199 = *v198;
    *(v199 + 1) = *(v198 + 1);
    *(v199 + 2) = *(v198 + 2);
    v257 = sqrDistance(a1, &v261, &v255, &v254);
    v253 = 0.0;
    v200 = KTri::Edge1(a2);
    v201 = KSegment::Direction(&v261);
    *v201 = *v200;
    *(v201 + 1) = *(v200 + 1);
    *(v201 + 2) = *(v200 + 2);
    v256 = sqrDistance(a1, &v261, &v252, &v250);
    v251 = 0.0;
    if ( v256 < v257 )
    {
      v257 = v256;
      v255 = v252;
      v254 = v251;
      v253 = v250;
    }
    v202 = KTri::Edge0(a2);
    v203 = KTri::Origin(a2);
    v204 = sub_10001A3C(&v216, v203, v202);
    v205 = KSegment::Origin(&v261);
    *v205 = *v204;
    *(v205 + 1) = v204[1];
    *(v205 + 2) = v204[2];
    v206 = KTri::Edge0(a2);
    v207 = KTri::Edge1(a2);
    v208 = sub_10002E2D(&v215, v207, v206);
    v209 = KSegment::Direction(&v261);
    *v209 = *v208;
    *(v209 + 1) = v208[1];
    *(v209 + 2) = v208[2];
    v256 = sqrDistance(a1, &v261, &v252, &v250);
    v251 = 1.0 - v250;
    if ( v256 < v257 )
    {
      v257 = v256;
      v255 = v252;
      v254 = v251;
      v253 = v250;
    }
    v210 = KSegment::Origin(a1);
    v256 = sqrDistance(v210, a2, &v251, &v250);
    v252 = 0.0;
    if ( v256 < v257 )
    {
      v257 = v256;
      v255 = v252;
      v254 = v251;
      v253 = v250;
    }
    v211 = KSegment::Direction(a1);
    v212 = KSegment::Origin(a1);
    v213 = sub_10001A3C(&v214, v212, v211);
    v258 = *v213;
    v259 = v213[1];
    v260 = v213[2];
    v256 = sqrDistance(&v258, a2, &v251, &v250);
    v252 = 1.0;
    result = v256;
    if ( v256 < v257 )
    {
      v257 = v256;
      v255 = v252;
      v254 = v251;
      v253 = v250;
    }
  }
  else
  {
    v249 = v274 * v269 - v272 * v272;
    v248 = v272 * v273 - v274 * v270;
    v247 = v274 * v271 - v273 * v273;
    v246 = 1.0 / v262;
    v245 = -v268 * v246;
    v244 = -v267 * v246;
    v243 = -v266 * v246;
    v255 = v265 * v245 + v264 * v244 + v263 * v243;
    v254 = v264 * v245 + v249 * v244 + v248 * v243;
    v253 = v263 * v245 + v248 * v244 + v247 * v243;
    if ( v255 >= 0.0 )
    {
      if ( v255 > 1.0 )
      {
        if ( v254 + v253 > 1.0 )
        {
          if ( v254 >= 0.0 )
          {
            if ( v253 >= 0.0 )
            {
              v185 = KTri::Edge0(a2);
              v186 = KTri::Origin(a2);
              v187 = sub_10001A3C(&v219, v186, v185);
              v188 = KSegment::Origin(&v261);
              *v188 = *v187;
              *(v188 + 1) = v187[1];
              *(v188 + 2) = v187[2];
              v189 = KTri::Edge0(a2);
              v190 = KTri::Edge1(a2);
              v191 = sub_10002E2D(&v218, v190, v189);
              v192 = KSegment::Direction(&v261);
              *v192 = *v191;
              *(v192 + 1) = v191[1];
              *(v192 + 2) = v191[2];
              v257 = sqrDistance(a1, &v261, &v255, &v253);
              v254 = 1.0 - v253;
              v193 = KSegment::Direction(a1);
              v194 = KSegment::Origin(a1);
              v195 = sub_10001A3C(&v217, v194, v193);
              v258 = *v195;
              v259 = v195[1];
              v260 = v195[2];
              v256 = sqrDistance(&v258, a2, &v251, &v250);
              v252 = 1.0;
              result = v256;
              if ( v256 < v257 )
              {
                v257 = v256;
                v255 = v252;
                v254 = v251;
                v253 = v250;
              }
            }
            else
            {
              v170 = KTri::Origin(a2);
              v171 = KSegment::Origin(&v261);
              *v171 = *v170;
              *(v171 + 1) = *(v170 + 1);
              *(v171 + 2) = *(v170 + 2);
              v172 = KTri::Edge0(a2);
              v173 = KSegment::Direction(&v261);
              *v173 = *v172;
              *(v173 + 1) = *(v172 + 1);
              *(v173 + 2) = *(v172 + 2);
              v257 = sqrDistance(a1, &v261, &v255, &v254);
              v253 = 0.0;
              v174 = KTri::Edge0(a2);
              v175 = KTri::Origin(a2);
              v176 = sub_10001A3C(&v222, v175, v174);
              v177 = KSegment::Origin(&v261);
              *v177 = *v176;
              *(v177 + 1) = v176[1];
              *(v177 + 2) = v176[2];
              v178 = KTri::Edge0(a2);
              v179 = KTri::Edge1(a2);
              v180 = sub_10002E2D(&v221, v179, v178);
              v181 = KSegment::Direction(&v261);
              *v181 = *v180;
              *(v181 + 1) = v180[1];
              *(v181 + 2) = v180[2];
              v256 = sqrDistance(a1, &v261, &v252, &v250);
              v251 = 1.0 - v250;
              if ( v256 < v257 )
              {
                v257 = v256;
                v255 = v252;
                v254 = v251;
                v253 = v250;
              }
              v182 = KSegment::Direction(a1);
              v183 = KSegment::Origin(a1);
              v184 = sub_10001A3C(&v220, v183, v182);
              v258 = *v184;
              v259 = v184[1];
              v260 = v184[2];
              v256 = sqrDistance(&v258, a2, &v251, &v250);
              v252 = 1.0;
              result = v256;
              if ( v256 < v257 )
              {
                v257 = v256;
                v255 = v252;
                v254 = v251;
                v253 = v250;
              }
            }
          }
          else
          {
            v155 = KTri::Origin(a2);
            v156 = KSegment::Origin(&v261);
            *v156 = *v155;
            *(v156 + 1) = *(v155 + 1);
            *(v156 + 2) = *(v155 + 2);
            v157 = KTri::Edge1(a2);
            v158 = KSegment::Direction(&v261);
            *v158 = *v157;
            *(v158 + 1) = *(v157 + 1);
            *(v158 + 2) = *(v157 + 2);
            v257 = sqrDistance(a1, &v261, &v255, &v253);
            v254 = 0.0;
            v159 = KTri::Edge0(a2);
            v160 = KTri::Origin(a2);
            v161 = sub_10001A3C(&v225, v160, v159);
            v162 = KSegment::Origin(&v261);
            *v162 = *v161;
            *(v162 + 1) = v161[1];
            *(v162 + 2) = v161[2];
            v163 = KTri::Edge0(a2);
            v164 = KTri::Edge1(a2);
            v165 = sub_10002E2D(&v224, v164, v163);
            v166 = KSegment::Direction(&v261);
            *v166 = *v165;
            *(v166 + 1) = v165[1];
            *(v166 + 2) = v165[2];
            v256 = sqrDistance(a1, &v261, &v252, &v250);
            v251 = 1.0 - v250;
            if ( v256 < v257 )
            {
              v257 = v256;
              v255 = v252;
              v254 = v251;
              v253 = v250;
            }
            v167 = KSegment::Direction(a1);
            v168 = KSegment::Origin(a1);
            v169 = sub_10001A3C(&v223, v168, v167);
            v258 = *v169;
            v259 = v169[1];
            v260 = v169[2];
            v256 = sqrDistance(&v258, a2, &v251, &v250);
            v252 = 1.0;
            result = v256;
            if ( v256 < v257 )
            {
              v257 = v256;
              v255 = v252;
              v254 = v251;
              v253 = v250;
            }
          }
        }
        else if ( v254 >= 0.0 )
        {
          if ( v253 >= 0.0 )
          {
            v152 = KSegment::Direction(a1);
            v153 = KSegment::Origin(a1);
            v154 = sub_10001A3C(&v226, v153, v152);
            v258 = *v154;
            v259 = v154[1];
            v260 = v154[2];
            result = sqrDistance(&v258, a2, &v254, &v253);
            v257 = result;
            v255 = 1.0;
          }
          else
          {
            v145 = KTri::Origin(a2);
            v146 = KSegment::Origin(&v261);
            *v146 = *v145;
            *(v146 + 1) = *(v145 + 1);
            *(v146 + 2) = *(v145 + 2);
            v147 = KTri::Edge0(a2);
            v148 = KSegment::Direction(&v261);
            *v148 = *v147;
            *(v148 + 1) = *(v147 + 1);
            *(v148 + 2) = *(v147 + 2);
            v257 = sqrDistance(a1, &v261, &v255, &v254);
            v253 = 0.0;
            v149 = KSegment::Direction(a1);
            v150 = KSegment::Origin(a1);
            v151 = sub_10001A3C(&v227, v150, v149);
            v258 = *v151;
            v259 = v151[1];
            v260 = v151[2];
            v256 = sqrDistance(&v258, a2, &v251, &v250);
            v252 = 1.0;
            result = v256;
            if ( v256 < v257 )
            {
              v257 = v256;
              v255 = v252;
              v254 = v251;
              v253 = v250;
            }
          }
        }
        else if ( v253 >= 0.0 )
        {
          v138 = KTri::Origin(a2);
          v139 = KSegment::Origin(&v261);
          *v139 = *v138;
          *(v139 + 1) = *(v138 + 1);
          *(v139 + 2) = *(v138 + 2);
          v140 = KTri::Edge1(a2);
          v141 = KSegment::Direction(&v261);
          *v141 = *v140;
          *(v141 + 1) = *(v140 + 1);
          *(v141 + 2) = *(v140 + 2);
          v257 = sqrDistance(a1, &v261, &v255, &v253);
          v254 = 0.0;
          v142 = KSegment::Direction(a1);
          v143 = KSegment::Origin(a1);
          v144 = sub_10001A3C(&v228, v143, v142);
          v258 = *v144;
          v259 = v144[1];
          v260 = v144[2];
          v256 = sqrDistance(&v258, a2, &v251, &v250);
          v252 = 1.0;
          result = v256;
          if ( v256 < v257 )
          {
            v257 = v256;
            v255 = v252;
            v254 = v251;
            v253 = v250;
          }
        }
        else
        {
          v127 = KTri::Origin(a2);
          v128 = KSegment::Origin(&v261);
          *v128 = *v127;
          *(v128 + 1) = *(v127 + 1);
          *(v128 + 2) = *(v127 + 2);
          v129 = KTri::Edge1(a2);
          v130 = KSegment::Direction(&v261);
          *v130 = *v129;
          *(v130 + 1) = *(v129 + 1);
          *(v130 + 2) = *(v129 + 2);
          v257 = sqrDistance(a1, &v261, &v255, &v253);
          v254 = 0.0;
          v131 = KTri::Origin(a2);
          v132 = KSegment::Origin(&v261);
          *v132 = *v131;
          *(v132 + 1) = *(v131 + 1);
          *(v132 + 2) = *(v131 + 2);
          v133 = KTri::Edge0(a2);
          v134 = KSegment::Direction(&v261);
          *v134 = *v133;
          *(v134 + 1) = *(v133 + 1);
          *(v134 + 2) = *(v133 + 2);
          v256 = sqrDistance(a1, &v261, &v252, &v251);
          v250 = 0.0;
          if ( v256 < v257 )
          {
            v257 = v256;
            v255 = v252;
            v254 = v251;
            v253 = v250;
          }
          v135 = KSegment::Direction(a1);
          v136 = KSegment::Origin(a1);
          v137 = sub_10001A3C(&v229, v136, v135);
          v258 = *v137;
          v259 = v137[1];
          v260 = v137[2];
          v256 = sqrDistance(&v258, a2, &v251, &v250);
          v252 = 1.0;
          result = v256;
          if ( v256 < v257 )
          {
            v257 = v256;
            v255 = v252;
            v254 = v251;
            v253 = v250;
          }
        }
      }
      else if ( v254 + v253 > 1.0 )
      {
        if ( v254 >= 0.0 )
        {
          if ( v253 >= 0.0 )
          {
            v119 = KTri::Edge0(a2);
            v120 = KTri::Origin(a2);
            v121 = sub_10001A3C(&v231, v120, v119);
            v122 = KSegment::Origin(&v261);
            *v122 = *v121;
            *(v122 + 1) = v121[1];
            *(v122 + 2) = v121[2];
            v123 = KTri::Edge0(a2);
            v124 = KTri::Edge1(a2);
            v125 = sub_10002E2D(&v230, v124, v123);
            v126 = KSegment::Direction(&v261);
            *v126 = *v125;
            *(v126 + 1) = v125[1];
            *(v126 + 2) = v125[2];
            v257 = sqrDistance(a1, &v261, &v255, &v253);
            result = 1.0 - v253;
            v254 = result;
          }
          else
          {
            v107 = KTri::Origin(a2);
            v108 = KSegment::Origin(&v261);
            *v108 = *v107;
            *(v108 + 1) = *(v107 + 1);
            *(v108 + 2) = *(v107 + 2);
            v109 = KTri::Edge0(a2);
            v110 = KSegment::Direction(&v261);
            *v110 = *v109;
            *(v110 + 1) = *(v109 + 1);
            *(v110 + 2) = *(v109 + 2);
            v257 = sqrDistance(a1, &v261, &v255, &v254);
            v253 = 0.0;
            v111 = KTri::Edge0(a2);
            v112 = KTri::Origin(a2);
            v113 = sub_10001A3C(&v233, v112, v111);
            v114 = KSegment::Origin(&v261);
            *v114 = *v113;
            *(v114 + 1) = v113[1];
            *(v114 + 2) = v113[2];
            v115 = KTri::Edge0(a2);
            v116 = KTri::Edge1(a2);
            v117 = sub_10002E2D(&v232, v116, v115);
            v118 = KSegment::Direction(&v261);
            *v118 = *v117;
            *(v118 + 1) = v117[1];
            *(v118 + 2) = v117[2];
            v256 = sqrDistance(a1, &v261, &v252, &v250);
            v251 = 1.0 - v250;
            result = v256;
            if ( v256 < v257 )
            {
              v257 = v256;
              v255 = v252;
              v254 = v251;
              v253 = v250;
            }
          }
        }
        else
        {
          v95 = KTri::Origin(a2);
          v96 = KSegment::Origin(&v261);
          *v96 = *v95;
          *(v96 + 1) = *(v95 + 1);
          *(v96 + 2) = *(v95 + 2);
          v97 = KTri::Edge1(a2);
          v98 = KSegment::Direction(&v261);
          *v98 = *v97;
          *(v98 + 1) = *(v97 + 1);
          *(v98 + 2) = *(v97 + 2);
          v257 = sqrDistance(a1, &v261, &v255, &v253);
          v254 = 0.0;
          v99 = KTri::Edge0(a2);
          v100 = KTri::Origin(a2);
          v101 = sub_10001A3C(&v235, v100, v99);
          v102 = KSegment::Origin(&v261);
          *v102 = *v101;
          *(v102 + 1) = v101[1];
          *(v102 + 2) = v101[2];
          v103 = KTri::Edge0(a2);
          v104 = KTri::Edge1(a2);
          v105 = sub_10002E2D(&v234, v104, v103);
          v106 = KSegment::Direction(&v261);
          *v106 = *v105;
          *(v106 + 1) = v105[1];
          *(v106 + 2) = v105[2];
          v256 = sqrDistance(a1, &v261, &v252, &v250);
          v251 = 1.0 - v250;
          result = v256;
          if ( v256 < v257 )
          {
            v257 = v256;
            v255 = v252;
            v254 = v251;
            v253 = v250;
          }
        }
      }
      else if ( v254 >= 0.0 )
      {
        if ( v253 >= 0.0 )
        {
          v94 = (v274 * v255 + v273 * v254 + v272 * v253 + 2.0 * v268) * v255
              + (v273 * v255 + v271 * v254 + v270 * v253 + 2.0 * v267) * v254
              + (v272 * v255 + v270 * v254 + v269 * v253 + 2.0 * v266) * v253;
          result = Vector3f::squaredLength(&v275) + v94;
          v257 = result;
        }
        else
        {
          v90 = KTri::Origin(a2);
          v91 = KSegment::Origin(&v261);
          *v91 = *v90;
          *(v91 + 1) = *(v90 + 1);
          *(v91 + 2) = *(v90 + 2);
          v92 = KTri::Edge0(a2);
          v93 = KSegment::Direction(&v261);
          *v93 = *v92;
          *(v93 + 1) = *(v92 + 1);
          *(v93 + 2) = *(v92 + 2);
          result = sqrDistance(a1, &v261, &v255, &v254);
          v257 = result;
          v253 = 0.0;
        }
      }
      else if ( v253 >= 0.0 )
      {
        v86 = KTri::Origin(a2);
        v87 = KSegment::Origin(&v261);
        *v87 = *v86;
        *(v87 + 1) = *(v86 + 1);
        *(v87 + 2) = *(v86 + 2);
        v88 = KTri::Edge1(a2);
        v89 = KSegment::Direction(&v261);
        *v89 = *v88;
        *(v89 + 1) = *(v88 + 1);
        *(v89 + 2) = *(v88 + 2);
        result = sqrDistance(a1, &v261, &v255, &v253);
        v257 = result;
        v254 = 0.0;
      }
      else
      {
        v78 = KTri::Origin(a2);
        v79 = KSegment::Origin(&v261);
        *v79 = *v78;
        *(v79 + 1) = *(v78 + 1);
        *(v79 + 2) = *(v78 + 2);
        v80 = KTri::Edge1(a2);
        v81 = KSegment::Direction(&v261);
        *v81 = *v80;
        *(v81 + 1) = *(v80 + 1);
        *(v81 + 2) = *(v80 + 2);
        v257 = sqrDistance(a1, &v261, &v255, &v253);
        v254 = 0.0;
        v82 = KTri::Origin(a2);
        v83 = KSegment::Origin(&v261);
        *v83 = *v82;
        *(v83 + 1) = *(v82 + 1);
        *(v83 + 2) = *(v82 + 2);
        v84 = KTri::Edge0(a2);
        v85 = KSegment::Direction(&v261);
        *v85 = *v84;
        *(v85 + 1) = *(v84 + 1);
        *(v85 + 2) = *(v84 + 2);
        v256 = sqrDistance(a1, &v261, &v252, &v251);
        v250 = 0.0;
        result = v256;
        if ( v256 < v257 )
        {
          v257 = v256;
          v255 = v252;
          v254 = v251;
          v253 = v250;
        }
      }
    }
    else if ( v254 + v253 > 1.0 )
    {
      if ( v254 >= 0.0 )
      {
        if ( v253 >= 0.0 )
        {
          v69 = KTri::Edge0(a2);
          v70 = KTri::Origin(a2);
          v71 = sub_10001A3C(&v237, v70, v69);
          v72 = KSegment::Origin(&v261);
          *v72 = *v71;
          *(v72 + 1) = v71[1];
          *(v72 + 2) = v71[2];
          v73 = KTri::Edge0(a2);
          v74 = KTri::Edge1(a2);
          v75 = sub_10002E2D(&v236, v74, v73);
          v76 = KSegment::Direction(&v261);
          *v76 = *v75;
          *(v76 + 1) = v75[1];
          *(v76 + 2) = v75[2];
          v257 = sqrDistance(a1, &v261, &v255, &v253);
          v254 = 1.0 - v253;
          v77 = KSegment::Origin(a1);
          v256 = sqrDistance(v77, a2, &v251, &v250);
          v252 = 0.0;
          result = v256;
          if ( v256 < v257 )
          {
            v257 = v256;
            v255 = v252;
            v254 = v251;
            v253 = v250;
          }
        }
        else
        {
          v56 = KTri::Origin(a2);
          v57 = KSegment::Origin(&v261);
          *v57 = *v56;
          *(v57 + 1) = *(v56 + 1);
          *(v57 + 2) = *(v56 + 2);
          v58 = KTri::Edge0(a2);
          v59 = KSegment::Direction(&v261);
          *v59 = *v58;
          *(v59 + 1) = *(v58 + 1);
          *(v59 + 2) = *(v58 + 2);
          v257 = sqrDistance(a1, &v261, &v255, &v254);
          v253 = 0.0;
          v60 = KTri::Edge0(a2);
          v61 = KTri::Origin(a2);
          v62 = sub_10001A3C(&v239, v61, v60);
          v63 = KSegment::Origin(&v261);
          *v63 = *v62;
          *(v63 + 1) = v62[1];
          *(v63 + 2) = v62[2];
          v64 = KTri::Edge0(a2);
          v65 = KTri::Edge1(a2);
          v66 = sub_10002E2D(&v238, v65, v64);
          v67 = KSegment::Direction(&v261);
          *v67 = *v66;
          *(v67 + 1) = v66[1];
          *(v67 + 2) = v66[2];
          v256 = sqrDistance(a1, &v261, &v252, &v250);
          v251 = 1.0 - v250;
          if ( v256 < v257 )
          {
            v257 = v256;
            v255 = v252;
            v254 = v251;
            v253 = v250;
          }
          v68 = KSegment::Origin(a1);
          v256 = sqrDistance(v68, a2, &v251, &v250);
          v252 = 0.0;
          result = v256;
          if ( v256 < v257 )
          {
            v257 = v256;
            v255 = v252;
            v254 = v251;
            v253 = v250;
          }
        }
      }
      else
      {
        v43 = KTri::Origin(a2);
        v44 = KSegment::Origin(&v261);
        *v44 = *v43;
        *(v44 + 1) = *(v43 + 1);
        *(v44 + 2) = *(v43 + 2);
        v45 = KTri::Edge1(a2);
        v46 = KSegment::Direction(&v261);
        *v46 = *v45;
        *(v46 + 1) = *(v45 + 1);
        *(v46 + 2) = *(v45 + 2);
        v257 = sqrDistance(a1, &v261, &v255, &v253);
        v254 = 0.0;
        v47 = KTri::Edge0(a2);
        v48 = KTri::Origin(a2);
        v49 = sub_10001A3C(&v241, v48, v47);
        v50 = KSegment::Origin(&v261);
        *v50 = *v49;
        *(v50 + 1) = v49[1];
        *(v50 + 2) = v49[2];
        v51 = KTri::Edge0(a2);
        v52 = KTri::Edge1(a2);
        v53 = sub_10002E2D(&v240, v52, v51);
        v54 = KSegment::Direction(&v261);
        *v54 = *v53;
        *(v54 + 1) = v53[1];
        *(v54 + 2) = v53[2];
        v256 = sqrDistance(a1, &v261, &v252, &v250);
        v251 = 1.0 - v250;
        if ( v256 < v257 )
        {
          v257 = v256;
          v255 = v252;
          v254 = v251;
          v253 = v250;
        }
        v55 = KSegment::Origin(a1);
        v256 = sqrDistance(v55, a2, &v251, &v250);
        v252 = 0.0;
        result = v256;
        if ( v256 < v257 )
        {
          v257 = v256;
          v255 = v252;
          v254 = v251;
          v253 = v250;
        }
      }
    }
    else if ( v254 >= 0.0 )
    {
      if ( v253 >= 0.0 )
      {
        v42 = KSegment::Origin(a1);
        result = sqrDistance(v42, a2, &v254, &v253);
        v257 = result;
        v255 = 0.0;
      }
      else
      {
        v37 = KTri::Origin(a2);
        v38 = KSegment::Origin(&v261);
        *v38 = *v37;
        *(v38 + 1) = *(v37 + 1);
        *(v38 + 2) = *(v37 + 2);
        v39 = KTri::Edge0(a2);
        v40 = KSegment::Direction(&v261);
        *v40 = *v39;
        *(v40 + 1) = *(v39 + 1);
        *(v40 + 2) = *(v39 + 2);
        v257 = sqrDistance(a1, &v261, &v255, &v254);
        v253 = 0.0;
        v41 = KSegment::Origin(a1);
        v256 = sqrDistance(v41, a2, &v251, &v250);
        v252 = 0.0;
        result = v256;
        if ( v256 < v257 )
        {
          v257 = v256;
          v255 = v252;
          v254 = v251;
          v253 = v250;
        }
      }
    }
    else if ( v253 >= 0.0 )
    {
      v32 = KTri::Origin(a2);
      v33 = KSegment::Origin(&v261);
      *v33 = *v32;
      *(v33 + 1) = *(v32 + 1);
      *(v33 + 2) = *(v32 + 2);
      v34 = KTri::Edge1(a2);
      v35 = KSegment::Direction(&v261);
      *v35 = *v34;
      *(v35 + 1) = *(v34 + 1);
      *(v35 + 2) = *(v34 + 2);
      v257 = sqrDistance(a1, &v261, &v255, &v253);
      v254 = 0.0;
      v36 = KSegment::Origin(a1);
      v256 = sqrDistance(v36, a2, &v251, &v250);
      v252 = 0.0;
      result = v256;
      if ( v256 < v257 )
      {
        v257 = v256;
        v255 = v252;
        v254 = v251;
        v253 = v250;
      }
    }
    else
    {
      v22 = KTri::Origin(a2);
      v23 = KSegment::Origin(&v261);
      *v23 = *v22;
      *(v23 + 1) = *(v22 + 1);
      *(v23 + 2) = *(v22 + 2);
      v24 = KTri::Edge1(a2);
      v25 = KSegment::Direction(&v261);
      *v25 = *v24;
      *(v25 + 1) = *(v24 + 1);
      *(v25 + 2) = *(v24 + 2);
      v257 = sqrDistance(a1, &v261, &v255, &v253);
      v254 = 0.0;
      v26 = KTri::Origin(a2);
      v27 = KSegment::Origin(&v261);
      *v27 = *v26;
      *(v27 + 1) = *(v26 + 1);
      *(v27 + 2) = *(v26 + 2);
      v28 = KTri::Edge0(a2);
      v29 = KSegment::Direction(&v261);
      *v29 = *v28;
      *(v29 + 1) = *(v28 + 1);
      *(v29 + 2) = *(v28 + 2);
      v256 = sqrDistance(a1, &v261, &v252, &v251);
      v250 = 0.0;
      if ( v256 < v257 )
      {
        v257 = v256;
        v255 = v252;
        v254 = v251;
        v253 = v250;
      }
      v30 = KSegment::Origin(a1);
      v256 = sqrDistance(v30, a2, &v251, &v250);
      v252 = 0.0;
      result = v256;
      if ( v256 < v257 )
      {
        v257 = v256;
        v255 = v252;
        v254 = v251;
        v253 = v250;
      }
    }
  }
  if ( a3 )
    *a3 = v255;
  if ( a4 )
    *a4 = v254;
  if ( a5 )
    *a5 = v253;
  sub_10001136(v257);
  return result;
}
// 101C6144: using guessed type float flt_101C6144;

//----- (10045B20) --------------------------------------------------------
double __cdecl sqrDistance(struct KSegment *a1, struct KSegment *a2, float *a3, float *a4)
{
  struct Vector3f *v4; // ST08_4
  struct Vector3f *v5; // eax
  const struct Vector3f *v6; // eax
  Vector3f *v7; // eax
  struct Vector3f *v8; // ST08_4
  Vector3f *v9; // eax
  Vector3f *v10; // eax
  struct Vector3f *v11; // eax
  double v12; // st7
  float v13; // ST08_4
  struct Vector3f *v14; // eax
  double result; // st7
  struct Vector3f *v16; // eax
  double v17; // st6
  struct Vector3f *v18; // eax
  char v19; // [esp+50h] [ebp-48h]
  float v20; // [esp+5Ch] [ebp-3Ch]
  float v21; // [esp+60h] [ebp-38h]
  float v22; // [esp+64h] [ebp-34h]
  float v23; // [esp+68h] [ebp-30h]
  float v24; // [esp+6Ch] [ebp-2Ch]
  float v25; // [esp+70h] [ebp-28h]
  float v26; // [esp+74h] [ebp-24h]
  float v27; // [esp+78h] [ebp-20h]
  float v28; // [esp+7Ch] [ebp-1Ch]
  float v29; // [esp+80h] [ebp-18h]
  float v30; // [esp+84h] [ebp-14h]
  float v31; // [esp+88h] [ebp-10h]
  char v32; // [esp+8Ch] [ebp-Ch]

  v4 = KSegment::Origin(a2);
  v5 = KSegment::Origin(a1);
  v6 = sub_10002E2D(&v19, v5, v4);
  Vector3f::Vector3f(&v32, v6);
  v7 = KSegment::Direction(a1);
  v31 = Vector3f::squaredLength(v7);
  v8 = KSegment::Direction(a2);
  v9 = KSegment::Direction(a1);
  v30 = -Vector3f::DP(v9, v8);
  v10 = KSegment::Direction(a2);
  v29 = Vector3f::squaredLength(v10);
  v11 = KSegment::Direction(a1);
  v28 = Vector3f::DP(&v32, v11);
  v27 = Vector3f::squaredLength(&v32);
  v12 = v31 * v29 - v30 * v30;
  v13 = v12;
  sub_10001136(v13);
  v26 = v12;
  if ( v26 < flt_101C6144 )
  {
    if ( v30 <= 0.0 )
    {
      if ( -v28 < v31 )
      {
        if ( v28 > 0.0 )
        {
          v18 = KSegment::Direction(a2);
          v25 = -Vector3f::DP(&v32, v18);
          v24 = 0.0;
          if ( -v30 > v28 )
          {
            v23 = -v28 / v30;
            result = (2.0 * v25 + v29 * v23) * v23 + v27;
          }
          else
          {
            v23 = 1.0;
            result = 2.0 * v25 + v29 + v27;
          }
          v22 = result;
        }
        else
        {
          v24 = -v28 / v31;
          v23 = 0.0;
          result = v28 * v24 + v27;
          v22 = result;
        }
      }
      else
      {
        v24 = 1.0;
        v23 = 0.0;
        result = 2.0 * v28 + v31 + v27;
        v22 = result;
      }
    }
    else
    {
      result = v28;
      if ( v28 < 0.0 )
      {
        if ( -v28 > v31 )
        {
          v16 = KSegment::Direction(a2);
          v25 = -Vector3f::DP(&v32, v16);
          v24 = 1.0;
          v21 = v31 + v28;
          if ( -v21 < v30 )
          {
            v23 = -v21 / v30;
            result = 2.0 * v28 + v31 + v27 + (v29 * v23 + v30 + v25 + v30 + v25) * v23;
          }
          else
          {
            v23 = 1.0;
            v17 = v30 + v28 + v25;
            result = v31 + v29 + v27 + v17 + v17;
          }
          v22 = result;
        }
        else
        {
          v24 = -v28 / v31;
          v23 = 0.0;
          result = v28 * v24 + v27;
          v22 = result;
        }
      }
      else
      {
        v24 = 0.0;
        v23 = 0.0;
        v22 = v27;
      }
    }
  }
  else
  {
    v14 = KSegment::Direction(a2);
    v25 = -Vector3f::DP(&v32, v14);
    v24 = v30 * v25 - v29 * v28;
    v23 = v30 * v28 - v31 * v25;
    if ( v24 < 0.0 )
    {
      if ( v23 < 0.0 )
      {
        if ( v28 >= 0.0 )
        {
          v24 = 0.0;
          result = v25;
          if ( v25 < 0.0 )
          {
            if ( -v25 < v29 )
            {
              v23 = -v25 / v29;
              result = v25 * v23 + v27;
            }
            else
            {
              v23 = 1.0;
              result = 2.0 * v25 + v29 + v27;
            }
            v22 = result;
          }
          else
          {
            v23 = 0.0;
            v22 = v27;
          }
        }
        else
        {
          v23 = 0.0;
          if ( -v28 < v31 )
          {
            v24 = -v28 / v31;
            result = v28 * v24 + v27;
          }
          else
          {
            v24 = 1.0;
            result = 2.0 * v28 + v31 + v27;
          }
          v22 = result;
        }
      }
      else if ( v23 > v26 )
      {
        v21 = v30 + v28;
        if ( v21 >= 0.0 )
        {
          v24 = 0.0;
          result = v25;
          if ( v25 < 0.0 )
          {
            if ( -v25 < v29 )
            {
              v23 = -v25 / v29;
              result = v25 * v23 + v27;
            }
            else
            {
              v23 = 1.0;
              result = 2.0 * v25 + v29 + v27;
            }
            v22 = result;
          }
          else
          {
            v23 = 0.0;
            v22 = v27;
          }
        }
        else
        {
          v23 = 1.0;
          if ( -v21 < v31 )
          {
            v24 = -v21 / v31;
            result = v21 * v24 + v29 + 2.0 * v25 + v27;
          }
          else
          {
            v24 = 1.0;
            result = v31 + v29 + v27 + v25 + v21 + v25 + v21;
          }
          v22 = result;
        }
      }
      else
      {
        v24 = 0.0;
        result = v25;
        if ( v25 < 0.0 )
        {
          if ( -v25 < v29 )
          {
            v23 = -v25 / v29;
            result = v25 * v23 + v27;
          }
          else
          {
            v23 = 1.0;
            result = 2.0 * v25 + v29 + v27;
          }
          v22 = result;
        }
        else
        {
          v23 = 0.0;
          v22 = v27;
        }
      }
    }
    else if ( v24 > v26 )
    {
      if ( v23 < 0.0 )
      {
        if ( -v28 >= v31 )
        {
          v24 = 1.0;
          v21 = v30 + v25;
          if ( v21 < 0.0 )
          {
            if ( -v21 < v29 )
            {
              v23 = -v21 / v29;
              result = v21 * v23 + v31 + 2.0 * v28 + v27;
            }
            else
            {
              v23 = 1.0;
              result = v31 + v29 + v27 + v28 + v21 + v28 + v21;
            }
            v22 = result;
          }
          else
          {
            v23 = 0.0;
            result = 2.0 * v28 + v31 + v27;
            v22 = result;
          }
        }
        else
        {
          v23 = 0.0;
          result = v28;
          if ( v28 < 0.0 )
          {
            v24 = -v28 / v31;
            result = v28 * v24 + v27;
            v22 = result;
          }
          else
          {
            v24 = 0.0;
            v22 = v27;
          }
        }
      }
      else if ( v23 > v26 )
      {
        v21 = v30 + v28;
        if ( -v21 > v31 )
        {
          v24 = 1.0;
          v21 = v30 + v25;
          if ( v21 < 0.0 )
          {
            if ( -v21 < v29 )
            {
              v23 = -v21 / v29;
              result = v21 * v23 + v31 + 2.0 * v28 + v27;
            }
            else
            {
              v23 = 1.0;
              result = v31 + v29 + v27 + v28 + v21 + v28 + v21;
            }
            v22 = result;
          }
          else
          {
            v23 = 0.0;
            result = 2.0 * v28 + v31 + v27;
            v22 = result;
          }
        }
        else
        {
          v23 = 1.0;
          if ( v21 < 0.0 )
          {
            v24 = -v21 / v31;
            result = v21 * v24 + v29 + 2.0 * v25 + v27;
          }
          else
          {
            v24 = 0.0;
            result = 2.0 * v25 + v29 + v27;
          }
          v22 = result;
        }
      }
      else
      {
        v24 = 1.0;
        v21 = v30 + v25;
        if ( v21 < 0.0 )
        {
          if ( -v21 < v29 )
          {
            v23 = -v21 / v29;
            result = v21 * v23 + v31 + 2.0 * v28 + v27;
          }
          else
          {
            v23 = 1.0;
            result = v31 + v29 + v27 + v28 + v21 + v28 + v21;
          }
          v22 = result;
        }
        else
        {
          v23 = 0.0;
          result = 2.0 * v28 + v31 + v27;
          v22 = result;
        }
      }
    }
    else if ( v23 < 0.0 )
    {
      v23 = 0.0;
      result = v28;
      if ( v28 < 0.0 )
      {
        if ( -v28 < v31 )
        {
          v24 = -v28 / v31;
          result = v28 * v24 + v27;
        }
        else
        {
          v24 = 1.0;
          result = 2.0 * v28 + v31 + v27;
        }
        v22 = result;
      }
      else
      {
        v24 = 0.0;
        v22 = v27;
      }
    }
    else if ( v23 > v26 )
    {
      v23 = 1.0;
      v21 = v30 + v28;
      if ( v21 < 0.0 )
      {
        if ( -v21 < v31 )
        {
          v24 = -v21 / v31;
          result = v21 * v24 + v29 + 2.0 * v25 + v27;
        }
        else
        {
          v24 = 1.0;
          result = v31 + v29 + v27 + v25 + v21 + v25 + v21;
        }
        v22 = result;
      }
      else
      {
        v24 = 0.0;
        result = 2.0 * v25 + v29 + v27;
        v22 = result;
      }
    }
    else
    {
      v20 = 1.0 / v26;
      v24 = v24 * v20;
      v23 = v23 * v20;
      result = (v31 * v24 + v30 * v23 + 2.0 * v28) * v24 + (v30 * v24 + v29 * v23 + 2.0 * v25) * v23 + v27;
      v22 = result;
    }
  }
  if ( a3 )
    *a3 = v24;
  if ( a4 )
    *a4 = v23;
  sub_10001136(v22);
  return result;
}
// 101C6144: using guessed type float flt_101C6144;

//----- (10046720) --------------------------------------------------------
double __cdecl sqrDistance(struct KSegment *a1, struct KRect *a2, float *a3, float *a4, float *a5)
{
  struct Vector3f *v5; // ST0C_4
  struct Vector3f *v6; // eax
  const struct Vector3f *v7; // eax
  Vector3f *v8; // eax
  struct Vector3f *v9; // ST0C_4
  Vector3f *v10; // eax
  struct Vector3f *v11; // ST0C_4
  Vector3f *v12; // eax
  Vector3f *v13; // eax
  Vector3f *v14; // eax
  struct Vector3f *v15; // eax
  struct Vector3f *v16; // eax
  struct Vector3f *v17; // eax
  double v18; // st7
  struct Vector3f *v19; // esi
  struct Vector3f *v20; // eax
  struct Vector3f *v21; // esi
  struct Vector3f *v22; // eax
  struct Vector3f *v23; // esi
  struct Vector3f *v24; // eax
  struct Vector3f *v25; // esi
  struct Vector3f *v26; // eax
  struct Vector3f *v27; // eax
  double result; // st7
  struct Vector3f *v29; // esi
  struct Vector3f *v30; // eax
  struct Vector3f *v31; // esi
  struct Vector3f *v32; // eax
  struct Vector3f *v33; // eax
  struct Vector3f *v34; // esi
  struct Vector3f *v35; // eax
  struct Vector3f *v36; // esi
  struct Vector3f *v37; // eax
  struct Vector3f *v38; // ST0C_4
  struct Vector3f *v39; // eax
  _DWORD *v40; // esi
  struct Vector3f *v41; // eax
  struct Vector3f *v42; // esi
  struct Vector3f *v43; // eax
  struct Vector3f *v44; // eax
  struct Vector3f *v45; // esi
  struct Vector3f *v46; // eax
  struct Vector3f *v47; // esi
  struct Vector3f *v48; // eax
  struct Vector3f *v49; // eax
  struct Vector3f *v50; // eax
  struct Vector3f *v51; // ST0C_4
  struct Vector3f *v52; // eax
  _DWORD *v53; // esi
  struct Vector3f *v54; // eax
  struct Vector3f *v55; // esi
  struct Vector3f *v56; // eax
  struct Vector3f *v57; // eax
  struct Vector3f *v58; // ST0C_4
  struct Vector3f *v59; // eax
  _DWORD *v60; // esi
  struct Vector3f *v61; // eax
  struct Vector3f *v62; // esi
  struct Vector3f *v63; // eax
  struct Vector3f *v64; // esi
  struct Vector3f *v65; // eax
  struct Vector3f *v66; // esi
  struct Vector3f *v67; // eax
  struct Vector3f *v68; // eax
  struct Vector3f *v69; // ST0C_4
  struct Vector3f *v70; // eax
  _DWORD *v71; // esi
  struct Vector3f *v72; // eax
  struct Vector3f *v73; // esi
  struct Vector3f *v74; // eax
  struct Vector3f *v75; // eax
  struct Vector3f *v76; // ST0C_4
  struct Vector3f *v77; // eax
  _DWORD *v78; // esi
  struct Vector3f *v79; // eax
  struct Vector3f *v80; // esi
  struct Vector3f *v81; // eax
  struct Vector3f *v82; // ST0C_4
  struct Vector3f *v83; // eax
  _DWORD *v84; // esi
  struct Vector3f *v85; // eax
  struct Vector3f *v86; // esi
  struct Vector3f *v87; // eax
  struct Vector3f *v88; // eax
  struct Vector3f *v89; // esi
  struct Vector3f *v90; // eax
  struct Vector3f *v91; // esi
  struct Vector3f *v92; // eax
  struct Vector3f *v93; // esi
  struct Vector3f *v94; // eax
  struct Vector3f *v95; // esi
  struct Vector3f *v96; // eax
  struct Vector3f *v97; // esi
  struct Vector3f *v98; // eax
  struct Vector3f *v99; // esi
  struct Vector3f *v100; // eax
  struct Vector3f *v101; // esi
  struct Vector3f *v102; // eax
  struct Vector3f *v103; // esi
  struct Vector3f *v104; // eax
  struct Vector3f *v105; // ST0C_4
  struct Vector3f *v106; // eax
  _DWORD *v107; // esi
  struct Vector3f *v108; // eax
  struct Vector3f *v109; // esi
  struct Vector3f *v110; // eax
  struct Vector3f *v111; // esi
  struct Vector3f *v112; // eax
  struct Vector3f *v113; // esi
  struct Vector3f *v114; // eax
  float v115; // ST5C_4
  struct Vector3f *v116; // ST0C_4
  struct Vector3f *v117; // eax
  _DWORD *v118; // esi
  struct Vector3f *v119; // eax
  struct Vector3f *v120; // esi
  struct Vector3f *v121; // eax
  struct Vector3f *v122; // ST0C_4
  struct Vector3f *v123; // eax
  _DWORD *v124; // esi
  struct Vector3f *v125; // eax
  struct Vector3f *v126; // esi
  struct Vector3f *v127; // eax
  struct Vector3f *v128; // esi
  struct Vector3f *v129; // eax
  struct Vector3f *v130; // esi
  struct Vector3f *v131; // eax
  struct Vector3f *v132; // ST0C_4
  struct Vector3f *v133; // eax
  _DWORD *v134; // esi
  struct Vector3f *v135; // eax
  struct Vector3f *v136; // esi
  struct Vector3f *v137; // eax
  struct Vector3f *v138; // ST0C_4
  struct Vector3f *v139; // eax
  _DWORD *v140; // esi
  struct Vector3f *v141; // eax
  struct Vector3f *v142; // esi
  struct Vector3f *v143; // eax
  struct Vector3f *v144; // ST0C_4
  struct Vector3f *v145; // eax
  _DWORD *v146; // esi
  struct Vector3f *v147; // eax
  struct Vector3f *v148; // esi
  struct Vector3f *v149; // eax
  struct Vector3f *v150; // esi
  struct Vector3f *v151; // eax
  struct Vector3f *v152; // esi
  struct Vector3f *v153; // eax
  struct Vector3f *v154; // esi
  struct Vector3f *v155; // eax
  struct Vector3f *v156; // esi
  struct Vector3f *v157; // eax
  struct Vector3f *v158; // ST0C_4
  struct Vector3f *v159; // eax
  int *v160; // eax
  struct Vector3f *v161; // esi
  struct Vector3f *v162; // eax
  struct Vector3f *v163; // esi
  struct Vector3f *v164; // eax
  struct Vector3f *v165; // eax
  struct Vector3f *v166; // ST0C_4
  struct Vector3f *v167; // eax
  int *v168; // eax
  struct Vector3f *v169; // esi
  struct Vector3f *v170; // eax
  struct Vector3f *v171; // esi
  struct Vector3f *v172; // eax
  struct Vector3f *v173; // ST0C_4
  struct Vector3f *v174; // eax
  _DWORD *v175; // esi
  struct Vector3f *v176; // eax
  struct Vector3f *v177; // esi
  struct Vector3f *v178; // eax
  struct Vector3f *v179; // ST0C_4
  struct Vector3f *v180; // eax
  int *v181; // eax
  struct Vector3f *v182; // esi
  struct Vector3f *v183; // eax
  struct Vector3f *v184; // esi
  struct Vector3f *v185; // eax
  struct Vector3f *v186; // ST0C_4
  struct Vector3f *v187; // eax
  int *v188; // eax
  struct Vector3f *v189; // ST0C_4
  struct Vector3f *v190; // eax
  int *v191; // eax
  struct Vector3f *v192; // ST0C_4
  struct Vector3f *v193; // eax
  _DWORD *v194; // esi
  struct Vector3f *v195; // eax
  struct Vector3f *v196; // esi
  struct Vector3f *v197; // eax
  struct Vector3f *v198; // ST0C_4
  struct Vector3f *v199; // eax
  int *v200; // eax
  struct Vector3f *v201; // ST0C_4
  struct Vector3f *v202; // eax
  _DWORD *v203; // esi
  struct Vector3f *v204; // eax
  struct Vector3f *v205; // esi
  struct Vector3f *v206; // eax
  struct Vector3f *v207; // esi
  struct Vector3f *v208; // eax
  struct Vector3f *v209; // esi
  struct Vector3f *v210; // eax
  struct Vector3f *v211; // ST0C_4
  struct Vector3f *v212; // eax
  int *v213; // eax
  struct Vector3f *v214; // ST0C_4
  struct Vector3f *v215; // eax
  _DWORD *v216; // esi
  struct Vector3f *v217; // eax
  struct Vector3f *v218; // esi
  struct Vector3f *v219; // eax
  struct Vector3f *v220; // ST0C_4
  struct Vector3f *v221; // eax
  int *v222; // eax
  struct Vector3f *v223; // ST0C_4
  struct Vector3f *v224; // eax
  _DWORD *v225; // esi
  struct Vector3f *v226; // eax
  struct Vector3f *v227; // esi
  struct Vector3f *v228; // eax
  struct Vector3f *v229; // ST0C_4
  struct Vector3f *v230; // eax
  _DWORD *v231; // esi
  struct Vector3f *v232; // eax
  struct Vector3f *v233; // esi
  struct Vector3f *v234; // eax
  struct Vector3f *v235; // ST0C_4
  struct Vector3f *v236; // eax
  int *v237; // eax
  struct Vector3f *v238; // esi
  struct Vector3f *v239; // eax
  struct Vector3f *v240; // esi
  struct Vector3f *v241; // eax
  struct Vector3f *v242; // esi
  struct Vector3f *v243; // eax
  struct Vector3f *v244; // ST0C_4
  struct Vector3f *v245; // eax
  _DWORD *v246; // esi
  struct Vector3f *v247; // eax
  struct Vector3f *v248; // esi
  struct Vector3f *v249; // eax
  struct Vector3f *v250; // ST0C_4
  struct Vector3f *v251; // eax
  _DWORD *v252; // esi
  struct Vector3f *v253; // eax
  struct Vector3f *v254; // esi
  struct Vector3f *v255; // eax
  struct Vector3f *v256; // eax
  struct Vector3f *v257; // ST0C_4
  struct Vector3f *v258; // eax
  int *v259; // eax
  char v260; // [esp+50h] [ebp-210h]
  char v261; // [esp+5Ch] [ebp-204h]
  char v262; // [esp+68h] [ebp-1F8h]
  char v263; // [esp+74h] [ebp-1ECh]
  char v264; // [esp+80h] [ebp-1E0h]
  char v265; // [esp+8Ch] [ebp-1D4h]
  char v266; // [esp+98h] [ebp-1C8h]
  char v267; // [esp+A4h] [ebp-1BCh]
  char v268; // [esp+B0h] [ebp-1B0h]
  char v269; // [esp+BCh] [ebp-1A4h]
  char v270; // [esp+C8h] [ebp-198h]
  char v271; // [esp+D4h] [ebp-18Ch]
  char v272; // [esp+E0h] [ebp-180h]
  char v273; // [esp+ECh] [ebp-174h]
  char v274; // [esp+F8h] [ebp-168h]
  char v275; // [esp+104h] [ebp-15Ch]
  char v276; // [esp+110h] [ebp-150h]
  char v277; // [esp+11Ch] [ebp-144h]
  char v278; // [esp+128h] [ebp-138h]
  char v279; // [esp+134h] [ebp-12Ch]
  char v280; // [esp+140h] [ebp-120h]
  char v281; // [esp+14Ch] [ebp-114h]
  char v282; // [esp+158h] [ebp-108h]
  char v283; // [esp+164h] [ebp-FCh]
  char v284; // [esp+170h] [ebp-F0h]
  char v285; // [esp+17Ch] [ebp-E4h]
  char v286; // [esp+188h] [ebp-D8h]
  char v287; // [esp+194h] [ebp-CCh]
  char v288; // [esp+1A0h] [ebp-C0h]
  char v289; // [esp+1ACh] [ebp-B4h]
  char v290; // [esp+1B8h] [ebp-A8h]
  float v291; // [esp+1C4h] [ebp-9Ch]
  float v292; // [esp+1C8h] [ebp-98h]
  float v293; // [esp+1CCh] [ebp-94h]
  float v294; // [esp+1D0h] [ebp-90h]
  float v295; // [esp+1D4h] [ebp-8Ch]
  float v296; // [esp+1D8h] [ebp-88h]
  float v297; // [esp+1DCh] [ebp-84h]
  float v298; // [esp+1E0h] [ebp-80h]
  float v299; // [esp+1E4h] [ebp-7Ch]
  float v300; // [esp+1E8h] [ebp-78h]
  float v301; // [esp+1ECh] [ebp-74h]
  float v302; // [esp+1F0h] [ebp-70h]
  float v303; // [esp+1F4h] [ebp-6Ch]
  float v304; // [esp+1F8h] [ebp-68h]
  float v305; // [esp+1FCh] [ebp-64h]
  int v306; // [esp+200h] [ebp-60h]
  int v307; // [esp+204h] [ebp-5Ch]
  int v308; // [esp+208h] [ebp-58h]
  char v309; // [esp+20Ch] [ebp-54h]
  float v310; // [esp+224h] [ebp-3Ch]
  float v311; // [esp+228h] [ebp-38h]
  float v312; // [esp+22Ch] [ebp-34h]
  float v313; // [esp+230h] [ebp-30h]
  float v314; // [esp+234h] [ebp-2Ch]
  float v315; // [esp+238h] [ebp-28h]
  float v316; // [esp+23Ch] [ebp-24h]
  float v317; // [esp+240h] [ebp-20h]
  float v318; // [esp+244h] [ebp-1Ch]
  float v319; // [esp+248h] [ebp-18h]
  float v320; // [esp+24Ch] [ebp-14h]
  float v321; // [esp+250h] [ebp-10h]
  char v322; // [esp+254h] [ebp-Ch]

  v5 = KSegment::Origin(a1);
  v6 = KTri::Origin(a2);
  v7 = sub_10002E2D(&v290, v6, v5);
  Vector3f::Vector3f(&v322, v7);
  v8 = KSegment::Direction(a1);
  v321 = Vector3f::squaredLength(v8);
  v9 = KTri::Edge0(a2);
  v10 = KSegment::Direction(a1);
  v320 = -Vector3f::DP(v10, v9);
  v11 = KTri::Edge1(a2);
  v12 = KSegment::Direction(a1);
  v319 = -Vector3f::DP(v12, v11);
  v13 = KTri::Edge0(a2);
  v318 = Vector3f::squaredLength(v13);
  v14 = KTri::Edge1(a2);
  v317 = Vector3f::squaredLength(v14);
  v15 = KSegment::Direction(a1);
  v316 = -Vector3f::DP(&v322, v15);
  v16 = KTri::Edge0(a2);
  v315 = Vector3f::DP(&v322, v16);
  v17 = KTri::Edge1(a2);
  v314 = Vector3f::DP(&v322, v17);
  v313 = v318 * v317;
  v312 = -v320 * v317;
  v311 = -v319 * v318;
  v18 = v321 * v313 + v320 * v312 + v319 * v311;
  v310 = v18;
  KSegment::KSegment(&v309);
  Vector3f::Vector3f(&v306);
  sub_10001136(v310);
  if ( v18 < flt_101C6144 )
  {
    v238 = KTri::Origin(a2);
    v239 = KSegment::Origin(&v309);
    *v239 = *v238;
    *(v239 + 1) = *(v238 + 1);
    *(v239 + 2) = *(v238 + 2);
    v240 = KTri::Edge0(a2);
    v241 = KSegment::Direction(&v309);
    *v241 = *v240;
    *(v241 + 1) = *(v240 + 1);
    *(v241 + 2) = *(v240 + 2);
    v305 = sqrDistance(a1, &v309, &v303, &v302);
    v301 = 0.0;
    v242 = KTri::Edge1(a2);
    v243 = KSegment::Direction(&v309);
    *v243 = *v242;
    *(v243 + 1) = *(v242 + 1);
    *(v243 + 2) = *(v242 + 2);
    v304 = sqrDistance(a1, &v309, &v300, &v298);
    v299 = 0.0;
    if ( v304 < v305 )
    {
      v305 = v304;
      v303 = v300;
      v302 = v299;
      v301 = v298;
    }
    v244 = KTri::Edge1(a2);
    v245 = KTri::Origin(a2);
    v246 = sub_10001A3C(&v262, v245, v244);
    v247 = KSegment::Origin(&v309);
    *v247 = *v246;
    *(v247 + 1) = v246[1];
    *(v247 + 2) = v246[2];
    v248 = KTri::Edge0(a2);
    v249 = KSegment::Direction(&v309);
    *v249 = *v248;
    *(v249 + 1) = *(v248 + 1);
    *(v249 + 2) = *(v248 + 2);
    v304 = sqrDistance(a1, &v309, &v300, &v299);
    v298 = 1.0;
    if ( v304 < v305 )
    {
      v305 = v304;
      v303 = v300;
      v302 = v299;
      v301 = v298;
    }
    v250 = KTri::Edge0(a2);
    v251 = KTri::Origin(a2);
    v252 = sub_10001A3C(&v261, v251, v250);
    v253 = KSegment::Origin(&v309);
    *v253 = *v252;
    *(v253 + 1) = v252[1];
    *(v253 + 2) = v252[2];
    v254 = KTri::Edge1(a2);
    v255 = KSegment::Direction(&v309);
    *v255 = *v254;
    *(v255 + 1) = *(v254 + 1);
    *(v255 + 2) = *(v254 + 2);
    v304 = sqrDistance(a1, &v309, &v300, &v298);
    v299 = 1.0;
    if ( v304 < v305 )
    {
      v305 = v304;
      v303 = v300;
      v302 = v299;
      v301 = v298;
    }
    v256 = KSegment::Origin(a1);
    v304 = sqrDistance(v256, a2, &v299, &v298);
    v300 = 0.0;
    if ( v304 < v305 )
    {
      v305 = v304;
      v303 = v300;
      v302 = v299;
      v301 = v298;
    }
    v257 = KSegment::Direction(a1);
    v258 = KSegment::Origin(a1);
    v259 = sub_10001A3C(&v260, v258, v257);
    v306 = *v259;
    v307 = v259[1];
    v308 = v259[2];
    v304 = sqrDistance(&v306, a2, &v299, &v298);
    v300 = 1.0;
    result = v304;
    if ( v304 < v305 )
    {
      v305 = v304;
      v303 = v300;
      v302 = v299;
      v301 = v298;
    }
  }
  else
  {
    v297 = v321 * v317 - v319 * v319;
    v296 = v319 * v320;
    v295 = v321 * v318 - v320 * v320;
    v294 = 1.0 / v310;
    v293 = -v316 * v294;
    v292 = -v315 * v294;
    v291 = -v314 * v294;
    v303 = v313 * v293 + v312 * v292 + v311 * v291;
    v302 = v312 * v293 + v297 * v292 + v296 * v291;
    v301 = v311 * v293 + v296 * v292 + v295 * v291;
    if ( v303 >= 0.0 )
    {
      if ( v303 > 1.0 )
      {
        if ( v302 >= 0.0 )
        {
          if ( v302 > 1.0 )
          {
            if ( v301 >= 0.0 )
            {
              if ( v301 > 1.0 )
              {
                v223 = KTri::Edge0(a2);
                v224 = KTri::Origin(a2);
                v225 = sub_10001A3C(&v265, v224, v223);
                v226 = KSegment::Origin(&v309);
                *v226 = *v225;
                *(v226 + 1) = v225[1];
                *(v226 + 2) = v225[2];
                v227 = KTri::Edge1(a2);
                v228 = KSegment::Direction(&v309);
                *v228 = *v227;
                *(v228 + 1) = *(v227 + 1);
                *(v228 + 2) = *(v227 + 2);
                v305 = sqrDistance(a1, &v309, &v303, &v301);
                v302 = 1.0;
                v229 = KTri::Edge1(a2);
                v230 = KTri::Origin(a2);
                v231 = sub_10001A3C(&v264, v230, v229);
                v232 = KSegment::Origin(&v309);
                *v232 = *v231;
                *(v232 + 1) = v231[1];
                *(v232 + 2) = v231[2];
                v233 = KTri::Edge0(a2);
                v234 = KSegment::Direction(&v309);
                *v234 = *v233;
                *(v234 + 1) = *(v233 + 1);
                *(v234 + 2) = *(v233 + 2);
                v304 = sqrDistance(a1, &v309, &v300, &v299);
                v298 = 1.0;
                if ( v304 < v305 )
                {
                  v305 = v304;
                  v303 = v300;
                  v302 = v299;
                  v301 = v298;
                }
                v235 = KSegment::Direction(a1);
                v236 = KSegment::Origin(a1);
                v237 = sub_10001A3C(&v263, v236, v235);
                v306 = *v237;
                v307 = v237[1];
                v308 = v237[2];
                v304 = sqrDistance(&v306, a2, &v299, &v298);
                v300 = 1.0;
                result = v304;
                if ( v304 < v305 )
                {
                  v305 = v304;
                  v303 = v300;
                  v302 = v299;
                  v301 = v298;
                }
              }
              else
              {
                v214 = KTri::Edge0(a2);
                v215 = KTri::Origin(a2);
                v216 = sub_10001A3C(&v267, v215, v214);
                v217 = KSegment::Origin(&v309);
                *v217 = *v216;
                *(v217 + 1) = v216[1];
                *(v217 + 2) = v216[2];
                v218 = KTri::Edge1(a2);
                v219 = KSegment::Direction(&v309);
                *v219 = *v218;
                *(v219 + 1) = *(v218 + 1);
                *(v219 + 2) = *(v218 + 2);
                v305 = sqrDistance(a1, &v309, &v303, &v301);
                v302 = 1.0;
                v220 = KSegment::Direction(a1);
                v221 = KSegment::Origin(a1);
                v222 = sub_10001A3C(&v266, v221, v220);
                v306 = *v222;
                v307 = v222[1];
                v308 = v222[2];
                v304 = sqrDistance(&v306, a2, &v299, &v298);
                v300 = 1.0;
                result = v304;
                if ( v304 < v305 )
                {
                  v305 = v304;
                  v303 = v300;
                  v302 = v299;
                  v301 = v298;
                }
              }
            }
            else
            {
              v201 = KTri::Edge0(a2);
              v202 = KTri::Origin(a2);
              v203 = sub_10001A3C(&v269, v202, v201);
              v204 = KSegment::Origin(&v309);
              *v204 = *v203;
              *(v204 + 1) = v203[1];
              *(v204 + 2) = v203[2];
              v205 = KTri::Edge1(a2);
              v206 = KSegment::Direction(&v309);
              *v206 = *v205;
              *(v206 + 1) = *(v205 + 1);
              *(v206 + 2) = *(v205 + 2);
              v305 = sqrDistance(a1, &v309, &v303, &v301);
              v302 = 1.0;
              v207 = KTri::Origin(a2);
              v208 = KSegment::Origin(&v309);
              *v208 = *v207;
              *(v208 + 1) = *(v207 + 1);
              *(v208 + 2) = *(v207 + 2);
              v209 = KTri::Edge0(a2);
              v210 = KSegment::Direction(&v309);
              *v210 = *v209;
              *(v210 + 1) = *(v209 + 1);
              *(v210 + 2) = *(v209 + 2);
              v304 = sqrDistance(a1, &v309, &v300, &v299);
              v298 = 0.0;
              if ( v304 < v305 )
              {
                v305 = v304;
                v303 = v300;
                v302 = v299;
                v301 = v298;
              }
              v211 = KSegment::Direction(a1);
              v212 = KSegment::Origin(a1);
              v213 = sub_10001A3C(&v268, v212, v211);
              v306 = *v213;
              v307 = v213[1];
              v308 = v213[2];
              v304 = sqrDistance(&v306, a2, &v299, &v298);
              v300 = 1.0;
              result = v304;
              if ( v304 < v305 )
              {
                v305 = v304;
                v303 = v300;
                v302 = v299;
                v301 = v298;
              }
            }
          }
          else if ( v301 >= 0.0 )
          {
            if ( v301 > 1.0 )
            {
              v192 = KTri::Edge1(a2);
              v193 = KTri::Origin(a2);
              v194 = sub_10001A3C(&v271, v193, v192);
              v195 = KSegment::Origin(&v309);
              *v195 = *v194;
              *(v195 + 1) = v194[1];
              *(v195 + 2) = v194[2];
              v196 = KTri::Edge0(a2);
              v197 = KSegment::Direction(&v309);
              *v197 = *v196;
              *(v197 + 1) = *(v196 + 1);
              *(v197 + 2) = *(v196 + 2);
              v305 = sqrDistance(a1, &v309, &v303, &v302);
              v301 = 1.0;
              v198 = KSegment::Direction(a1);
              v199 = KSegment::Origin(a1);
              v200 = sub_10001A3C(&v270, v199, v198);
              v306 = *v200;
              v307 = v200[1];
              v308 = v200[2];
              v304 = sqrDistance(&v306, a2, &v299, &v298);
              v300 = 1.0;
              result = v304;
              if ( v304 < v305 )
              {
                v305 = v304;
                v303 = v300;
                v302 = v299;
                v301 = v298;
              }
            }
            else
            {
              v189 = KSegment::Direction(a1);
              v190 = KSegment::Origin(a1);
              v191 = sub_10001A3C(&v272, v190, v189);
              v306 = *v191;
              v307 = v191[1];
              v308 = v191[2];
              result = sqrDistance(&v306, a2, &v302, &v301);
              v305 = result;
              v303 = 1.0;
            }
          }
          else
          {
            v182 = KTri::Origin(a2);
            v183 = KSegment::Origin(&v309);
            *v183 = *v182;
            *(v183 + 1) = *(v182 + 1);
            *(v183 + 2) = *(v182 + 2);
            v184 = KTri::Edge0(a2);
            v185 = KSegment::Direction(&v309);
            *v185 = *v184;
            *(v185 + 1) = *(v184 + 1);
            *(v185 + 2) = *(v184 + 2);
            v305 = sqrDistance(a1, &v309, &v303, &v302);
            v301 = 0.0;
            v186 = KSegment::Direction(a1);
            v187 = KSegment::Origin(a1);
            v188 = sub_10001A3C(&v273, v187, v186);
            v306 = *v188;
            v307 = v188[1];
            v308 = v188[2];
            v304 = sqrDistance(&v306, a2, &v299, &v298);
            v300 = 1.0;
            result = v304;
            if ( v304 < v305 )
            {
              v305 = v304;
              v303 = v300;
              v302 = v299;
              v301 = v298;
            }
          }
        }
        else if ( v301 >= 0.0 )
        {
          if ( v301 > 1.0 )
          {
            v169 = KTri::Origin(a2);
            v170 = KSegment::Origin(&v309);
            *v170 = *v169;
            *(v170 + 1) = *(v169 + 1);
            *(v170 + 2) = *(v169 + 2);
            v171 = KTri::Edge1(a2);
            v172 = KSegment::Direction(&v309);
            *v172 = *v171;
            *(v172 + 1) = *(v171 + 1);
            *(v172 + 2) = *(v171 + 2);
            v305 = sqrDistance(a1, &v309, &v303, &v301);
            v302 = 0.0;
            v173 = KTri::Edge1(a2);
            v174 = KTri::Origin(a2);
            v175 = sub_10001A3C(&v275, v174, v173);
            v176 = KSegment::Origin(&v309);
            *v176 = *v175;
            *(v176 + 1) = v175[1];
            *(v176 + 2) = v175[2];
            v177 = KTri::Edge0(a2);
            v178 = KSegment::Direction(&v309);
            *v178 = *v177;
            *(v178 + 1) = *(v177 + 1);
            *(v178 + 2) = *(v177 + 2);
            v304 = sqrDistance(a1, &v309, &v300, &v299);
            v298 = 1.0;
            if ( v304 < v305 )
            {
              v305 = v304;
              v303 = v300;
              v302 = v299;
              v301 = v298;
            }
            v179 = KSegment::Direction(a1);
            v180 = KSegment::Origin(a1);
            v181 = sub_10001A3C(&v274, v180, v179);
            v306 = *v181;
            v307 = v181[1];
            v308 = v181[2];
            v304 = sqrDistance(&v306, a2, &v299, &v298);
            v300 = 1.0;
            result = v304;
            if ( v304 < v305 )
            {
              v305 = v304;
              v303 = v300;
              v302 = v299;
              v301 = v298;
            }
          }
          else
          {
            v161 = KTri::Origin(a2);
            v162 = KSegment::Origin(&v309);
            *v162 = *v161;
            *(v162 + 1) = *(v161 + 1);
            *(v162 + 2) = *(v161 + 2);
            v163 = KTri::Edge1(a2);
            v164 = KSegment::Direction(&v309);
            *v164 = *v163;
            *(v164 + 1) = *(v163 + 1);
            *(v164 + 2) = *(v163 + 2);
            v305 = sqrDistance(a1, &v309, &v303, &v301);
            v302 = 0.0;
            v165 = KSegment::Origin(a1);
            v304 = sqrDistance(v165, a2, &v299, &v298);
            v166 = KSegment::Direction(a1);
            v167 = KSegment::Origin(a1);
            v168 = sub_10001A3C(&v276, v167, v166);
            v306 = *v168;
            v307 = v168[1];
            v308 = v168[2];
            v304 = sqrDistance(&v306, a2, &v299, &v298);
            v300 = 1.0;
            result = v304;
            if ( v304 < v305 )
            {
              v305 = v304;
              v303 = v300;
              v302 = v299;
              v301 = v298;
            }
          }
        }
        else
        {
          v150 = KTri::Origin(a2);
          v151 = KSegment::Origin(&v309);
          *v151 = *v150;
          *(v151 + 1) = *(v150 + 1);
          *(v151 + 2) = *(v150 + 2);
          v152 = KTri::Edge1(a2);
          v153 = KSegment::Direction(&v309);
          *v153 = *v152;
          *(v153 + 1) = *(v152 + 1);
          *(v153 + 2) = *(v152 + 2);
          v305 = sqrDistance(a1, &v309, &v303, &v301);
          v302 = 0.0;
          v154 = KTri::Origin(a2);
          v155 = KSegment::Origin(&v309);
          *v155 = *v154;
          *(v155 + 1) = *(v154 + 1);
          *(v155 + 2) = *(v154 + 2);
          v156 = KTri::Edge0(a2);
          v157 = KSegment::Direction(&v309);
          *v157 = *v156;
          *(v157 + 1) = *(v156 + 1);
          *(v157 + 2) = *(v156 + 2);
          v304 = sqrDistance(a1, &v309, &v300, &v299);
          v298 = 0.0;
          if ( v304 < v305 )
          {
            v305 = v304;
            v303 = v300;
            v302 = v299;
            v301 = v298;
          }
          v158 = KSegment::Direction(a1);
          v159 = KSegment::Origin(a1);
          v160 = sub_10001A3C(&v277, v159, v158);
          v306 = *v160;
          v307 = v160[1];
          v308 = v160[2];
          v304 = sqrDistance(&v306, a2, &v299, &v298);
          v300 = 1.0;
          result = v304;
          if ( v304 < v305 )
          {
            v305 = v304;
            v303 = v300;
            v302 = v299;
            v301 = v298;
          }
        }
      }
      else if ( v302 >= 0.0 )
      {
        if ( v302 > 1.0 )
        {
          if ( v301 >= 0.0 )
          {
            if ( v301 > 1.0 )
            {
              v138 = KTri::Edge0(a2);
              v139 = KTri::Origin(a2);
              v140 = sub_10001A3C(&v279, v139, v138);
              v141 = KSegment::Origin(&v309);
              *v141 = *v140;
              *(v141 + 1) = v140[1];
              *(v141 + 2) = v140[2];
              v142 = KTri::Edge1(a2);
              v143 = KSegment::Direction(&v309);
              *v143 = *v142;
              *(v143 + 1) = *(v142 + 1);
              *(v143 + 2) = *(v142 + 2);
              v305 = sqrDistance(a1, &v309, &v303, &v301);
              v302 = 1.0;
              v144 = KTri::Edge1(a2);
              v145 = KTri::Origin(a2);
              v146 = sub_10001A3C(&v278, v145, v144);
              v147 = KSegment::Origin(&v309);
              *v147 = *v146;
              *(v147 + 1) = v146[1];
              *(v147 + 2) = v146[2];
              v148 = KTri::Edge0(a2);
              v149 = KSegment::Direction(&v309);
              *v149 = *v148;
              *(v149 + 1) = *(v148 + 1);
              *(v149 + 2) = *(v148 + 2);
              v304 = sqrDistance(a1, &v309, &v300, &v299);
              v298 = 1.0;
              result = v304;
              if ( v304 < v305 )
              {
                v305 = v304;
                v303 = v300;
                v302 = v299;
                v301 = v298;
              }
            }
            else
            {
              v132 = KTri::Edge0(a2);
              v133 = KTri::Origin(a2);
              v134 = sub_10001A3C(&v280, v133, v132);
              v135 = KSegment::Origin(&v309);
              *v135 = *v134;
              *(v135 + 1) = v134[1];
              *(v135 + 2) = v134[2];
              v136 = KTri::Edge1(a2);
              v137 = KSegment::Direction(&v309);
              *v137 = *v136;
              *(v137 + 1) = *(v136 + 1);
              *(v137 + 2) = *(v136 + 2);
              result = sqrDistance(a1, &v309, &v303, &v301);
              v305 = result;
              v302 = 1.0;
            }
          }
          else
          {
            v122 = KTri::Edge0(a2);
            v123 = KTri::Origin(a2);
            v124 = sub_10001A3C(&v281, v123, v122);
            v125 = KSegment::Origin(&v309);
            *v125 = *v124;
            *(v125 + 1) = v124[1];
            *(v125 + 2) = v124[2];
            v126 = KTri::Edge1(a2);
            v127 = KSegment::Direction(&v309);
            *v127 = *v126;
            *(v127 + 1) = *(v126 + 1);
            *(v127 + 2) = *(v126 + 2);
            v305 = sqrDistance(a1, &v309, &v303, &v301);
            v302 = 1.0;
            v128 = KTri::Origin(a2);
            v129 = KSegment::Origin(&v309);
            *v129 = *v128;
            *(v129 + 1) = *(v128 + 1);
            *(v129 + 2) = *(v128 + 2);
            v130 = KTri::Edge0(a2);
            v131 = KSegment::Direction(&v309);
            *v131 = *v130;
            *(v131 + 1) = *(v130 + 1);
            *(v131 + 2) = *(v130 + 2);
            v304 = sqrDistance(a1, &v309, &v300, &v299);
            v298 = 0.0;
            result = v304;
            if ( v304 < v305 )
            {
              v305 = v304;
              v303 = v300;
              v302 = v299;
              v301 = v298;
            }
          }
        }
        else if ( v301 >= 0.0 )
        {
          if ( v301 > 1.0 )
          {
            v116 = KTri::Edge1(a2);
            v117 = KTri::Origin(a2);
            v118 = sub_10001A3C(&v282, v117, v116);
            v119 = KSegment::Origin(&v309);
            *v119 = *v118;
            *(v119 + 1) = v118[1];
            *(v119 + 2) = v118[2];
            v120 = KTri::Edge0(a2);
            v121 = KSegment::Direction(&v309);
            *v121 = *v120;
            *(v121 + 1) = *(v120 + 1);
            *(v121 + 2) = *(v120 + 2);
            result = sqrDistance(a1, &v309, &v303, &v302);
            v305 = result;
            v301 = 1.0;
          }
          else
          {
            v115 = (v321 * v303 + v320 * v302 + v319 * v301 + 2.0 * v316) * v303
                 + (v320 * v303 + v318 * v302 + 2.0 * v315) * v302
                 + (v319 * v303 + v317 * v301 + 2.0 * v314) * v301;
            result = Vector3f::squaredLength(&v322) + v115;
            v305 = result;
          }
        }
        else
        {
          v111 = KTri::Origin(a2);
          v112 = KSegment::Origin(&v309);
          *v112 = *v111;
          *(v112 + 1) = *(v111 + 1);
          *(v112 + 2) = *(v111 + 2);
          v113 = KTri::Edge0(a2);
          v114 = KSegment::Direction(&v309);
          *v114 = *v113;
          *(v114 + 1) = *(v113 + 1);
          *(v114 + 2) = *(v113 + 2);
          result = sqrDistance(a1, &v309, &v303, &v302);
          v305 = result;
          v301 = 0.0;
        }
      }
      else if ( v301 >= 0.0 )
      {
        if ( v301 > 1.0 )
        {
          v101 = KTri::Origin(a2);
          v102 = KSegment::Origin(&v309);
          *v102 = *v101;
          *(v102 + 1) = *(v101 + 1);
          *(v102 + 2) = *(v101 + 2);
          v103 = KTri::Edge1(a2);
          v104 = KSegment::Direction(&v309);
          *v104 = *v103;
          *(v104 + 1) = *(v103 + 1);
          *(v104 + 2) = *(v103 + 2);
          v305 = sqrDistance(a1, &v309, &v303, &v301);
          v302 = 0.0;
          v105 = KTri::Edge1(a2);
          v106 = KTri::Origin(a2);
          v107 = sub_10001A3C(&v283, v106, v105);
          v108 = KSegment::Origin(&v309);
          *v108 = *v107;
          *(v108 + 1) = v107[1];
          *(v108 + 2) = v107[2];
          v109 = KTri::Edge0(a2);
          v110 = KSegment::Direction(&v309);
          *v110 = *v109;
          *(v110 + 1) = *(v109 + 1);
          *(v110 + 2) = *(v109 + 2);
          v304 = sqrDistance(a1, &v309, &v300, &v299);
          v298 = 1.0;
          result = v304;
          if ( v304 < v305 )
          {
            v305 = v304;
            v303 = v300;
            v302 = v299;
            v301 = v298;
          }
        }
        else
        {
          v97 = KTri::Origin(a2);
          v98 = KSegment::Origin(&v309);
          *v98 = *v97;
          *(v98 + 1) = *(v97 + 1);
          *(v98 + 2) = *(v97 + 2);
          v99 = KTri::Edge1(a2);
          v100 = KSegment::Direction(&v309);
          *v100 = *v99;
          *(v100 + 1) = *(v99 + 1);
          *(v100 + 2) = *(v99 + 2);
          result = sqrDistance(a1, &v309, &v303, &v301);
          v305 = result;
          v302 = 0.0;
        }
      }
      else
      {
        v89 = KTri::Origin(a2);
        v90 = KSegment::Origin(&v309);
        *v90 = *v89;
        *(v90 + 1) = *(v89 + 1);
        *(v90 + 2) = *(v89 + 2);
        v91 = KTri::Edge1(a2);
        v92 = KSegment::Direction(&v309);
        *v92 = *v91;
        *(v92 + 1) = *(v91 + 1);
        *(v92 + 2) = *(v91 + 2);
        v305 = sqrDistance(a1, &v309, &v303, &v301);
        v302 = 0.0;
        v93 = KTri::Origin(a2);
        v94 = KSegment::Origin(&v309);
        *v94 = *v93;
        *(v94 + 1) = *(v93 + 1);
        *(v94 + 2) = *(v93 + 2);
        v95 = KTri::Edge0(a2);
        v96 = KSegment::Direction(&v309);
        *v96 = *v95;
        *(v96 + 1) = *(v95 + 1);
        *(v96 + 2) = *(v95 + 2);
        v304 = sqrDistance(a1, &v309, &v300, &v299);
        v298 = 0.0;
        result = v304;
        if ( v304 < v305 )
        {
          v305 = v304;
          v303 = v300;
          v302 = v299;
          v301 = v298;
        }
      }
    }
    else if ( v302 >= 0.0 )
    {
      if ( v302 > 1.0 )
      {
        if ( v301 >= 0.0 )
        {
          if ( v301 > 1.0 )
          {
            v76 = KTri::Edge0(a2);
            v77 = KTri::Origin(a2);
            v78 = sub_10001A3C(&v285, v77, v76);
            v79 = KSegment::Origin(&v309);
            *v79 = *v78;
            *(v79 + 1) = v78[1];
            *(v79 + 2) = v78[2];
            v80 = KTri::Edge1(a2);
            v81 = KSegment::Direction(&v309);
            *v81 = *v80;
            *(v81 + 1) = *(v80 + 1);
            *(v81 + 2) = *(v80 + 2);
            v305 = sqrDistance(a1, &v309, &v303, &v301);
            v302 = 1.0;
            v82 = KTri::Edge1(a2);
            v83 = KTri::Origin(a2);
            v84 = sub_10001A3C(&v284, v83, v82);
            v85 = KSegment::Origin(&v309);
            *v85 = *v84;
            *(v85 + 1) = v84[1];
            *(v85 + 2) = v84[2];
            v86 = KTri::Edge0(a2);
            v87 = KSegment::Direction(&v309);
            *v87 = *v86;
            *(v87 + 1) = *(v86 + 1);
            *(v87 + 2) = *(v86 + 2);
            v304 = sqrDistance(a1, &v309, &v300, &v299);
            v298 = 1.0;
            if ( v304 < v305 )
            {
              v305 = v304;
              v303 = v300;
              v302 = v299;
              v301 = v298;
            }
            v88 = KSegment::Origin(a1);
            v304 = sqrDistance(v88, a2, &v299, &v298);
            v300 = 0.0;
            result = v304;
            if ( v304 < v305 )
            {
              v305 = v304;
              v303 = v300;
              v302 = v299;
              v301 = v298;
            }
          }
          else
          {
            v69 = KTri::Edge0(a2);
            v70 = KTri::Origin(a2);
            v71 = sub_10001A3C(&v286, v70, v69);
            v72 = KSegment::Origin(&v309);
            *v72 = *v71;
            *(v72 + 1) = v71[1];
            *(v72 + 2) = v71[2];
            v73 = KTri::Edge1(a2);
            v74 = KSegment::Direction(&v309);
            *v74 = *v73;
            *(v74 + 1) = *(v73 + 1);
            *(v74 + 2) = *(v73 + 2);
            v305 = sqrDistance(a1, &v309, &v303, &v301);
            v302 = 1.0;
            v75 = KSegment::Origin(a1);
            v304 = sqrDistance(v75, a2, &v299, &v298);
            v300 = 0.0;
            result = v304;
            if ( v304 < v305 )
            {
              v305 = v304;
              v303 = v300;
              v302 = v299;
              v301 = v298;
            }
          }
        }
        else
        {
          v58 = KTri::Edge0(a2);
          v59 = KTri::Origin(a2);
          v60 = sub_10001A3C(&v287, v59, v58);
          v61 = KSegment::Origin(&v309);
          *v61 = *v60;
          *(v61 + 1) = v60[1];
          *(v61 + 2) = v60[2];
          v62 = KTri::Edge1(a2);
          v63 = KSegment::Direction(&v309);
          *v63 = *v62;
          *(v63 + 1) = *(v62 + 1);
          *(v63 + 2) = *(v62 + 2);
          v305 = sqrDistance(a1, &v309, &v303, &v301);
          v302 = 1.0;
          v64 = KTri::Origin(a2);
          v65 = KSegment::Origin(&v309);
          *v65 = *v64;
          *(v65 + 1) = *(v64 + 1);
          *(v65 + 2) = *(v64 + 2);
          v66 = KTri::Edge0(a2);
          v67 = KSegment::Direction(&v309);
          *v67 = *v66;
          *(v67 + 1) = *(v66 + 1);
          *(v67 + 2) = *(v66 + 2);
          v304 = sqrDistance(a1, &v309, &v300, &v299);
          v298 = 0.0;
          if ( v304 < v305 )
          {
            v305 = v304;
            v303 = v300;
            v302 = v299;
            v301 = v298;
          }
          v68 = KSegment::Origin(a1);
          v304 = sqrDistance(v68, a2, &v299, &v298);
          v300 = 0.0;
          result = v304;
          if ( v304 < v305 )
          {
            v305 = v304;
            v303 = v300;
            v302 = v299;
            v301 = v298;
          }
        }
      }
      else if ( v301 >= 0.0 )
      {
        if ( v301 > 1.0 )
        {
          v51 = KTri::Edge1(a2);
          v52 = KTri::Origin(a2);
          v53 = sub_10001A3C(&v288, v52, v51);
          v54 = KSegment::Origin(&v309);
          *v54 = *v53;
          *(v54 + 1) = v53[1];
          *(v54 + 2) = v53[2];
          v55 = KTri::Edge0(a2);
          v56 = KSegment::Direction(&v309);
          *v56 = *v55;
          *(v56 + 1) = *(v55 + 1);
          *(v56 + 2) = *(v55 + 2);
          v305 = sqrDistance(a1, &v309, &v303, &v302);
          v301 = 1.0;
          v57 = KSegment::Origin(a1);
          v304 = sqrDistance(v57, a2, &v299, &v298);
          v300 = 0.0;
          result = v304;
          if ( v304 < v305 )
          {
            v305 = v304;
            v303 = v300;
            v302 = v299;
            v301 = v298;
          }
        }
        else
        {
          v50 = KSegment::Origin(a1);
          result = sqrDistance(v50, a2, &v302, &v301);
          v305 = result;
          v303 = 0.0;
        }
      }
      else
      {
        v45 = KTri::Origin(a2);
        v46 = KSegment::Origin(&v309);
        *v46 = *v45;
        *(v46 + 1) = *(v45 + 1);
        *(v46 + 2) = *(v45 + 2);
        v47 = KTri::Edge0(a2);
        v48 = KSegment::Direction(&v309);
        *v48 = *v47;
        *(v48 + 1) = *(v47 + 1);
        *(v48 + 2) = *(v47 + 2);
        v305 = sqrDistance(a1, &v309, &v303, &v302);
        v301 = 0.0;
        v49 = KSegment::Origin(a1);
        v304 = sqrDistance(v49, a2, &v299, &v298);
        v300 = 0.0;
        result = v304;
        if ( v304 < v305 )
        {
          v305 = v304;
          v303 = v300;
          v302 = v299;
          v301 = v298;
        }
      }
    }
    else if ( v301 >= 0.0 )
    {
      if ( v301 > 1.0 )
      {
        v34 = KTri::Origin(a2);
        v35 = KSegment::Origin(&v309);
        *v35 = *v34;
        *(v35 + 1) = *(v34 + 1);
        *(v35 + 2) = *(v34 + 2);
        v36 = KTri::Edge1(a2);
        v37 = KSegment::Direction(&v309);
        *v37 = *v36;
        *(v37 + 1) = *(v36 + 1);
        *(v37 + 2) = *(v36 + 2);
        v305 = sqrDistance(a1, &v309, &v303, &v301);
        v302 = 0.0;
        v38 = KTri::Edge1(a2);
        v39 = KTri::Origin(a2);
        v40 = sub_10001A3C(&v289, v39, v38);
        v41 = KSegment::Origin(&v309);
        *v41 = *v40;
        *(v41 + 1) = v40[1];
        *(v41 + 2) = v40[2];
        v42 = KTri::Edge0(a2);
        v43 = KSegment::Direction(&v309);
        *v43 = *v42;
        *(v43 + 1) = *(v42 + 1);
        *(v43 + 2) = *(v42 + 2);
        v304 = sqrDistance(a1, &v309, &v300, &v299);
        v298 = 1.0;
        if ( v304 < v305 )
        {
          v305 = v304;
          v303 = v300;
          v302 = v299;
          v301 = v298;
        }
        v44 = KSegment::Origin(a1);
        v304 = sqrDistance(v44, a2, &v299, &v298);
        v300 = 0.0;
        result = v304;
        if ( v304 < v305 )
        {
          v305 = v304;
          v303 = v300;
          v302 = v299;
          v301 = v298;
        }
      }
      else
      {
        v29 = KTri::Origin(a2);
        v30 = KSegment::Origin(&v309);
        *v30 = *v29;
        *(v30 + 1) = *(v29 + 1);
        *(v30 + 2) = *(v29 + 2);
        v31 = KTri::Edge1(a2);
        v32 = KSegment::Direction(&v309);
        *v32 = *v31;
        *(v32 + 1) = *(v31 + 1);
        *(v32 + 2) = *(v31 + 2);
        v305 = sqrDistance(a1, &v309, &v303, &v301);
        v302 = 0.0;
        v33 = KSegment::Origin(a1);
        v304 = sqrDistance(v33, a2, &v299, &v298);
        v300 = 0.0;
        result = v304;
        if ( v304 < v305 )
        {
          v305 = v304;
          v303 = v300;
          v302 = v299;
          v301 = v298;
        }
      }
    }
    else
    {
      v19 = KTri::Origin(a2);
      v20 = KSegment::Origin(&v309);
      *v20 = *v19;
      *(v20 + 1) = *(v19 + 1);
      *(v20 + 2) = *(v19 + 2);
      v21 = KTri::Edge1(a2);
      v22 = KSegment::Direction(&v309);
      *v22 = *v21;
      *(v22 + 1) = *(v21 + 1);
      *(v22 + 2) = *(v21 + 2);
      v305 = sqrDistance(a1, &v309, &v303, &v301);
      v302 = 0.0;
      v23 = KTri::Origin(a2);
      v24 = KSegment::Origin(&v309);
      *v24 = *v23;
      *(v24 + 1) = *(v23 + 1);
      *(v24 + 2) = *(v23 + 2);
      v25 = KTri::Edge0(a2);
      v26 = KSegment::Direction(&v309);
      *v26 = *v25;
      *(v26 + 1) = *(v25 + 1);
      *(v26 + 2) = *(v25 + 2);
      v304 = sqrDistance(a1, &v309, &v300, &v299);
      v298 = 0.0;
      if ( v304 < v305 )
      {
        v305 = v304;
        v303 = v300;
        v302 = v299;
        v301 = v298;
      }
      v27 = KSegment::Origin(a1);
      v304 = sqrDistance(v27, a2, &v299, &v298);
      v300 = 0.0;
      result = v304;
      if ( v304 < v305 )
      {
        v305 = v304;
        v303 = v300;
        v302 = v299;
        v301 = v298;
      }
    }
  }
  if ( a3 )
    *a3 = v303;
  if ( a4 )
    *a4 = v302;
  if ( a5 )
    *a5 = v301;
  sub_10001136(v305);
  return result;
}
// 101C6144: using guessed type float flt_101C6144;

//----- (10049050) --------------------------------------------------------
double __cdecl sqrDistance(struct KTri *a1, struct KRect *a2, float *a3, float *a4, float *a5, float *a6)
{
  struct Vector3f *v6; // esi
  struct Vector3f *v7; // eax
  struct Vector3f *v8; // esi
  struct Vector3f *v9; // eax
  struct Vector3f *v10; // esi
  struct Vector3f *v11; // eax
  struct Vector3f *v12; // ST10_4
  struct Vector3f *v13; // eax
  _DWORD *v14; // esi
  struct Vector3f *v15; // eax
  struct Vector3f *v16; // ST10_4
  struct Vector3f *v17; // eax
  _DWORD *v18; // esi
  struct Vector3f *v19; // eax
  struct Vector3f *v20; // esi
  struct Vector3f *v21; // eax
  struct Vector3f *v22; // esi
  struct Vector3f *v23; // eax
  struct Vector3f *v24; // esi
  struct Vector3f *v25; // eax
  struct Vector3f *v26; // ST10_4
  struct Vector3f *v27; // eax
  _DWORD *v28; // esi
  struct Vector3f *v29; // eax
  struct Vector3f *v30; // esi
  struct Vector3f *v31; // eax
  struct Vector3f *v32; // ST10_4
  struct Vector3f *v33; // eax
  _DWORD *v34; // esi
  struct Vector3f *v35; // eax
  struct Vector3f *v36; // esi
  struct Vector3f *v37; // eax
  double result; // st7
  char v39; // [esp+4Ch] [ebp-70h]
  char v40; // [esp+58h] [ebp-64h]
  char v41; // [esp+64h] [ebp-58h]
  char v42; // [esp+70h] [ebp-4Ch]
  char v43; // [esp+7Ch] [ebp-40h]
  float v44; // [esp+94h] [ebp-28h]
  float v45; // [esp+98h] [ebp-24h]
  float v46; // [esp+9Ch] [ebp-20h]
  float v47; // [esp+A0h] [ebp-1Ch]
  float v48; // [esp+A4h] [ebp-18h]
  float v49; // [esp+A8h] [ebp-14h]
  float v50; // [esp+ACh] [ebp-10h]
  float v51; // [esp+B0h] [ebp-Ch]
  float v52; // [esp+B4h] [ebp-8h]
  float v53; // [esp+B8h] [ebp-4h]

  KSegment::KSegment(&v43);
  v6 = KTri::Origin(a1);
  v7 = KSegment::Origin(&v43);
  *v7 = *v6;
  *(v7 + 1) = *(v6 + 1);
  *(v7 + 2) = *(v6 + 2);
  v8 = KTri::Edge0(a1);
  v9 = KSegment::Direction(&v43);
  *v9 = *v8;
  *(v9 + 1) = *(v8 + 1);
  *(v9 + 2) = *(v8 + 2);
  v45 = sqrDistance(&v43, a2, &v53, &v49, &v48);
  v52 = 0.0;
  v10 = KTri::Edge1(a1);
  v11 = KSegment::Direction(&v43);
  *v11 = *v10;
  *(v11 + 1) = *(v10 + 1);
  *(v11 + 2) = *(v10 + 2);
  v44 = sqrDistance(&v43, a2, &v50, &v47, &v46);
  v51 = 0.0;
  if ( v44 < v45 )
  {
    v45 = v44;
    v53 = v51;
    v52 = v50;
    v49 = v47;
    v48 = v46;
  }
  v12 = KTri::Edge0(a1);
  v13 = KSegment::Origin(&v43);
  v14 = sub_10001A3C(&v42, v13, v12);
  v15 = KSegment::Origin(&v43);
  *v15 = *v14;
  *(v15 + 1) = v14[1];
  *(v15 + 2) = v14[2];
  v16 = KTri::Edge0(a1);
  v17 = KSegment::Direction(&v43);
  v18 = sub_10002E2D(&v41, v17, v16);
  v19 = KSegment::Direction(&v43);
  *v19 = *v18;
  *(v19 + 1) = v18[1];
  *(v19 + 2) = v18[2];
  v44 = sqrDistance(&v43, a2, &v50, &v47, &v46);
  v51 = 1.0 - v50;
  if ( v44 < v45 )
  {
    v45 = v44;
    v53 = v51;
    v52 = v50;
    v49 = v47;
    v48 = v46;
  }
  v20 = KTri::Origin(a2);
  v21 = KSegment::Origin(&v43);
  *v21 = *v20;
  *(v21 + 1) = *(v20 + 1);
  *(v21 + 2) = *(v20 + 2);
  v22 = KTri::Edge0(a2);
  v23 = KSegment::Direction(&v43);
  *v23 = *v22;
  *(v23 + 1) = *(v22 + 1);
  *(v23 + 2) = *(v22 + 2);
  v44 = sqrDistance(&v43, a1, &v47, &v51, &v50);
  v46 = 0.0;
  if ( v44 < v45 )
  {
    v45 = v44;
    v53 = v51;
    v52 = v50;
    v49 = v47;
    v48 = v46;
  }
  v24 = KTri::Edge1(a2);
  v25 = KSegment::Direction(&v43);
  *v25 = *v24;
  *(v25 + 1) = *(v24 + 1);
  *(v25 + 2) = *(v24 + 2);
  v44 = sqrDistance(&v43, a1, &v46, &v51, &v50);
  v47 = 0.0;
  if ( v44 < v45 )
  {
    v45 = v44;
    v53 = v51;
    v52 = v50;
    v49 = v47;
    v48 = v46;
  }
  v26 = KTri::Edge1(a2);
  v27 = KTri::Origin(a2);
  v28 = sub_10001A3C(&v40, v27, v26);
  v29 = KSegment::Origin(&v43);
  *v29 = *v28;
  *(v29 + 1) = v28[1];
  *(v29 + 2) = v28[2];
  v30 = KTri::Edge0(a2);
  v31 = KSegment::Direction(&v43);
  *v31 = *v30;
  *(v31 + 1) = *(v30 + 1);
  *(v31 + 2) = *(v30 + 2);
  v44 = sqrDistance(&v43, a1, &v47, &v51, &v50);
  v46 = 1.0;
  if ( v44 < v45 )
  {
    v45 = v44;
    v53 = v51;
    v52 = v50;
    v49 = v47;
    v48 = v46;
  }
  v32 = KTri::Edge0(a2);
  v33 = KTri::Origin(a2);
  v34 = sub_10001A3C(&v39, v33, v32);
  v35 = KSegment::Origin(&v43);
  *v35 = *v34;
  *(v35 + 1) = v34[1];
  *(v35 + 2) = v34[2];
  v36 = KTri::Edge1(a2);
  v37 = KSegment::Direction(&v43);
  *v37 = *v36;
  *(v37 + 1) = *(v36 + 1);
  *(v37 + 2) = *(v36 + 2);
  v44 = sqrDistance(&v43, a1, &v46, &v51, &v50);
  v47 = 1.0;
  result = v44;
  if ( v44 < v45 )
  {
    v45 = v44;
    v53 = v51;
    v52 = v50;
    v49 = v47;
    v48 = v46;
  }
  if ( a3 )
    *a3 = v53;
  if ( a4 )
    *a4 = v52;
  if ( a5 )
    *a5 = v49;
  if ( a6 )
    *a6 = v48;
  sub_10001136(v45);
  return result;
}

//----- (100495F0) --------------------------------------------------------
double __cdecl sqrDistance(struct Vector3f *a1, struct KTri *a2, float *a3, float *a4)
{
  struct Vector3f *v4; // eax
  const struct Vector3f *v5; // eax
  Vector3f *v6; // eax
  struct Vector3f *v7; // ST08_4
  Vector3f *v8; // eax
  Vector3f *v9; // eax
  struct Vector3f *v10; // eax
  struct Vector3f *v11; // eax
  double v12; // st7
  float v13; // ST08_4
  double result; // st7
  char v15; // [esp+50h] [ebp-54h]
  float v16; // [esp+5Ch] [ebp-48h]
  float v17; // [esp+60h] [ebp-44h]
  float v18; // [esp+64h] [ebp-40h]
  float v19; // [esp+68h] [ebp-3Ch]
  float v20; // [esp+6Ch] [ebp-38h]
  float v21; // [esp+70h] [ebp-34h]
  float v22; // [esp+74h] [ebp-30h]
  float v23; // [esp+78h] [ebp-2Ch]
  float v24; // [esp+7Ch] [ebp-28h]
  float v25; // [esp+80h] [ebp-24h]
  float v26; // [esp+84h] [ebp-20h]
  float v27; // [esp+88h] [ebp-1Ch]
  float v28; // [esp+8Ch] [ebp-18h]
  float v29; // [esp+90h] [ebp-14h]
  float v30; // [esp+94h] [ebp-10h]
  char v31; // [esp+98h] [ebp-Ch]

  v4 = KTri::Origin(a2);
  v5 = sub_10002E2D(&v15, v4, a1);
  Vector3f::Vector3f(&v31, v5);
  v6 = KTri::Edge0(a2);
  v30 = Vector3f::squaredLength(v6);
  v7 = KTri::Edge1(a2);
  v8 = KTri::Edge0(a2);
  v29 = Vector3f::DP(v8, v7);
  v9 = KTri::Edge1(a2);
  v28 = Vector3f::squaredLength(v9);
  v10 = KTri::Edge0(a2);
  v27 = Vector3f::DP(&v31, v10);
  v11 = KTri::Edge1(a2);
  v26 = Vector3f::DP(&v31, v11);
  v25 = Vector3f::squaredLength(&v31);
  v12 = v30 * v28 - v29 * v29;
  v13 = v12;
  sub_10001136(v13);
  v24 = v12;
  v23 = v29 * v26 - v28 * v27;
  v22 = v29 * v27 - v30 * v26;
  if ( v23 + v22 > v24 )
  {
    if ( v23 >= 0.0 )
    {
      if ( v22 >= 0.0 )
      {
        v17 = v28 + v26 - v29 - v27;
        if ( v17 > 0.0 )
        {
          v16 = v30 - 2.0 * v29 + v28;
          if ( v17 < v16 )
          {
            v23 = v17 / v16;
            v22 = 1.0 - v23;
            result = (v30 * v23 + v29 * v22 + 2.0 * v27) * v23 + (v29 * v23 + v28 * v22 + 2.0 * v26) * v22 + v25;
          }
          else
          {
            v23 = 1.0;
            v22 = 0.0;
            result = 2.0 * v27 + v30 + v25;
          }
          v21 = result;
        }
        else
        {
          v23 = 0.0;
          v22 = 1.0;
          result = 2.0 * v26 + v28 + v25;
          v21 = result;
        }
      }
      else
      {
        v19 = v29 + v26;
        v18 = v30 + v27;
        if ( v18 <= v19 )
        {
          v22 = 0.0;
          if ( v18 > 0.0 )
          {
            result = v27;
            if ( v27 < 0.0 )
            {
              v23 = -v27 / v30;
              result = v27 * v23 + v25;
              v21 = result;
            }
            else
            {
              v23 = 0.0;
              v21 = v25;
            }
          }
          else
          {
            v23 = 1.0;
            result = 2.0 * v27 + v30 + v25;
            v21 = result;
          }
        }
        else
        {
          v17 = v18 - v19;
          v16 = v30 - 2.0 * v29 + v28;
          if ( v17 < v16 )
          {
            v22 = v17 / v16;
            v23 = 1.0 - v22;
            result = (v30 * v23 + v29 * v22 + 2.0 * v27) * v23 + (v29 * v23 + v28 * v22 + 2.0 * v26) * v22 + v25;
          }
          else
          {
            v22 = 1.0;
            v23 = 0.0;
            result = 2.0 * v26 + v28 + v25;
          }
          v21 = result;
        }
      }
    }
    else
    {
      v19 = v29 + v27;
      v18 = v28 + v26;
      if ( v18 <= v19 )
      {
        v23 = 0.0;
        if ( v18 > 0.0 )
        {
          result = v26;
          if ( v26 < 0.0 )
          {
            v22 = -v26 / v28;
            result = v26 * v22 + v25;
            v21 = result;
          }
          else
          {
            v22 = 0.0;
            v21 = v25;
          }
        }
        else
        {
          v22 = 1.0;
          result = 2.0 * v26 + v28 + v25;
          v21 = result;
        }
      }
      else
      {
        v17 = v18 - v19;
        v16 = v30 - 2.0 * v29 + v28;
        if ( v17 < v16 )
        {
          v23 = v17 / v16;
          v22 = 1.0 - v23;
          result = (v30 * v23 + v29 * v22 + 2.0 * v27) * v23 + (v29 * v23 + v28 * v22 + 2.0 * v26) * v22 + v25;
        }
        else
        {
          v23 = 1.0;
          v22 = 0.0;
          result = 2.0 * v27 + v30 + v25;
        }
        v21 = result;
      }
    }
  }
  else if ( v23 >= 0.0 )
  {
    if ( v22 >= 0.0 )
    {
      v20 = 1.0 / v24;
      v23 = v23 * v20;
      v22 = v22 * v20;
      result = (v30 * v23 + v29 * v22 + 2.0 * v27) * v23 + (v29 * v23 + v28 * v22 + 2.0 * v26) * v22 + v25;
      v21 = result;
    }
    else
    {
      v22 = 0.0;
      result = v27;
      if ( v27 < 0.0 )
      {
        if ( -v27 < v30 )
        {
          v23 = -v27 / v30;
          result = v27 * v23 + v25;
        }
        else
        {
          v23 = 1.0;
          result = 2.0 * v27 + v30 + v25;
        }
        v21 = result;
      }
      else
      {
        v23 = 0.0;
        v21 = v25;
      }
    }
  }
  else if ( v22 >= 0.0 )
  {
    v23 = 0.0;
    result = v26;
    if ( v26 < 0.0 )
    {
      if ( -v26 < v28 )
      {
        v22 = -v26 / v28;
        result = v26 * v22 + v25;
      }
      else
      {
        v22 = 1.0;
        result = 2.0 * v26 + v28 + v25;
      }
      v21 = result;
    }
    else
    {
      v22 = 0.0;
      v21 = v25;
    }
  }
  else if ( v27 >= 0.0 )
  {
    v23 = 0.0;
    result = v26;
    if ( v26 < 0.0 )
    {
      if ( -v26 < v28 )
      {
        v22 = -v26 / v28;
        result = v26 * v22 + v25;
      }
      else
      {
        v22 = 1.0;
        result = 2.0 * v26 + v28 + v25;
      }
      v21 = result;
    }
    else
    {
      v22 = 0.0;
      v21 = v25;
    }
  }
  else
  {
    v22 = 0.0;
    if ( -v27 < v30 )
    {
      v23 = -v27 / v30;
      result = v27 * v23 + v25;
    }
    else
    {
      v23 = 1.0;
      result = 2.0 * v27 + v30 + v25;
    }
    v21 = result;
  }
  if ( a3 )
    *a3 = v23;
  if ( a4 )
    *a4 = v22;
  sub_10001136(v21);
  return result;
}

//----- (10049E80) --------------------------------------------------------
void __thiscall AyuStack::create(AyuStack *this, char *a2, int a3, void *a4, int a5, bool a6)
{
  AyuStack *v6; // ST50_4

  v6 = this;
  *this = a3;
  *(this + 29) = 1;
  *(this + 8) = a2;
  *(this + 3) = a4;
  *(v6 + 4) = a5 + *(v6 + 3);
  *(v6 + 1) = *(v6 + 4) - *(v6 + 3);
  *(this + 28) = a6;
  if ( *(this + 28) )
    **(this + 3) = 305419896;
  AyuStack::reset(this);
}

//----- (10049F50) --------------------------------------------------------
void __thiscall AyuStack::reset(AyuStack *this)
{
  *(this + 5) = *(this + 3);
  *(this + 6) = *(this + 4);
  *(this + 2) = 0;
}

//----- (10049FB0) --------------------------------------------------------
void __thiscall AyuStack::checkStack(AyuStack *this)
{
  if ( *this & 2 )
  {
    if ( *(this + 5) - *(*(this + 5) - 8) != *(this + 3) )
      sub_1004A040("trashed memory stack (%s)\n", *(this + 8));
  }
}

//----- (1004A040) --------------------------------------------------------
void __noreturn sub_1004A040(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscommon\\ayustack.cpp", 7, &Dest);
}

//----- (1004A0E0) --------------------------------------------------------
void __thiscall AyuStack::reset(AyuStack *this, int a2)
{
  int v2; // [esp+4Ch] [ebp-Ch]
  int v3; // [esp+50h] [ebp-8h]
  unsigned __int32 *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  if ( a2 & 2 )
  {
    v3 = AyuStack::setAllocType(this, a2);
    StdSystem::invalidateObjs(gsys, v4[3], v4[5]);
    while ( v4[5] != v4[3] )
      AyuStack::pop(v4);
    AyuStack::setAllocType(v4, v3);
  }
  if ( a2 & 1 )
  {
    v2 = AyuStack::setAllocType(v4, a2);
    StdSystem::invalidateObjs(gsys, v4[6], v4[4]);
    while ( v4[6] != v4[4] )
      AyuStack::pop(v4);
    AyuStack::setAllocType(v4, v2);
  }
}

//----- (1004A200) --------------------------------------------------------
void *__thiscall AyuStack::push(AyuStack *this, int a2)
{
  void *result; // eax
  int v3; // ST54_4
  int v4; // [esp+4Ch] [ebp-Ch]
  void *v5; // [esp+50h] [ebp-8h]
  int v6; // [esp+60h] [ebp+8h]

  if ( !a2 )
    a2 = 1;
  if ( a2 & 7 )
    a2 = (a2 + 7) & 0xFFFFFFF8;
  v6 = a2 + 8;
  if ( *this == 2 )
  {
    if ( (v6 + *(this + 5)) <= *(this + 6) )
    {
      v3 = *(this + 5);
      if ( *(this + 5) == *(this + 3) )
      {
        v4 = 0;
        v5 = *(this + 5);
      }
      else
      {
        v4 = *(*(this + 5) - 8);
        v5 = (*(this + 5) - 8);
      }
      *(this + 2) += v6;
      *(this + 5) += v6;
      *(*(this + 5) - 8) = v4 + v6;
      AyuStack::checkStack(this);
      result = v5;
    }
    else
    {
      result = 0;
    }
  }
  else if ( (*(this + 6) - v6) >= *(this + 5) )
  {
    *(this + 2) += v6;
    *(this + 6) -= v6;
    **(this + 6) = v6;
    result = (*(this + 6) + 8);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004A3A0) --------------------------------------------------------
void __thiscall AyuStack::pop(AyuStack *this)
{
  int v1; // ST54_4
  int v2; // ST50_4

  if ( *this == 2 )
  {
    v1 = *(*(this + 5) - 8);
    *(this + 2) -= v1;
    *(this + 5) -= v1;
  }
  else
  {
    v2 = **(this + 6);
    *(this + 2) -= v2;
    *(this + 6) += v2;
  }
}

//----- (1004A450) --------------------------------------------------------
void __thiscall AyuHeap::init(AyuHeap *this, char *a2, int a3, void *a4, int a5)
{
  AyuStack *v5; // ST60_4

  v5 = this;
  AyuStack::create(this, a2, a3, a4, a5, 0);
  *(v5 + 36) = 0;
}

//----- (1004A4C0) --------------------------------------------------------
AyuCache *__thiscall AyuCache::AyuCache(AyuCache *this, unsigned __int32 a2)
{
  AyuCache *v2; // ST6C_4
  double v3; // ST04_8
  unsigned __int32 v4; // eax

  v2 = this;
  v3 = a2 / 1024.0;
  sub_1004A590("Creating cache of size %.2f k\n", SLOBYTE(v3));
  v4 = sub_10001AC3(4 * (((a2 + 31) & 0xFFFFFFE0) / 4));
  AyuCache::init(v2, v4, ((a2 + 31) & 0xFFFFFFE0) + v4);
  return v2;
}

//----- (1004A590) --------------------------------------------------------
char *__cdecl sub_1004A590(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "AyuStack" )
      Stream::print(sysCon, "%s: ", "AyuStack");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1004A6A0) --------------------------------------------------------
void __thiscall AyuCache::init(AyuCache *this, unsigned __int32 a2, unsigned __int32 a3)
{
  AyuCache *v3; // ST5C_4
  signed int i; // [esp+4Ch] [ebp-10h]

  v3 = this;
  *(this + 9) = 0;
  *(this + 10) = a3 - a2;
  *(this + 8) = 0;
  *(v3 + 5) = v3 + 16;
  *(v3 + 6) = v3 + 16;
  *(this + 4) = 0;
  *(this + 7) = -2023406815;
  *(a2 + 4) = this;
  *(a2 + 8) = this;
  *a2 = ((a3 - a2) >> 4) - 16777217;
  *(a2 + 12) = -2023406815;
  *(this + 1) = a2;
  *(this + 2) = a2;
  *this = -16777216;
  for ( i = 0; i < 256; ++i )
    *(this + i + 44) = i;
  *(this + 75) = 0;
}

//----- (1004A7F0) --------------------------------------------------------
int __thiscall AyuCache::getIndex(AyuCache *this)
{
  return *(this + (*(this + 75))++ + 44);
}

//----- (1004A850) --------------------------------------------------------
void __thiscall AyuCache::releaseIndex(AyuCache *this, int a2)
{
  char v2; // ST54_1
  int i; // [esp+50h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    if ( i >= *(this + 75) )
      sub_1004A040("Could not release the index %d\n", a2);
    if ( *(this + i + 44) == a2 )
      break;
  }
  v2 = *(this + i + 44);
  *(this + i + 44) = *(this + *(this + 75) + 43);
  *(this + (*(this + 75))-- + 43) = v2;
}

//----- (1004A950) --------------------------------------------------------
int __thiscall AyuCache::mallocL(AyuCache *this, unsigned __int32 a2)
{
  _DWORD *v3; // ST58_4
  int v4; // [esp+50h] [ebp-18h]
  AyuCache *i; // [esp+54h] [ebp-14h]
  AyuCache *v6; // [esp+58h] [ebp-10h]
  unsigned __int32 v7; // [esp+60h] [ebp-8h]
  AyuCache *v8; // [esp+64h] [ebp-4h]

  v8 = this;
  v7 = (a2 + 15) >> 4;
  v6 = 0;
  for ( i = *(this + 1); i != this; i = *(i + 1) )
  {
    v4 = (*i & 0xFFFFFF) - v7;
    if ( v4 >= 0 && v4 < 0x7FFFFFFF )
    {
      v6 = i;
      break;
    }
  }
  if ( !v6 )
    return 0;
  if ( (*v6 & 0xFFFFFF) == v7 )
  {
    *(*(v6 + 1) + 8) = *(v6 + 2);
    *(*(v6 + 2) + 4) = *(v6 + 1);
  }
  else
  {
    v3 = (v6 + 16 * v7 + 16);
    *(v6 + 4 * v7 + 5) = *(v6 + 1);
    v3[2] = *(v6 + 2);
    *(v3[1] + 8) = v3;
    *(v3[2] + 4) = v3;
    *v3 = *v6 - v7 - 1;
    v3[3] = -2023406815;
  }
  sub_1004AB20(v6, v7 + (*(this + 8) << 24), this + 16);
  *(v8 + 9) += *v6 & 0xFFFFFF;
  *(v6 + 3) = 305419896;
  return v6 + 16;
}

//----- (1004AB20) --------------------------------------------------------
_DWORD *__cdecl sub_1004AB20(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  a1[1] = a3;
  a1[2] = *(a3 + 8);
  *(a3 + 8) = a1;
  result = a1;
  *(a1[2] + 4) = a1;
  *a1 = a2;
  return result;
}

//----- (1004AB90) --------------------------------------------------------
void __thiscall AyuCache::cacheFree(AyuCache *this, void *a2)
{
  AyuCache *i; // [esp+4Ch] [ebp-10h]
  AyuCache *v3; // [esp+50h] [ebp-Ch]
  AyuCache *v4; // [esp+54h] [ebp-8h]

  v4 = (a2 - 16);
  *(this + 9) -= *(a2 - 4) & 0xFFFFFF;
  v3 = this;
  for ( i = *(this + 1); i != this && v3 == this; i = *(i + 1) )
  {
    if ( v4 < i )
      v3 = i;
  }
  *(*(v4 + 1) + 8) = *(v4 + 2);
  *(*(v4 + 2) + 4) = *(v4 + 1);
  sub_1004AB20(v4, (*v4 & 0xFFFFFF) - 0x1000000, v3);
  if ( a2 + 16 * (*(a2 - 4) & 0xFFFFFF) == *(a2 - 3) )
  {
    *v4 += (**(v4 + 1) & 0xFFFFFF) + 1;
    *(*(*(v4 + 1) + 4) + 8) = v4;
    *(v4 + 1) = *(*(v4 + 1) + 4);
  }
  if ( (*(v4 + 2) + 16 * (**(v4 + 2) & 0xFFFFFF) + 16) == v4 )
  {
    **(v4 + 2) += (*v4 & 0xFFFFFF) + 1;
    *(*(v4 + 1) + 8) = *(v4 + 2);
    *(*(v4 + 2) + 4) = *(v4 + 1);
  }
}

//----- (1004AD70) --------------------------------------------------------
void __thiscall AyuCache::deleteIdAll(AyuCache *this, unsigned __int32 a2)
{
  _DWORD *v2; // [esp+4Ch] [ebp-Ch]
  _DWORD *i; // [esp+50h] [ebp-8h]
  AyuCache *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  for ( i = *(this + 5); i != (v4 + 16); i = v2 )
  {
    v2 = i[1];
    if ( *i >> 24 == a2 )
      AyuCache::cacheFree(v4, i + 4);
  }
}

//----- (1004AE00) --------------------------------------------------------
int __thiscall AyuCache::amountFree(AyuCache *this)
{
  AyuCache *i; // [esp+4Ch] [ebp-Ch]
  int v3; // [esp+50h] [ebp-8h]

  v3 = 0;
  for ( i = *(this + 1); i != this; i = *(i + 1) )
    v3 += 16 * (*i & 0xFFFFFF);
  return v3;
}

//----- (1004AE80) --------------------------------------------------------
bool __thiscall AyuCache::isEmpty(AyuCache *this)
{
  return *(this + 5) == this + 16;
}

//----- (1004AED0) --------------------------------------------------------
unsigned __int32 __thiscall AyuCache::largestBlockFree(AyuCache *this)
{
  AyuCache *i; // [esp+50h] [ebp-Ch]
  unsigned int v3; // [esp+54h] [ebp-8h]

  v3 = 0;
  for ( i = *(this + 1); i != this; i = *(i + 1) )
  {
    if ( 16 * (*i & 0xFFFFFFu) > v3 )
      v3 = 16 * (*i & 0xFFFFFF);
  }
  return v3;
}

//----- (1004AF60) --------------------------------------------------------
void __thiscall AgeServer::close(AgeServer *this)
{
  AtxStream::close(this);
}

//----- (1004AFB0) --------------------------------------------------------
char __thiscall AgeServer::Open(AgeServer *this)
{
  char result; // al
  char v2; // [esp+0h] [ebp-50h]
  char v3; // [esp+0h] [ebp-50h]
  AtxStream *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  sub_1004B040("!!!!! Opening Age server\n", v2);
  if ( AtxStream::open(v4, "age", 3) )
  {
    *(v4 + 16) = 0;
    result = 1;
  }
  else
  {
    sub_1004B040("cant open AgeServer\n", v3);
    result = 0;
  }
  return result;
}

//----- (1004B040) --------------------------------------------------------
char *__cdecl sub_1004B040(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "Age" )
      Stream::print(sysCon, "%s: ", "Age");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1004B150) --------------------------------------------------------
float *__userpurge AgeServer::readPropValue@<eax>(int a1@<ecx>, double a2@<st0>, int a3, float *a4)
{
  float *result; // eax
  char v5; // al
  char v6; // al
  char v7; // al
  int v8; // [esp+4Ch] [ebp-20h]
  float *v9; // [esp+50h] [ebp-1Ch]
  float *v10; // [esp+54h] [ebp-18h]
  float *v11; // [esp+58h] [ebp-14h]
  _DWORD *v12; // [esp+5Ch] [ebp-10h]
  float *v13; // [esp+60h] [ebp-Ch]
  float *v14; // [esp+64h] [ebp-8h]
  int v15; // [esp+68h] [ebp-4h]

  v15 = a1;
  v8 = a3;
  switch ( a3 )
  {
    case 0:
      v14 = a4;
      result = (**v15)(v15);
      *v14 = result;
      break;
    case 1:
      v13 = a4;
      result = (**v15)(v15);
      *v13 = result;
      break;
    case 2:
      v12 = a4;
      result = (**v15)(v15);
      *v12 = result;
      break;
    case 3:
      v11 = a4;
      (*(*v15 + 12))(v15);
      result = v11;
      *v11 = a2;
      break;
    case 4:
      v10 = a4;
      v5 = (**v15)(v15);
      *v10 = v5;
      v6 = (**v15)(v15);
      *(v10 + 1) = v6;
      v7 = (**v15)(v15);
      *(v10 + 2) = v7;
      result = (**v15)(v15);
      *(v10 + 3) = result;
      break;
    case 8:
      v9 = a4;
      result = (*(*v15 + 24))(v15, a4, 10000);
      break;
    default:
      sub_1004B350("Unsupported PropType");
      return result;
  }
  return result;
}

//----- (1004B350) --------------------------------------------------------
void __noreturn sub_1004B350(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("C:\\Development\\DolphinPiki\\sysCommon\\age.cpp", 7, &Dest);
}

//----- (1004B3F0) --------------------------------------------------------
int __thiscall AgeServer::writeProp(void *this, int a2, int a3)
{
  void *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, a2);
  (*(*v4 + 28))(v4, a3);
  return AgeServer::writePropValue(v4, a2, a3);
}
// 10001884: using guessed type int __thiscall AgeServer::writePropValue(_DWORD, _DWORD, _DWORD);

//----- (1004B480) --------------------------------------------------------
int __thiscall AgeServer::writePropValue(void *this, int a2, unsigned __int8 *a3)
{
  int result; // eax
  int v4; // [esp+4Ch] [ebp-14h]
  unsigned __int8 *v5; // [esp+50h] [ebp-10h]
  void *v6; // [esp+5Ch] [ebp-4h]

  v6 = this;
  result = a2;
  v4 = a2;
  switch ( a2 )
  {
    case 0:
      result = (*(*v6 + 28))(v6, *a3);
      break;
    case 1:
      result = (*(*v6 + 28))(v6, *a3);
      break;
    case 2:
      result = (*(*v6 + 28))(v6, *a3);
      break;
    case 3:
      result = (*(*v6 + 40))(v6, *a3);
      break;
    case 4:
      v5 = a3;
      (*(*v6 + 28))(v6, *a3);
      (*(*v6 + 28))(v6, v5[1]);
      (*(*v6 + 28))(v6, v5[2]);
      result = (*(*v6 + 28))(v6, v5[3]);
      break;
    case 7:
    case 9:
      return result;
    case 8:
      result = (*(*v6 + 48))(v6, a3);
      break;
    default:
      sub_1004B350("Unsupported PropType");
      return result;
  }
  return result;
}

//----- (1004B690) --------------------------------------------------------
int __thiscall AgeServer::update(AgeServer *this)
{
  int result; // eax
  char v2; // [esp+0h] [ebp-84h]
  int v3; // [esp+4Ch] [ebp-38h]
  int v4; // [esp+50h] [ebp-34h]
  void (__thiscall ***v5)(_DWORD); // [esp+54h] [ebp-30h]
  void (__thiscall ***v6)(_DWORD, AgeServer *); // [esp+58h] [ebp-2Ch]
  void (__thiscall ***v7)(_DWORD, AgeServer *); // [esp+5Ch] [ebp-28h]
  int v8; // [esp+60h] [ebp-24h]
  int v9; // [esp+64h] [ebp-20h]
  int v10; // [esp+68h] [ebp-1Ch]
  int v11; // [esp+6Ch] [ebp-18h]
  void (__thiscall ***v12)(_DWORD, AgeServer *); // [esp+70h] [ebp-14h]
  char v13[4]; // [esp+74h] [ebp-10h]
  char v14[4]; // [esp+78h] [ebp-Ch]
  int v15; // [esp+7Ch] [ebp-8h]
  AgeServer *v16; // [esp+80h] [ebp-4h]

  v16 = this;
  LOBYTE(v15) = 0;
  while ( 2 )
  {
    if ( (*(*v16 + 60))(v16) )
    {
      LOBYTE(v15) = 1;
      *v14 = (**v16)(v16);
      v3 = *v14;
      if ( *v14 > 0x1F4u )
        goto LABEL_15;
      if ( v3 != 500 )
      {
        v3 -= 202;
        switch ( v3 )
        {
          case 0:
            *v13 = (**v16)(v16);
            sub_1004B040("got genage command : %08x\n", v13[0]);
            AgeServer::NewPropWindow(v16, "Props", *v13);
            (***v13)(*v13, v16);
            AgeServer::Done(v16);
            continue;
          case 1:
            v11 = (**v16)(v16);
            v10 = (**v16)(v16);
            AgeServer::readPropValue(v16, v11, v10);
            continue;
          case 2:
            v6 = (**v16)(v16);
            (**v6)(v6, v16);
            AgeServer::Done(v16);
            continue;
          case 3:
            v5 = (**v16)(v16);
            (**v5)(v5);
            continue;
          case 4:
            v9 = (**v16)(v16);
            v8 = (**v16)(v16);
            AgeServer::writePropValue(v16, v9, v8);
            continue;
          case 7:
            v7 = (**v16)(v16);
            (**v7)(v7, v16);
            AgeServer::Done(v16);
            continue;
          case 8:
            sub_1004B040("got update genage command\n", v2);
            v12 = (**v16)(v16);
            (**v12)(v12, v16);
            AgeServer::Done(v16);
            continue;
          default:
            break;
        }
LABEL_15:
        sub_1004B350("Age cmd unknown %d", *v14);
      }
      sub_1004B040("wants to close age\n", v2);
      (*(*v16 + 28))(v16, 0xFFFF);
      result = -1;
    }
    else
    {
      v4 = (*(*v16 + 60))(v16);
      if ( v4 )
        sub_1004B040("still data on stream !!\n", v2);
      result = v15 != 0;
    }
    return result;
  }
}
// 10001884: using guessed type int __thiscall AgeServer::writePropValue(_DWORD, _DWORD, _DWORD);
// 10002432: using guessed type int __thiscall AgeServer::readPropValue(_DWORD, _DWORD, _DWORD);

//----- (1004BA70) --------------------------------------------------------
int __thiscall AgeServer::setSectionRefresh(void *this, int a2)
{
  void *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 28))(this, 208);
  return (*(*v3 + 28))(v3, a2);
}

//----- (1004BAF0) --------------------------------------------------------
int __thiscall AgeServer::setOnChange(void *this, int a2)
{
  void *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 28))(this, 207);
  (*(*v3 + 28))(v3, 1);
  return (*(*v3 + 28))(v3, a2);
}

//----- (1004BB90) --------------------------------------------------------
void __thiscall AgeServer::setOnChange(AgeServer *this, struct IDelegate *a2)
{
  AgeServer *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*this + 28))(this, 207);
  (*(*v2 + 28))(v2, 0);
  (*(*v2 + 28))(v2, a2);
}

//----- (1004BC30) --------------------------------------------------------
void __thiscall AgeServer::NewNodeWindow(AgeServer *this, char *a2)
{
  AgeServer *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*this + 28))(this, 100);
  (*(*v2 + 48))(v2, a2);
}

//----- (1004BCB0) --------------------------------------------------------
void __thiscall AgeServer::NewPropWindow(AgeServer *this, char *a2, unsigned __int32 a3)
{
  AgeServer *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 28))(this, 104);
  (*(*v3 + 48))(v3, a2);
  (*(*v3 + 28))(v3, a3);
}

//----- (1004BD50) --------------------------------------------------------
void __thiscall AgeServer::RefreshSection(AgeServer *this)
{
  AgeServer *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*this + 28))(this, 403);
}

//----- (1004BDB0) --------------------------------------------------------
void __thiscall AgeServer::RefreshNode(AgeServer *this)
{
  AgeServer *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*this + 28))(this, 402);
}

//----- (1004BE10) --------------------------------------------------------
BOOL __thiscall AgeServer::getOpenFilename(AgeServer *this, struct String *a2, char *Str)
{
  char v3; // al
  AgeServer *v5; // [esp+4Ch] [ebp-4h]

  v5 = this;
  (*(*this + 28))(this, 404);
  if ( Str )
  {
    v3 = strlen(Str);
    sub_1004B040("filter length = %d\n", v3);
    (*(*v5 + 48))(v5, Str);
  }
  else
  {
    (*(*v5 + 48))(v5, "All (*.*)|*.*");
  }
  (*(*v5 + 20))(v5, a2);
  return String::getLength(a2) != 0;
}

//----- (1004BF10) --------------------------------------------------------
BOOL __thiscall AgeServer::getSaveFilename(AgeServer *this, struct String *a2, char *a3)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 405);
  if ( a3 )
    (*(*v4 + 48))(v4, a3);
  else
    (*(*v4 + 48))(v4, "All (*.*)|*.*");
  (*(*v4 + 20))(v4, a2);
  return String::getLength(a2) != 0;
}

//----- (1004BFF0) --------------------------------------------------------
void __thiscall AgeServer::NewNode(AgeServer *this, char *a2, struct ANode *a3)
{
  int v3; // eax
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 101);
  (*(*v4 + 28))(v4, a3);
  (*(*v4 + 48))(v4, a2);
  v3 = (*(*a3 + 8))(a3);
  (*(*v4 + 28))(v4, v3);
}

//----- (1004C0C0) --------------------------------------------------------
void __thiscall AgeServer::EndNode(AgeServer *this)
{
  AgeServer *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*this + 28))(this, 200);
}

//----- (1004C120) --------------------------------------------------------
void __thiscall AgeServer::Done(AgeServer *this)
{
  AgeServer *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*this + 28))(this, 200);
}

//----- (1004C180) --------------------------------------------------------
void __thiscall AgeServer::StartSection(AgeServer *this, char *a2, bool a3)
{
  AgeServer *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 28))(this, 300);
  (*(*v3 + 28))(v3, a3);
  (*(*v3 + 48))(v3, a2);
  *(v3 + 16) = 1;
}

//----- (1004C230) --------------------------------------------------------
void __thiscall AgeServer::EndSection(AgeServer *this)
{
  AgeServer *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*this + 28))(this, 301);
  *(v1 + 16) = 0;
}

//----- (1004C2A0) --------------------------------------------------------
void __thiscall AgeServer::StartGroup(AgeServer *this, char *a2)
{
  AgeServer *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*this + 28))(this, 302);
  (*(*v2 + 48))(v2, a2);
}

//----- (1004C320) --------------------------------------------------------
void __thiscall AgeServer::EndGroup(AgeServer *this)
{
  AgeServer *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*this + 28))(this, 303);
}

//----- (1004C380) --------------------------------------------------------
void __thiscall AgeServer::NewEditor(AgeServer *this, char *a2, int *a3, int a4, int a5, int a6)
{
  AgeServer *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  (*(*this + 28))(this, 102);
  (*(*v6 + 48))(v6, a2);
  AgeServer::writeProp(v6, 2, a3);
  (*(*v6 + 28))(v6, a4);
  (*(*v6 + 28))(v6, a5);
  (*(*v6 + 28))(v6, a6);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004C470) --------------------------------------------------------
void __thiscall AgeServer::NewEditor(AgeServer *this, char *a2, __int16 *a3, int a4, int a5, int a6)
{
  AgeServer *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  (*(*this + 28))(this, 102);
  (*(*v6 + 48))(v6, a2);
  AgeServer::writeProp(v6, 1, a3);
  (*(*v6 + 28))(v6, a4);
  (*(*v6 + 28))(v6, a5);
  (*(*v6 + 28))(v6, a6);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004C560) --------------------------------------------------------
void __thiscall AgeServer::NewEditor(AgeServer *this, char *a2, char *a3, int a4, int a5, int a6)
{
  AgeServer *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  (*(*this + 28))(this, 102);
  (*(*v6 + 48))(v6, a2);
  AgeServer::writeProp(v6, 0, a3);
  (*(*v6 + 28))(v6, a4);
  (*(*v6 + 28))(v6, a5);
  (*(*v6 + 28))(v6, a6);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004C650) --------------------------------------------------------
void __thiscall AgeServer::NewEditor(AgeServer *this, char *a2, float *a3, float a4, float a5, int a6)
{
  AgeServer *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  (*(*this + 28))(this, 102);
  (*(*v6 + 48))(v6, a2);
  AgeServer::writeProp(v6, 3, a3);
  (*(*v6 + 40))(v6, LODWORD(a4));
  (*(*v6 + 40))(v6, LODWORD(a5));
  (*(*v6 + 28))(v6, a6);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004C740) --------------------------------------------------------
void __thiscall AgeServer::NewEditor(AgeServer *this, char *a2, struct Colour *a3)
{
  AgeServer *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 28))(this, 102);
  (*(*v3 + 48))(v3, a2);
  AgeServer::writeProp(v3, 4, a3);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004C7D0) --------------------------------------------------------
void __thiscall AgeServer::NewEditor(AgeServer *this, char *a2, char *a3, int a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 102);
  (*(*v4 + 48))(v4, a2);
  AgeServer::writeProp(v4, 8, a3);
  (*(*v4 + 28))(v4, a4 - 1);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004C880) --------------------------------------------------------
void __thiscall AgeServer::NewEditor(AgeServer *this, char *a2, struct AyuImage *a3, bool a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 102);
  (*(*v4 + 48))(v4, a2);
  if ( a4 )
    AgeServer::writeProp(v4, 5, a3);
  else
    AgeServer::writeProp(v4, 6, a3);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004C930) --------------------------------------------------------
void __thiscall AgeServer::NewViewer(AgeServer *this, char *a2, int *a3)
{
  AgeServer *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 28))(this, 107);
  (*(*v3 + 48))(v3, a2);
  AgeServer::writeProp(v3, 2, a3);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004C9C0) --------------------------------------------------------
void __thiscall AgeServer::NewViewer(AgeServer *this, char *a2, float *a3)
{
  AgeServer *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 28))(this, 107);
  (*(*v3 + 48))(v3, a2);
  AgeServer::writeProp(v3, 3, a3);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004CA50) --------------------------------------------------------
void __thiscall AgeServer::StartBitGroup(AgeServer *this, char *a2, unsigned __int32 *a3, int a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 102);
  (*(*v4 + 48))(v4, a2);
  AgeServer::writeProp(v4, 7, 0);
  AgeServer::writeProp(v4, 2, a3);
  (*(*v4 + 28))(v4, a4);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004CB10) --------------------------------------------------------
void __thiscall AgeServer::StartBitGroup(AgeServer *this, char *a2, unsigned __int8 *a3, int a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 102);
  (*(*v4 + 48))(v4, a2);
  AgeServer::writeProp(v4, 7, 0);
  AgeServer::writeProp(v4, 0, a3);
  (*(*v4 + 28))(v4, a4);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004CBD0) --------------------------------------------------------
void __thiscall AgeServer::NewBit(AgeServer *this, char *a2, unsigned __int32 a3, unsigned __int32 a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 1);
  (*(*v4 + 48))(v4, a2);
  (*(*v4 + 28))(v4, a3);
  (*(*v4 + 28))(v4, a4);
}

//----- (1004CC90) --------------------------------------------------------
void __thiscall AgeServer::EndBitGroup(AgeServer *this)
{
  AgeServer *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*this + 28))(this, 0);
}

//----- (1004CCF0) --------------------------------------------------------
void __thiscall AgeServer::StartOptionBox(AgeServer *this, char *a2, int *a3, int a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 102);
  (*(*v4 + 48))(v4, a2);
  sub_1004B040("new optionbox : %08x\n", a3);
  AgeServer::writeProp(v4, 9, 0);
  AgeServer::writeProp(v4, 2, a3);
  (*(*v4 + 28))(v4, a4);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004CDC0) --------------------------------------------------------
void __thiscall AgeServer::StartOptionBox(AgeServer *this, char *a2, unsigned __int8 *a3, int a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 102);
  (*(*v4 + 48))(v4, a2);
  AgeServer::writeProp(v4, 9, 0);
  AgeServer::writeProp(v4, 0, a3);
  (*(*v4 + 28))(v4, a4);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004CE80) --------------------------------------------------------
void __thiscall AgeServer::StartOptionBox(AgeServer *this, char *a2, unsigned __int16 *a3, int a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 102);
  (*(*v4 + 48))(v4, a2);
  AgeServer::writeProp(v4, 9, 0);
  AgeServer::writeProp(v4, 1, a3);
  (*(*v4 + 28))(v4, a4);
}
// 10001DC5: using guessed type int __thiscall AgeServer::writeProp(_DWORD, _DWORD, _DWORD);

//----- (1004CF40) --------------------------------------------------------
void __thiscall AgeServer::NewOption(AgeServer *this, char *a2, int a3)
{
  AgeServer *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 28))(this, 1);
  (*(*v3 + 48))(v3, a2);
  (*(*v3 + 28))(v3, a3);
}

//----- (1004CFE0) --------------------------------------------------------
void __thiscall AgeServer::NewLabel(AgeServer *this, char *a2)
{
  AgeServer *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*this + 28))(this, 108);
  (*(*v2 + 48))(v2, a2);
}

//----- (1004D060) --------------------------------------------------------
void __thiscall AgeServer::EndOptionBox(AgeServer *this)
{
  AgeServer *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*this + 28))(this, 0);
}

//----- (1004D0C0) --------------------------------------------------------
int __thiscall AgeServer::NewButton(void *this, int a2, int a3, int a4)
{
  void *v5; // [esp+4Ch] [ebp-4h]

  v5 = this;
  (*(*this + 28))(this, 105);
  (*(*v5 + 48))(v5, a2);
  (*(*v5 + 28))(v5, a4);
  (*(*v5 + 28))(v5, 1);
  return (*(*v5 + 28))(v5, a3);
}

//----- (1004D190) --------------------------------------------------------
void __thiscall AgeServer::NewButton(AgeServer *this, char *a2, struct IDelegate *a3, int a4)
{
  AgeServer *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 28))(this, 105);
  (*(*v4 + 48))(v4, a2);
  (*(*v4 + 28))(v4, a4);
  (*(*v4 + 28))(v4, 0);
  (*(*v4 + 28))(v4, a3);
}

//----- (1004D260) --------------------------------------------------------
void __stdcall BaseApp::InitApp(char *a2)
{
  ;
}

//----- (1004D290) --------------------------------------------------------
int BaseApp::idle()
{
  return 0;
}

//----- (1004D2C0) --------------------------------------------------------
bool __stdcall BaseApp::keyDown(int a2, int a3, int a4)
{
  return 0;
}

//----- (1004D300) --------------------------------------------------------
double BaseApp::rnd()
{
  return rand() / 32767.0;
}

//----- (1004D360) --------------------------------------------------------
double __thiscall BaseApp::rnd(BaseApp *this, float a2)
{
  return BaseApp::rnd(this) * a2;
}

//----- (1004D3B0) --------------------------------------------------------
void __thiscall BaseApp::useHeap(BaseApp *this, int a2)
{
  *(this + 20) = a2;
  StdSystem::setHeap(gsys, *(this + 20));
}

//----- (1004D410) --------------------------------------------------------
void __stdcall BaseApp::procCmd(char *a2)
{
  ;
}

//----- (1004D440) --------------------------------------------------------
BaseApp *__thiscall BaseApp::BaseApp(BaseApp *this, const struct BaseApp *a2)
{
  BaseApp *v2; // ST50_4

  v2 = this;
  Node::Node(this, a2);
  *(v2 + 8) = *(a2 + 8);
  *(v2 + 9) = *(a2 + 9);
  *(v2 + 40) = *(a2 + 40);
  *(v2 + 11) = *(a2 + 11);
  Node::Node((v2 + 48), (a2 + 48));
  *(v2 + 20) = *(a2 + 20);
  *v2 = &BaseApp::`vftable';
  return v2;
}
// 101AF360: using guessed type void *BaseApp::`vftable';

//----- (1004D500) --------------------------------------------------------
_DWORD *__thiscall BaseApp::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  Node::operator=(a2);
  v2[8] = *(a2 + 32);
  v2[9] = *(a2 + 36);
  *(v2 + 40) = *(a2 + 40);
  v2[11] = *(a2 + 44);
  Node::operator=(a2 + 48);
  v2[20] = *(a2 + 80);
  return v2;
}
// 1000171C: using guessed type _DWORD __stdcall Node::operator=(_DWORD);

//----- (1004D620) --------------------------------------------------------
int __thiscall sub_1004D620(char *this, char a2)
{
  int result; // eax
  char *hMem; // [esp+4Ch] [ebp-4h]

  hMem = this;
  if ( a2 & 2 )
  {
    `eh vector destructor iterator'(this, 0x54u, *(this - 1), BaseApp::~BaseApp);
    if ( a2 & 1 )
      sub_1000136B(hMem - 4);
    result = (hMem - 4);
  }
  else
  {
    BaseApp::~BaseApp(this);
    if ( a2 & 1 )
      sub_10001938(hMem);
    result = hMem;
  }
  return result;
}

//----- (1004D6E0) --------------------------------------------------------
void __thiscall AtxStream::close(AtxStream *this)
{
  int v1; // [esp+4Ch] [ebp-8h]
  AtxStream *v2; // [esp+50h] [ebp-4h]

  v2 = this;
  v1 = System::getAtxRouter(gsys);
  (*(*v1 + 4))(v1, v2);
}
// 10002626: using guessed type int __thiscall System::getAtxRouter(_DWORD);

//----- (1004D750) --------------------------------------------------------
char __thiscall AtxStream::open(AtxStream *this, char *a2, int a3)
{
  char result; // al
  char v4; // [esp+0h] [ebp-58h]
  int v5; // [esp+4Ch] [ebp-Ch]
  int (__thiscall ***v6)(_DWORD, AtxStream *, int); // [esp+50h] [ebp-8h]
  AtxStream *v7; // [esp+54h] [ebp-4h]

  v7 = this;
  v6 = System::getAtxRouter(gsys);
  if ( !v6 )
    return 0;
  if ( (**v6)(v6, v7, a3) & 0xFF )
  {
    (*(*v7 + 56))(v7, a2, 4);
    v5 = (***(v7 + 2))(*(v7 + 2));
    if ( v5 == 0xFFFF )
    {
      result = 0;
    }
    else
    {
      (*(*v7 + 76))(v7);
      result = 1;
    }
  }
  else
  {
    sub_1004D870("Could not open route to server\n", v4);
    System::setAtxRouter(gsys);
    result = 0;
  }
  return result;
}
// 10002626: using guessed type int __thiscall System::getAtxRouter(_DWORD);

//----- (1004D870) --------------------------------------------------------
char *__cdecl sub_1004D870(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "Atx" )
      Stream::print(sysCon, "%s: ", "Atx");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1004D980) --------------------------------------------------------
void __thiscall AtxStream::write(AtxStream *this, void *a2, int a3)
{
  int v3; // [esp+4Ch] [ebp-8h]
  AtxStream *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  v3 = System::getAtxRouter(gsys);
  (*(*v3 + 8))(v3);
  (*(**(v4 + 2) + 56))(*(v4 + 2), a2, a3);
  (*(*v3 + 12))(v3);
}
// 10002626: using guessed type int __thiscall System::getAtxRouter(_DWORD);

//----- (1004DA30) --------------------------------------------------------
void __thiscall AtxStream::read(AtxStream *this, void *a2, int a3)
{
  int v3; // [esp+4Ch] [ebp-8h]
  AtxStream *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  v3 = System::getAtxRouter(gsys);
  (*(*v3 + 8))(v3);
  (*(**(v4 + 2) + 52))(*(v4 + 2), a2, a3);
  (*(*v3 + 12))(v3);
}
// 10002626: using guessed type int __thiscall System::getAtxRouter(_DWORD);

//----- (1004DAE0) --------------------------------------------------------
int __thiscall AtxStream::getPending(AtxStream *this)
{
  int v2; // [esp+4Ch] [ebp-Ch]
  int v3; // [esp+50h] [ebp-8h]
  AtxStream *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  v3 = System::getAtxRouter(gsys);
  (*(*v3 + 8))(v3);
  v2 = (*(**(v4 + 2) + 60))(*(v4 + 2));
  (*(*v3 + 12))(v3);
  return v2;
}
// 10002626: using guessed type int __thiscall System::getAtxRouter(_DWORD);

//----- (1004DB90) --------------------------------------------------------
void __thiscall AtxStream::flush(AtxStream *this)
{
  int v1; // [esp+4Ch] [ebp-8h]
  AtxStream *v2; // [esp+50h] [ebp-4h]

  v2 = this;
  v1 = System::getAtxRouter(gsys);
  (*(*v1 + 8))(v1);
  (*(**(v2 + 2) + 76))(*(v2 + 2));
  (*(*v1 + 12))(v1);
}
// 10002626: using guessed type int __thiscall System::getAtxRouter(_DWORD);

//----- (1004DC30) --------------------------------------------------------
int __thiscall AtxCommandStream::checkCommands(AtxCommandStream *this)
{
  char v2; // [esp+0h] [ebp-58h]
  int v3; // [esp+4Ch] [ebp-Ch]
  int v4; // [esp+50h] [ebp-8h]
  AtxCommandStream *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  if ( !(*(**(this + 2) + 60))(*(this + 2)) )
    return 0;
  v4 = (***(v5 + 2))(*(v5 + 2));
  v3 = v4;
  if ( v4 == 1 )
  {
    sub_1004D870("Atx - Sending identification information\n", v2);
    (*(**(v5 + 2) + 48))(*(v5 + 2), *(v5 + 1));
  }
  else
  {
    if ( v3 == 0xFFFF )
    {
      sub_1004D870("Atx - Server is closing\n", v2);
      BaseApp::stopAgeServer(*(v5 + 4));
      return 0;
    }
    if ( v3 == 1634166016 )
      BaseApp::startAgeServer(*(v5 + 4));
  }
  return 1;
}

//----- (1004DD60) --------------------------------------------------------
char __thiscall AtxFileStream::open(AtxFileStream *this, char *a2, unsigned __int32 a3)
{
  char result; // al
  int v4; // eax
  char v5; // [esp+0h] [ebp-50h]
  AtxFileStream *v6; // [esp+4Ch] [ebp-4h]

  v6 = this;
  if ( AtxStream::open((this + 16), "fil", 3) )
  {
    (*(*(v6 + 4) + 48))(v6 + 16, a2);
    (*(*(v6 + 4) + 28))(v6 + 16, a3);
    v4 = (**(v6 + 4))(v6 + 16);
    *(v6 + 3) = v4;
    *(v6 + 2) = 0;
    if ( *(v6 + 3) >= 0 )
    {
      *(v6 + 1) = a2;
      result = 1;
    }
    else
    {
      (*(*(v6 + 4) + 68))(v6 + 16);
      result = 0;
    }
  }
  else
  {
    sub_1004D870("Could not open file service!!\n", v5);
    result = 0;
  }
  return result;
}

//----- (1004DE90) --------------------------------------------------------
void __thiscall AtxFileStream::setPosition(AtxFileStream *this, int a2)
{
  AtxFileStream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  *(this + 2) = a2;
  (*(*(v2 + 4) + 28))(v2 + 16, 102);
  (*(*(v2 + 4) + 28))(v2 + 16, *(v2 + 2));
}

//----- (1004DF20) --------------------------------------------------------
void __thiscall AtxFileStream::read(AtxFileStream *this, void *a2, int a3)
{
  AtxFileStream *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*(this + 4) + 28))(this + 16, 100);
  (*(*(v3 + 4) + 28))(v3 + 16, a3);
  (*(*(v3 + 4) + 52))(v3 + 16, a2, a3);
  *(v3 + 2) += a3;
}

//----- (1004DFE0) --------------------------------------------------------
void __thiscall AtxFileStream::write(AtxFileStream *this, void *a2, int a3)
{
  AtxFileStream *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*(this + 4) + 28))(this + 16, 101);
  (*(*(v3 + 4) + 28))(v3 + 16, a3);
  (*(*(v3 + 4) + 56))(v3 + 16, a2, a3);
  *(v3 + 2) += a3;
  if ( *(v3 + 2) > *(v3 + 3) )
    *(v3 + 3) = *(v3 + 2);
}

//----- (1004E0C0) --------------------------------------------------------
void __thiscall AtxFileStream::close(AtxFileStream *this)
{
  AtxFileStream *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(*(this + 4) + 28))(this + 16, 103);
  (*(*(v1 + 4) + 76))(v1 + 16);
  (**(v1 + 4))(v1 + 16);
  (*(*(v1 + 4) + 68))(v1 + 16);
}

//----- (1004E180) --------------------------------------------------------
BaseApp *__thiscall BaseApp::BaseApp(BaseApp *this)
{
  BaseApp *v1; // ST50_4
  CoreNode *v2; // eax

  v1 = this;
  Node::Node(this, "<Node>");
  Node::Node((v1 + 48), "<Node>");
  *v1 = &BaseApp::`vftable';
  *(v1 + 11) = 0;
  *(v1 + 8) = 0;
  *(v1 + 9) = 0;
  *(v1 + 40) = 1;
  v2 = NodeMgr::firstNode(nodeMgr);
  CoreNode::add(v2, v1);
  return v1;
}
// 101AF360: using guessed type void *BaseApp::`vftable';

//----- (1004E240) --------------------------------------------------------
int __thiscall BaseApp::idleupdate(BaseApp *this)
{
  int v2; // [esp+4Ch] [ebp-10h]
  int v3; // [esp+50h] [ebp-Ch]
  signed int v4; // [esp+54h] [ebp-8h]
  BaseApp *v5; // [esp+58h] [ebp-4h]

  v5 = this;
  v4 = 0;
  if ( *(this + 8) )
  {
    v3 = AtxCommandStream::checkCommands(*(this + 8));
    if ( v3 == -1 )
    {
      *(v5 + 8) = 0;
    }
    else if ( v3 )
    {
      v4 = 1;
    }
  }
  if ( *(v5 + 9) )
  {
    v2 = AgeServer::update(*(v5 + 9));
    if ( v2 == -1 )
    {
      BaseApp::stopAgeServer(v5);
      *(v5 + 9) = 0;
    }
    else if ( v2 )
    {
      v4 = 1;
    }
  }
  return v4;
}

//----- (1004E320) --------------------------------------------------------
void __thiscall BaseApp::startAgeServer(BaseApp *this)
{
  char *v1; // eax
  char v2; // [esp+0h] [ebp-70h]
  AgeServer *v3; // [esp+4Ch] [ebp-24h]
  HGLOBAL hMem; // [esp+50h] [ebp-20h]
  AgeServer *v5; // [esp+54h] [ebp-1Ch]
  int v6; // [esp+58h] [ebp-18h]
  AgeServer *v7; // [esp+5Ch] [ebp-14h]
  CoreNode *v8; // [esp+60h] [ebp-10h]
  int v9; // [esp+6Ch] [ebp-4h]

  v8 = this;
  if ( !*(this + 9) )
  {
    sub_1004E470("Atx - Wants to open Age service\n", v2);
    hMem = sub_10002A81(0x14u);
    v9 = 0;
    if ( hMem )
      v3 = AgeServer::AgeServer(hMem);
    else
      v3 = 0;
    v5 = v3;
    v9 = -1;
    v7 = v3;
    LOBYTE(v6) = AgeServer::Open(v3);
    if ( v6 )
    {
      v8[1].Child = v7;
      v1 = CoreNode::Name(v8);
      AgeServer::NewNodeWindow(v8[1].Child, v1);
      (*(v8->vtblPointer + 4))(v8, v8[1].Child);
      AgeServer::Done(v8[1].Child);
    }
  }
}

//----- (1004E470) --------------------------------------------------------
char *__cdecl sub_1004E470(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "baseApp" )
      Stream::print(sysCon, "%s: ", "baseApp");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1004E580) --------------------------------------------------------
void __thiscall BaseApp::stopAgeServer(BaseApp *this)
{
  char v1; // [esp+0h] [ebp-50h]
  BaseApp *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  if ( *(this + 9) )
  {
    sub_1004E470("Atx - Wants to close Age service\n", v1);
    (*(**(*(v2 + 9) + 8) + 28))(*(*(v2 + 9) + 8), 0xFFFF);
    (*(**(*(v2 + 9) + 8) + 76))(*(*(v2 + 9) + 8));
    *(v2 + 9) = 0;
  }
}

//----- (1004E640) --------------------------------------------------------
void __thiscall BaseApp::softReset(BaseApp *this)
{
  BaseApp *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  BaseApp::stopAgeServer(this);
  *(v1 + 4) = 0;
  Node::init((v1 + 48), "[Windows]");
  (**gsys)(gsys);
}

//----- (1004E6D0) --------------------------------------------------------
void __stdcall BaseApp::genAge(struct AgeServer *a2)
{
  System::genAge(gsys);
}

//----- (1004E720) --------------------------------------------------------
void __thiscall BaseApp::~BaseApp(BaseApp *this)
{
  char v1; // [esp+0h] [ebp-50h]
  struct Node *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  *this = &BaseApp::`vftable';
  sub_1004E470("default baseApp deconstructor\n", v1);
  if ( v2[1].pVtbl )
  {
    (*(**(v2[1].pVtbl + 8) + 28))(*(v2[1].pVtbl + 8), 0xFFFF);
    (*(**(v2[1].pVtbl + 8) + 76))(*(v2[1].pVtbl + 8));
  }
  BaseApp::stopAgeServer(v2);
  NodeMgr::Del(nodeMgr, v2);
}
// 101AF360: using guessed type void *BaseApp::`vftable';

//----- (1004E800) --------------------------------------------------------
void __thiscall CullFrustum::vectorToWorldPlane(CullFrustum *this, struct Vector3f *a2, struct CullingPlane *a3)
{
  CullFrustum *v3; // ST54_4

  v3 = this;
  CullFrustum::projectVector(this, a2, a3);
  *(a3 + 3) = Vector3f::DP(a3, (v3 + 356));
}

//----- (1004E870) --------------------------------------------------------
char __thiscall CullFrustum::isPointVisible(CullFrustum *this, struct Vector3f *a2, float a3)
{
  float *v3; // edx
  int i; // [esp+50h] [ebp-8h]

  for ( i = 0; i < *(this + 1); ++i )
  {
    v3 = *(this + i + 69);
    if ( -a3 > *a2 * *v3 + *(a2 + 1) * v3[1] + *(a2 + 2) * v3[2] - v3[3] )
      return 0;
  }
  return 1;
}

//----- (1004E930) --------------------------------------------------------
void __thiscall CullFrustum::draw(CullFrustum *this, struct Graphics *a2)
{
  int v2; // eax
  int v3; // eax
  double v4; // st7
  float v5; // ST2C_4
  double v6; // st7
  float v7; // ST2C_4
  double v8; // st7
  double v9; // st7
  double v10; // st7
  double v11; // st7
  double v12; // st7
  double v13; // st7
  double v14; // st7
  double v15; // st7
  double v16; // st7
  double v17; // st7
  double v18; // st7
  double v19; // st7
  const struct Vector3f *v20; // eax
  double v21; // st7
  double v22; // st7
  double v23; // st7
  double v24; // st7
  double v25; // st7
  double v26; // st7
  double v27; // st7
  double v28; // st7
  double v29; // st7
  double v30; // st7
  double v31; // st7
  double v32; // st7
  double v33; // st7
  const struct Vector3f *v34; // eax
  double v35; // st7
  double v36; // st7
  double v37; // st7
  double v38; // st7
  double v39; // st7
  double v40; // st7
  double v41; // st7
  double v42; // st7
  double v43; // st7
  double v44; // st7
  double v45; // st7
  double v46; // st7
  double v47; // st7
  int v48; // eax
  int v49; // eax
  int v50; // eax
  int v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // ecx
  float v55; // [esp+7Ch] [ebp-2DCh]
  char v56; // [esp+80h] [ebp-2D8h]
  char v57; // [esp+84h] [ebp-2D4h]
  char v58; // [esp+88h] [ebp-2D0h]
  char v59; // [esp+8Ch] [ebp-2CCh]
  char v60; // [esp+90h] [ebp-2C8h]
  char v61; // [esp+94h] [ebp-2C4h]
  float v62; // [esp+98h] [ebp-2C0h]
  float v63; // [esp+9Ch] [ebp-2BCh]
  float v64; // [esp+A0h] [ebp-2B8h]
  float v65; // [esp+A4h] [ebp-2B4h]
  float v66; // [esp+A8h] [ebp-2B0h]
  float v67; // [esp+ACh] [ebp-2ACh]
  float v68; // [esp+B0h] [ebp-2A8h]
  float v69; // [esp+B4h] [ebp-2A4h]
  float v70; // [esp+B8h] [ebp-2A0h]
  float v71; // [esp+BCh] [ebp-29Ch]
  float v72; // [esp+C0h] [ebp-298h]
  float v73; // [esp+C4h] [ebp-294h]
  float v74; // [esp+C8h] [ebp-290h]
  float v75; // [esp+CCh] [ebp-28Ch]
  float v76; // [esp+D0h] [ebp-288h]
  float v77; // [esp+D4h] [ebp-284h]
  float v78; // [esp+D8h] [ebp-280h]
  float v79; // [esp+DCh] [ebp-27Ch]
  float v80; // [esp+E0h] [ebp-278h]
  float v81; // [esp+E4h] [ebp-274h]
  char v82; // [esp+E8h] [ebp-270h]
  float v83; // [esp+F4h] [ebp-264h]
  float v84; // [esp+F8h] [ebp-260h]
  float v85; // [esp+FCh] [ebp-25Ch]
  float v86; // [esp+100h] [ebp-258h]
  float v87; // [esp+104h] [ebp-254h]
  float v88; // [esp+108h] [ebp-250h]
  float v89; // [esp+10Ch] [ebp-24Ch]
  float v90; // [esp+110h] [ebp-248h]
  float v91; // [esp+114h] [ebp-244h]
  float v92; // [esp+118h] [ebp-240h]
  float v93; // [esp+11Ch] [ebp-23Ch]
  float v94; // [esp+120h] [ebp-238h]
  float v95; // [esp+124h] [ebp-234h]
  float v96; // [esp+128h] [ebp-230h]
  float v97; // [esp+12Ch] [ebp-22Ch]
  float v98; // [esp+130h] [ebp-228h]
  float v99; // [esp+134h] [ebp-224h]
  float v100; // [esp+138h] [ebp-220h]
  float v101; // [esp+13Ch] [ebp-21Ch]
  float v102; // [esp+140h] [ebp-218h]
  char v103; // [esp+144h] [ebp-214h]
  float v104; // [esp+150h] [ebp-208h]
  float v105; // [esp+154h] [ebp-204h]
  float v106; // [esp+158h] [ebp-200h]
  float v107; // [esp+15Ch] [ebp-1FCh]
  float v108; // [esp+160h] [ebp-1F8h]
  float v109; // [esp+164h] [ebp-1F4h]
  float v110; // [esp+168h] [ebp-1F0h]
  float v111; // [esp+16Ch] [ebp-1ECh]
  float v112; // [esp+170h] [ebp-1E8h]
  float v113; // [esp+174h] [ebp-1E4h]
  float v114; // [esp+178h] [ebp-1E0h]
  float v115; // [esp+17Ch] [ebp-1DCh]
  float v116; // [esp+180h] [ebp-1D8h]
  float v117; // [esp+184h] [ebp-1D4h]
  float v118; // [esp+188h] [ebp-1D0h]
  float v119; // [esp+18Ch] [ebp-1CCh]
  float v120; // [esp+190h] [ebp-1C8h]
  float v121; // [esp+194h] [ebp-1C4h]
  float v122; // [esp+198h] [ebp-1C0h]
  float v123; // [esp+19Ch] [ebp-1BCh]
  char v124; // [esp+1A0h] [ebp-1B8h]
  char v125; // [esp+1A4h] [ebp-1B4h]
  char v126; // [esp+1A8h] [ebp-1B0h]
  char v127; // [esp+1B0h] [ebp-1A8h]
  char v128; // [esp+1B8h] [ebp-1A0h]
  char v129; // [esp+1C0h] [ebp-198h]
  int v130; // [esp+1C8h] [ebp-190h]
  int v131; // [esp+1CCh] [ebp-18Ch]
  int v132; // [esp+1D0h] [ebp-188h]
  int v133; // [esp+1D4h] [ebp-184h]
  int v134; // [esp+1D8h] [ebp-180h]
  int v135; // [esp+1DCh] [ebp-17Ch]
  int v136; // [esp+1E0h] [ebp-178h]
  int v137; // [esp+1E4h] [ebp-174h]
  int v138; // [esp+1E8h] [ebp-170h]
  int v139; // [esp+1ECh] [ebp-16Ch]
  int v140; // [esp+1F0h] [ebp-168h]
  int v141; // [esp+1F4h] [ebp-164h]
  int v142; // [esp+1F8h] [ebp-160h]
  int v143; // [esp+1FCh] [ebp-15Ch]
  int v144; // [esp+200h] [ebp-158h]
  int v145; // [esp+204h] [ebp-154h]
  int v146; // [esp+208h] [ebp-150h]
  int v147; // [esp+20Ch] [ebp-14Ch]
  int v148; // [esp+210h] [ebp-148h]
  int v149; // [esp+214h] [ebp-144h]
  int v150; // [esp+218h] [ebp-140h]
  int v151; // [esp+21Ch] [ebp-13Ch]
  int v152; // [esp+220h] [ebp-138h]
  int v153; // [esp+224h] [ebp-134h]
  char v154; // [esp+228h] [ebp-130h]
  char v155; // [esp+234h] [ebp-124h]
  char v156; // [esp+240h] [ebp-118h]
  char v157; // [esp+24Ch] [ebp-10Ch]
  float v158; // [esp+258h] [ebp-100h]
  float v159; // [esp+25Ch] [ebp-FCh]
  float v160; // [esp+260h] [ebp-F8h]
  int v161; // [esp+264h] [ebp-F4h]
  int v162; // [esp+268h] [ebp-F0h]
  int v163; // [esp+26Ch] [ebp-ECh]
  int v164; // [esp+270h] [ebp-E8h]
  int v165; // [esp+274h] [ebp-E4h]
  int v166; // [esp+278h] [ebp-E0h]
  int v167; // [esp+27Ch] [ebp-DCh]
  int v168; // [esp+280h] [ebp-D8h]
  int v169; // [esp+284h] [ebp-D4h]
  int v170; // [esp+288h] [ebp-D0h]
  int v171; // [esp+28Ch] [ebp-CCh]
  int v172; // [esp+290h] [ebp-C8h]
  char v173; // [esp+294h] [ebp-C4h]
  char v174; // [esp+2A0h] [ebp-B8h]
  char v175; // [esp+2ACh] [ebp-ACh]
  char v176; // [esp+2B8h] [ebp-A0h]
  float v177; // [esp+2C4h] [ebp-94h]
  float v178; // [esp+2C8h] [ebp-90h]
  float v179; // [esp+2CCh] [ebp-8Ch]
  float v180; // [esp+2D0h] [ebp-88h]
  float v181; // [esp+2D4h] [ebp-84h]
  float v182; // [esp+2D8h] [ebp-80h]
  char v183; // [esp+2DCh] [ebp-7Ch]
  char v184; // [esp+2E8h] [ebp-70h]
  char v185; // [esp+2F4h] [ebp-64h]
  char v186; // [esp+300h] [ebp-58h]
  char v187; // [esp+30Ch] [ebp-4Ch]
  char v188; // [esp+318h] [ebp-40h]
  char v189; // [esp+324h] [ebp-34h]
  char v190; // [esp+330h] [ebp-28h]
  float v191; // [esp+33Ch] [ebp-1Ch]
  float v192; // [esp+340h] [ebp-18h]
  float v193; // [esp+344h] [ebp-14h]
  float v194; // [esp+348h] [ebp-10h]
  float v195; // [esp+34Ch] [ebp-Ch]
  char v196; // [esp+350h] [ebp-8h]
  float *v197; // [esp+354h] [ebp-4h]

  v197 = this;
  *(a2 + 202) = 0;
  v196 = (*(*a2 + 40))(a2, 0, 0);
  (*(*a2 + 108))(a2, *(a2 + 186) + 480, 0);
  (*(*a2 + 196))(a2, 0, 0);
  v2 = Colour::Colour(&v125, 255, 255, 255, 0xFFu);
  (*(*a2 + 160))(a2, v2, 1);
  v3 = Colour::Colour(&v124, 255, 255, 255, 0xFFu);
  (*(*a2 + 164))(a2, v3);
  (*(*a2 + 144))(a2, v197 + 89, v197 + 92);
  v195 = Vector3f::distance((v197 + 89), (v197 + 92));
  v4 = v197[115] / 2.0 * 3.1415927 / 180.0;
  v5 = v4;
  sub_10002635(v5);
  v55 = v4 * v195;
  v6 = v197[115] / 2.0 * 3.1415927 / 180.0;
  v7 = v6;
  sub_10002D47(v7);
  v194 = v55 / v6;
  v193 = v194 / v197[113];
  v192 = v193 * v197[113];
  v191 = v194;
  v123 = 0.0;
  v122 = -v192;
  Vector3f::Vector3f(&v190, &v122, &v191, &v123);
  v121 = 0.0;
  Vector3f::Vector3f(&v189, &v192, &v191, &v121);
  v120 = 0.0;
  v119 = -v191;
  Vector3f::Vector3f(&v188, &v192, &v119, &v120);
  v118 = 0.0;
  v117 = -v191;
  v116 = -v192;
  Vector3f::Vector3f(&v187, &v116, &v117, &v118);
  v8 = Vector3f::DP(&v190, (v197 + 101));
  v115 = v8 + v197[94];
  v9 = Vector3f::DP(&v190, (v197 + 98));
  v114 = v9 + v197[93];
  v10 = Vector3f::DP(&v190, (v197 + 95));
  v113 = v10 + v197[92];
  Vector3f::Vector3f(&v186, &v113, &v114, &v115);
  v11 = Vector3f::DP(&v189, (v197 + 101));
  v112 = v11 + v197[94];
  v12 = Vector3f::DP(&v189, (v197 + 98));
  v111 = v12 + v197[93];
  v13 = Vector3f::DP(&v189, (v197 + 95));
  v110 = v13 + v197[92];
  Vector3f::Vector3f(&v185, &v110, &v111, &v112);
  v14 = Vector3f::DP(&v188, (v197 + 101));
  v109 = v14 + v197[94];
  v15 = Vector3f::DP(&v188, (v197 + 98));
  v108 = v15 + v197[93];
  v16 = Vector3f::DP(&v188, (v197 + 95));
  v107 = v16 + v197[92];
  Vector3f::Vector3f(&v184, &v107, &v108, &v109);
  v17 = Vector3f::DP(&v187, (v197 + 101));
  v106 = v17 + v197[94];
  v18 = Vector3f::DP(&v187, (v197 + 98));
  v105 = v18 + v197[93];
  v19 = Vector3f::DP(&v187, (v197 + 95));
  v104 = v19 + v197[92];
  Vector3f::Vector3f(&v183, &v104, &v105, &v106);
  v20 = sub_10002E2D(&v103, (v197 + 92), (v197 + 89));
  Vector3f::Vector3f(&v180, v20);
  Vector3f::normalise(&v180);
  Vector3f::multiply(&v180, v197[116]);
  Vector3f::add(&v180, (v197 + 89));
  v21 = Vector3f::distance((v197 + 92), (v197 + 89));
  v179 = v197[116] / v21;
  v178 = v193 * v179;
  v177 = v194 * v179;
  v102 = 0.0;
  v101 = -v178;
  Vector3f::Vector3f(&v176, &v101, &v177, &v102);
  v100 = 0.0;
  Vector3f::Vector3f(&v175, &v178, &v177, &v100);
  v99 = 0.0;
  v98 = -v177;
  Vector3f::Vector3f(&v174, &v178, &v98, &v99);
  v97 = 0.0;
  v96 = -v177;
  v95 = -v178;
  Vector3f::Vector3f(&v173, &v95, &v96, &v97);
  v22 = Vector3f::DP(&v176, (v197 + 101));
  v94 = v22 + v182;
  v23 = Vector3f::DP(&v176, (v197 + 98));
  v93 = v23 + v181;
  v24 = Vector3f::DP(&v176, (v197 + 95));
  v92 = v24 + v180;
  Vector3f::Vector3f(&v170, &v92, &v93, &v94);
  v25 = Vector3f::DP(&v175, (v197 + 101));
  v91 = v25 + v182;
  v26 = Vector3f::DP(&v175, (v197 + 98));
  v90 = v26 + v181;
  v27 = Vector3f::DP(&v175, (v197 + 95));
  v89 = v27 + v180;
  Vector3f::Vector3f(&v167, &v89, &v90, &v91);
  v28 = Vector3f::DP(&v174, (v197 + 101));
  v88 = v28 + v182;
  v29 = Vector3f::DP(&v174, (v197 + 98));
  v87 = v29 + v181;
  v30 = Vector3f::DP(&v174, (v197 + 95));
  v86 = v30 + v180;
  Vector3f::Vector3f(&v164, &v86, &v87, &v88);
  v31 = Vector3f::DP(&v173, (v197 + 101));
  v85 = v31 + v182;
  v32 = Vector3f::DP(&v173, (v197 + 98));
  v84 = v32 + v181;
  v33 = Vector3f::DP(&v173, (v197 + 95));
  v83 = v33 + v180;
  Vector3f::Vector3f(&v161, &v83, &v84, &v85);
  v34 = sub_10002E2D(&v82, (v197 + 92), (v197 + 89));
  Vector3f::Vector3f(&v158, v34);
  Vector3f::normalise(&v158);
  Vector3f::multiply(&v158, v197[117]);
  Vector3f::add(&v158, (v197 + 89));
  v35 = Vector3f::distance((v197 + 92), (v197 + 89));
  v179 = v197[117] / v35;
  v192 = v192 * v179;
  v191 = v191 * v179;
  v81 = 0.0;
  v80 = -v192;
  Vector3f::Vector3f(&v157, &v80, &v191, &v81);
  v79 = 0.0;
  Vector3f::Vector3f(&v156, &v192, &v191, &v79);
  v78 = 0.0;
  v77 = -v191;
  Vector3f::Vector3f(&v155, &v192, &v77, &v78);
  v76 = 0.0;
  v75 = -v191;
  v74 = -v192;
  Vector3f::Vector3f(&v154, &v74, &v75, &v76);
  v36 = Vector3f::DP(&v157, (v197 + 101));
  v73 = v36 + v160;
  v37 = Vector3f::DP(&v157, (v197 + 98));
  v72 = v37 + v159;
  v38 = Vector3f::DP(&v157, (v197 + 95));
  v71 = v38 + v158;
  Vector3f::Vector3f(&v151, &v71, &v72, &v73);
  v39 = Vector3f::DP(&v156, (v197 + 101));
  v70 = v39 + v160;
  v40 = Vector3f::DP(&v156, (v197 + 98));
  v69 = v40 + v159;
  v41 = Vector3f::DP(&v156, (v197 + 95));
  v68 = v41 + v158;
  Vector3f::Vector3f(&v148, &v68, &v69, &v70);
  v42 = Vector3f::DP(&v155, (v197 + 101));
  v67 = v42 + v160;
  v43 = Vector3f::DP(&v155, (v197 + 98));
  v66 = v43 + v159;
  v44 = Vector3f::DP(&v155, (v197 + 95));
  v65 = v44 + v158;
  Vector3f::Vector3f(&v145, &v65, &v66, &v67);
  v45 = Vector3f::DP(&v154, (v197 + 101));
  v64 = v45 + v160;
  v46 = Vector3f::DP(&v154, (v197 + 98));
  v63 = v46 + v159;
  v47 = Vector3f::DP(&v154, (v197 + 95));
  v62 = v47 + v158;
  Vector3f::Vector3f(&v142, &v62, &v63, &v64);
  v48 = Colour::Colour(&v61, 32, 255, 32, 0x80u);
  (*(*a2 + 160))(a2, v48, 1);
  (*(*a2 + 144))(a2, &v170, &v167);
  (*(*a2 + 144))(a2, &v167, &v164);
  (*(*a2 + 144))(a2, &v164, &v161);
  (*(*a2 + 144))(a2, &v161, &v170);
  (*(*a2 + 144))(a2, &v170, &v186);
  (*(*a2 + 144))(a2, &v167, &v185);
  (*(*a2 + 144))(a2, &v164, &v184);
  (*(*a2 + 144))(a2, &v161, &v183);
  (*(*a2 + 144))(a2, &v186, &v185);
  (*(*a2 + 144))(a2, &v185, &v184);
  (*(*a2 + 144))(a2, &v184, &v183);
  (*(*a2 + 144))(a2, &v183, &v186);
  v49 = Colour::Colour(&v60, 255, 32, 32, 0x80u);
  (*(*a2 + 160))(a2, v49, 1);
  (*(*a2 + 144))(a2, &v151, &v148);
  (*(*a2 + 144))(a2, &v148, &v145);
  (*(*a2 + 144))(a2, &v145, &v142);
  (*(*a2 + 144))(a2, &v142, &v151);
  (*(*a2 + 144))(a2, &v151, &v186);
  (*(*a2 + 144))(a2, &v148, &v185);
  (*(*a2 + 144))(a2, &v145, &v184);
  (*(*a2 + 144))(a2, &v142, &v183);
  v50 = Colour::Colour(&v59, 255, 0, 0, 0x10u);
  (*(*a2 + 160))(a2, v50, 1);
  sub_1000291E(&v130, 12, 4, Vector3f::Vector3f);
  sub_1000291E(&v126, 8, 4, Vector2f::Vector2f);
  Vector2f::set(&v126, 0.0, 0.0);
  Vector2f::set(&v127, 0.0, 0.0);
  Vector2f::set(&v128, 0.0, 0.0);
  Vector2f::set(&v129, 0.0, 0.0);
  v130 = v167;
  v131 = v168;
  v132 = v169;
  v133 = v170;
  v134 = v171;
  v135 = v172;
  v136 = v151;
  v137 = v152;
  v138 = v153;
  v139 = v148;
  v140 = v149;
  v141 = v150;
  (*(*a2 + 152))(a2, &v130, 0, &v126, 4);
  v51 = Colour::Colour(&v58, 255, 0, 32, 0x10u);
  (*(*a2 + 160))(a2, v51, 1);
  v130 = v164;
  v131 = v165;
  v132 = v166;
  v133 = v167;
  v134 = v168;
  v135 = v169;
  v136 = v148;
  v137 = v149;
  v138 = v150;
  v139 = v145;
  v140 = v146;
  v141 = v147;
  (*(*a2 + 152))(a2, &v130, 0, &v126, 4);
  v52 = Colour::Colour(&v57, 255, 0, 0, 0x10u);
  (*(*a2 + 160))(a2, v52, 1);
  v130 = v161;
  v131 = v162;
  v132 = v163;
  v133 = v164;
  v134 = v165;
  v135 = v166;
  v136 = v145;
  v137 = v146;
  v138 = v147;
  v139 = v142;
  v140 = v143;
  v141 = v144;
  (*(*a2 + 152))(a2, &v130, 0, &v126, 4);
  v53 = Colour::Colour(&v56, 255, 0, 32, 0x10u);
  (*(*a2 + 160))(a2, v53, 1);
  v130 = v170;
  v131 = v171;
  v132 = v172;
  v133 = v161;
  v134 = v162;
  v135 = v163;
  v136 = v142;
  v137 = v143;
  v138 = v144;
  v139 = v151;
  v140 = v152;
  v141 = v153;
  (*(*a2 + 152))(a2, &v130, 0, &v126, 4);
  LOBYTE(v54) = v196;
  (*(*a2 + 40))(a2, v54, 0);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100500B0) --------------------------------------------------------
void __userpurge CullFrustum::updateViewPlanes(CullFrustum *this@<ecx>, double a2@<st0>, float a3, float a4, float a5, float a6)
{
  double v6; // st7
  float v7; // ST58_4
  double v8; // st7
  float v9; // ST54_4
  double v10; // st7
  float v11; // [esp+54h] [ebp-14h]
  float v12; // [esp+58h] [ebp-10h]
  int v13; // [esp+5Ch] [ebp-Ch]
  CullingPlane *v14; // [esp+60h] [ebp-8h]
  CullFrustum *v15; // [esp+64h] [ebp-4h]

  v15 = this;
  v14 = (this + 44 * *(this + 2) + 12);
  Vector3f::Vector3f(&v11);
  sub_10001136(a3);
  v11 = *(v15 + 119) / a2;
  v12 = 0.0;
  v13 = *(v15 + 118);
  Vector3f::normalise(&v11);
  CullFrustum::vectorToWorldPlane(v15, &v11, v14);
  CullingPlane::CheckMinMaxDir(v14);
  *(v14 + 40) = 1;
  v14 = (v14 + 44);
  v6 = -*(v15 + 119);
  v7 = v6;
  sub_10001136(a4);
  v11 = v7 / v6;
  v12 = 0.0;
  v13 = *(v15 + 118);
  Vector3f::normalise(&v11);
  CullFrustum::vectorToWorldPlane(v15, &v11, v14);
  CullingPlane::CheckMinMaxDir(v14);
  *(v14 + 40) = 1;
  v14 = (v14 + 44);
  v11 = 0.0;
  v8 = -*(v15 + 119);
  v9 = v8;
  sub_10001136(a5);
  v12 = v8 * v9;
  v13 = *(v15 + 118);
  v10 = Vector3f::normalise(&v11);
  CullFrustum::vectorToWorldPlane(v15, &v11, v14);
  CullingPlane::CheckMinMaxDir(v14);
  *(v14 + 40) = 1;
  v14 = (v14 + 44);
  v11 = 0.0;
  sub_10001136(a6);
  v12 = v10 * *(v15 + 119);
  v13 = *(v15 + 118);
  Vector3f::normalise(&v11);
  CullFrustum::vectorToWorldPlane(v15, &v11, v14);
  CullingPlane::CheckMinMaxDir(v14);
  *(v14 + 40) = 1;
  *v15 = ((v14 + 44) - (v15 + 12)) / 44;
}

//----- (10050320) --------------------------------------------------------
void __thiscall CullFrustum::createViewPlanes(CullFrustum *this)
{
  double v1; // st7
  float v2; // ST0C_4
  double v3; // st7
  float v4; // ST0C_4
  struct CullingPlane *v5; // ST0C_4
  struct Vector3f *v6; // eax
  struct CullingPlane *v7; // ST0C_4
  struct Vector3f *v8; // eax
  float v9; // [esp+50h] [ebp-44h]
  float v10; // [esp+54h] [ebp-40h]
  float v11; // [esp+58h] [ebp-3Ch]
  char v12; // [esp+5Ch] [ebp-38h]
  float v13; // [esp+68h] [ebp-2Ch]
  float v14; // [esp+6Ch] [ebp-28h]
  float v15; // [esp+70h] [ebp-24h]
  char v16; // [esp+74h] [ebp-20h]
  char v17; // [esp+80h] [ebp-14h]
  CullingPlane *v18; // [esp+8Ch] [ebp-8h]
  CullFrustum *v19; // [esp+90h] [ebp-4h]

  v19 = this;
  v18 = (this + 12);
  Vector3f::Vector3f(&v17);
  *v19 = 0;
  v1 = *(v19 + 115) * 0.5 * 3.1415927 / 180.0;
  v2 = v1;
  sub_10002635(v2);
  *(v19 + 118) = v1;
  v3 = *(v19 + 115) * 0.5 * 3.1415927 / 180.0;
  v4 = v3;
  sub_10002D47(v4);
  *(v19 + 119) = v3;
  v15 = 1.0;
  v14 = 0.0;
  v13 = 0.0;
  v5 = v18;
  v6 = Vector3f::Vector3f(&v16, &v13, &v14, &v15);
  CullFrustum::vectorToWorldPlane(v19, v6, v5);
  *(v18 + 3) = *(v18 + 3) + *(v19 + 116);
  CullingPlane::CheckMinMaxDir(v18);
  *(v18 + 40) = 1;
  v18 = (v18 + 44);
  v11 = -1.0;
  v10 = 0.0;
  v9 = 0.0;
  v7 = v18;
  v8 = Vector3f::Vector3f(&v12, &v9, &v10, &v11);
  CullFrustum::vectorToWorldPlane(v19, v8, v7);
  *(v18 + 3) = *(v18 + 3) - 2600.0;
  CullingPlane::CheckMinMaxDir(v18);
  *(v18 + 40) = 1;
  *(v19 + 2) = ((v18 + 44) - (v19 + 12)) / 44;
}

//----- (10050510) --------------------------------------------------------
void __thiscall CullFrustum::additionalPlanes(CullFrustum *this, struct CullFrustum *a2)
{
  int k; // [esp+4Ch] [ebp-10h]
  int j; // [esp+50h] [ebp-Ch]
  int i; // [esp+54h] [ebp-8h]

  if ( a2 )
  {
    for ( i = 0; i < *a2; ++i )
      *(this + i + 69) = *(a2 + i + 69);
    for ( j = 0; j < *this; ++j )
      *(this + *a2 + j + 69) = this + 44 * j + 12;
    *(this + 1) = *a2 + *this;
  }
  else
  {
    *(this + 1) = *this;
    for ( k = 0; k < *this; ++k )
      *(this + k + 69) = this + 44 * k + 12;
  }
}

//----- (10050650) --------------------------------------------------------
void __thiscall CullFrustum::createVecs(CullFrustum *this)
{
  CullFrustum *v1; // ST50_4

  v1 = this;
  *(this + 95) = *(this + 120);
  *(v1 + 96) = *(v1 + 124);
  *(v1 + 97) = -*(v1 + 128);
  *(v1 + 98) = *(v1 + 121);
  *(v1 + 99) = *(v1 + 125);
  *(v1 + 100) = -*(v1 + 129);
  *(v1 + 101) = *(v1 + 122);
  *(this + 102) = *(this + 126);
  *(this + 103) = -*(this + 130);
}

//----- (10050750) --------------------------------------------------------
void __thiscall CullFrustum::createInvVecs(CullFrustum *this)
{
  CullFrustum *v1; // ST50_4

  v1 = this;
  *(this + 104) = *(this + 120);
  *(v1 + 105) = *(v1 + 121);
  *(v1 + 106) = *(v1 + 122);
  *(v1 + 107) = *(v1 + 124);
  *(v1 + 108) = *(v1 + 125);
  *(v1 + 109) = *(v1 + 126);
  *(v1 + 110) = -*(v1 + 128);
  *(v1 + 111) = -*(v1 + 129);
  *(this + 112) = -*(this + 130);
}

//----- (10050850) --------------------------------------------------------
void __thiscall CullFrustum::update(CullFrustum *this, float a2, float a3, float a4, float a5)
{
  float v5; // ST08_4
  float v6; // ST04_4
  float v7; // [esp+58h] [ebp-14h]
  float v8; // [esp+5Ch] [ebp-10h]
  float v9; // [esp+60h] [ebp-Ch]
  int i; // [esp+64h] [ebp-8h]
  CullFrustum *v11; // [esp+68h] [ebp-4h]

  v11 = this;
  *(this + 113) = a2;
  *(v11 + 114) = 1065353216;
  *(v11 + 115) = a3;
  *(v11 + 116) = a4;
  *(v11 + 117) = a5;
  CullFrustum::createVecs(v11);
  CullFrustum::createInvVecs(v11);
  CullFrustum::createViewPlanes(v11);
  v5 = -*(v11 + 114);
  v6 = -*(v11 + 113);
  CullFrustum::updateViewPlanes(v11, *(v11 + 113), v6, v5, *(v11 + 114));
  for ( i = 0; i < *v11; ++i )
    *(v11 + i + 69) = v11 + 44 * i + 12;
  *(v11 + 1) = *v11;
  v9 = 0.0;
  v8 = 0.0;
  v7 = 0.0;
  Vector3f::set((v11 + 344), &v7, &v8, &v9);
}

//----- (100509D0) --------------------------------------------------------
void __thiscall CullFrustum::calcVectors(CullFrustum *this, struct Vector3f *a2, struct Vector3f *a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  char *v5; // eax
  _DWORD *v6; // ecx
  float v7; // [esp+4Ch] [ebp-Ch]
  float v8; // [esp+50h] [ebp-8h]
  CullFrustum *v9; // [esp+54h] [ebp-4h]

  v9 = this;
  v3 = (this + 356);
  *v3 = *a2;
  v3[1] = *(a2 + 1);
  v3[2] = *(a2 + 2);
  v4 = (v9 + 368);
  *v4 = *a3;
  v4[1] = *(a3 + 1);
  v4[2] = *(a3 + 2);
  if ( *(v9 + 89) == *(v9 + 92) && *(v9 + 91) == *(v9 + 94) )
    *(v9 + 94) = *(v9 + 94) + 0.000099999997;
  *(v9 + 101) = *(v9 + 89) - *(v9 + 92);
  *(v9 + 102) = *(v9 + 90) - *(v9 + 93);
  *(v9 + 103) = *(v9 + 91) - *(v9 + 94);
  Vector3f::normalise((v9 + 404));
  v8 = -*(v9 + 101);
  v7 = 0.0;
  Vector3f::set((v9 + 380), v9 + 103, &v7, &v8);
  Vector3f::normalise((v9 + 380));
  v5 = v9 + 404;
  v6 = (v9 + 392);
  *v6 = *(v9 + 101);
  v6[1] = *(v5 + 1);
  v6[2] = *(v5 + 2);
  Vector3f::CP((v9 + 392), (v9 + 380));
  Vector3f::normalise((v9 + 392));
  Matrix4f::makeLookat((v9 + 480), (v9 + 356), (v9 + 380), (v9 + 392), (v9 + 404));
  Matrix4f::inverse((v9 + 480), (v9 + 544));
  CullFrustum::update(v9, 1.0, *(v9 + 115), *(v9 + 116), *(v9 + 117));
}

//----- (10050C70) --------------------------------------------------------
void __thiscall CullFrustum::calcLookAt(CullFrustum *this, struct Vector3f *a2, struct Vector3f *a3, struct Vector3f *a4)
{
  CullFrustum *v4; // ST58_4

  v4 = this;
  Matrix4f::makeLookat((this + 480), a2, a3, a4);
  Matrix4f::inverse((v4 + 480), (v4 + 544));
}

//----- (10050CF0) --------------------------------------------------------
void __thiscall CullFrustum::calcLookFrom(CullFrustum *this, struct Vector3f *a2, struct Vector3f *a3)
{
  CullFrustum *v3; // ST54_4

  v3 = this;
  Matrix4f::makeLookfrom((this + 480), a2, a3);
  Matrix4f::inverse((v3 + 480), (v3 + 544));
}

//----- (10050D70) --------------------------------------------------------
void __thiscall Camera::camReflect(Camera *this, struct Camera *a2, struct Plane *a3)
{
  float v3; // ST0C_4
  _DWORD *v4; // eax
  CullingPlane *v5; // edx
  char v6; // [esp+50h] [ebp-24h]
  CullingPlane *v7; // [esp+5Ch] [ebp-18h]
  char v8; // [esp+60h] [ebp-14h]
  float v9; // [esp+6Ch] [ebp-8h]
  float *v10; // [esp+70h] [ebp-4h]

  v10 = this;
  qmemcpy(a2, this, 0x348u);
  *(a2 + 110) = *(a2 + 110) * -1.0;
  *(a2 + 111) = *(a2 + 111) * -1.0;
  *(a2 + 112) = *(a2 + 112) * -1.0;
  Plane::reflect(a3, (a2 + 356));
  Plane::reflectVector(a3, (a2 + 416));
  Plane::reflectVector(a3, (a2 + 428));
  Plane::reflectVector(a3, (a2 + 440));
  Matrix4f::makeLookat((a2 + 480), (a2 + 356), (a2 + 416), (a2 + 428), (a2 + 440));
  Matrix4f::inverse((a2 + 480), (a2 + 544));
  CullFrustum::update(a2, v10[113], v10[115], v10[116], v10[117]);
  v9 = Plane::dist(a3, (v10 + 89));
  Vector3f::Vector3f(&v8, a3);
  v3 = -v9;
  Vector3f::multiply(&v8, v3);
  Vector3f::add(&v8, (v10 + 89));
  v7 = (a2 + 12);
  v4 = sub_100021A8(&v6, a3);
  v5 = v7;
  *v7 = *v4;
  *(v5 + 1) = v4[1];
  *(v5 + 2) = v4[2];
  *(v7 + 3) = -*(a3 + 3);
  CullingPlane::CheckMinMaxDir(v7);
  *(v7 + 40) = 1;
}

//----- (10050FC0) --------------------------------------------------------
double __thiscall Camera::projectWorldPoint(Camera *this, struct Graphics *a2, struct Vector3f *a3)
{
  float v4; // ST50_4
  float v5; // [esp+50h] [ebp-8h]

  v5 = *(this + 180) * *a3 + *(this + 181) * *(a3 + 1) + *(this + 182) * *(a3 + 2) + *(this + 183);
  if ( v5 <= 0.0 )
    return v5;
  Vector3f::multMatrix(a3, (this + 672));
  v4 = 1.0 / v5;
  *a3 = v4 * *a3;
  *(a3 + 1) = v4 * *(a3 + 1);
  *(a3 + 2) = v4 * *(a3 + 2);
  *a3 = *(a2 + 196) / 2.0 * *a3;
  *(a3 + 1) = -(*(a2 + 197) / 2.0) * *(a3 + 1);
  *a3 = *(a2 + 196) / 2.0 + *a3;
  *(a3 + 1) = *(a2 + 197) / 2.0 + *(a3 + 1);
  return *(a3 + 2);
}

//----- (10051150) --------------------------------------------------------
double __thiscall Camera::projectCamPoint(Camera *this, struct Vector3f *a2)
{
  float v3; // ST50_4
  float v4; // [esp+50h] [ebp-8h]

  v4 = *(this + 164) * *a2 + *(this + 165) * *(a2 + 1) + *(this + 166) * *(a2 + 2) + *(this + 167);
  if ( v4 > 0.0 )
  {
    Vector3f::multMatrix(a2, (this + 608));
    v3 = 1.0 / v4;
    *a2 = v3 * *a2;
    *(a2 + 1) = v3 * *(a2 + 1);
    *(a2 + 2) = v3 * *(a2 + 2);
    *a2 = glnWidth / 2.0 * *a2;
    *(a2 + 1) = -(glnHeight / 2.0) * *(a2 + 1);
    *a2 = glnWidth / 2.0 + *a2;
    *(a2 + 1) = glnHeight / 2.0 + *(a2 + 1);
  }
  return v4;
}

//----- (100512D0) --------------------------------------------------------
CullFrustum *__thiscall Camera::Camera(Camera *this)
{
  float v2; // [esp+4Ch] [ebp-1Ch]
  float v3; // [esp+50h] [ebp-18h]
  float v4; // [esp+54h] [ebp-14h]
  float v5; // [esp+58h] [ebp-10h]
  float v6; // [esp+5Ch] [ebp-Ch]
  float v7; // [esp+60h] [ebp-8h]
  CullFrustum *v8; // [esp+64h] [ebp-4h]

  v8 = this;
  CullFrustum::CullFrustum(this);
  Matrix4f::Matrix4f((v8 + 608));
  Matrix4f::Matrix4f((v8 + 672));
  Matrix4f::Matrix4f((v8 + 736));
  Vector3f::Vector3f((v8 + 800));
  Vector3f::Vector3f((v8 + 812));
  Vector3f::Vector3f((v8 + 824));
  v7 = 0.0;
  v6 = 4.3633232;
  v5 = 0.0;
  Vector3f::set((v8 + 800), &v5, &v6, &v7);
  v4 = 0.0;
  v3 = 0.0;
  v2 = 0.0;
  Vector3f::set((v8 + 812), &v2, &v3, &v4);
  *(v8 + 113) = 1065353216;
  *(v8 + 209) = 1121714176;
  return v8;
}

//----- (10051420) --------------------------------------------------------
void __thiscall LightCamera::initLightmap(LightCamera *this, int a2, int a3)
{
  int v3; // [esp+4Ch] [ebp-1Ch]
  Texture *hMem; // [esp+50h] [ebp-18h]
  LightCamera *v5; // [esp+58h] [ebp-10h]

  v5 = this;
  hMem = sub_10002A81(0x34u);
  if ( hMem )
    v3 = Texture::Texture(hMem);
  else
    v3 = 0;
  *(v5 + 214) = v3;
  *(*(v5 + 214) + 28) = 1.0 / a2;
  *(*(v5 + 214) + 32) = 1.0 / a2;
  *(*(v5 + 214) + 6) = 261;
  Texture::createBuffer(*(v5 + 214), a2, a2, a3, 0);
  StdSystem::addTexture(gsys, *(v5 + 214), "internalLightmap");
}

//----- (10051570) --------------------------------------------------------
void __thiscall LightCamera::calcProjection(LightCamera *this, struct Graphics *a2, bool a3, struct Node *a4)
{
  double v4; // st7
  float v5; // ST14_4
  double v6; // st7
  float v7; // ST14_4
  double v8; // st7
  const struct Vector3f *v9; // eax
  double v10; // st7
  double v11; // st7
  int v12; // eax
  int v13; // eax
  int v14; // [esp+4h] [ebp-D0h]
  int v15; // [esp+50h] [ebp-84h]
  int v16; // [esp+54h] [ebp-80h]
  float v17; // [esp+58h] [ebp-7Ch]
  char v18; // [esp+5Ch] [ebp-78h]
  char v19; // [esp+6Ch] [ebp-68h]
  char v20; // [esp+70h] [ebp-64h]
  float v21; // [esp+80h] [ebp-54h]
  float v22; // [esp+84h] [ebp-50h]
  float v23; // [esp+88h] [ebp-4Ch]
  char v24; // [esp+8Ch] [ebp-48h]
  float v25; // [esp+98h] [ebp-3Ch]
  float v26; // [esp+9Ch] [ebp-38h]
  float v27; // [esp+A0h] [ebp-34h]
  int v28; // [esp+A4h] [ebp-30h]
  float v29; // [esp+A8h] [ebp-2Ch]
  float v30; // [esp+ACh] [ebp-28h]
  char v31; // [esp+B0h] [ebp-24h]
  float v32; // [esp+BCh] [ebp-18h]
  float v33; // [esp+C0h] [ebp-14h]
  float v34; // [esp+C8h] [ebp-Ch]
  float v35; // [esp+CCh] [ebp-8h]
  LightCamera *v36; // [esp+D0h] [ebp-4h]

  v36 = this;
  v35 = Vector3f::distance((this + 356), (this + 368));
  v4 = *(v36 + 115) * 3.1415927 / 180.0;
  v5 = v4;
  sub_10002635(v5);
  v17 = v4;
  v6 = *(v36 + 115) * 3.1415927 / 180.0;
  v7 = v6;
  sub_10002D47(v7);
  v8 = v17 / v6;
  v34 = v8;
  *(v36 + 213) = v8 * v35;
  *(v36 + 212) = *(v36 + 213);
  v27 = 1.0;
  v26 = *(v36 + 213) * (1.0 / v34);
  v25 = *(v36 + 212) * (1.0 / v34);
  Vector3f::Vector3f(&v32, &v25, &v26, &v27);
  v9 = sub_10002E2D(&v24, v36 + 356, v36 + 368);
  Vector3f::Vector3f(&v31, v9);
  v10 = Vector3f::length(&v31);
  *(v36 + 210) = v10 / v32;
  v11 = Vector3f::length(&v31);
  *(v36 + 211) = v11 / v33;
  v23 = 1.0;
  v22 = 0.5 * *(v36 + 211);
  v21 = 0.5 * *(v36 + 210);
  Vector3f::set((v36 + 860), &v21, &v22, &v23);
  if ( *(v36 + 214) )
  {
    if ( a4 )
    {
      v16 = *(*(v36 + 214) + 8);
      v30 = v16;
      v15 = *(*(v36 + 214) + 10);
      v29 = v15;
      (*(*a2 + 52))(a2, v36 + 608, *(v36 + 115), *(v36 + 113), 1065353216, *(v36 + 117), *(v36 + 210));
      v12 = RectArea::RectArea(&v20, 0, 0, *(*(v36 + 214) + 8), *(*(v36 + 214) + 10));
      (*(*a2 + 64))(a2, v12);
      v28 = *(a2 + 186);
      v13 = Colour::Colour(&v19, 0, 0, 0, 0);
      (*(*a2 + 172))(a2, v13);
      (*(*a2 + 48))(a2, 3, 0);
      v14 = RectArea::RectArea(&v18, 1, 1, v30 - 1, v14);
      (*(*a2 + 72))(a2, v14);
      (*(*a2 + 180))(a2, 0);
      (*(*a2 + 40))(a2, 0, 0);
      (*(*a2 + 100))(a2, v36);
      (*(*a2 + 196))(a2, 0, 0);
      (*(a4->pVtbl + 24))(a4, a2);
      Texture::grabBuffer(*(v36 + 214), *(*(v36 + 214) + 8), *(*(v36 + 214) + 10), 1, 1);
      (*(*a2 + 100))(a2, v28);
    }
  }
}

//----- (10051A30) --------------------------------------------------------
void __thiscall LightCamera::genAge(LightCamera *this, struct AgeServer *a2)
{
  LightCamera *v2; // ST60_4

  v2 = this;
  AgeServer::StartGroup(a2, "LightCam");
  AgeServer::NewEditor(a2, "vFOV", v2 + 115, 1.0, 90.0, 320);
  AgeServer::EndGroup(a2);
}

//----- (10051AC0) --------------------------------------------------------
Vector3f *__cdecl sub_10051AC0(Vector3f *a1, int a2)
{
  const struct Vector3f *v2; // eax
  float v4; // [esp+4Ch] [ebp-18h]
  float v5; // [esp+50h] [ebp-14h]
  float v6; // [esp+54h] [ebp-10h]
  char v7; // [esp+58h] [ebp-Ch]

  v6 = -*(a2 + 8);
  v5 = -*(a2 + 4);
  v4 = -*a2;
  v2 = Vector3f::Vector3f(&v7, &v4, &v5, &v6);
  Vector3f::Vector3f(a1, v2);
  return a1;
}

//----- (10051B50) --------------------------------------------------------
void __thiscall CmdStream::init(CmdStream *this, struct Stream *a2)
{
  int v2; // eax
  void *v3; // [esp+4Ch] [ebp-8h]
  CmdStream *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  *(this + 1) = 0;
  if ( !CmdStream::statbuff )
  {
    v3 = sub_10001AC3(0x8000u);
    CmdStream::statbuff = v3;
  }
  memset(CmdStream::statbuff, 0, 0x8000u);
  *v4 = a2;
  v2 = (*(**v4 + 60))(*v4);
  *(v4 + 66) = v2;
  *(v4 + 69) = 0;
  *(v4 + 67) = 0;
  *(v4 + 68) = 0;
  *(v4 + 1) = CmdStream::statbuff;
  CmdStream::fillBuffer(v4, 1);
}

//----- (10051C60) --------------------------------------------------------
CmdStream *__thiscall CmdStream::CmdStream(CmdStream *this)
{
  return this;
}

//----- (10051C90) --------------------------------------------------------
CmdStream *__thiscall CmdStream::CmdStream(CmdStream *this, struct Stream *a2)
{
  CmdStream *v2; // ST50_4

  v2 = this;
  CmdStream::init(this, a2);
  return v2;
}

//----- (10051CE0) --------------------------------------------------------
void __thiscall CmdStream::fillBuffer(CmdStream *this, bool a2)
{
  int v2; // [esp+4Ch] [ebp-8h]
  CmdStream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  if ( a2 || *(v3 + 69) - *(v3 + 68) >= 0x4000 )
  {
    if ( *(v3 + 67) )
    {
      memcpy((*(v3 + 68) + *(v3 + 1)), (*(v3 + 1) + *(v3 + 68) + 0x4000), 0x4000u);
      *(v3 + 1) -= 0x4000;
      *(v3 + 68) += 0x4000;
    }
    v2 = *(v3 + 67) != 0 ? 0x4000 : 0x8000;
    if ( *(v3 + 66) - *(v3 + 67) < v2 )
      v2 = *(v3 + 66) - *(v3 + 67);
    (*(**v3 + 52))(*v3, *(v3 + 67) + *(v3 + 1), v2);
    *(v3 + 67) += v2;
  }
}

//----- (10051E80) --------------------------------------------------------
bool __stdcall CmdStream::whiteSpace(char a2)
{
  return !a2 || a2 == 10 || a2 == 13 || a2 == 9 || a2 == 32 || a2 == 44;
}

//----- (10051F00) --------------------------------------------------------
bool __thiscall CmdStream::endOfCmds(CmdStream *this)
{
  bool result; // al
  CmdStream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  CmdStream::fillBuffer(this, 0);
  while ( *(v2 + 69) < *(v2 + 66) && CmdStream::whiteSpace(v2, *(*(v2 + 1) + *(v2 + 69))) )
    ++*(v2 + 69);
  if ( *(v2 + 69) >= *(v2 + 66) )
    result = 1;
  else
    result = *(*(v2 + 1) + *(v2 + 69)) == -1;
  return result;
}

//----- (10051FF0) --------------------------------------------------------
bool __thiscall CmdStream::LineIsComment(CmdStream *this)
{
  return *(*(this + 1) + *(this + 69)) == 35
      || *(*(this + 1) + *(this + 69)) == 47 && *(*(this + 1) + *(this + 69) + 1) == 47;
}

//----- (10052080) --------------------------------------------------------
void __thiscall CmdStream::copyToToken(CmdStream *this, int a2)
{
  char v2; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]

  for ( i = 0; i < a2; ++i )
  {
    v2 = *(*(this + 1) + i + *(this + 69));
    if ( v2 == 9 )
      v2 = 32;
    *(this + i + 8) = v2;
  }
  *(this + i + 8) = 0;
}

//----- (10052120) --------------------------------------------------------
char *__thiscall CmdStream::skipLine(CmdStream *this)
{
  int i; // [esp+4Ch] [ebp-8h]
  CmdStream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  CmdStream::fillBuffer(this, 0);
  for ( i = *(v3 + 69); i < *(v3 + 66) && *(*(v3 + 1) + i) != 10 && *(*(v3 + 1) + i) != 13; ++i )
    ;
  CmdStream::copyToToken(v3, i - *(v3 + 69));
  while ( *(*(v3 + 1) + i) == 10 || *(*(v3 + 1) + i) == 13 )
    ++i;
  *(v3 + 69) = i;
  return v3 + 8;
}

//----- (10052230) --------------------------------------------------------
char *__thiscall CmdStream::getToken(CmdStream *this, bool a2)
{
  BOOL v3; // [esp+4Ch] [ebp-14h]
  signed int v4; // [esp+50h] [ebp-10h]
  char v5; // [esp+54h] [ebp-Ch]
  int v6; // [esp+58h] [ebp-8h]
  CmdStream *v7; // [esp+5Ch] [ebp-4h]

  v7 = this;
  CmdStream::fillBuffer(this, 0);
  if ( a2 )
  {
    while ( CmdStream::LineIsComment(v7) )
      CmdStream::skipLine(v7);
  }
  v6 = *(v7 + 69);
  v5 = 0;
  if ( *(*(v7 + 1) + v6) == 34 || *(*(v7 + 1) + v6) == 39 )
  {
    v5 = 1;
    ++v6;
    ++*(v7 + 69);
  }
  while ( 1 )
  {
    if ( v5 )
    {
      v4 = *(*(v7 + 1) + v6) == 34 || *(*(v7 + 1) + v6) == 39 ? 0 : 1;
      v3 = v4;
    }
    else
    {
      v3 = CmdStream::whiteSpace(v7, *(*(v7 + 1) + v6)) == 0;
    }
    if ( !v3 )
      break;
    ++v6;
  }
  CmdStream::copyToToken(v7, v6 - *(v7 + 69));
  if ( v5 )
    *(v7 + v6++ - *(v7 + 69) + 8) = 0;
  while ( v6 < *(v7 + 66) && CmdStream::whiteSpace(v7, *(*(v7 + 1) + v6)) )
    ++v6;
  *(v7 + 69) = v6;
  return v7 + 8;
}

//----- (10052460) --------------------------------------------------------
char __thiscall CmdStream::nextChar(CmdStream *this)
{
  return *(*(this + 1) + *(this + 69));
}

//----- (100524B0) --------------------------------------------------------
char __thiscall CmdStream::isToken(CmdStream *this, char *Str)
{
  size_t v2; // esi
  signed int i; // [esp+4Ch] [ebp-8h]
  CmdStream *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  if ( !strlen(this + 8) )
    return 0;
  v2 = strlen(v5 + 8);
  if ( v2 != strlen(Str) )
    return 0;
  for ( i = 0; i < strlen(v5 + 8); ++i )
  {
    if ( Str[i] != *(v5 + i + 8) )
      return 0;
  }
  return 1;
}

//----- (10052590) --------------------------------------------------------
bool __thiscall CmdStream::endOfSection(CmdStream *this)
{
  CmdStream *v1; // ST50_4

  v1 = this;
  CmdStream::fillBuffer(this, 0);
  return *(*(v1 + 1) + *(v1 + 69)) == 125;
}

//----- (10052600) --------------------------------------------------------
void __thiscall Controller::reset(Controller *this, unsigned __int32 a2)
{
  this->dword3C = -1;
  this->byte44 = 0;
  this->dword38 = a2;
  this->dword40 = 0;
  this->dword20 = 0;
  this->dword24 = 0;
}

//----- (10052680) --------------------------------------------------------
void __thiscall Controller::updateCont(Controller *this, unsigned __int32 a2)
{
  this->dword24 = this->dword20;
  this->dword20 = 0;
  if ( !this->byte44 )
    this->dword20 = a2;
  this->dword28 = ~this->dword24 & this->dword20;
  this->dword2C = this->dword24 & ~this->dword20;
  if ( this->dword40 )
  {
    if ( --this->dword40 )
    {
      this->dword30 = this->dword28 & this->dword34;
      if ( this->dword30 )
        this->dword40 = 0;
    }
  }
  else
  {
    this->dword30 = 0;
    this->dword34 = this->dword28;
    if ( this->dword34 )
      this->dword40 = 10;
  }
}

//----- (100527B0) --------------------------------------------------------
void __thiscall Controller::update(Controller *this)
{
  ControllerMgr::updateController((gsys + 692), this);
}

//----- (10052810) --------------------------------------------------------
double __thiscall Controller::getMainStickX(Controller *this)
{
  return this->byte45 / 74.0;
}

//----- (10052860) --------------------------------------------------------
double __thiscall Controller::getMainStickY(Controller *this)
{
  return this->byte46 / 74.0;
}

//----- (100528B0) --------------------------------------------------------
double __thiscall Controller::getSubStickX(Controller *this)
{
  return this->byte47 / 74.0;
}

//----- (10052900) --------------------------------------------------------
double __thiscall Controller::getSubStickY(Controller *this)
{
  return this->byte48 / 74.0;
}

//----- (10052950) --------------------------------------------------------
Controller *__thiscall Controller::Controller(Controller *this, unsigned __int32 a2)
{
  Controller *v2; // ST50_4

  v2 = this;
  Node::Node(this, "<Controller>");
  v2->module0.newObjAddr = &Controller::`vftable';
  Controller::initialise(v2, a2);
  return v2;
}
// 101AF52C: using guessed type void *Controller::`vftable';

//----- (100529C0) --------------------------------------------------------
void __thiscall Controller::initialise(Controller *this, unsigned __int32 a2)
{
  Controller::reset(this, a2);
}

//----- (10052A10) --------------------------------------------------------
BOOL __thiscall Controller::keyDown(Controller *this, unsigned __int32 a2)
{
  return (a2 & this->dword20) != 0;
}

//----- (10052A60) --------------------------------------------------------
BOOL __thiscall Controller::keyUp(Controller *this, unsigned __int32 a2)
{
  return (a2 & this->dword20) == 0;
}

//----- (10052AB0) --------------------------------------------------------
BOOL __thiscall Controller::keyClick(Controller *this, unsigned __int32 a2)
{
  return (a2 & this->dword28) != 0;
}

//----- (10052B00) --------------------------------------------------------
BOOL __thiscall Controller::keyDoubleClick(Controller *this, unsigned __int32 a2)
{
  return (a2 & this->dword30) != 0;
}

//----- (10052B50) --------------------------------------------------------
BOOL __thiscall Controller::keyUnClick(Controller *this, unsigned __int32 a2)
{
  return (a2 & this->dword2C) != 0;
}

//----- (10052BA0) --------------------------------------------------------
Controller *__thiscall Controller::Controller(Controller *this, const struct Controller *a2)
{
  Controller *v2; // ST50_4

  v2 = this;
  Node::Node(this, a2);
  v2->dword20 = a2->dword20;
  v2->dword24 = a2->dword24;
  v2->dword28 = a2->dword28;
  v2->dword2C = a2->dword2C;
  v2->dword30 = a2->dword30;
  v2->dword34 = a2->dword34;
  v2->dword38 = a2->dword38;
  v2->dword3C = a2->dword3C;
  v2->dword40 = a2->dword40;
  v2->byte44 = a2->byte44;
  v2->byte45 = a2->byte45;
  v2->byte46 = a2->byte46;
  v2->byte47 = a2->byte47;
  v2->byte48 = a2->byte48;
  v2->byte49 = a2->byte49;
  v2->byte4A = a2->byte4A;
  v2->byte4B = a2->byte4B;
  v2->byte4C = a2->byte4C;
  v2->module0.newObjAddr = &Controller::`vftable';
  return v2;
}
// 101AF52C: using guessed type void *Controller::`vftable';

//----- (10052D10) --------------------------------------------------------
Controller *__thiscall Controller::operator=(Module *this, int a2)
{
  Controller *v2; // ST50_4

  v2 = this;
  Node::operator=(a2);
  v2->dword20 = *(a2 + 32);
  v2->dword24 = *(a2 + 36);
  v2->dword28 = *(a2 + 40);
  v2->dword2C = *(a2 + 44);
  v2->dword30 = *(a2 + 48);
  v2->dword34 = *(a2 + 52);
  v2->dword38 = *(a2 + 56);
  v2->dword3C = *(a2 + 60);
  v2->dword40 = *(a2 + 64);
  v2->byte44 = *(a2 + 68);
  v2->byte45 = *(a2 + 69);
  v2->byte46 = *(a2 + 70);
  v2->byte47 = *(a2 + 71);
  v2->byte48 = *(a2 + 72);
  v2->byte49 = *(a2 + 73);
  v2->byte4A = *(a2 + 74);
  v2->byte4B = *(a2 + 75);
  v2->byte4C = *(a2 + 76);
  return v2;
}
// 1000171C: using guessed type _DWORD __stdcall Node::operator=(_DWORD);

//----- (10052E70) --------------------------------------------------------
void __thiscall Controller::`default constructor closure'(Controller *this)
{
  Controller::Controller(this, 0);
}

//----- (10052EC0) --------------------------------------------------------
ID32 *__thiscall ID32::ID32(ID32 *this)
{
  ID32 *v1; // ST50_4

  v1 = this;
  ID32::setID(this, 0x6E6F6E65u);
  return v1;
}

//----- (10052F10) --------------------------------------------------------
ID32 *__thiscall ID32::ID32(ID32 *this, unsigned __int32 a2)
{
  ID32 *v2; // ST50_4

  v2 = this;
  ID32::setID(this, a2);
  return v2;
}

//----- (10052F60) --------------------------------------------------------
void __thiscall ID32::setID(ID32 *this, unsigned __int32 a2)
{
  *this = a2;
  ID32::updateString(this);
}

//----- (10052FB0) --------------------------------------------------------
char __thiscall ID32::match(ID32 *this, char a2, char a3)
{
  signed int i; // [esp+4Ch] [ebp-10h]

  for ( i = 0; i < 4; ++i )
  {
    if ( *(&a2 + i) != a3 && *(&a2 + i) != *(this + i) )
      return 0;
  }
  return 1;
}

//----- (10053050) --------------------------------------------------------
void __thiscall ID32::updateID(ID32 *this)
{
  signed int i; // [esp+4Ch] [ebp-Ch]

  for ( i = 0; i < 4; ++i )
    *(this + i) = *(this + 3 - i + 4);
}

//----- (100530D0) --------------------------------------------------------
void __thiscall ID32::updateString(ID32 *this)
{
  signed int i; // [esp+4Ch] [ebp-Ch]

  for ( i = 0; i < 4; ++i )
    *(this + i + 4) = *(this + 3 - i);
  *(this + 8) = 0;
}

//----- (10053150) --------------------------------------------------------
void __thiscall ID32::operator=(ID32 *this, unsigned __int32 a2)
{
  ID32::setID(this, a2);
}

//----- (100531A0) --------------------------------------------------------
BOOL __thiscall ID32::operator==(_DWORD *this, int a2)
{
  return *this == a2;
}

//----- (100531E0) --------------------------------------------------------
BOOL __thiscall ID32::operator!=(_DWORD *this, int a2)
{
  return *this != a2;
}

//----- (10053220) --------------------------------------------------------
void __thiscall ID32::write(ID32 *this, struct RandomAccessStream *a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  ID32 *v5; // [esp+4Ch] [ebp-8h]
  ID32 *v6; // [esp+50h] [ebp-4h]

  v6 = this;
  v5 = this;
  (*(*a2 + 32))(a2, *this);
  LOBYTE(v2) = *(v5 + 1);
  (*(*a2 + 32))(a2, v2);
  LOBYTE(v3) = *(v5 + 2);
  (*(*a2 + 32))(a2, v3);
  LOBYTE(v4) = *(v5 + 3);
  (*(*a2 + 32))(a2, v4);
}

//----- (100532F0) --------------------------------------------------------
void __thiscall ID32::ageChangeID(ID32 *this)
{
  ID32::updateID(this);
}

//----- (10053340) --------------------------------------------------------
void __thiscall ID32::genAge(ID32 *this, struct AgeServer *a2, char *a3)
{
  struct IDelegate *v3; // [esp+4Ch] [ebp-1Ch]
  ID32 *v4; // [esp+58h] [ebp-10h]

  v4 = this;
  if ( sub_10002A81(0xCu) )
    v3 = sub_100024BE(v4, ID32::ageChangeID);
  else
    v3 = 0;
  AgeServer::setOnChange(a2, v3);
  AgeServer::NewEditor(a2, a3, v4 + 4, 5);
  AgeServer::setOnChange(a2, 0);
}
// 100024BE: using guessed type _DWORD __stdcall sub_100024BE(_DWORD, _DWORD);

//----- (10053430) --------------------------------------------------------
void __thiscall ID32::read(ID32 *this, struct RandomAccessStream *a2)
{
  char v2; // al
  char v3; // al
  char v4; // al
  char v5; // al
  int i; // [esp+4Ch] [ebp-10h]
  ID32 *v7; // [esp+50h] [ebp-Ch]
  ID32 *v8; // [esp+54h] [ebp-8h]
  ID32 *v9; // [esp+58h] [ebp-4h]

  v9 = this;
  v8 = this;
  v2 = (*(*a2 + 4))(a2);
  *v8 = v2;
  v3 = (*(*a2 + 4))(a2);
  *(v8 + 1) = v3;
  v4 = (*(*a2 + 4))(a2);
  *(v8 + 2) = v4;
  v5 = (*(*a2 + 4))(a2);
  *(v8 + 3) = v5;
  v7 = v9;
  for ( i = 0; i < 4; ++i )
    *(v9 + i + 4) = *(v7 + 3 - i);
  *(v9 + 8) = 0;
}

//----- (10053550) --------------------------------------------------------
void __thiscall ID32::print(ID32 *this)
{
  char v1; // [esp+4Ch] [ebp-Ch]
  char v2; // [esp+4Dh] [ebp-Bh]
  char v3; // [esp+4Eh] [ebp-Ah]
  char v4; // [esp+4Fh] [ebp-9h]
  char v5; // [esp+50h] [ebp-8h]
  ID32 *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  v1 = (*this & 0xFF000000) >> 24;
  v2 = (*this & 0xFF0000u) >> 16;
  v3 = (*this & 0xFF00) >> 8;
  v4 = *this;
  v5 = 0;
  sub_10053600("id (%x) is %s\n", *this);
}

//----- (10053600) --------------------------------------------------------
char *__cdecl sub_10053600(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "id32" )
      Stream::print(sysCon, "%s: ", "id32");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10053710) --------------------------------------------------------
void __thiscall ID32::sprint(ID32 *this, char *a2)
{
  *a2 = (*this & 0xFF000000) >> 24;
  a2[1] = (*this & 0xFF0000u) >> 16;
  a2[2] = (*this & 0xFF00) >> 8;
  a2[3] = *this;
  a2[4] = 0;
}

//----- (100537B0) --------------------------------------------------------
_DWORD *__thiscall sub_100537B0(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ST50_4

  v3 = this;
  sub_10002347(this);
  *v3 = &off_101AF598;
  v3[1] = a2;
  v3[2] = a3;
  return v3;
}
// 10002347: using guessed type int __thiscall sub_10002347(_DWORD);
// 101AF598: using guessed type int (*off_101AF598)();

//----- (10053820) --------------------------------------------------------
int __thiscall sub_10053820(int this)
{
  int v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  return (*(this + 8))(*(this + 4));
}

//----- (10053880) --------------------------------------------------------
_DWORD *__thiscall sub_10053880(_DWORD *this)
{
  *this = &off_101AF59C;
  return this;
}
// 101AF59C: using guessed type void *off_101AF59C;

//----- (100538C0) --------------------------------------------------------
void __thiscall AnmobjInfo::detach(AnmobjInfo *this)
{
  AnmobjInfo *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(**(this + 8) + 28))(*(this + 8));
}

//----- (10053920) --------------------------------------------------------
StdSystem *__thiscall StdSystem::StdSystem(StdSystem *this)
{
  StdSystem *v1; // ST5C_4

  v1 = this;
  sub_1000291E(this + 88, 40, 8, AyuHeap::AyuHeap);
  GfxobjInfo::GfxobjInfo((v1 + 464));
  CoreNode::CoreNode((v1 + 512), "CoreNode");
  CoreNode::CoreNode((v1 + 532), "CoreNode");
  *v1 = &StdSystem::`vftable';
  *(v1 + 5) = 0;
  *(v1 + 2) = 0;
  *(v1 + 3) = 0;
  *(v1 + 4) = 1065353216;
  *(v1 + 12) = 1;
  *(v1 + 103) = 0;
  *(v1 + 117) = v1 + 464;
  *(v1 + 118) = *(v1 + 117);
  *(v1 + 496) = 1;
  *(v1 + 142) = 0;
  StdSystem::initSoftReset(v1);
  StdSystem::setDataRoot(v1, "dataDir/");
  *(v1 + 104) = 0;
  return v1;
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);
// 101AD9D0: using guessed type void *StdSystem::`vftable';

//----- (10053A90) --------------------------------------------------------
void __thiscall StdSystem::onceInit(StdSystem *this)
{
  int v1; // [esp+4Ch] [ebp-10h]
  int v2; // [esp+50h] [ebp-Ch]
  int v3; // [esp+54h] [ebp-8h]
  StdSystem *v4; // [esp+58h] [ebp-4h]

  v4 = this;
  *(this + 16) = 0x2000;
  v3 = *(this + 16);
  v2 = sub_100011A4(v3 << 6, 32);
  if ( v2 )
  {
    sub_1000291E(v2, 64, v3, Matrix4f::Matrix4f);
    v1 = v2;
  }
  else
  {
    v1 = 0;
  }
  *(v4 + 17) = v1;
}
// 100011A4: using guessed type _DWORD __cdecl sub_100011A4(_DWORD, _DWORD);
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10053B40) --------------------------------------------------------
struct AyuHeap *__thiscall StdSystem::getHeap(StdSystem *this, int a2)
{
  return (this + 40 * a2 + 88);
}

//----- (10053B80) --------------------------------------------------------
void __thiscall StdSystem::resetHeap(StdSystem *this, int a2, int a3)
{
  AyuStack::reset((this + 40 * a2 + 88), a3);
}

//----- (10053BE0) --------------------------------------------------------
int __thiscall StdSystem::setHeap(StdSystem *this, int a2)
{
  int v2; // ST50_4

  v2 = *(this + 102);
  *(this + 102) = a2;
  return v2;
}

//----- (10053C40) --------------------------------------------------------
void __thiscall StdSystem::getAppMemory(StdSystem *this, char *Dest)
{
  AyuStack *v2; // eax
  unsigned __int64 v3; // st7
  int v4; // [esp+54h] [ebp-Ch]
  float v5; // [esp+58h] [ebp-8h]
  StdSystem *v6; // [esp+5Ch] [ebp-4h]

  v6 = this;
  v2 = StdSystem::getHeap(this, 2);
  v4 = AyuStack::getFree(v2);
  *&v3 = v4 / 1024.0;
  v5 = *&v3;
  sprintf(Dest, "FreeMem %.2fk", v3, (v3 >> 32));
}

//----- (10053CD0) --------------------------------------------------------
struct GfxobjInfo *__thiscall StdSystem::findGfxObject(StdSystem *this, char *Str2, unsigned __int32 a3)
{
  int i; // [esp+4Ch] [ebp-8h]
  StdSystem *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  for ( i = *(this + 118); i != (v5 + 464); i = *(i + 8) )
  {
    if ( ID32::operator==(a3) && !strcmp(*(i + 12), Str2) )
      return i;
  }
  return 0;
}
// 10001168: using guessed type _DWORD __stdcall ID32::operator==(_DWORD);

//----- (10053D80) --------------------------------------------------------
struct GfxobjInfo *__thiscall StdSystem::findAnyGfxObject(StdSystem *this, char *Str, unsigned __int32 a3)
{
  size_t v3; // eax
  int i; // [esp+4Ch] [ebp-8h]
  StdSystem *v6; // [esp+50h] [ebp-4h]

  v6 = this;
  for ( i = *(this + 118); i != (v6 + 464); i = *(i + 8) )
  {
    if ( ID32::operator==(a3) )
    {
      v3 = strlen(Str);
      if ( !strncmp(*(i + 12), Str, v3) )
        return i;
    }
  }
  return 0;
}
// 10001168: using guessed type _DWORD __stdcall ID32::operator==(_DWORD);

//----- (10053E50) --------------------------------------------------------
struct Texture *__thiscall StdSystem::loadTexture(StdSystem *this, char *Str2, bool a3)
{
  int v3; // edx
  Texture *v5; // [esp+4Ch] [ebp-28h]
  HGLOBAL hMem; // [esp+50h] [ebp-24h]
  Texture *v7; // [esp+54h] [ebp-20h]
  struct RandomAccessStream *v8; // [esp+58h] [ebp-1Ch]
  Texture *v9; // [esp+5Ch] [ebp-18h]
  struct GfxobjInfo *v10; // [esp+60h] [ebp-14h]
  StdSystem *v11; // [esp+64h] [ebp-10h]
  int v12; // [esp+70h] [ebp-4h]

  v11 = this;
  v10 = StdSystem::findGfxObject(this, Str2, 0x5F746578u);
  if ( v10 )
    return *(v10 + 8);
  v9 = 0;
  LOBYTE(v3) = a3;
  v8 = (*(*v11 + 4))(v11, Str2, v3, 1);
  if ( v8 )
  {
    hMem = sub_10002A81(0x34u);
    v12 = 0;
    if ( hMem )
      v5 = Texture::Texture(hMem);
    else
      v5 = 0;
    v7 = v5;
    v12 = -1;
    v9 = v5;
    Texture::read(v5, v8);
    (*(*v8 + 68))(v8);
  }
  return v9;
}

//----- (10053FA0) --------------------------------------------------------
struct GfxobjInfo *__thiscall StdSystem::findTexture(StdSystem *this, struct Texture *a2)
{
  int i; // [esp+4Ch] [ebp-8h]

  for ( i = *(this + 118); i != (this + 464); i = *(i + 8) )
  {
    if ( *(i + 32) == a2 )
      return i;
  }
  return 0;
}

//----- (10054020) --------------------------------------------------------
struct Shape *__thiscall StdSystem::loadShape(StdSystem *this, char *Str2, bool a3)
{
  char *v3; // eax
  struct GfxobjInfo *v5; // [esp+4Ch] [ebp-130h]
  HGLOBAL hMem; // [esp+50h] [ebp-12Ch]
  struct GfxobjInfo *v7; // [esp+54h] [ebp-128h]
  struct GfxobjInfo *v8; // [esp+58h] [ebp-124h]
  int i; // [esp+5Ch] [ebp-120h]
  char *v10; // [esp+60h] [ebp-11Ch]
  char Dest; // [esp+64h] [ebp-118h]
  char v12[255]; // [esp+65h] [ebp-117h]
  struct GfxobjInfo *v13; // [esp+164h] [ebp-18h]
  struct Shape *v14; // [esp+168h] [ebp-14h]
  StdSystem *v15; // [esp+16Ch] [ebp-10h]
  int v16; // [esp+178h] [ebp-4h]

  v15 = this;
  v14 = 0;
  if ( a3 )
  {
    v13 = StdSystem::findGfxObject(v15, Str2, 0x5F736870u);
    if ( v13 )
      v14 = *(v13 + 8);
  }
  if ( !v14 )
  {
    sprintf(&Dest, "%s", Str2);
    v10 = 0;
    for ( i = strlen(&Dest) - 1; i >= 0; --i )
    {
      if ( Str2[i] == 63 )
      {
        v10 = &v12[i];
        *(&Dest + i) = 0;
        break;
      }
    }
    v14 = StdSystem::getShape(v15, &Dest, Str2, v10, 1);
    if ( !v14 )
      sub_100542B0("Could not load shape : %s\n", Str2);
    hMem = sub_10002A81(0x24u);
    v16 = 0;
    if ( hMem )
      v5 = ShpobjInfo::ShpobjInfo(hMem);
    else
      v5 = 0;
    v7 = v5;
    v16 = -1;
    v8 = v5;
    v3 = StdSystem::stringDup(Str2);
    *(v8 + 3) = v3;
    ID32::setID((v8 + 16), 0x5F736870u);
    *(v8 + 8) = v14;
    StdSystem::addGfxObject(v15, v8);
  }
  return v14;
}
// 10054020: using guessed type char var_117[255];

//----- (100542B0) --------------------------------------------------------
void __noreturn sub_100542B0(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscommon\\stdsystem.cpp", 12, &Dest);
}

//----- (10054350) --------------------------------------------------------
struct AnimData *__thiscall StdSystem::findAnimation(StdSystem *this, char *Str2)
{
  int v3; // [esp+4Ch] [ebp-Ch]
  struct GfxobjInfo *v4; // [esp+50h] [ebp-8h]

  v4 = StdSystem::findGfxObject(this, Str2, 0x5F616E6Du);
  if ( v4 )
    v3 = *(v4 + 8);
  else
    v3 = 0;
  return v3;
}

//----- (100543D0) --------------------------------------------------------
struct AnimData *__thiscall StdSystem::findAnyAnimation(StdSystem *this, char *Str)
{
  int v3; // [esp+4Ch] [ebp-Ch]
  struct GfxobjInfo *v4; // [esp+50h] [ebp-8h]

  v4 = StdSystem::findAnyGfxObject(this, Str, 0x5F616E6Du);
  if ( v4 )
    v3 = *(v4 + 8);
  else
    v3 = 0;
  return v3;
}

//----- (10054450) --------------------------------------------------------
struct AnimData *__thiscall StdSystem::findIndexAnimation(StdSystem *this, char *Str, int a3)
{
  size_t v3; // eax
  int i; // [esp+4Ch] [ebp-Ch]
  int v6; // [esp+50h] [ebp-8h]
  StdSystem *v7; // [esp+54h] [ebp-4h]

  v7 = this;
  v6 = 0;
  for ( i = *(this + 118); i != (v7 + 464); i = *(i + 8) )
  {
    if ( ID32::operator==(1600220781) )
    {
      v3 = strlen(Str);
      if ( !strncmp(*(i + 12), Str, v3) )
      {
        if ( v6 == a3 )
          return *(i + 32);
        ++v6;
      }
    }
  }
  return 0;
}
// 10001168: using guessed type _DWORD __stdcall ID32::operator==(_DWORD);

//----- (10054540) --------------------------------------------------------
int __thiscall StdSystem::findAnyIndex(StdSystem *this, char *Str, char *Str2)
{
  size_t v3; // eax
  int i; // [esp+4Ch] [ebp-Ch]
  int v6; // [esp+50h] [ebp-8h]
  StdSystem *v7; // [esp+54h] [ebp-4h]

  v7 = this;
  v6 = 0;
  for ( i = *(this + 118); i != (v7 + 464); i = *(i + 8) )
  {
    if ( ID32::operator==(1600220781) )
    {
      v3 = strlen(Str);
      if ( !strncmp(*(i + 12), Str, v3) )
      {
        if ( !strcmp(*(i + 12), Str2) )
          return v6;
        ++v6;
      }
    }
  }
  return 0;
}
// 10001168: using guessed type _DWORD __stdcall ID32::operator==(_DWORD);

//----- (10054650) --------------------------------------------------------
void __thiscall StdSystem::ageAnyAnimations(StdSystem *this, struct AgeServer *a2, char *Str)
{
  size_t v3; // eax
  int v4; // ST08_4
  int i; // [esp+50h] [ebp-Ch]
  int v6; // [esp+54h] [ebp-8h]
  StdSystem *v7; // [esp+58h] [ebp-4h]

  v7 = this;
  v6 = 0;
  for ( i = *(this + 118); i != (v7 + 464); i = *(i + 8) )
  {
    if ( ID32::operator==(1600220781) )
    {
      v3 = strlen(Str);
      if ( !strncmp(*(i + 12), Str, v3) )
      {
        v4 = v6++;
        AgeServer::NewOption(a2, *(i + 12), v4);
      }
    }
  }
}
// 10001168: using guessed type _DWORD __stdcall ID32::operator==(_DWORD);

//----- (10054750) --------------------------------------------------------
struct AnimData *__thiscall StdSystem::loadAnimation(StdSystem *this, struct Shape *a2, char *Str2, bool a4)
{
  struct AnimData *v5; // [esp+4Ch] [ebp-Ch]
  struct GfxobjInfo *v6; // [esp+50h] [ebp-8h]
  StdSystem *v7; // [esp+54h] [ebp-4h]

  v7 = this;
  v6 = StdSystem::findGfxObject(this, Str2, 0x5F616E6Du);
  if ( v6 )
    return *(v6 + 8);
  v5 = BaseShape::loadAnimation(a2, Str2, a4);
  if ( v5 )
    StdSystem::addAnimation(v7, v5, Str2);
  return v5;
}

//----- (100547F0) --------------------------------------------------------
void __thiscall StdSystem::addAnimation(StdSystem *this, struct AnimData *a2, char *Str)
{
  _DWORD *v3; // [esp+4Ch] [ebp-20h]
  AnmobjInfo *hMem; // [esp+50h] [ebp-1Ch]
  StdSystem *v5; // [esp+5Ch] [ebp-10h]

  v5 = this;
  hMem = sub_10002A81(0x24u);
  if ( hMem )
    v3 = AnmobjInfo::AnmobjInfo(hMem);
  else
    v3 = 0;
  v3[3] = StdSystem::stringDup(Str);
  ID32::setID((v3 + 4), 0x5F616E6Du);
  v3[8] = a2;
  StdSystem::addGfxObject(v5, v3);
}

//----- (100548F0) --------------------------------------------------------
void __thiscall StdSystem::addGfxObject(StdSystem *this, struct GfxobjInfo *a2)
{
  StdSystem *v2; // ST50_4

  v2 = this;
  GfxobjInfo::insertAfter((this + 464), a2);
  *(v2 + 496) = 1;
}

//----- (10054950) --------------------------------------------------------
void __thiscall StdSystem::attachObjs(StdSystem *this)
{
  void (__thiscall ***i)(int); // [esp+4Ch] [ebp-8h]
  StdSystem *v2; // [esp+50h] [ebp-4h]

  v2 = this;
  if ( *(this + 496) )
  {
    for ( i = *(v2 + 118); i != (v2 + 464); i = i[2] )
    {
      if ( !i[7] )
      {
        (**i)(i);
        i[7] = 1;
      }
    }
    *(v2 + 496) = 0;
  }
}

//----- (10054A10) --------------------------------------------------------
void __thiscall StdSystem::detachObjs(StdSystem *this)
{
  _DWORD *i; // [esp+4Ch] [ebp-8h]
  StdSystem *v2; // [esp+50h] [ebp-4h]

  v2 = this;
  for ( i = *(this + 118); i != (v2 + 464); i = i[2] )
  {
    if ( i[7] )
    {
      (*(*i + 4))(i);
      i[7] = 0;
    }
  }
  *(v2 + 496) = 1;
}

//----- (10054AC0) --------------------------------------------------------
void __thiscall StdSystem::invalidateObjs(StdSystem *this, unsigned __int32 a2, unsigned __int32 a3)
{
  GfxobjInfo *i; // [esp+4Ch] [ebp-Ch]
  GfxobjInfo *v4; // [esp+50h] [ebp-8h]
  StdSystem *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  for ( i = *(this + 118); i != (v5 + 464); i = v4 )
  {
    v4 = *(i + 2);
    if ( i >= a2 && i < a3 )
      GfxobjInfo::remove(i);
  }
}

//----- (10054B60) --------------------------------------------------------
void __thiscall StdSystem::addTexture(StdSystem *this, struct Texture *a2, char *Str)
{
  _DWORD *v3; // [esp+4Ch] [ebp-20h]
  TexobjInfo *hMem; // [esp+50h] [ebp-1Ch]
  StdSystem *v5; // [esp+5Ch] [ebp-10h]

  v5 = this;
  hMem = sub_10002A81(0x24u);
  if ( hMem )
    v3 = TexobjInfo::TexobjInfo(hMem);
  else
    v3 = 0;
  v3[3] = StdSystem::stringDup(Str);
  ID32::setID((v3 + 4), 0x5F746578u);
  v3[8] = a2;
  *(a2 + 12) = v3;
  StdSystem::addGfxObject(v5, v3);
}

//----- (10054C70) --------------------------------------------------------
void __thiscall StdSystem::initSoftReset(StdSystem *this)
{
  CmdStream::statbuff = 0;
  *(this + 127) = 0;
}

//----- (10054CC0) --------------------------------------------------------
void __stdcall StdSystem::genAge(struct AgeServer *a2)
{
  AgeServer::StartSection(a2, "StdSystem", 1);
  AgeServer::EndSection(a2);
}

//----- (10054D20) --------------------------------------------------------
struct Shape *__thiscall StdSystem::getShape(StdSystem *this, char *a2, char *Str, char *a4, bool a5)
{
  char *v5; // eax
  BaseShape *v7; // [esp+4Ch] [ebp-24h]
  HGLOBAL hMem; // [esp+50h] [ebp-20h]
  BaseShape *v9; // [esp+54h] [ebp-1Ch]
  int v10; // [esp+58h] [ebp-18h]
  BaseShape *v11; // [esp+5Ch] [ebp-14h]
  StdSystem *v12; // [esp+60h] [ebp-10h]
  int v13; // [esp+6Ch] [ebp-4h]

  v12 = this;
  v11 = 0;
  v10 = (*(*gsys + 4))(gsys, a2, a5, 1);
  if ( v10 )
  {
    hMem = sub_10002A81(0x2F4u);
    v13 = 0;
    if ( hMem )
      v7 = Shape::Shape(hMem);
    else
      v7 = 0;
    v9 = v7;
    v13 = -1;
    v11 = v7;
    *(v12 + 127) = v7;
    v5 = StdSystem::stringDup(Str);
    *(v11 + 1) = v5;
    (*(*v11 + 16))(v11, v10);
    (*(*v10 + 68))(v10);
  }
  if ( v11 )
  {
    StdSystem::setTextureBase(gsys, `string', a4);
    BaseShape::resolveTextureNames(v11);
    BaseShape::initialise(v11);
    BaseShape::initIni(v11, 1);
    StdSystem::setTextureBase(gsys, `string', `string');
    (*(*v11 + 20))(v11);
  }
  return v11;
}

//----- (10054F00) --------------------------------------------------------
void __thiscall StdSystem::initLFlares(StdSystem *this, int a2)
{
  HGLOBAL v2; // [esp+4Ch] [ebp-20h]
  HGLOBAL hMem; // [esp+50h] [ebp-1Ch]
  StdSystem *v4; // [esp+5Ch] [ebp-10h]

  v4 = this;
  *(this + 140) = a2;
  hMem = sub_10001AC3(44 * a2);
  if ( hMem )
  {
    sub_1000291E(hMem, 44, a2, LFInfo::LFInfo);
    v2 = hMem;
  }
  else
  {
    v2 = 0;
  }
  *(v4 + 141) = v2;
  StdSystem::resetLFlares(v4);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10055000) --------------------------------------------------------
void __thiscall StdSystem::resetLFlares(StdSystem *this)
{
  *(this + 139) = 0;
}

//----- (10055040) --------------------------------------------------------
struct LFInfo *__thiscall StdSystem::getLFlareInfo(StdSystem *this)
{
  if ( *(this + 139) >= *(this + 140) )
    return 0;
  return (44 * (++*(this + 139) - 1) + *(this + 141));
}

//----- (100550D0) --------------------------------------------------------
struct CoreNode *__thiscall StdSystem::registerLFlare(StdSystem *this, struct Texture *a2)
{
  struct CoreNode *v3; // [esp+4Ch] [ebp-24h]
  LFlareGroup *hMem; // [esp+50h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-14h]
  StdSystem *v6; // [esp+60h] [ebp-10h]

  v6 = this;
  for ( i = *(*(this + 142) + 16); i; i = *(i + 12) )
  {
    if ( *(i + 24) == a2 )
      return i;
  }
  hMem = sub_10002A81(0x28u);
  if ( hMem )
    v3 = LFlareGroup::LFlareGroup(hMem);
  else
    v3 = 0;
  v3[1].name = a2;
  CoreNode::add(*(v6 + 142), v3);
  return v3;
}

//----- (100551F0) --------------------------------------------------------
void __thiscall StdSystem::flushLFlares(StdSystem *this, struct Graphics *a2)
{
  int v2; // ST18_4
  int v3; // ST14_4
  int v4; // eax
  int v5; // ecx
  char v6; // [esp+4Ch] [ebp-18h]
  int j; // [esp+50h] [ebp-14h]
  _DWORD *i; // [esp+54h] [ebp-10h]
  char v9; // [esp+58h] [ebp-Ch]
  int v10; // [esp+5Ch] [ebp-8h]
  StdSystem *v11; // [esp+60h] [ebp-4h]

  v11 = this;
  v2 = *(*(a2 + 186) + 468);
  v3 = *(*(a2 + 186) + 464);
  v4 = Colour::Colour(&v6, 0, 0, 0, 0);
  (*(*a2 + 176))(a2, 1, v4, 1065353216, v3, v2);
  v10 = (*(*a2 + 88))(a2, 1);
  v9 = (*(*a2 + 40))(a2, 0, 0);
  (*(*a2 + 108))(a2, &Matrix4f::ident, 0);
  (*(*a2 + 192))(a2, 0);
  for ( i = *(*(v11 + 142) + 16); i; i = i[3] )
  {
    if ( i[8] )
    {
      if ( i[7] )
      {
        (*(*a2 + 192))(a2, i[7]);
      }
      else
      {
        (*(*a2 + 88))(a2, i[9]);
        (*(*a2 + 192))(a2, 0);
        (*(*a2 + 196))(a2, i[6], 0);
      }
      (*(*a2 + 128))(a2, 1);
      for ( j = i[8]; j; j = *(j + 40) )
      {
        if ( !i[7] )
          (*(*a2 + 160))(a2, j, 1);
        (*(*a2 + 140))(a2, *(a2 + 186), j + 4, j + 16, j + 24, j + 32);
      }
      i[8] = 0;
    }
  }
  (*(*a2 + 88))(a2, v10);
  LOBYTE(v5) = v9;
  (*(*a2 + 40))(a2, v5, 0);
  (*(*a2 + 192))(a2, 0);
}

//----- (10055520) --------------------------------------------------------
void __thiscall StdSystem::loadBundle(StdSystem *this, char *a2, bool a3)
{
  char *v3; // eax
  struct GfxobjInfo *v4; // [esp+4Ch] [ebp-78h]
  struct Texture *v5; // [esp+50h] [ebp-74h]
  TexImg *v6; // [esp+54h] [ebp-70h]
  int v7; // [esp+58h] [ebp-6Ch]
  HGLOBAL v8; // [esp+5Ch] [ebp-68h]
  struct GfxobjInfo *v9; // [esp+60h] [ebp-64h]
  int v10; // [esp+64h] [ebp-60h]
  HGLOBAL v11; // [esp+68h] [ebp-5Ch]
  struct Texture *v12; // [esp+6Ch] [ebp-58h]
  HGLOBAL hMem; // [esp+70h] [ebp-54h]
  TexImg *v14; // [esp+74h] [ebp-50h]
  int v15; // [esp+78h] [ebp-4Ch]
  struct GfxobjInfo *v16; // [esp+7Ch] [ebp-48h]
  int v17; // [esp+80h] [ebp-44h]
  struct Texture *v18; // [esp+84h] [ebp-40h]
  TexImg *v19; // [esp+88h] [ebp-3Ch]
  struct Texture *v20; // [esp+8Ch] [ebp-38h]
  struct AnimData *v21; // [esp+90h] [ebp-34h]
  struct AnimData *v22; // [esp+94h] [ebp-30h]
  char v23; // [esp+98h] [ebp-2Ch]
  char *Str; // [esp+9Ch] [ebp-28h]
  SIZE_T dwBytes; // [esp+A0h] [ebp-24h]
  int v26; // [esp+A4h] [ebp-20h]
  int i; // [esp+A8h] [ebp-1Ch]
  int v28; // [esp+ACh] [ebp-18h]
  struct RandomAccessStream *v29; // [esp+B0h] [ebp-14h]
  StdSystem *v30; // [esp+B4h] [ebp-10h]
  int v31; // [esp+C0h] [ebp-4h]

  v30 = this;
  v29 = (*(*this + 4))(this, a2, 1, 1);
  if ( v29 )
  {
    v28 = (**v29)(v29);
    for ( i = 0; i < v28; ++i )
    {
      v26 = (**v29)(v29);
      dwBytes = (**v29)(v29);
      String::String(&v23, 0);
      (*(*v29 + 20))(v29, &v23);
      v7 = v26;
      switch ( v26 )
      {
        case 0:
          v10 = sub_10001AC3(dwBytes);
          v17 = v10;
          (*(*v29 + 52))(v29, v10, dwBytes);
          v8 = sub_10002A81(0x24u);
          v31 = 2;
          if ( v8 )
            v4 = BinobjInfo::BinobjInfo(v8);
          else
            v4 = 0;
          v9 = v4;
          v31 = -1;
          v16 = v4;
          v3 = StdSystem::stringDup(Str);
          *(v16 + 3) = v3;
          ID32::setID((v16 + 16), 0x5F62696Eu);
          *(v16 + 8) = v17;
          StdSystem::addGfxObject(gsys, v16);
          break;
        case 1:
          hMem = sub_10002A81(0x34u);
          v31 = 0;
          if ( hMem )
            v6 = TexImg::TexImg(hMem);
          else
            v6 = 0;
          v14 = v6;
          v31 = -1;
          v19 = v6;
          v11 = sub_10002A81(0x34u);
          v31 = 1;
          if ( v11 )
            v5 = Texture::Texture(v11);
          else
            v5 = 0;
          v12 = v5;
          v31 = -1;
          v18 = v5;
          v20 = v5;
          TexImg::importBti(v19, v5, v29, 0);
          StdSystem::addTexture(gsys, v20, Str);
          break;
        case 2:
          v22 = BaseShape::loadDca(*(v30 + 127), Str, v29);
          StdSystem::addAnimation(v30, v22, Str);
          break;
        case 3:
          v21 = BaseShape::loadDck(*(v30 + 127), Str, v29);
          StdSystem::addAnimation(v30, v21, Str);
          break;
        default:
          v15 = (*(*v29 + 80))(v29);
          (*(*v29 + 84))(v29, dwBytes + v15);
          break;
      }
    }
    (*(*v29 + 68))(v29);
  }
}

//----- (10055930) --------------------------------------------------------
char *__cdecl StdSystem::stringDup(char *Str)
{
  SIZE_T Size; // ST60_4
  void *Dst; // ST5C_4

  Size = strlen(Str) + 1;
  Dst = sub_10001AC3(Size);
  memcpy(Dst, Str, Size);
  return Dst;
}

//----- (100559B0) --------------------------------------------------------
void __thiscall TextureCacher::updateInfo(TextureCacher *this, struct CacheTexture *a2)
{
  TextureCacher *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  if ( *(this + 2) != *(a2 + 14) )
  {
    CacheInfo::remove(*(a2 + 14));
    CacheInfo::insertAfter(v2, *(a2 + 14));
  }
}

//----- (10055A20) --------------------------------------------------------
void __thiscall TextureCacher::purgeAll(TextureCacher *this)
{
  TextureCacher *i; // [esp+4Ch] [ebp-4h]

  for ( i = this; !AyuCache::isEmpty(*(i + 5)); TextureCacher::removeOldest(i) )
    ;
}

//----- (10055A80) --------------------------------------------------------
void __thiscall TextureCacher::removeOldest(TextureCacher *this)
{
  TextureCacher *v1; // ST54_4
  _DWORD **v2; // ST50_4

  v1 = this;
  v2 = *(this + 1);
  CacheInfo::remove(*(this + 1));
  *v2[3] = 0;
  AyuCache::cacheFree(*(v1 + 5), v2);
}

//----- (10055B00) --------------------------------------------------------
void __thiscall TextureCacher::cacheTexture(TextureCacher *this, struct CacheTexture *a2)
{
  struct CacheInfo *v2; // [esp+50h] [ebp-10h]
  unsigned __int32 v3; // [esp+54h] [ebp-Ch]
  unsigned __int32 v4; // [esp+58h] [ebp-8h]
  CacheInfo *v5; // [esp+5Ch] [ebp-4h]

  v5 = this;
  v4 = (*(*(a2 + 15) + 40) + 83) & 0xFFFFFFE0;
  while ( 1 )
  {
    v3 = AyuCache::largestBlockFree(*(v5 + 5));
    if ( v3 > v4 )
      break;
    TextureCacher::removeOldest(v5);
  }
  v2 = AyuCache::mallocL(*(v5 + 5), v4);
  if ( !v2 )
    sub_100542B0("Could not get memory from cache! %d : %d\n", v4, v3);
  *(*(a2 + 15) + 44) = (v2 + 51) & 0xFFFFFFE0;
  *(v2 + 3) = a2 + 56;
  *(a2 + 14) = v2;
  CacheInfo::insertAfter(v5, v2);
}

//----- (10055C10) --------------------------------------------------------
unsigned int __thiscall Stream::readInt(Stream *this)
{
  int v2; // [esp+4Ch] [ebp-8h]
  Stream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  (*(*this + 52))(this, &v2, 4);
  return ((v2 & 0xFF000000) >> 24) | ((v2 & 0xFF0000) >> 8) | ((v2 & 0xFF00) << 8) | (v2 << 24);
}

//----- (10055CB0) --------------------------------------------------------
char __thiscall Stream::readByte(Stream *this)
{
  char v2; // [esp+4Ch] [ebp-8h]
  Stream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  (*(*this + 52))(this, &v2, 1);
  return v2;
}

//----- (10055D10) --------------------------------------------------------
int __thiscall Stream::readShort(Stream *this)
{
  __int16 v2; // [esp+4Ch] [ebp-8h]
  Stream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  (*(*this + 52))(this, &v2, 2);
  return ((v2 & 0xFF00) >> 8) | (v2 << 8);
}

//----- (10055D90) --------------------------------------------------------
double __thiscall Stream::readFloat(Stream *this)
{
  int v2; // [esp+4Ch] [ebp-8h]
  Stream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  (*(*this + 52))(this, &v2, 4);
  return COERCE_FLOAT(((v2 & 0xFF000000) >> 24) | ((v2 & 0xFF0000) >> 8) | ((v2 & 0xFF00) << 8) | (v2 << 24));
}

//----- (10055E40) --------------------------------------------------------
char *__thiscall Stream::readString(Stream *this)
{
  int v1; // eax
  int v2; // eax
  int v4; // [esp+4Ch] [ebp-10h]
  int v5; // [esp+50h] [ebp-Ch]
  int v6; // [esp+54h] [ebp-8h]
  Stream *v7; // [esp+58h] [ebp-4h]

  v7 = this;
  v1 = (**this)(this);
  v6 = v1;
  v2 = sub_10002A81(v1 + 1);
  v4 = v2;
  v5 = v2;
  (*(*v7 + 52))(v7, v2, v6);
  *(v6 + v5) = 0;
  return v5;
}

//----- (10055EF0) --------------------------------------------------------
void __thiscall Stream::readString(Stream *this, char *a2, int a3)
{
  char v3; // [esp+4Ch] [ebp-Ch]
  Stream *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  String::String(&v3, a2, a3);
  (*(*v4 + 20))(v4, &v3);
}

//----- (10055F60) --------------------------------------------------------
void __thiscall Stream::readString(Stream *this, struct String *a2)
{
  int v2; // [esp+4Ch] [ebp-8h]
  Stream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  v2 = (**this)(this);
  if ( *a2 < v2 )
    String::init(a2, v2);
  (*(*v3 + 52))(v3, *(a2 + 1), v2);
  *(*(a2 + 1) + v2) = 0;
}

//----- (10056010) --------------------------------------------------------
void __thiscall Stream::writeInt(Stream *this, int a2)
{
  unsigned int v2; // [esp+4Ch] [ebp-8h]
  Stream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  v2 = ((a2 & 0xFF000000) >> 24) | ((a2 & 0xFF0000) >> 8) | ((a2 & 0xFF00) << 8) | (a2 << 24);
  (*(*this + 56))(this, &v2, 4);
}

//----- (100560C0) --------------------------------------------------------
void __thiscall Stream::writeByte(Stream *this, unsigned __int8 a2)
{
  Stream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(*this + 56))(this, &a2, 1);
}

//----- (10056120) --------------------------------------------------------
void __thiscall Stream::writeShort(Stream *this, __int16 a2)
{
  __int16 v2; // [esp+4Ch] [ebp-8h]
  Stream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  v2 = ((a2 & 0xFF00) >> 8) | (a2 << 8);
  (*(*this + 56))(this, &v2, 2);
}

//----- (100561B0) --------------------------------------------------------
void __thiscall Stream::writeFloat(Stream *this, float a2)
{
  unsigned int v2; // [esp+4Ch] [ebp-8h]
  Stream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  v2 = ((LODWORD(a2) & 0xFF000000) >> 24) | ((LODWORD(a2) & 0xFF0000) >> 8) | ((LOWORD(a2) & 0xFF00) << 8) | (LOBYTE(a2) << 24);
  (*(*this + 56))(this, &v2, 4);
}

//----- (10056260) --------------------------------------------------------
void __thiscall Stream::writeString(Stream *this, char *a2)
{
  char v2; // [esp+4Ch] [ebp-Ch]
  Stream *v3; // [esp+54h] [ebp-4h]

  v3 = this;
  String::String(&v2, a2, 0);
  (*(*v3 + 44))(v3, &v2);
}

//----- (100562D0) --------------------------------------------------------
void __thiscall Stream::writeString(Stream *this, struct String *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int i; // [esp+4Ch] [ebp-10h]
  char v6; // [esp+50h] [ebp-Ch]
  int v7; // [esp+54h] [ebp-8h]
  Stream *v8; // [esp+58h] [ebp-4h]

  v8 = this;
  v2 = String::getLength(a2) + 3;
  LOBYTE(v2) = v2 & 0xFC;
  v7 = v2;
  (*(*v8 + 28))(v8, v2);
  v3 = String::getLength(a2);
  (*(*v8 + 56))(v8, *(a2 + 1), v3);
  v6 = 0;
  for ( i = 0; ; ++i )
  {
    v4 = String::getLength(a2);
    if ( i >= v7 - v4 )
      break;
    (*(*v8 + 56))(v8, &v6, 1);
  }
}

//----- (100563C0) --------------------------------------------------------
void Stream::print(Stream *this, char *Format, ...)
{
  size_t v2; // eax
  char Dest; // [esp+50h] [ebp-400h]
  va_list va; // [esp+460h] [ebp+10h]

  va_start(va, Format);
  vsprintf(&Dest, Format, va);
  if ( strlen(&Dest) )
  {
    v2 = strlen(&Dest);
    (*(*this + 56))(this, &Dest, v2);
  }
}

//----- (10056490) --------------------------------------------------------
void __thiscall Stream::vPrintf(Stream *this, char *Format, char *Args)
{
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  Stream *v5; // [esp+44Ch] [ebp-4h]

  v5 = this;
  vsprintf(&Dest, Format, Args);
  if ( strlen(&Dest) )
  {
    v3 = strlen(&Dest);
    (*(*v5 + 56))(v5, &Dest, v3);
  }
}

//----- (10056550) --------------------------------------------------------
void __stdcall Stream::read(void *a2, int a3)
{
  ;
}

//----- (10056580) --------------------------------------------------------
void __stdcall Stream::write(void *a2, int a3)
{
  ;
}

//----- (100565B0) --------------------------------------------------------
int Stream::getPending()
{
  return 0;
}

//----- (100565E0) --------------------------------------------------------
int Stream::getAvailable()
{
  return 0;
}

//----- (10056610) --------------------------------------------------------
void Stream::close()
{
  ;
}

//----- (10056640) --------------------------------------------------------
void __thiscall RandomAccessStream::writeTo(RandomAccessStream *this, int a2, void *a3, int a4)
{
  RandomAccessStream *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 84))(this, a2);
  (*(*v4 + 56))(v4, a3, a4);
}

//----- (100566C0) --------------------------------------------------------
void __thiscall RandomAccessStream::readFrom(RandomAccessStream *this, int a2, void *a3, int a4)
{
  RandomAccessStream *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  (*(*this + 84))(this, a2);
  (*(*v4 + 52))(v4, a3, a4);
}

//----- (10056740) --------------------------------------------------------
void __thiscall RandomAccessStream::writeIntTo(RandomAccessStream *this, int a2, int a3)
{
  RandomAccessStream *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  (*(*this + 84))(this, a2);
  (*(*v3 + 28))(v3, a3);
}

//----- (100567C0) --------------------------------------------------------
int __thiscall RandomAccessStream::readIntFrom(RandomAccessStream *this, int a2)
{
  RandomAccessStream *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  (*(*this + 84))(this, a2);
  return (**v3)(v3);
}

//----- (10056840) --------------------------------------------------------
void __thiscall BufferedInputStream::init(BufferedInputStream *this, struct Stream *a2, unsigned __int8 *a3, int a4)
{
  unsigned __int8 *v4; // [esp+4Ch] [ebp-Ch]
  BufferedInputStream *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  *(this + 1) = StdSystem::stringDup(*(a2 + 1));
  *(v5 + 3) = a4;
  if ( a3 )
    v4 = a3;
  else
    v4 = sub_100011A4(*(v5 + 3), 32);
  *(v5 + 2) = v4;
  *(v5 + 6) = 0;
  *(v5 + 5) = 0;
  *(v5 + 4) = 0;
  *(v5 + 7) = a2;
  BufferedInputStream::fillBuffer(v5);
}
// 100011A4: using guessed type _DWORD __cdecl sub_100011A4(_DWORD, _DWORD);

//----- (10056920) --------------------------------------------------------
RandomAccessStream *__thiscall BufferedInputStream::BufferedInputStream(BufferedInputStream *this, struct Stream *a2, unsigned __int8 *a3, int a4)
{
  RandomAccessStream *v4; // ST58_4

  v4 = this;
  RandomAccessStream::RandomAccessStream(this);
  *v4 = &BufferedInputStream::`vftable';
  BufferedInputStream::init(v4, a2, a3, a4);
  return v4;
}
// 101AD2C0: using guessed type void *BufferedInputStream::`vftable';

//----- (10056990) --------------------------------------------------------
void __thiscall BufferedInputStream::fillBuffer(BufferedInputStream *this)
{
  int v1; // eax
  BufferedInputStream *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  if ( *(this + 4) == *(this + 5) )
  {
    v1 = (*(*v2 + 60))(v2);
    *(v2 + 4) = v1;
    if ( *(v2 + 4) > *(v2 + 3) )
      *(v2 + 4) = *(v2 + 3);
    (*(**(v2 + 7) + 52))(*(v2 + 7), *(v2 + 2), *(v2 + 4));
    *(v2 + 5) = 0;
  }
}

//----- (10056A60) --------------------------------------------------------
void __thiscall BufferedInputStream::read(BufferedInputStream *this, void *a2, int a3)
{
  int Size; // [esp+4Ch] [ebp-10h]
  char *Dst; // [esp+54h] [ebp-8h]
  BufferedInputStream *v5; // [esp+58h] [ebp-4h]

  v5 = this;
  Dst = a2;
  while ( a3 )
  {
    BufferedInputStream::fillBuffer(v5);
    Size = a3;
    if ( a3 > *(v5 + 4) - *(v5 + 5) )
      Size = *(v5 + 4) - *(v5 + 5);
    memcpy(Dst, (*(v5 + 5) + *(v5 + 2)), Size);
    Dst += Size;
    *(v5 + 5) += Size;
    *(v5 + 6) += Size;
    a3 -= Size;
  }
}

//----- (10056B50) --------------------------------------------------------
bool __thiscall String::isSame(String *this, char *a2)
{
  int v2; // ecx
  int v3; // eax
  BOOL v5; // [esp+4Ch] [ebp-Ch]
  _BYTE *v6; // [esp+50h] [ebp-8h]

  v6 = *(this + 1);
  while ( *v6 && *a2 )
  {
    v2 = *v6;
    v3 = *a2++;
    ++v6;
    if ( v2 != v3 )
      return 0;
  }
  v5 = *v6 || *a2;
  return v5 == 0;
}

//----- (10056C10) --------------------------------------------------------
int __thiscall String::getLength(String *this)
{
  int v1; // eax
  int i; // [esp+4Ch] [ebp-Ch]
  char *v4; // [esp+50h] [ebp-8h]

  v4 = *(this + 1);
  for ( i = 0; ; ++i )
  {
    v1 = *v4++;
    if ( !v1 )
      break;
  }
  return i;
}

//----- (10056C80) --------------------------------------------------------
double String::toFloat()
{
  return 0.0;
}

//----- (10056CC0) --------------------------------------------------------
int __thiscall String::toInt(String *this)
{
  int result; // eax
  int v2; // [esp+4Ch] [ebp-1Ch]
  signed int v3; // [esp+50h] [ebp-18h]
  int v4; // [esp+54h] [ebp-14h]
  int v5; // [esp+54h] [ebp-14h]
  int v6; // [esp+58h] [ebp-10h]
  char *v7; // [esp+5Ch] [ebp-Ch]
  char *v8; // [esp+5Ch] [ebp-Ch]
  char v9; // [esp+60h] [ebp-8h]
  char v10; // [esp+60h] [ebp-8h]

  v7 = *(this + 1);
  v4 = 0;
  v3 = 0;
  if ( *v7 != 48 || v7[1] != 120 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v10 = *v7++;
        if ( (v10 < 48 || v10 > 57) && v10 != 45 )
          return 0;
        if ( v10 != 45 )
          break;
        v3 = 1;
      }
      v5 = (v10 - 48) + v4;
      if ( !*v7 || *v7 == 46 || *v7 < 48 || *v7 > 57 )
        break;
      v4 = 10 * v5;
    }
    if ( v3 )
      v5 = -v5;
    result = v5;
  }
  else
  {
    v6 = 0;
    v8 = v7 + 2;
    while ( 1 )
    {
      v9 = *v8++;
      if ( !v9 )
        break;
      if ( v9 < 48 || v9 > 57 )
      {
        if ( v9 < 97 || v9 > 102 )
        {
          if ( v9 < 65 || v9 > 70 )
            return 0;
          v2 = v9 - 55;
        }
        else
        {
          v2 = v9 - 87;
        }
      }
      else
      {
        v2 = v9 - 48;
      }
      v6 += v2;
      if ( *v8 )
        v6 *= 16;
    }
    result = v6;
  }
  return result;
}

//----- (10056F00) --------------------------------------------------------
int __cdecl String::getLength(char *a1)
{
  char v2; // [esp+4Ch] [ebp-8h]

  String::String(&v2, a1, 0);
  return String::getLength(&v2);
}

//----- (10056F50) --------------------------------------------------------
bool __cdecl String::isSame(char *a1, char *a2)
{
  char v3; // [esp+4Ch] [ebp-8h]

  String::String(&v3, a1, 0);
  return String::isSame(&v3, a2);
}

//----- (10056FB0) --------------------------------------------------------
char *__cdecl String::dup(char *a1)
{
  int v1; // eax
  char *v2; // ST58_4

  v1 = String::getLength(a1);
  v2 = sub_10002A81(v1 + 1);
  String::copy(v2, a1);
  return v2;
}

//----- (10057030) --------------------------------------------------------
char __cdecl String::contains(char *a1, char *a2)
{
  int v2; // eax
  int v3; // edx
  char *v5; // [esp+4Ch] [ebp-4h]

  v5 = a2;
  while ( *a1 && *a2 )
  {
    v2 = *a1;
    v3 = *a2++;
    ++a1;
    if ( v2 == v3 )
    {
      if ( !*a2 )
        return 1;
    }
    else
    {
      a2 = v5;
    }
  }
  return 0;
}

//----- (100570D0) --------------------------------------------------------
char *__cdecl String::copy(char *a1, char *a2)
{
  int v2; // ecx

  do
  {
    *a1 = *a2;
    v2 = *a1++;
    ++a2;
  }
  while ( v2 );
  return a1;
}

//----- (10057130) --------------------------------------------------------
bool __cdecl String::copyUntil(char *a1, char *a2, char a3, char **a4)
{
  while ( *a2 != a3 && *a2 )
    *a1++ = *a2++;
  *a1 = 0;
  if ( a4 )
    *a4 = a2;
  return *a2 == a3;
}

//----- (100571D0) --------------------------------------------------------
void __cdecl String::concat(char *a1, char *a2)
{
  int v2; // ecx
  int v3; // edx
  char *v4; // [esp+54h] [ebp+8h]

  do
    v2 = *a1++;
  while ( v2 );
  v4 = a1 - 1;
  do
  {
    *v4 = *a2;
    v3 = *v4++;
    ++a2;
  }
  while ( v3 );
}

//----- (10057250) --------------------------------------------------------
unsigned __int32 __cdecl String::calcHash(char *a1)
{
  char v2; // [esp+4Ch] [ebp-8h]

  String::String(&v2, a1, 0);
  return String::calcHash(&v2);
}

//----- (100572A0) --------------------------------------------------------
int __thiscall String::calcHash(String *this)
{
  _BYTE *v2; // [esp+4Ch] [ebp-10h]
  unsigned int v3; // [esp+50h] [ebp-Ch]
  int v4; // [esp+54h] [ebp-8h]
  int v5; // [esp+54h] [ebp-8h]

  v4 = 0;
  v2 = *(this + 1);
  while ( *v2 )
  {
    v5 = *v2++ + 16 * v4;
    v3 = v5 & 0xF0000000;
    if ( v5 & 0xF0000000 )
      v5 ^= v3 >> 24;
    v4 = ~v3 & v5;
  }
  return v4;
}

//----- (10057350) --------------------------------------------------------
int __cdecl String::toInt(char *a1)
{
  char v2; // [esp+4Ch] [ebp-8h]

  String::String(&v2, a1, 0);
  return String::toInt(&v2);
}

//----- (10057500) --------------------------------------------------------
void __thiscall Timers::reset(Timers *this)
{
  *this = 0;
  *(this + 2) = 0;
}

//----- (10057550) --------------------------------------------------------
void __thiscall Timers::newFrame(Timers *this)
{
  ++*(this + 1);
}

//----- (10057590) --------------------------------------------------------
void __thiscall Timers::_start(Timers *this, char *Str2, bool a3)
{
  int v3; // [esp+4Ch] [ebp-2Ch]
  TimerInf *hMem; // [esp+50h] [ebp-28h]
  int v5; // [esp+58h] [ebp-20h]
  int j; // [esp+5Ch] [ebp-1Ch]
  int i; // [esp+64h] [ebp-14h]
  Timers *v8; // [esp+68h] [ebp-10h]

  v8 = this;
  if ( *(gsys + 7) == 2 || !a3 )
  {
    for ( i = *this; i; i = *(i + 36) )
    {
      if ( !strcmp(*i, Str2) )
      {
        *(i + 4) = System::getTime(gsys);
        return;
      }
    }
    hMem = sub_10002A81(0x28u);
    if ( hMem )
      v3 = TimerInf::TimerInf(hMem, Str2);
    else
      v3 = 0;
    *(v3 + 32) = a3 == 0;
    v5 = 0;
    for ( j = *v8; j && !*(j + 32); j = *(j + 36) )
      v5 = j;
    if ( v5 )
    {
      *(v3 + 36) = j;
      *(v5 + 36) = v3;
    }
    else
    {
      *(v3 + 36) = j;
      *v8 = v3;
    }
    *(v3 + 4) = System::getTime(gsys);
    ++*(v8 + 2);
  }
}
// 10001AA0: using guessed type double __thiscall System::getTime(_DWORD);

//----- (10057780) --------------------------------------------------------
void __thiscall Timers::_stop(Timers *this, char *Str2)
{
  int i; // [esp+4Ch] [ebp-8h]

  for ( i = *this; i; i = *(i + 36) )
  {
    if ( !strcmp(*i, Str2) )
    {
      *(i + 8) = System::getTime(gsys) - *(i + 4) + *(i + 8);
      return;
    }
  }
}
// 10001AA0: using guessed type double __thiscall System::getTime(_DWORD);

//----- (10057820) --------------------------------------------------------
void __thiscall Timers::showTimes(Timers *this)
{
  double v1; // st7
  int i; // [esp+54h] [ebp-8h]

  for ( i = *this; i; i = *(i + 36) )
  {
    v1 = *(i + 12);
    sub_100578B0("timer : %s = %f\n", *i);
  }
}

//----- (100578B0) --------------------------------------------------------
char *__cdecl sub_100578B0(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "Timers" )
      Stream::print(sysCon, "%s: ", "Timers");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (100579C0) --------------------------------------------------------
void __thiscall Timers::draw(Timers *this, struct Graphics *a2, struct Font *a3)
{
  double v3; // st7
  double v4; // st7
  int v5; // eax
  int v6; // eax
  unsigned __int64 v7; // st7
  int v8; // ST14_4
  int v9; // edi
  int v10; // eax
  int v11; // ST14_4
  int v12; // edi
  int v13; // eax
  signed __int64 v14; // [esp+18h] [ebp-210h]
  int v15; // [esp+20h] [ebp-208h]
  float v16; // [esp+6Ch] [ebp-1BCh]
  int v17; // [esp+70h] [ebp-1B8h]
  char v18; // [esp+74h] [ebp-1B4h]
  char v19; // [esp+78h] [ebp-1B0h]
  char v20; // [esp+7Ch] [ebp-1ACh]
  char v21; // [esp+8Ch] [ebp-19Ch]
  char v22; // [esp+90h] [ebp-198h]
  char v23; // [esp+94h] [ebp-194h]
  char v24; // [esp+A4h] [ebp-184h]
  char v25; // [esp+A8h] [ebp-180h]
  char v26; // [esp+ACh] [ebp-17Ch]
  char v27; // [esp+B0h] [ebp-178h]
  char v28; // [esp+B4h] [ebp-174h]
  char v29; // [esp+C4h] [ebp-164h]
  char v30; // [esp+C8h] [ebp-160h]
  int m; // [esp+CCh] [ebp-15Ch]
  char Dest; // [esp+D0h] [ebp-158h]
  float v33; // [esp+1D0h] [ebp-58h]
  float v34; // [esp+1D4h] [ebp-54h]
  int l; // [esp+1D8h] [ebp-50h]
  int v36; // [esp+1DCh] [ebp-4Ch]
  int k; // [esp+1E0h] [ebp-48h]
  int j; // [esp+1E4h] [ebp-44h]
  int v39; // [esp+1E8h] [ebp-40h]
  float v40; // [esp+1ECh] [ebp-3Ch]
  float v41; // [esp+1F0h] [ebp-38h]
  float v42; // [esp+1F4h] [ebp-34h]
  float v43; // [esp+1F8h] [ebp-30h]
  float v44; // [esp+1FCh] [ebp-2Ch]
  int v45; // [esp+200h] [ebp-28h]
  float v46; // [esp+204h] [ebp-24h]
  float v47; // [esp+208h] [ebp-20h]
  float v48; // [esp+20Ch] [ebp-1Ch]
  float v49; // [esp+210h] [ebp-18h]
  int v50; // [esp+214h] [ebp-14h]
  int v51; // [esp+218h] [ebp-10h]
  float v52; // [esp+21Ch] [ebp-Ch]
  int i; // [esp+220h] [ebp-8h]
  int *v54; // [esp+224h] [ebp-4h]

  v54 = this;
  (*(*a2 + 196))(a2, 0, 0);
  for ( i = *v54; i; i = *(i + 36) )
  {
    if ( ++*(i + 24) == 10 )
    {
      *(i + 12) = *(i + 8) / 10.0;
      if ( *(i + 12) < 0.0 )
        *(i + 12) = 0;
      if ( *(i + 12) > *(i + 16) )
      {
        *(i + 20) = 1092616192;
        *(i + 16) = *(i + 12);
      }
      *(i + 8) = 0;
      *(i + 24) = 0;
    }
    v3 = System::getFrameTime(gsys);
    *(i + 20) = *(i + 20) - v3;
    if ( *(i + 20) < 0.0 && *(i + 16) > 0.0 )
    {
      v4 = System::getFrameTime(gsys);
      *(i + 16) = *(i + 16) - v4 * 6.0;
      if ( *(i + 16) < 0.0 )
        *(i + 16) = 0;
    }
  }
  v52 = 192.0;
  v51 = 4;
  v50 = 12;
  v49 = *(a2 + 196) - 192.0;
  v48 = v49 / 4;
  v47 = v49;
  v46 = v54[2] * 12 + 32.0;
  v17 = *(a2 + 196) / 2;
  *&v45 = v17 - v49 / 2.0;
  v44 = *(a2 + 197) - v46;
  v43 = *&v45;
  v42 = v44;
  v40 = v44;
  v39 = 0;
  for ( j = *v54; j; j = *(j + 36) )
  {
    v41 = v43;
    for ( k = 0; k < v51; ++k )
    {
      if ( ((v39 & 1) + k) & 1 )
        v16 = 0.1;
      else
        v16 = 0.30000001;
      v36 = (v16 * 255.0);
      v14 = 4294967424i64;
      LODWORD(v14) = Colour::Colour(&v30, v36, v36, v36, 0x80u);
      (*(*a2 + 160))(a2);
      v5 = Colour::Colour(&v29, v36, v36, v36, 0x80u);
      (*(*a2 + 164))(a2, v5);
      v15 = RectArea::RectArea(&v28, v41, v14, SHIDWORD(v14), v15);
      (*(*a2 + 204))(a2);
      v41 = v41 + v48;
    }
    v40 = v50 + v40;
    ++v39;
  }
  v41 = v43;
  v40 = v44 + 2.0;
  for ( l = *v54; l; l = *(l + 36) )
  {
    v34 = *(l + 12) / 16.666666;
    if ( v51 >= v34 )
    {
      v14 = 4294967551i64;
      LODWORD(v14) = Colour::Colour(&v25, 128, 255, 128, 0xFFu);
      (*(*a2 + 160))(a2, v14, HIDWORD(v14));
      HIDWORD(v14) = Colour::Colour(&v24, 0, 32, 0, 0xFFu);
      (*(*a2 + 164))(a2, HIDWORD(v14));
    }
    else
    {
      v14 = 4294967551i64;
      LODWORD(v14) = Colour::Colour(&v27, 255, 0, 0, 0xFFu);
      (*(*a2 + 160))(a2, v14, HIDWORD(v14));
      HIDWORD(v14) = Colour::Colour(&v26, 32, 0, 0, 0xFFu);
      (*(*a2 + 164))(a2, HIDWORD(v14));
      v34 = v51;
    }
    v34 = v34 * v48;
    v15 = RectArea::RectArea(&v23, v41, (v41 + v34), v40 + v50 - 4, v15);
    (*(*a2 + 204))(a2);
    v33 = *(l + 16) / 16.666666 * v48;
    v14 = 4294967392i64;
    LODWORD(v14) = Colour::Colour(&v22, 255, 192, 64, 0x60u);
    (*(*a2 + 160))(a2);
    v6 = Colour::Colour(&v21, 32, 0, 0, 0x60u);
    (*(*a2 + 164))(a2, v6);
    v15 = RectArea::RectArea(&v20, (v41 + v34), v14, SHIDWORD(v14), v15);
    (*(*a2 + 204))(a2);
    v40 = v50 + v40;
  }
  v40 = v44 - 1.0;
  *&v7 = System::getFrameRate(gsys);
  v14 = v7;
  sprintf(&Dest, "%.1f fps", v7, (v7 >> 32));
  v14 = 4294967551i64;
  LODWORD(v14) = Colour::Colour(&v19, 255, 255, 255, 0xFFu);
  (*(*a2 + 160))(a2, v14);
  v8 = v40 - 14;
  v9 = *(a2 + 196) / 2;
  v10 = Font::stringWidth(a3, &Dest);
  (*(*a2 + 228))(a2, a3, v9 - v10 + 30, v8);
  v14 = 4294967424i64;
  LODWORD(v14) = Colour::Colour(&v18, 255, 255, 255, 0x80u);
  (*(*a2 + 160))(a2, v14, HIDWORD(v14));
  for ( m = *v54; m; m = *(m + 36) )
  {
    HIDWORD(v14) = *m;
    LODWORD(v14) = "%s";
    v11 = v40;
    v12 = (v52 * 0.5);
    v13 = Font::stringWidth(a3, *m);
    (*(*a2 + 228))(a2, a3, v12 - v13, v11, v14, HIDWORD(v14));
    *&v14 = *(m + 12) / 16.666666;
    (*(*a2 + 228))(a2, a3, *(a2 + 196) - (v52 * 0.5), v40, "%.4f", v14, HIDWORD(v14));
    v40 = v50 + v40;
  }
}
// 10001410: using guessed type double __thiscall System::getFrameTime(_DWORD);
// 100016F4: using guessed type double __thiscall System::getFrameRate(_DWORD);

//----- (10058350) --------------------------------------------------------
void __thiscall sub_10058350(_DWORD *this)
{
  int v1; // edi
  int v2; // edi
  int v3; // ST04_4
  _DWORD *v4; // eax
  unsigned __int8 v5; // cf
  int v6; // edi
  int v7; // edi
  int v8; // ST04_4
  _DWORD *v9; // eax
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  _DWORD *v13; // eax
  int v14; // ecx
  int v15; // ecx
  char v16; // [esp+0h] [ebp-CCh]
  int v17; // [esp+4Ch] [ebp-80h]
  int v18; // [esp+50h] [ebp-7Ch]
  int v19; // [esp+54h] [ebp-78h]
  HGLOBAL v20; // [esp+58h] [ebp-74h]
  int kk; // [esp+70h] [ebp-5Ch]
  int jj; // [esp+74h] [ebp-58h]
  int v23; // [esp+78h] [ebp-54h]
  int ii; // [esp+7Ch] [ebp-50h]
  int v25; // [esp+80h] [ebp-4Ch]
  int v26; // [esp+84h] [ebp-48h]
  signed int v27; // [esp+88h] [ebp-44h]
  int n; // [esp+8Ch] [ebp-40h]
  int v29; // [esp+90h] [ebp-3Ch]
  int v30; // [esp+94h] [ebp-38h]
  int v31; // [esp+98h] [ebp-34h]
  signed int m; // [esp+9Ch] [ebp-30h]
  signed int v33; // [esp+A0h] [ebp-2Ch]
  signed int v34; // [esp+A4h] [ebp-28h]
  signed int l; // [esp+ACh] [ebp-20h]
  int k; // [esp+B0h] [ebp-1Ch]
  signed int j; // [esp+B4h] [ebp-18h]
  int i; // [esp+B8h] [ebp-14h]
  _DWORD *v39; // [esp+BCh] [ebp-10h]

  v39 = this;
  for ( i = 0; i < v39[4]; ++i )
  {
    for ( j = 0; j < 3; ++j )
    {
      for ( k = 0; k < v39[4]; ++k )
      {
        if ( i != k )
        {
          for ( l = 0; l < 3; ++l )
          {
            v1 = *sub_1000297D(i);
            if ( *(v1 + 4 * (j % 3)) == *(*sub_1000297D(k) + 4 * (l % 3)) )
            {
              v2 = *sub_1000297D(i);
              if ( *(v2 + 4 * ((j + 1) % 3)) == *(*sub_1000297D(k) + 4 * ((l + 1) % 3)) )
              {
                if ( sub_10002A81(0xCu) )
                {
                  v3 = *sub_1000297D(k);
                  v4 = sub_1000297D(i);
                  v19 = sub_10002509(*v4, v3, j);
                }
                else
                {
                  v19 = 0;
                }
                v5 = __CFADD__(*sub_1000297D(i), 12);
                sub_100018CA(v19);
                break;
              }
            }
            v6 = *sub_1000297D(i);
            if ( *(v6 + 4 * (j % 3)) == *(*sub_1000297D(k) + 4 * ((l + 1) % 3)) )
            {
              v7 = *sub_1000297D(i);
              if ( *(v7 + 4 * ((j + 1) % 3)) == *(*sub_1000297D(k) + 4 * (l % 3)) )
              {
                if ( sub_10002A81(0xCu) )
                {
                  v8 = *sub_1000297D(k);
                  v9 = sub_1000297D(i);
                  v18 = sub_10002509(*v9, v8, j);
                }
                else
                {
                  v18 = 0;
                }
                v5 = __CFADD__(*sub_1000297D(i), 12);
                sub_100018CA(v18);
                break;
              }
            }
          }
        }
      }
    }
  }
  while ( v39[4] )
  {
    v20 = sub_10002A81(0x18u);
    if ( v20 )
      v17 = sub_10002266(v20);
    else
      v17 = 0;
    v34 = -1;
    v33 = 4;
    for ( m = 0; m < v39[4]; ++m )
    {
      if ( *(*sub_1000297D(m) + 16) < v33 )
      {
        v34 = m;
        v33 = *(*sub_1000297D(m) + 16);
      }
    }
    if ( v34 == -1 )
    {
      sub_10058B80("ERROR: could not find starting tri\n", v16);
      return;
    }
    v31 = *sub_1000297D(v34);
    v30 = 0;
    v29 = 0;
    sub_1000145B(v31);
    for ( n = 0; n < *(v31 + 16); ++n )
    {
      v10 = *(*sub_10001677(n) + 4);
      sub_10002D3D(v31);
    }
    sub_1000110E(v31);
    v27 = 1;
    while ( v31 && *(v31 + 16) )
    {
      v26 = *sub_10001677(0);
      if ( v29 )
      {
        v25 = 0;
        for ( ii = 0; ii < *(v31 + 16); ++ii )
        {
          v23 = *sub_10001677(ii);
          if ( !v27 && *(v30 + 4 * ((*(v29 + 8) + 1) % 3)) == *(v31 + 4 * ((*(v23 + 8) + 1) % 3)) )
          {
            v25 = v23;
            break;
          }
          if ( v27 && *(v30 + 4 * (*(v29 + 8) % 3)) == *(v31 + 4 * (*(v23 + 8) % 3)) )
          {
            v25 = v23;
            break;
          }
        }
        v26 = v25;
      }
      if ( !v26 )
        break;
      sub_10002D15(v26);
      sub_10002A72(v26);
      for ( jj = 0; jj < *(*(v26 + 4) + 16); ++jj )
      {
        v11 = *(v26 + 4);
        if ( *(*sub_10001677(jj) + 4) == v31 )
        {
          v12 = *(v26 + 4);
          v13 = sub_10001677(jj);
          v14 = *(v26 + 4);
          sub_10002A72(*v13);
          break;
        }
      }
      v29 = v26;
      v30 = v31;
      v31 = *(v26 + 4);
      v27 ^= 1u;
      sub_1000145B(v31);
      for ( kk = 0; kk < *(v31 + 16); ++kk )
      {
        v15 = *(*sub_10001677(kk) + 4);
        sub_10002D3D(v31);
      }
      sub_1000110E(*(v26 + 4));
    }
    sub_10002621(v17);
  }
}
// 1000110E: using guessed type _DWORD __stdcall sub_1000110E(_DWORD);
// 1000145B: using guessed type _DWORD __stdcall sub_1000145B(_DWORD);
// 10001677: using guessed type _DWORD __stdcall sub_10001677(_DWORD);
// 100018CA: using guessed type _DWORD __stdcall sub_100018CA(_DWORD);
// 10002266: using guessed type int __thiscall sub_10002266(_DWORD);
// 10002509: using guessed type _DWORD __stdcall sub_10002509(_DWORD, _DWORD, _DWORD);
// 10002621: using guessed type _DWORD __stdcall sub_10002621(_DWORD);
// 1000297D: using guessed type _DWORD __stdcall sub_1000297D(_DWORD);
// 10002A72: using guessed type _DWORD __stdcall sub_10002A72(_DWORD);
// 10002D15: using guessed type _DWORD __stdcall sub_10002D15(_DWORD);
// 10002D3D: using guessed type _DWORD __stdcall sub_10002D3D(_DWORD);

//----- (10058B80) --------------------------------------------------------
char *__cdecl sub_10058B80(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "TriStripifier" )
      Stream::print(sysCon, "%s: ", "TriStripifier");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10058C90) --------------------------------------------------------
void *__thiscall sub_10058C90(void *this)
{
  void *v1; // ST50_4

  v1 = this;
  sub_10002D74(0);
  sub_10001186(0);
  return v1;
}
// 10001186: using guessed type _DWORD __stdcall sub_10001186(_DWORD);
// 10002D74: using guessed type _DWORD __stdcall sub_10002D74(_DWORD);

//----- (10058D30) --------------------------------------------------------
char *__thiscall sub_10058D30(_DWORD *this, int a2)
{
  int v2; // ecx
  unsigned __int8 v3; // cf
  _BYTE **v4; // eax
  _DWORD **v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ST04_4
  int v16; // ecx
  _DWORD **v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // ecx
  _DWORD **v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // ecx
  _DWORD **v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // eax
  int ii; // [esp+4Ch] [ebp-44h]
  int n; // [esp+50h] [ebp-40h]
  int m; // [esp+54h] [ebp-3Ch]
  int v45; // [esp+58h] [ebp-38h]
  int v46; // [esp+5Ch] [ebp-34h]
  int v47; // [esp+60h] [ebp-30h]
  int l; // [esp+64h] [ebp-2Ch]
  int k; // [esp+68h] [ebp-28h]
  int j; // [esp+6Ch] [ebp-24h]
  int v51; // [esp+70h] [ebp-20h]
  int v52; // [esp+74h] [ebp-1Ch]
  int v53; // [esp+78h] [ebp-18h]
  int v54; // [esp+7Ch] [ebp-14h]
  int v55; // [esp+80h] [ebp-10h]
  int i; // [esp+84h] [ebp-Ch]
  int v57; // [esp+88h] [ebp-8h]
  _DWORD *v58; // [esp+8Ch] [ebp-4h]

  v58 = this;
  v57 = 0;
  for ( i = 0; i < v58[7]; ++i )
  {
    v2 = *sub_10001FAF(i);
    v55 = *sub_1000297D(0);
    if ( *(*sub_10001FAF(i) + 16) )
    {
      v3 = __CFADD__(*sub_10001FAF(i), 12);
      v53 = *(v55 + 4 * *(*sub_10001677(0) + 8));
      v3 = __CFADD__(*sub_10001FAF(i), 12);
      v54 = *(v55 + 4 * ((*(*sub_10001677(0) + 8) + 1) % 3));
      v52 = *(*sub_10001FAF(i) + 4) + 2;
      v51 = 0;
      v58[11] += v52;
      (*(*a2 + 32))(a2, 152);
      (*(*a2 + 32))(a2, v52 >> 8);
      (*(*a2 + 32))(a2, v52);
      for ( j = 0; j < 3; ++j )
      {
        if ( *(v55 + 4 * j) != v53 && *(v55 + 4 * j) != v54 )
        {
          for ( k = 0; k < 3; ++k )
          {
            ++v51;
            if ( v58[12] & 1 )
            {
              v4 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
              LOBYTE(v4) = **v4;
              (*(*a2 + 32))(a2, v4);
            }
            if ( v58[12] & 2 )
            {
              v5 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
              (*(*a2 + 32))(a2, **v5 + 30);
            }
            v6 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
            (*(*a2 + 32))(a2, *(*v6 + 4) >> 8);
            v7 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
            (*(*a2 + 32))(a2, *(*v7 + 4) & 0xFF);
            v8 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
            (*(*a2 + 32))(a2, *(*v8 + 8) >> 8);
            v9 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
            (*(*a2 + 32))(a2, *(*v9 + 8) & 0xFF);
            v10 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
            (*(*a2 + 32))(a2, *(*v10 + 8) >> 8);
            v11 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
            (*(*a2 + 32))(a2, *(*v11 + 8) & 0xFF);
            v12 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
            (*(*a2 + 32))(a2, *(*v12 + 12) >> 8);
            v13 = sub_10002504(*(v55 + 4 * ((k + j) % 3)));
            (*(*a2 + 32))(a2, *(*v13 + 12) & 0xFF);
          }
          break;
        }
      }
      for ( l = 0; ; ++l )
      {
        v14 = sub_10001FAF(i);
        if ( l >= *(*v14 + 16) )
          break;
        v15 = l;
        v3 = __CFADD__(*sub_10001FAF(i), 12);
        v47 = *sub_10001677(v15);
        if ( l )
        {
          v45 = *(v55 + 4 * *(v47 + 8));
          v46 = *(v55 + 4 * ((*(v47 + 8) + 1) % 3));
          for ( m = 0; m < 2; ++m )
          {
            if ( *(&v45 + m) != v53 && *(&v45 + m) != v54 )
            {
              ++v51;
              if ( v58[12] & 1 )
              {
                LOBYTE(v16) = **sub_10002504(*(&v45 + m));
                (*(*a2 + 32))(a2, v16);
              }
              if ( v58[12] & 2 )
              {
                v17 = sub_10002504(*(&v45 + m));
                (*(*a2 + 32))(a2, **v17 + 30);
              }
              v18 = sub_10002504(*(&v45 + m));
              (*(*a2 + 32))(a2, *(*v18 + 4) >> 8);
              v19 = sub_10002504(*(&v45 + m));
              (*(*a2 + 32))(a2, *(*v19 + 4) & 0xFF);
              v20 = sub_10002504(*(&v45 + m));
              (*(*a2 + 32))(a2, *(*v20 + 8) >> 8);
              v21 = sub_10002504(*(&v45 + m));
              (*(*a2 + 32))(a2, *(*v21 + 8) & 0xFF);
              v22 = sub_10002504(*(&v45 + m));
              (*(*a2 + 32))(a2, *(*v22 + 12) >> 8);
              v23 = sub_10002504(*(&v45 + m));
              (*(*a2 + 32))(a2, *(*v23 + 12) & 0xFF);
              if ( *(&v45 + (m ^ 1)) == v53 )
                v54 = *(&v45 + m);
              else
                v53 = *(&v45 + m);
              break;
            }
          }
        }
        v55 = *(v47 + 4);
      }
      for ( n = 0; n < 3; ++n )
      {
        if ( *(v55 + 4 * n) != v53 && *(v55 + 4 * n) != v54 )
        {
          ++v51;
          if ( v58[12] & 1 )
          {
            LOBYTE(v24) = **sub_10002504(*(v55 + 4 * n));
            (*(*a2 + 32))(a2, v24);
          }
          if ( v58[12] & 2 )
          {
            v25 = sub_10002504(*(v55 + 4 * n));
            (*(*a2 + 32))(a2, **v25 + 30);
          }
          v26 = sub_10002504(*(v55 + 4 * n));
          (*(*a2 + 32))(a2, *(*v26 + 4) >> 8);
          v27 = sub_10002504(*(v55 + 4 * n));
          (*(*a2 + 32))(a2, *(*v27 + 4) & 0xFF);
          v28 = sub_10002504(*(v55 + 4 * n));
          (*(*a2 + 32))(a2, *(*v28 + 8) >> 8);
          v29 = sub_10002504(*(v55 + 4 * n));
          (*(*a2 + 32))(a2, *(*v29 + 8) & 0xFF);
          v30 = sub_10002504(*(v55 + 4 * n));
          (*(*a2 + 32))(a2, *(*v30 + 12) >> 8);
          v31 = sub_10002504(*(v55 + 4 * n));
          (*(*a2 + 32))(a2, *(*v31 + 12) & 0xFF);
          break;
        }
      }
    }
    else
    {
      (*(*a2 + 32))(a2, 160);
      (*(*a2 + 32))(a2, 0);
      (*(*a2 + 32))(a2, 3);
      v58[11] += 3;
      for ( ii = 0; ii < 3; ++ii )
      {
        if ( v58[12] & 1 )
        {
          LOBYTE(v32) = **sub_10002504(*(v55 + 4 * ii));
          (*(*a2 + 32))(a2, v32);
        }
        if ( v58[12] & 2 )
        {
          v33 = sub_10002504(*(v55 + 4 * ii));
          (*(*a2 + 32))(a2, **v33 + 30);
        }
        v34 = sub_10002504(*(v55 + 4 * ii));
        (*(*a2 + 32))(a2, *(*v34 + 4) >> 8);
        v35 = sub_10002504(*(v55 + 4 * ii));
        (*(*a2 + 32))(a2, *(*v35 + 4) & 0xFF);
        v36 = sub_10002504(*(v55 + 4 * ii));
        (*(*a2 + 32))(a2, *(*v36 + 8) >> 8);
        v37 = sub_10002504(*(v55 + 4 * ii));
        (*(*a2 + 32))(a2, *(*v37 + 8) & 0xFF);
        v38 = sub_10002504(*(v55 + 4 * ii));
        (*(*a2 + 32))(a2, *(*v38 + 12) >> 8);
        v39 = sub_10002504(*(v55 + 4 * ii));
        (*(*a2 + 32))(a2, *(*v39 + 12) & 0xFF);
      }
    }
    v40 = sub_10001FAF(i);
    v57 += *(*v40 + 4);
  }
  return sub_10058B80("strip loads = %d\n", v58[11]);
}
// 10001677: using guessed type _DWORD __stdcall sub_10001677(_DWORD);
// 10001FAF: using guessed type _DWORD __stdcall sub_10001FAF(_DWORD);
// 10002504: using guessed type _DWORD __stdcall sub_10002504(_DWORD);
// 1000297D: using guessed type _DWORD __stdcall sub_1000297D(_DWORD);

//----- (10059AF0) --------------------------------------------------------
int __thiscall sub_10059AF0(_DWORD *this, int a2)
{
  if ( a2 < 0 || a2 >= this[1] )
    assert("i>=0 && i<num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x21u);
  return *this + 4 * a2;
}

//----- (10059B80) --------------------------------------------------------
int __thiscall sub_10059B80(_DWORD *this, int a2)
{
  if ( a2 < 0 || a2 >= this[1] )
    assert("i>=0 && i<num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x21u);
  return *this + 4 * a2;
}

//----- (10059C10) --------------------------------------------------------
int __thiscall sub_10059C10(_DWORD *this, int a2)
{
  if ( a2 < 0 || a2 >= this[1] )
    assert("i>=0 && i<num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x21u);
  return *this + 4 * a2;
}

//----- (10059CA0) --------------------------------------------------------
int __thiscall sub_10059CA0(_DWORD *this, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  if ( this[1] > this[2] )
    assert("num<=array_size", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x57u);
  if ( this[1] == this[2] )
  {
    if ( this[2] )
      sub_1000100A(2 * this[2]);
    else
      sub_1000100A(16);
  }
  *(*v3 + 4 * v3[1]) = a2;
  result = v3[1] + 1;
  v3[1] = result;
  return result;
}
// 1000100A: using guessed type _DWORD __stdcall sub_1000100A(_DWORD);

//----- (10059D80) --------------------------------------------------------
char __stdcall sub_10059D80(int a1)
{
  if ( sub_10001005(a1) )
    return 0;
  sub_10002D15(a1);
  return 1;
}
// 10001005: using guessed type _DWORD __stdcall sub_10001005(_DWORD);
// 10002D15: using guessed type _DWORD __stdcall sub_10002D15(_DWORD);

//----- (10059DF0) --------------------------------------------------------
_DWORD *__thiscall sub_10059DF0(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  int i; // [esp+4Ch] [ebp-8h]
  int j; // [esp+4Ch] [ebp-8h]
  _DWORD *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  for ( i = 0; i < this[1] && *(*this + 4 * i) != a2; ++i )
    ;
  sub_10002BF8(i);
  for ( j = 0; ; ++j )
  {
    result = v5;
    if ( j >= v5[1] )
      break;
    if ( *(*v5 + 4 * j) == a2 )
      assert("element[i] != t", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x8Fu);
  }
  return result;
}
// 10002BF8: using guessed type _DWORD __stdcall sub_10002BF8(_DWORD);

//----- (10059EE0) --------------------------------------------------------
_DWORD *__thiscall sub_10059EE0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  if ( a2 >= this[1] )
    assert("i<num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x7Du);
  --this[1];
  while ( 1 )
  {
    result = this;
    if ( a2 >= this[1] )
      break;
    *(*this + 4 * a2) = *(*this + 4 * a2 + 4);
    ++a2;
  }
  return result;
}

//----- (10059FA0) --------------------------------------------------------
_DWORD *__thiscall sub_10059FA0(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  int i; // [esp+4Ch] [ebp-8h]
  int j; // [esp+4Ch] [ebp-8h]
  _DWORD *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  for ( i = 0; i < this[1] && *(*this + 4 * i) != a2; ++i )
    ;
  sub_10001C6C(i);
  for ( j = 0; ; ++j )
  {
    result = v5;
    if ( j >= v5[1] )
      break;
    if ( *(*v5 + 4 * j) == a2 )
      assert("element[i] != t", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x8Fu);
  }
  return result;
}
// 10001C6C: using guessed type _DWORD __stdcall sub_10001C6C(_DWORD);

//----- (1005A090) --------------------------------------------------------
int __thiscall sub_1005A090(_DWORD *this, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  if ( this[1] > this[2] )
    assert("num<=array_size", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x57u);
  if ( this[1] == this[2] )
  {
    if ( this[2] )
      sub_10001730(2 * this[2]);
    else
      sub_10001730(16);
  }
  *(*v3 + 4 * v3[1]) = a2;
  result = v3[1] + 1;
  v3[1] = result;
  return result;
}
// 10001730: using guessed type _DWORD __stdcall sub_10001730(_DWORD);

//----- (1005A170) --------------------------------------------------------
int __thiscall sub_1005A170(_DWORD *this, int a2)
{
  int v3; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]

  v3 = 0;
  for ( i = 0; i < this[1]; ++i )
  {
    if ( *(*this + 4 * i) == a2 )
      ++v3;
  }
  return v3;
}

//----- (1005A200) --------------------------------------------------------
_DWORD *__thiscall sub_1005A200(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  if ( a2 >= this[1] )
    assert("i<num", "c:\\development\\dolphinpiki\\syscommon\\llist.h", 0x7Du);
  --this[1];
  while ( 1 )
  {
    result = this;
    if ( a2 >= this[1] )
      break;
    *(*this + 4 * a2) = *(*this + 4 * a2 + 4);
    ++a2;
  }
  return result;
}

//----- (1005A2C0) --------------------------------------------------------
_DWORD *__thiscall sub_1005A2C0(_DWORD *this, int a2, int a3, int a4)
{
  *this = a2;
  this[1] = a3;
  this[2] = a4;
  return this;
}

//----- (1005A320) --------------------------------------------------------
void __thiscall sub_1005A320(_DWORD *this, int a2)
{
  int i; // [esp+4Ch] [ebp-8h]
  _DWORD *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  for ( i = 0; i < v3[4]; ++i )
  {
    if ( *(*sub_10001677(i) + 4) == a2 )
    {
      sub_10002BF8(i);
      return;
    }
  }
}
// 10001677: using guessed type _DWORD __stdcall sub_10001677(_DWORD);
// 10002BF8: using guessed type _DWORD __stdcall sub_10002BF8(_DWORD);

//----- (1005A3C0) --------------------------------------------------------
Graphics *__thiscall sub_1005A3C0(Graphics *this, int a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  Graphics *v8; // [esp+4Ch] [ebp-4h]

  v8 = this;
  Graphics::Graphics(this);
  String::String((v8 + 952));
  String::String((v8 + 960));
  String::String((v8 + 968));
  String::String((v8 + 976));
  RectArea::RectArea((v8 + 984));
  *v8 = &off_101AF7F8;
  *(v8 + 196) = a2;
  *(v8 + 197) = a3;
  v3 = glGetString(0x1F00u);
  String::init((v8 + 952), v3);
  v4 = glGetString(0x1F01u);
  String::init((v8 + 960), v4);
  v5 = glGetString(0x1F02u);
  String::init((v8 + 968), v5);
  v6 = glGetString(0x1F03u);
  String::init((v8 + 976), v6);
  if ( !dword_101D5A84 )
  {
    sub_1005A690("Vendor: %s\n", *(v8 + 239));
    sub_1005A690("Renderer: %s\n", *(v8 + 241));
    sub_1005A690("Version: %s\n", *(v8 + 243));
    if ( String::contains((v8 + 976), "GL_EXT_compiled_vertex_array") )
    {
      byte_101D5A80 = 1;
      dword_101D5A84 = wglGetProcAddress("glLockArraysEXT");
      dword_101D5A88 = wglGetProcAddress("glUnlockArraysEXT");
    }
    if ( String::contains((v8 + 976), "GL_ARB_multitexture") )
    {
      dword_101D5A8C = wglGetProcAddress("glActiveTextureARB");
      dword_101D5A90 = wglGetProcAddress("glMultiTexCoord2fARB");
      dword_101D5A94 = wglGetProcAddress("glClientActiveTextureARB");
    }
  }
  return v8;
}
// 101AF7F8: using guessed type void (__thiscall *off_101AF7F8)(Graphics *this);
// 101D5A80: using guessed type char byte_101D5A80;
// 101D5A84: using guessed type int dword_101D5A84;
// 101D5A88: using guessed type int dword_101D5A88;
// 101D5A8C: using guessed type int (__stdcall *dword_101D5A8C)(_DWORD);
// 101D5A90: using guessed type int dword_101D5A90;
// 101D5A94: using guessed type int (__stdcall *dword_101D5A94)(_DWORD);

//----- (1005A690) --------------------------------------------------------
char *__cdecl sub_1005A690(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "OGLGraphics" )
      Stream::print(sysCon, "%s: ", "OGLGraphics");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1005A7A0) --------------------------------------------------------
void __thiscall sub_1005A7A0(Graphics *this, GLsizei width, GLsizei height)
{
  int v3; // eax
  char v4; // [esp+4Ch] [ebp-Ch]
  GLint params; // [esp+50h] [ebp-8h]
  Graphics *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  Graphics::initRender(this, width, height);
  dword_101D5A98 ^= 1u;
  *(v6 + 222) = 1065353216;
  glViewport(0, 0, width, height);
  byte_101D5A9C = 0;
  glEnable(0xC11u);
  glEnable(0xB71u);
  glDepthFunc(0x203u);
  glPolygonMode(0x404u, 0x1B02u);
  *(v6 + 224) = 1065353216;
  glLineWidth(*(v6 + 224));
  glPointSize(4.0);
  glDepthFunc(0x203u);
  glEnable(0xB71u);
  glDisable(0xBD0u);
  glDisable(0xDE1u);
  v3 = Colour::Colour(&v4, 255, 255, 255, 0xFFu);
  (*(*v6 + 160))(v6, v3, 1);
  glDisable(0xB50u);
  glEnable(0xBA1u);
  *(v6 + 804) = 0;
  glShadeModel(0x1D01u);
  (*(*v6 + 196))(v6, 0, 0);
  glEnable(0xBE2u);
  glBlendFunc(0x302u, 0x303u);
  *(v6 + 204) = 0;
  glDepthMask(1u);
  *(v6 + 805) = 1;
  glEnable(0xB44u);
  glCullFace(0x404u);
  *(v6 + 205) = 1;
  *(v6 + 206) = 0;
  glGetIntegerv(0xC01u, &params);
  glDrawBuffer(0x405u);
  *(v6 + 202) = 0;
  *(v6 + 225) = 0;
  *(v6 + 2) = 1792;
  (*(*v6 + 184))(v6, 0);
  StdSystem::resetLFlares(gsys);
}
// 101D5A98: using guessed type int dword_101D5A98;
// 101D5A9C: using guessed type char byte_101D5A9C;

//----- (1005AB60) --------------------------------------------------------
int __thiscall sub_1005AB60(_DWORD *this, int a2, int a3)
{
  int result; // eax
  int j; // [esp+4Ch] [ebp-4Ch]
  int i; // [esp+50h] [ebp-48h]
  GLfloat m[16]; // [esp+54h] [ebp-44h]
  _DWORD *v7; // [esp+94h] [ebp-4h]

  v7 = this;
  Matrix4f::Matrix4f(m);
  v7[4] = a2;
  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
      m[4 * j + i] = *(16 * i + a2 + 4 * j);
  }
  glLoadMatrixf(m);
  if ( v7[207] )
    result = (*(*v7 + 220))(v7, 1, v7[207]);
  else
    result = (*(*v7 + 220))(v7, 0, 0);
  return result;
}
// 1005AB60: using guessed type GLfloat m[16];

//----- (1005ACA0) --------------------------------------------------------
_DWORD *__thiscall sub_1005ACA0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[186] = a2;
  return result;
}

//----- (1005ACE0) --------------------------------------------------------
void __thiscall sub_1005ACE0(_DWORD *this, struct Matrix4f *a2, struct Matrix4f *a3)
{
  this[3] = a2;
  Matrix4f::multiplyTo((this[186] + 480), a2, a3);
}

//----- (1005AD50) --------------------------------------------------------
int __thiscall sub_1005AD50(_DWORD *this, int a2)
{
  int v3; // [esp+50h] [ebp-8h]

  v3 = this[204];
  this[204] = a2;
  if ( a2 != 4 )
    glEnable(0xB71u);
  switch ( a2 )
  {
    case 0:
      glBlendFunc(0x302u, 0x303u);
      glDepthMask(1u);
      break;
    case 1:
      glBlendFunc(0x300u, 1u);
      glDepthMask(0);
      break;
    case 2:
      glBlendFunc(0, 0x301u);
      glDepthMask(1u);
      break;
    case 3:
      glBlendFunc(0x302u, 1u);
      glDepthMask(0);
      break;
    case 4:
      glBlendFunc(0x300u, 1u);
      glDepthMask(0);
      glDisable(0xB71u);
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (1005AF30) --------------------------------------------------------
int __thiscall sub_1005AF30(_DWORD *this, int a2)
{
  int v3; // [esp+4Ch] [ebp-8h]

  v3 = this[205];
  this[205] = a2;
  if ( a2 == 1 )
  {
    glEnable(0xB44u);
    glCullFace(0x405u);
  }
  else if ( a2 )
  {
    glDisable(0xB44u);
  }
  else
  {
    glEnable(0xB44u);
    glCullFace(0x404u);
  }
  return v3;
}

//----- (1005B020) --------------------------------------------------------
char __thiscall sub_1005B020(_BYTE *this, char a2)
{
  char v3; // [esp+4Ch] [ebp-8h]

  v3 = this[805];
  this[805] = a2;
  if ( a2 )
    glDepthMask(1u);
  else
    glDepthMask(0);
  return v3;
}

//----- (1005B0C0) --------------------------------------------------------
char __thiscall sub_1005B0C0(_BYTE *this, char a2, int a3)
{
  signed int i; // [esp+4Ch] [ebp-Ch]
  char v5; // [esp+50h] [ebp-8h]
  _BYTE *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  v5 = this[804];
  this[804] = a2;
  for ( i = 0; i < 8; ++i )
  {
    if ( a2 && (1 << i) & *(v6 + 223) )
      glEnable(i + 0x4000);
    else
      glDisable(i + 0x4000);
  }
  if ( a2 )
    glEnable(0xB50u);
  else
    glDisable(0xB50u);
  return v5;
}

//----- (1005B200) --------------------------------------------------------
void __thiscall sub_1005B200(int this, int a2, int a3)
{
  GLfloat v3; // [esp+6Ch] [ebp-6Ch]
  int v4; // [esp+70h] [ebp-68h]
  int v5; // [esp+74h] [ebp-64h]
  int v6; // [esp+78h] [ebp-60h]
  GLfloat v7; // [esp+7Ch] [ebp-5Ch]
  int v8; // [esp+80h] [ebp-58h]
  int v9; // [esp+84h] [ebp-54h]
  int v10; // [esp+88h] [ebp-50h]
  float v11; // [esp+8Ch] [ebp-4Ch]
  int v12; // [esp+90h] [ebp-48h]
  int v13; // [esp+94h] [ebp-44h]
  GLfloat v14; // [esp+98h] [ebp-40h]
  float v15; // [esp+9Ch] [ebp-3Ch]
  float v16; // [esp+A0h] [ebp-38h]
  float v17; // [esp+A4h] [ebp-34h]
  GLfloat params; // [esp+A8h] [ebp-30h]
  int v19; // [esp+ACh] [ebp-2Ch]
  int v20; // [esp+B0h] [ebp-28h]
  int v21; // [esp+B4h] [ebp-24h]
  float v22; // [esp+B8h] [ebp-20h]
  int v23; // [esp+BCh] [ebp-1Ch]
  int v24; // [esp+C0h] [ebp-18h]
  GLfloat v25; // [esp+C4h] [ebp-14h]
  float v26; // [esp+C8h] [ebp-10h]
  float v27; // [esp+CCh] [ebp-Ch]
  float v28; // [esp+D0h] [ebp-8h]
  int v29; // [esp+D4h] [ebp-4h]

  v29 = this;
  v25 = *(this + 876) / 256.0;
  v26 = *(this + 877) / 256.0;
  v27 = *(this + 878) / 256.0;
  v28 = *(this + 879) / 256.0 * *(this + 888);
  Vector3f::Vector3f(&v22, (a2 + 84));
  Vector3f::multMatrix(&v22, (*(v29 + 744) + 480));
  params = v22;
  v19 = v23;
  v20 = v24;
  v21 = 1065353216;
  glLightfv(a3 + 0x4000, 0x1203u, &params);
  v14 = *(a2 + 108) / 256.0;
  v15 = *(a2 + 109) / 256.0;
  v16 = *(a2 + 110) / 256.0;
  v17 = *(a2 + 111) * *(v29 + 888) / 256.0;
  glLightfv(a3 + 0x4000, 0x1200u, &v25);
  glLightfv(a3 + 0x4000, 0x1201u, &v14);
  if ( (*(a2 + 20) & 0xFF) == 3 )
  {
    Vector3f::Vector3f(&v11, (a2 + 96));
    Vector3f::rotate(&v11, (*(v29 + 744) + 480));
    v7 = v11;
    v8 = v12;
    v9 = v13;
    v10 = 1065353216;
    glLightfv(a3 + 0x4000, 0x1204u, &v7);
    glLightf(a3 + 0x4000, 0x1206u, *(a2 + 32));
    glLightf(a3 + 0x4000, 0x1205u, *(a2 + 32));
  }
  else
  {
    v3 = 0.0;
    v4 = 0;
    v5 = -1082130432;
    v6 = 1065353216;
    glLightfv(a3 + 0x4000, 0x1204u, &v3);
    glLightf(a3 + 0x4000, 0x1206u, 180.0);
    glLightf(a3 + 0x4000, 0x1205u, 0.0);
  }
  glLightf(a3 + 0x4000, 0x1207u, *(a2 + 44));
  glLightf(a3 + 0x4000, 0x1208u, *(a2 + 48));
  glLightf(a3 + 0x4000, 0x1209u, *(a2 + 52));
}

//----- (1005B660) --------------------------------------------------------
void __stdcall sub_1005B660(GLfloat size)
{
  glPointSize(size);
}

//----- (1005B6C0) --------------------------------------------------------
void __thiscall sub_1005B6C0(GLfloat *this, int a2)
{
  int v2; // ST50_4

  v2 = *(this + 224);
  *(this + 224) = a2;
  glLineWidth(this[224]);
}

//----- (1005B740) --------------------------------------------------------
void __thiscall sub_1005B740(_DWORD *this, RectArea *a2)
{
  _DWORD *v2; // ST5C_4
  _DWORD *v3; // ecx
  GLsizei v4; // ST0C_4
  GLsizei v5; // ST08_4
  int v6; // eax

  v2 = this;
  v3 = this + 246;
  *v3 = *a2;
  v3[1] = *(a2 + 1);
  v3[2] = *(a2 + 2);
  v3[3] = *(a2 + 3);
  v4 = RectArea::height(a2);
  v5 = RectArea::width(a2);
  v6 = RectArea::height(a2);
  glViewport(*a2, v2[197] - (v6 + *(a2 + 1)), v5, v4);
}

//----- (1005B800) --------------------------------------------------------
void __thiscall sub_1005B800(int this, _DWORD *a2)
{
  int v2; // ST5C_4
  GLsizei v3; // ST0C_4
  GLsizei v4; // eax

  v2 = this;
  v3 = RectArea::height((this + 984));
  v4 = RectArea::width((v2 + 984));
  glViewport(*a2 + *(v2 + 984), a2[1] + *(v2 + 988), v4, v3);
}

//----- (1005B8A0) --------------------------------------------------------
void __thiscall sub_1005B8A0(_DWORD *this, RectArea *a2)
{
  _DWORD *v2; // ST5C_4
  GLsizei v3; // ST0C_4
  GLsizei v4; // ST08_4
  int v5; // eax

  v2 = this;
  v3 = RectArea::height(a2);
  v4 = RectArea::width(a2);
  v5 = RectArea::height(a2);
  glScissor(*a2, v2[197] - (v5 + *(a2 + 1)), v4, v3);
}

//----- (1005B930) --------------------------------------------------------
_DWORD *__thiscall sub_1005B930(_DWORD *this, int a2, signed int *a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+7Ch] [ebp-4h]

  v4 = this;
  glMatrixMode(0x1701u);
  glLoadIdentity();
  glOrtho(*a3, a3[2], a3[3], a3[1], -2.0, 2.0);
  glMatrixMode(0x1700u);
  glLoadIdentity();
  glDisable(0xBC0u);
  glDisable(0xB71u);
  (*(*v4 + 40))(v4, 0, 0);
  glEnable(0xBE2u);
  glBlendFunc(0x302u, 0x303u);
  (*(*v4 + 64))(v4, a3);
  (*(*v4 + 72))(v4, a3);
  result = v4;
  v4[222] = 1065353216;
  return result;
}

//----- (1005BB00) --------------------------------------------------------
void __thiscall sub_1005BB00(void *this, int a2, float a3, float a4, float a5, float a6, GLfloat x)
{
  signed int j; // [esp+6Ch] [ebp-4Ch]
  signed int i; // [esp+70h] [ebp-48h]
  GLfloat params[16]; // [esp+74h] [ebp-44h]
  void *v10; // [esp+B4h] [ebp-4h]

  v10 = this;
  glLoadIdentity();
  glMatrixMode(0x1701u);
  glLoadIdentity();
  gluPerspective(a3, a4, a5, a6);
  glScalef(x, x, 1.0);
  glGetFloatv(0xBA7u, params);
  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
      *(16 * j + a2 + 4 * i) = params[4 * i + j];
  }
  glMatrixMode(0x1700u);
  glLoadIdentity();
  glEnable(0xB71u);
}
// 1005BB00: using guessed type GLfloat params[16];

//----- (1005BCB0) --------------------------------------------------------
void __thiscall sub_1005BCB0(void *this, char a2, float *a3)
{
  GLdouble equation; // [esp+4Ch] [ebp-24h]
  double v4; // [esp+54h] [ebp-1Ch]
  double v5; // [esp+5Ch] [ebp-14h]
  double v6; // [esp+64h] [ebp-Ch]
  void *v7; // [esp+6Ch] [ebp-4h]

  v7 = this;
  if ( a2 )
  {
    glEnable(0x3000u);
    equation = *a3;
    v4 = a3[1];
    v5 = a3[2];
    v6 = a3[3];
    glClipPlane(0x3000u, &equation);
  }
  else
  {
    glDisable(0x3000u);
  }
}

//----- (1005BD80) --------------------------------------------------------
int __thiscall sub_1005BD80(_DWORD *this, int a2, int a3)
{
  int result; // eax
  _DWORD *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  if ( a2 )
  {
    glEnable(0xDE1u);
    if ( a2 != v4[a3 + 187] )
    {
      if ( a2 )
        glBindTexture(0xDE1u, *(a2 + 24));
      else
        glBindTexture(0xDE1u, 0);
    }
  }
  else
  {
    glDisable(0xDE1u);
  }
  result = a3;
  v4[a3 + 187] = a2;
  return result;
}

//----- (1005BE60) --------------------------------------------------------
void __thiscall sub_1005BE60(_DWORD *this, char a2, GLfloat *a3)
{
  signed int l; // [esp+4Ch] [ebp-158h]
  signed int k; // [esp+50h] [ebp-154h]
  int v5; // [esp+54h] [ebp-150h]
  GLfloat v6[16]; // [esp+58h] [ebp-14Ch]
  GLfloat v7; // [esp+98h] [ebp-10Ch]
  int j; // [esp+D8h] [ebp-CCh]
  int i; // [esp+DCh] [ebp-C8h]
  char v10[64]; // [esp+E0h] [ebp-C4h]
  GLfloat m[16]; // [esp+120h] [ebp-84h]
  GLfloat v12; // [esp+160h] [ebp-44h]
  int v13; // [esp+164h] [ebp-40h]
  int v14; // [esp+168h] [ebp-3Ch]
  int v15; // [esp+16Ch] [ebp-38h]
  GLfloat v16; // [esp+170h] [ebp-34h]
  int v17; // [esp+174h] [ebp-30h]
  int v18; // [esp+178h] [ebp-2Ch]
  int v19; // [esp+17Ch] [ebp-28h]
  GLfloat v20; // [esp+180h] [ebp-24h]
  int v21; // [esp+184h] [ebp-20h]
  int v22; // [esp+188h] [ebp-1Ch]
  int v23; // [esp+18Ch] [ebp-18h]
  GLfloat params; // [esp+190h] [ebp-14h]
  int v25; // [esp+194h] [ebp-10h]
  int v26; // [esp+198h] [ebp-Ch]
  int v27; // [esp+19Ch] [ebp-8h]
  _DWORD *v28; // [esp+1A0h] [ebp-4h]

  v28 = this;
  if ( a2 )
  {
    params = 1.0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v20 = 0.0;
    v21 = 1065353216;
    v22 = 0;
    v23 = 0;
    v16 = 0.0;
    v17 = 0;
    v18 = 1065353216;
    v19 = 0;
    v12 = 0.0;
    v13 = 0;
    v14 = 0;
    v15 = 1065353216;
    glTexGenfv(0x2000u, 0x2501u, &params);
    glTexGenfv(0x2001u, 0x2501u, &v20);
    glTexGenfv(0x2002u, 0x2501u, &v16);
    glTexGenfv(0x2003u, 0x2501u, &v12);
    glTexGeni(0x2000u, 0x2500u, 9217);
    glTexGeni(0x2001u, 0x2500u, 9217);
    glTexGeni(0x2002u, 0x2500u, 9217);
    glTexGeni(0x2003u, 0x2500u, 9217);
    glEnable(0xC60u);
    glEnable(0xC61u);
    glEnable(0xC62u);
    glEnable(0xC63u);
    glTexEnvi(0x2300u, 0x2200u, 8448);
    Matrix4f::Matrix4f(m);
    qmemcpy(v10, a3 + 120, sizeof(v10));
    for ( i = 0; i < 4; ++i )
    {
      for ( j = 0; j < 4; ++j )
        m[4 * i + j] = *&v10[16 * j + 4 * i];
    }
    Matrix4f::Matrix4f(&v7);
    Matrix4f::Matrix4f(v6);
    glGetFloatv(0xBA7u, &v7);
    Matrix4f::multiply(m, &v7);
    glMatrixMode(0x1702u);
    glLoadIdentity();
    glTranslatef(0.5, 0.5, 0.0);
    glScalef(a3[215], a3[216], a3[217]);
    glMultMatrixf(m);
    v5 = v28[186] + 480;
    for ( k = 0; k < 4; ++k )
    {
      for ( l = 0; l < 4; ++l )
        v6[4 * k + l] = *(16 * l + v5 + 4 * k);
    }
    glMultMatrixf(v6);
    glMatrixMode(0x1700u);
  }
  else
  {
    glDisable(0xC60u);
    glDisable(0xC61u);
    glDisable(0xC62u);
    glDisable(0xC63u);
    glMatrixMode(0x1702u);
    glLoadIdentity();
    glMatrixMode(0x1700u);
  }
}
// 1005BE60: using guessed type GLfloat m[16];
// 1005BE60: using guessed type char var_C4[64];
// 1005BE60: using guessed type GLfloat var_14C[16];

//----- (1005C450) --------------------------------------------------------
void __stdcall sub_1005C450(char a1)
{
  if ( a1 )
  {
    glMatrixMode(0x1702u);
    glLoadIdentity();
    glMatrixMode(0x1700u);
    glEnable(0xC60u);
    glEnable(0xC61u);
    glTexGenf(0x2000u, 0x2500u, 9218.0);
    glTexGenf(0x2001u, 0x2500u, 9218.0);
    glTexEnvi(0x2300u, 0x2200u, 260);
  }
  else
  {
    glMatrixMode(0x1702u);
    glLoadIdentity();
    glMatrixMode(0x1700u);
  }
}

//----- (1005C5D0) --------------------------------------------------------
int sub_1005C5D0()
{
  return sub_1005C610();
}

//----- (1005C610) --------------------------------------------------------
int sub_1005C610()
{
  sub_1000291E(&unk_101D5480, 12, 128, Vector3f::Vector3f);
  return sub_1000291E(&unk_101D4E80, 12, 128, Vector3f::Vector3f);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1005C680) --------------------------------------------------------
int sub_1005C680()
{
  return sub_1005C6C0();
}

//----- (1005C6C0) --------------------------------------------------------
int sub_1005C6C0()
{
  return sub_1000291E(&unk_101D4A80, 8, 128, Vector2f::Vector2f);
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1005C710) --------------------------------------------------------
void __thiscall sub_1005C710(_DWORD *this, Material *a2, int a3)
{
  struct Colour *v3; // eax
  char v4; // [esp+4Ch] [ebp-8h]
  _DWORD **v5; // [esp+50h] [ebp-4h]

  v5 = this;
  this[214] = a2;
  if ( a2 )
  {
    if ( *(a2 + 6) & 0x100 )
    {
      glDisable(0xBC0u);
      glDisable(0xBE2u);
      glDepthMask(1u);
    }
    else if ( *(a2 + 6) & 0x200 )
    {
      glEnable(0xBC0u);
      glAlphaFunc(0x206u, 0.5);
      glDisable(0xBE2u);
      glDepthMask(1u);
    }
    else if ( *(a2 + 6) & 0x400 )
    {
      glDisable(0xBC0u);
      glEnable(0xBE2u);
      glBlendFunc(0x302u, 0x303u);
      glDepthMask(0);
    }
    if ( *(a2 + 6) & 1 )
    {
      Colour::Colour(&v4);
      Material::getColour(a2, &v4);
      ((*v5)[40])(v5, &v4, 1);
      ((*v5)[10])(v5, (*(a2 + 19) & 1) != 0, 0);
      if ( *(a2 + 29) )
        ((*v5)[49])(v5, *(*(a2 + 33) + 8), 0);
      else
        ((*v5)[49])(v5, 0, 0);
    }
    else
    {
      if ( dword_101D5A90 )
      {
        if ( *(a2 + 10) )
        {
          if ( !byte_101D5A9C )
          {
            dword_101D5A8C(33985);
            dword_101D5A94(33985);
            (*(*v5[213] + 4))(v5[213], 1);
            dword_101D5A8C(33984);
            dword_101D5A94(33984);
          }
          dword_101D5A8C(33985);
          dword_101D5A94(33985);
          glEnable(0xDE1u);
          ((*v5)[49])(v5, *(a2 + 10), 0);
          byte_101D5A9C = 1;
        }
        else if ( byte_101D5A9C )
        {
          dword_101D5A8C(33985);
          dword_101D5A94(33985);
          glDisable(0xDE1u);
          byte_101D5A9C = 0;
        }
        dword_101D5A8C(33984);
        dword_101D5A94(33984);
      }
      ((*v5)[49])(v5, *(a2 + 9), 0);
      v3 = Material::Colour(a2);
      ((*v5)[40])(v5, v3, 1);
    }
  }
  else
  {
    glEnable(0xBE2u);
    glDisable(0xBC0u);
    glBlendFunc(0x302u, 0x303u);
    glDepthMask(1u);
    if ( dword_101D5A90 )
    {
      dword_101D5A8C(33985);
      dword_101D5A94(33985);
      glDisable(0xDE1u);
      glDisableClientState(0x8078u);
      (*(*v5[213] + 4))(v5[213], 0);
      dword_101D5A8C(33984);
      dword_101D5A94(33984);
    }
  }
}
// 101D5A8C: using guessed type int (__stdcall *dword_101D5A8C)(_DWORD);
// 101D5A90: using guessed type int dword_101D5A90;
// 101D5A94: using guessed type int (__stdcall *dword_101D5A94)(_DWORD);
// 101D5A9C: using guessed type char byte_101D5A9C;

//----- (1005CD10) --------------------------------------------------------
void __stdcall sub_1005CD10(int a1)
{
  ;
}

//----- (1005CD40) --------------------------------------------------------
_DWORD *__thiscall sub_1005CD40(_DWORD *this, BaseShape *a2, int a3)
{
  _DWORD *result; // eax
  struct Matrix4f *v4; // eax
  GLfloat alpha; // ST14_4
  GLfloat blue; // ST10_4
  GLfloat green; // ST0C_4
  GLfloat red; // ST08_4
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  GLfloat *v12; // edx
  int v13; // [esp+64h] [ebp-D4h]
  int v14; // [esp+68h] [ebp-D0h]
  int v15; // [esp+6Ch] [ebp-CCh]
  int v16; // [esp+70h] [ebp-C8h]
  int v17; // [esp+74h] [ebp-C4h]
  int m; // [esp+78h] [ebp-C0h]
  float *v19; // [esp+7Ch] [ebp-BCh]
  float *v20; // [esp+80h] [ebp-B8h]
  float *v21; // [esp+84h] [ebp-B4h]
  int v22; // [esp+88h] [ebp-B0h]
  int v23; // [esp+8Ch] [ebp-ACh]
  int l; // [esp+90h] [ebp-A8h]
  int ii; // [esp+94h] [ebp-A4h]
  int v26; // [esp+98h] [ebp-A0h]
  int v27; // [esp+9Ch] [ebp-9Ch]
  GLfloat *v; // [esp+A0h] [ebp-98h]
  int v29; // [esp+A4h] [ebp-94h]
  char v30; // [esp+A8h] [ebp-90h]
  int n; // [esp+ACh] [ebp-8Ch]
  GLfloat *v32; // [esp+B0h] [ebp-88h]
  GLfloat *v33; // [esp+B4h] [ebp-84h]
  GLfloat *v34; // [esp+B8h] [ebp-80h]
  int v35; // [esp+BCh] [ebp-7Ch]
  int v36; // [esp+C0h] [ebp-78h]
  int v37; // [esp+C4h] [ebp-74h]
  unsigned __int8 *v38; // [esp+C8h] [ebp-70h]
  int v39; // [esp+CCh] [ebp-6Ch]
  int v40; // [esp+D0h] [ebp-68h]
  int k; // [esp+D4h] [ebp-64h]
  _DWORD *v42; // [esp+D8h] [ebp-60h]
  int v43; // [esp+DCh] [ebp-5Ch]
  int v44; // [esp+E0h] [ebp-58h]
  int v45; // [esp+E4h] [ebp-54h]
  int v46; // [esp+E8h] [ebp-50h]
  int v47; // [esp+ECh] [ebp-4Ch]
  int v48; // [esp+F0h] [ebp-48h]
  int v49; // [esp+F4h] [ebp-44h]
  int j; // [esp+F8h] [ebp-40h]
  _DWORD *v51; // [esp+FCh] [ebp-3Ch]
  int i; // [esp+100h] [ebp-38h]
  _DWORD *v53; // [esp+104h] [ebp-34h]
  _DWORD *v54; // [esp+108h] [ebp-30h]
  int v55[10]; // [esp+10Ch] [ebp-2Ch]
  _DWORD *v56; // [esp+134h] [ebp-4h]

  v56 = this;
  v54 = (48 * *(a3 + 32) + *(a2 + 21));
  v53 = (156 * *(a3 + 28) + *(a2 + 17));
  if ( !v54[10] || (result = v54, *(v54[10] + 32)) )
  {
    result = v53;
    if ( !(v53[6] & 0x10000) )
    {
      result = v56;
      if ( v56[2] & v53[6] )
      {
        result = (*(*v56 + 192))(v56, v53);
        for ( i = 0; i < v54[8]; ++i )
        {
          v51 = (16 * i + v54[9]);
          if ( !*v51 )
            v55[0] = &Matrix4f::ident;
          for ( j = 0; j < *v51; ++j )
          {
            v49 = *(v51[1] + 4 * j);
            if ( v49 != -1 )
            {
              v48 = *(a2 + 15) + 8 * v49;
              if ( *(*(a2 + 6) + 4) )
              {
                if ( *v48 )
                  v4 = BaseShape::getAnimMatrix(a2, *(v48 + 4));
                else
                  v4 = BaseShape::getAnimMatrix(a2, *(v48 + 4) + *(a2 + 22));
                v55[j] = v4;
              }
              else
              {
                v55[j] = *(a2 + 23) + 284 * *(v48 + 4) + 72;
              }
            }
          }
          v47 = *(a2 + 160);
          v46 = *(a2 + 162);
          if ( v54[11] & 0x10000 )
            v17 = *(a2 + 183);
          else
            v17 = *(a2 + 181);
          v45 = v17;
          v44 = (v54[11] & 0x10000) != 0 ? 3 : 1;
          v43 = *(a2 + 172);
          v42 = v51[3];
          for ( k = 0; k < v51[2]; ++k )
          {
            *(gsys + 105) += v42[10];
            LOBYTE(v40) = 0;
            if ( *v51 || v42[8] == -1 )
            {
              v39 = (*(*v56 + 80))(v56, v56[206] ^ v42[5] & 3);
              v38 = v42[7];
              v37 = v42[6];
              while ( v37 && v38 < v37 + v42[7] )
              {
                v36 = *v38++;
                if ( !v36 )
                {
                  v37 = 0;
                  break;
                }
                v35 = v38[1] | (*v38 << 8);
                v38 += 2;
                v34 = &unk_101D5480;
                v33 = &unk_101D4E80;
                v32 = &unk_101D4A80;
                if ( v36 == 152 )
                {
                  glBegin(5u);
                }
                else if ( v36 == 144 )
                {
                  glBegin(4u);
                }
                else
                {
                  glBegin(6u);
                }
                if ( *v51 )
                {
                  for ( l = 0; l < v35; ++l )
                  {
                    LOBYTE(v23) = 0;
                    if ( v54[11] & 1 )
                      LOBYTE(v23) = *v38++ / 3;
                    if ( v54[11] & 2 )
                      ++v38;
                    v22 = 0;
                    v21 = v55[v23];
                    v20 = (12 * (v38[1] | (*v38 << 8)) + v47);
                    v19 = (12 * v44 * (v38[3] | (v38[2] << 8)) + v45);
                    *v34 = *v21 * *v20 + v21[1] * v20[1] + v21[2] * v20[2] + v21[3];
                    v34[1] = v21[4] * *v20 + v21[5] * v20[1] + v21[6] * v20[2] + v21[7];
                    v34[2] = v21[8] * *v20 + v21[9] * v20[1] + v21[10] * v20[2] + v21[11];
                    *v33 = *v21 * *v19 + v21[1] * v19[1] + v21[2] * v19[2];
                    v33[1] = v21[4] * *v19 + v21[5] * v19[1] + v21[6] * v19[2];
                    v33[2] = v21[8] * *v19 + v21[9] * v19[1] + v21[10] * v19[2];
                    v38 += 4;
                    if ( v54[11] & 4 )
                      v38 += 2;
                    for ( m = 0; m < 8; ++m )
                    {
                      if ( (1 << (m + 3)) & v54[11] )
                      {
                        v22 += 2;
                        if ( !m )
                        {
                          v9 = v38[1] | (*v38 << 8);
                          v10 = *(v43 + 8 * v9);
                          v11 = *(v43 + 8 * v9 + 4);
                          v12 = v32;
                          *v32 = v10;
                          *(v12 + 1) = v11;
                        }
                      }
                    }
                    glTexCoord2fv(v32);
                    glNormal3fv(v33);
                    glVertex3fv(v34);
                    v38 += v22;
                  }
                }
                else
                {
                  for ( n = 0; n < v35; ++n )
                  {
                    v30 = 0;
                    if ( v54[11] & 1 )
                      v30 = *v38++ / 3;
                    if ( v54[11] & 2 )
                      ++v38;
                    v29 = 0;
                    v = (12 * (v38[1] | (*v38 << 8)) + v47);
                    glNormal3fv((12 * v44 * (v38[3] | (v38[2] << 8)) + v45));
                    v38 += 4;
                    if ( v54[11] & 4 )
                    {
                      v27 = v38[1] | (*v38 << 8);
                      v26 = v46 + 4 * v27;
                      v16 = *(v46 + 4 * v27 + 3);
                      alpha = v16 / 255.0;
                      v15 = *(v46 + 4 * v27 + 2);
                      blue = v15 / 255.0;
                      v14 = *(v46 + 4 * v27 + 1);
                      green = v14 / 255.0;
                      v13 = *(v46 + 4 * v27);
                      red = v13 / 255.0;
                      glColor4f(red, green, blue, alpha);
                      v38 += 2;
                    }
                    for ( ii = 0; ii < 8; ++ii )
                    {
                      if ( (1 << (ii + 3)) & v54[11] )
                      {
                        v29 += 2;
                        if ( !ii )
                          glTexCoord2fv((v43 + 8 * (v38[1] | (*v38 << 8))));
                      }
                    }
                    glVertex3fv(v);
                    v38 += v29;
                  }
                }
                glEnd();
              }
              if ( v40 )
                glEndList();
              v42 += 29;
            }
            else
            {
              glCallList(v42[8]);
            }
          }
          result = (i + 1);
        }
      }
    }
  }
  return result;
}
// 1005CD40: using guessed type int var_2C[10];

//----- (1005D970) --------------------------------------------------------
int __thiscall sub_1005D970(void *this, int a2, int a3)
{
  int i; // [esp+4Ch] [ebp-8h]
  void *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  for ( i = *(a3 + 96) - 1; i >= 0; --i )
    (*(*v5 + 120))(v5, a3, *(*(a3 + 100) + 4 * i));
  return (*(*v5 + 192))(v5, 0);
}

//----- (1005DA20) --------------------------------------------------------
void __thiscall sub_1005DA20(int this, unsigned __int8 *a2, char a3)
{
  GLfloat v; // [esp+5Ch] [ebp-14h]
  float v4; // [esp+60h] [ebp-10h]
  float v5; // [esp+64h] [ebp-Ch]
  float v6; // [esp+68h] [ebp-8h]
  int v7; // [esp+6Ch] [ebp-4h]

  v7 = this;
  v = *a2 / 255.0;
  v4 = a2[1] / 255.0;
  v5 = a2[2] / 255.0;
  v6 = a2[3] / 255.0 * *(this + 888);
  *(this + 796) = *a2;
  if ( a3 )
    *(v7 + 800) = *a2;
  glColor4fv(&v);
  glMaterialfv(0x404u, 0x1201u, &v);
  glMaterialfv(0x404u, 0x1200u, &v);
}

//----- (1005DB70) --------------------------------------------------------
_DWORD *__thiscall sub_1005DB70(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  this[200] = *a2;
  return result;
}

//----- (1005DBC0) --------------------------------------------------------
_DWORD *__thiscall sub_1005DBC0(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  this[198] = *a2;
  return result;
}

//----- (1005DC10) --------------------------------------------------------
void __thiscall sub_1005DC10(unsigned __int8 *this, int a2, char a3)
{
  GLclampf alpha; // ST0C_4
  GLclampf blue; // ST08_4
  GLclampf green; // ST04_4
  GLclampf red; // ST00_4
  unsigned __int8 *v7; // [esp+6Ch] [ebp-4h]

  v7 = this;
  if ( a3 )
  {
    glClearDepth(0.0);
    glDepthFunc(0x207u);
  }
  else
  {
    glClearDepth(1.0);
    glDepthFunc(0x203u);
  }
  if ( a2 )
  {
    alpha = v7[795] / 255.0;
    blue = v7[794] / 255.0;
    green = v7[793] / 255.0;
    red = v7[792] / 255.0;
    glClearColor(red, green, blue, alpha);
    glClear(((a2 & 1) != 0 ? 0x4000 : 0) | ((a2 & 2) != 0 ? 0x100 : 0));
  }
}

//----- (1005DDB0) --------------------------------------------------------
void __thiscall sub_1005DDB0(GLfloat *this, char a2)
{
  GLfloat params; // [esp+5Ch] [ebp-14h]
  float v3; // [esp+60h] [ebp-10h]
  float v4; // [esp+64h] [ebp-Ch]
  float v5; // [esp+68h] [ebp-8h]
  GLfloat *v6; // [esp+6Ch] [ebp-4h]

  v6 = this;
  if ( a2 )
  {
    params = *(v6 + 872) / 255.0;
    v3 = *(v6 + 873) / 255.0;
    v4 = *(v6 + 874) / 255.0;
    v5 = *(v6 + 875) / 255.0;
    glEnable(0xB60u);
    glFogi(0xB65u, 9729);
    glFogfv(0xB66u, &params);
    glFogf(0xB62u, v6[217]);
    glFogf(0xB63u, v6[215]);
    glFogf(0xB64u, v6[216]);
  }
  else
  {
    glDisable(0xB60u);
  }
}

//----- (1005DF70) --------------------------------------------------------
int __thiscall sub_1005DF70(_DWORD *this, char a2, _DWORD *a3, int a4, int a5, int a6)
{
  int v6; // eax
  _DWORD *v8; // [esp+4Ch] [ebp-4h]

  v8 = this;
  this[218] = *a3;
  v8[215] = a5;
  v6 = a6;
  v8[216] = a6;
  v8[217] = a4;
  LOBYTE(v6) = a2;
  return (*(*v8 + 180))(v8, v6);
}

//----- (1005E010) --------------------------------------------------------
void __thiscall sub_1005E010(_DWORD *this, signed int *a2, signed int *a3, float *a4)
{
  GLfloat alpha; // ST0C_4
  GLfloat blue; // ST08_4
  GLfloat green; // ST04_4
  GLfloat red; // ST00_4
  GLfloat v8; // ST0C_4
  GLfloat v9; // ST08_4
  GLfloat v10; // ST08_4
  GLfloat v11; // ST04_4
  GLfloat v12; // ST0C_4
  GLfloat v13; // ST08_4
  GLfloat v14; // ST04_4
  GLfloat v15; // ST00_4
  GLfloat v16; // ST0C_4
  GLfloat v17; // ST08_4
  GLfloat v18; // ST08_4
  GLfloat v19; // ST04_4
  GLfloat v20; // ST0C_4
  GLfloat v21; // ST08_4
  GLfloat v22; // ST04_4
  GLfloat v23; // ST00_4
  GLfloat v24; // ST0C_4
  GLfloat v25; // ST08_4
  GLfloat v26; // ST08_4
  GLfloat v27; // ST04_4
  GLfloat v28; // ST0C_4
  GLfloat v29; // ST08_4
  GLfloat v30; // ST04_4
  GLfloat v31; // ST00_4
  GLfloat v32; // ST0C_4
  GLfloat v33; // ST08_4
  GLfloat v34; // ST08_4
  GLfloat v35; // ST04_4
  float v36; // [esp+5Ch] [ebp-74h]
  float v37; // [esp+60h] [ebp-70h]
  GLfloat v38; // [esp+64h] [ebp-6Ch]
  float v39; // [esp+78h] [ebp-58h]
  float v40; // [esp+7Ch] [ebp-54h]
  GLfloat v41; // [esp+80h] [ebp-50h]
  float v42; // [esp+94h] [ebp-3Ch]
  float v43; // [esp+98h] [ebp-38h]
  GLfloat v44; // [esp+9Ch] [ebp-34h]
  float v45; // [esp+B0h] [ebp-20h]
  float v46; // [esp+B4h] [ebp-1Ch]
  GLfloat z; // [esp+B8h] [ebp-18h]
  _DWORD *v48; // [esp+CCh] [ebp-4h]

  v48 = this;
  glBegin(7u);
  alpha = *(v48 + 799) / 255.0;
  blue = *(v48 + 798) / 255.0;
  green = *(v48 + 797) / 255.0;
  red = *(v48 + 796) / 255.0;
  glColor4f(red, green, blue, alpha);
  v8 = a3[1] * *(v48[187] + 32);
  v9 = *a3 * *(v48[187] + 28);
  glTexCoord2f(v9, v8);
  if ( a4 )
    z = a4[2];
  else
    z = 0.0;
  if ( a4 )
    v46 = a4[1];
  else
    v46 = 0.0;
  if ( a4 )
    v45 = *a4;
  else
    v45 = 0.0;
  v10 = a2[1] + v46;
  v11 = *a2 + v45;
  glVertex3f(v11, v10, z);
  v12 = *(v48 + 799) / 255.0;
  v13 = *(v48 + 798) / 255.0;
  v14 = *(v48 + 797) / 255.0;
  v15 = *(v48 + 796) / 255.0;
  glColor4f(v15, v14, v13, v12);
  v16 = a3[1] * *(v48[187] + 32);
  v17 = a3[2] * *(v48[187] + 28);
  glTexCoord2f(v17, v16);
  if ( a4 )
    v44 = a4[2];
  else
    v44 = 0.0;
  if ( a4 )
    v43 = a4[1];
  else
    v43 = 0.0;
  if ( a4 )
    v42 = *a4;
  else
    v42 = 0.0;
  v18 = a2[1] + v43;
  v19 = a2[2] + v42;
  glVertex3f(v19, v18, v44);
  v20 = *(v48 + 803) / 255.0;
  v21 = *(v48 + 802) / 255.0;
  v22 = *(v48 + 801) / 255.0;
  v23 = *(v48 + 800) / 255.0;
  glColor4f(v23, v22, v21, v20);
  v24 = a3[3] * *(v48[187] + 32);
  v25 = a3[2] * *(v48[187] + 28);
  glTexCoord2f(v25, v24);
  if ( a4 )
    v41 = a4[2];
  else
    v41 = 0.0;
  if ( a4 )
    v40 = a4[1];
  else
    v40 = 0.0;
  if ( a4 )
    v39 = *a4;
  else
    v39 = 0.0;
  v26 = a2[3] + v40;
  v27 = a2[2] + v39;
  glVertex3f(v27, v26, v41);
  v28 = *(v48 + 803) / 255.0;
  v29 = *(v48 + 802) / 255.0;
  v30 = *(v48 + 801) / 255.0;
  v31 = *(v48 + 800) / 255.0;
  glColor4f(v31, v30, v29, v28);
  v32 = a3[3] * *(v48[187] + 32);
  v33 = *a3 * *(v48[187] + 28);
  glTexCoord2f(v33, v32);
  if ( a4 )
    v38 = a4[2];
  else
    v38 = 0.0;
  if ( a4 )
    v37 = a4[1];
  else
    v37 = 0.0;
  if ( a4 )
    v36 = *a4;
  else
    v36 = 0.0;
  v34 = a2[3] + v37;
  v35 = *a2 + v36;
  glVertex3f(v35, v34, v38);
  glEnd();
}

//----- (1005E650) --------------------------------------------------------
void __thiscall sub_1005E650(unsigned __int8 *this, signed int *a2)
{
  unsigned __int8 *v2; // ST7C_4
  GLfloat alpha; // ST0C_4
  GLfloat blue; // ST08_4
  GLfloat green; // ST04_4
  GLfloat red; // ST00_4
  GLfloat v7; // ST08_4
  GLfloat v8; // ST04_4
  GLfloat v9; // ST08_4
  GLfloat v10; // ST04_4
  GLfloat v11; // ST0C_4
  GLfloat v12; // ST08_4
  GLfloat v13; // ST04_4
  GLfloat v14; // ST00_4
  GLfloat v15; // ST08_4
  GLfloat v16; // ST04_4
  GLfloat v17; // ST08_4
  GLfloat v18; // ST04_4

  v2 = this;
  glBegin(7u);
  alpha = v2[799] / 255.0;
  blue = v2[798] / 255.0;
  green = v2[797] / 255.0;
  red = v2[796] / 255.0;
  glColor4f(red, green, blue, alpha);
  v7 = a2[1];
  v8 = *a2;
  glVertex3f(v8, v7, 0.0);
  v9 = a2[1];
  v10 = a2[2];
  glVertex3f(v10, v9, 0.0);
  v11 = v2[803] / 255.0;
  v12 = v2[802] / 255.0;
  v13 = v2[801] / 255.0;
  v14 = v2[800] / 255.0;
  glColor4f(v14, v13, v12, v11);
  v15 = a2[3];
  v16 = a2[2];
  glVertex3f(v16, v15, 0.0);
  v17 = a2[3];
  v18 = *a2;
  glVertex3f(v18, v17, 0.0);
  glEnd();
}

//----- (1005E8A0) --------------------------------------------------------
void __thiscall sub_1005E8A0(unsigned __int8 *this, signed int *a2)
{
  unsigned __int8 *v2; // ST6C_4
  GLfloat y; // ST08_4
  GLfloat x; // ST04_4
  GLfloat v5; // ST08_4
  GLfloat v6; // ST04_4
  GLfloat alpha; // ST0C_4
  GLfloat v8; // ST08_4
  GLfloat v9; // ST04_4
  GLfloat red; // ST00_4
  GLfloat v11; // ST08_4
  GLfloat v12; // ST04_4
  GLfloat v13; // ST08_4
  GLfloat v14; // ST04_4

  v2 = this;
  glBegin(2u);
  y = a2[1];
  x = *a2;
  glVertex3f(x, y, 0.0);
  v5 = a2[1];
  v6 = a2[2];
  glVertex3f(v6, v5, 0.0);
  alpha = v2[803] / 255.0;
  v8 = v2[802] / 255.0;
  v9 = v2[801] / 255.0;
  red = v2[800] / 255.0;
  glColor4f(red, v9, v8, alpha);
  v11 = a2[3];
  v12 = a2[2];
  glVertex3f(v12, v11, 0.0);
  v13 = a2[3];
  v14 = *a2;
  glVertex3f(v14, v13, 0.0);
  glEnd();
}

//----- (1005EA60) --------------------------------------------------------
void __thiscall sub_1005EA60(void *this, int a2, int a3, int a4, float a5)
{
  double v5; // st7
  float z; // ST08_4
  double v7; // st7
  float v8; // ST08_4
  double v9; // st7
  float v10; // ST08_4
  double v11; // st7
  float v12; // ST08_4
  double v13; // st7
  float v14; // ST08_4
  double v15; // st7
  float v16; // ST08_4
  double v17; // st7
  float v18; // ST08_4
  double v19; // st7
  float v20; // ST08_4
  GLfloat v21; // ST08_4
  GLfloat y; // ST04_4
  GLfloat x; // ST00_4
  GLfloat v24; // ST08_4
  GLfloat v25; // ST04_4
  GLfloat v26; // ST00_4
  GLfloat v27; // ST08_4
  GLfloat v28; // ST04_4
  GLfloat v29; // ST00_4
  GLfloat v30; // ST08_4
  GLfloat v31; // ST04_4
  GLfloat v32; // ST00_4
  float v33; // [esp+5Ch] [ebp-68h]
  float v34; // [esp+60h] [ebp-64h]
  float v35; // [esp+64h] [ebp-60h]
  float v36; // [esp+68h] [ebp-5Ch]
  float v37; // [esp+6Ch] [ebp-58h]
  float v38; // [esp+70h] [ebp-54h]
  float v39; // [esp+74h] [ebp-50h]
  float v40; // [esp+78h] [ebp-4Ch]
  float v41; // [esp+7Ch] [ebp-48h]
  float v42; // [esp+80h] [ebp-44h]
  float v43; // [esp+84h] [ebp-40h]
  float v44; // [esp+88h] [ebp-3Ch]
  char v45; // [esp+8Ch] [ebp-38h]
  char v46; // [esp+98h] [ebp-2Ch]
  char v47; // [esp+A4h] [ebp-20h]
  char v48; // [esp+B0h] [ebp-14h]
  float v49; // [esp+BCh] [ebp-8h]
  void *v50; // [esp+C0h] [ebp-4h]

  v50 = this;
  v49 = a4 / 65536.0 * 6.2831855;
  v44 = 0.0;
  v5 = v49 - 0.78539819;
  z = v5;
  sub_10002D47(z);
  v43 = v5 * a5;
  v7 = v49 - 0.78539819;
  v8 = v7;
  sub_10002635(v8);
  v42 = v7 * a5;
  Vector3f::Vector3f(&v48, &v42, &v43, &v44);
  v41 = 0.0;
  v9 = v49 + 0.78539819;
  v10 = v9;
  sub_10002D47(v10);
  v40 = v9 * a5;
  v11 = v49 + 0.78539819;
  v12 = v11;
  sub_10002635(v12);
  v39 = v11 * a5;
  Vector3f::Vector3f(&v47, &v39, &v40, &v41);
  v38 = 0.0;
  v13 = v49 + 2.3561945;
  v14 = v13;
  sub_10002D47(v14);
  v37 = v13 * a5;
  v15 = v49 + 2.3561945;
  v16 = v15;
  sub_10002635(v16);
  v36 = v15 * a5;
  Vector3f::Vector3f(&v46, &v36, &v37, &v38);
  v35 = 0.0;
  v17 = v49 + 3.926991;
  v18 = v17;
  sub_10002D47(v18);
  v34 = v17 * a5;
  v19 = v49 + 3.926991;
  v20 = v19;
  sub_10002635(v20);
  v33 = v19 * a5;
  Vector3f::Vector3f(&v45, &v33, &v34, &v35);
  glBegin(7u);
  glTexCoord2f(0.0, 0.0);
  v21 = Vector3f::DP(&v48, (a2 + 404)) + *(a3 + 8);
  y = Vector3f::DP(&v48, (a2 + 392)) + *(a3 + 4);
  x = Vector3f::DP(&v48, (a2 + 380)) + *a3;
  glVertex3f(x, y, v21);
  glTexCoord2f(1.0, 0.0);
  v24 = Vector3f::DP(&v47, (a2 + 404)) + *(a3 + 8);
  v25 = Vector3f::DP(&v47, (a2 + 392)) + *(a3 + 4);
  v26 = Vector3f::DP(&v47, (a2 + 380)) + *a3;
  glVertex3f(v26, v25, v24);
  glTexCoord2f(1.0, 1.0);
  v27 = Vector3f::DP(&v46, (a2 + 404)) + *(a3 + 8);
  v28 = Vector3f::DP(&v46, (a2 + 392)) + *(a3 + 4);
  v29 = Vector3f::DP(&v46, (a2 + 380)) + *a3;
  glVertex3f(v29, v28, v27);
  glTexCoord2f(0.0, 1.0);
  v30 = Vector3f::DP(&v45, (a2 + 404)) + *(a3 + 8);
  v31 = Vector3f::DP(&v45, (a2 + 392)) + *(a3 + 4);
  v32 = Vector3f::DP(&v45, (a2 + 380)) + *a3;
  glVertex3f(v32, v31, v30);
  glEnd();
}

//----- (1005EEE0) --------------------------------------------------------
void __thiscall sub_1005EEE0(void *this, int a2, int a3, float a4)
{
  GLfloat z; // ST08_4
  GLfloat y; // ST04_4
  GLfloat x; // ST00_4
  GLfloat v7; // ST08_4
  GLfloat v8; // ST04_4
  GLfloat v9; // ST00_4
  GLfloat v10; // ST08_4
  GLfloat v11; // ST04_4
  GLfloat v12; // ST00_4
  GLfloat v13; // ST08_4
  GLfloat v14; // ST04_4
  GLfloat v15; // ST00_4
  float v16; // [esp+58h] [ebp-54h]
  float v17; // [esp+5Ch] [ebp-50h]
  float v18; // [esp+60h] [ebp-4Ch]
  float v19; // [esp+64h] [ebp-48h]
  float v20; // [esp+68h] [ebp-44h]
  float v21; // [esp+6Ch] [ebp-40h]
  float v22; // [esp+70h] [ebp-3Ch]
  float v23; // [esp+74h] [ebp-38h]
  char v24; // [esp+78h] [ebp-34h]
  char v25; // [esp+84h] [ebp-28h]
  char v26; // [esp+90h] [ebp-1Ch]
  char v27; // [esp+9Ch] [ebp-10h]
  void *v28; // [esp+A8h] [ebp-4h]

  v28 = this;
  v23 = 0.0;
  v22 = -a4;
  Vector3f::Vector3f(&v27, &v22, &a4, &v23);
  v21 = 0.0;
  Vector3f::Vector3f(&v26, &a4, &a4, &v21);
  v20 = 0.0;
  v19 = -a4;
  Vector3f::Vector3f(&v25, &a4, &v19, &v20);
  v18 = 0.0;
  v17 = -a4;
  v16 = -a4;
  Vector3f::Vector3f(&v24, &v16, &v17, &v18);
  glBegin(7u);
  glTexCoord2f(0.0, 0.0);
  z = Vector3f::DP(&v27, (a2 + 404)) + *(a3 + 8);
  y = Vector3f::DP(&v27, (a2 + 392)) + *(a3 + 4);
  x = Vector3f::DP(&v27, (a2 + 380)) + *a3;
  glVertex3f(x, y, z);
  glTexCoord2f(1.0, 0.0);
  v7 = Vector3f::DP(&v26, (a2 + 404)) + *(a3 + 8);
  v8 = Vector3f::DP(&v26, (a2 + 392)) + *(a3 + 4);
  v9 = Vector3f::DP(&v26, (a2 + 380)) + *a3;
  glVertex3f(v9, v8, v7);
  glTexCoord2f(1.0, 1.0);
  v10 = Vector3f::DP(&v25, (a2 + 404)) + *(a3 + 8);
  v11 = Vector3f::DP(&v25, (a2 + 392)) + *(a3 + 4);
  v12 = Vector3f::DP(&v25, (a2 + 380)) + *a3;
  glVertex3f(v12, v11, v10);
  glTexCoord2f(0.0, 1.0);
  v13 = Vector3f::DP(&v24, (a2 + 404)) + *(a3 + 8);
  v14 = Vector3f::DP(&v24, (a2 + 392)) + *(a3 + 4);
  v15 = Vector3f::DP(&v24, (a2 + 380)) + *a3;
  glVertex3f(v15, v14, v13);
  glEnd();
}

//----- (1005F260) --------------------------------------------------------
void __thiscall sub_1005F260(void *this, int a2, int a3, float *a4, GLfloat *a5, GLfloat *a6)
{
  float v6; // [esp+4Ch] [ebp-54h]
  float v7; // [esp+50h] [ebp-50h]
  float v8; // [esp+54h] [ebp-4Ch]
  float v9; // [esp+58h] [ebp-48h]
  float v10; // [esp+5Ch] [ebp-44h]
  float v11; // [esp+60h] [ebp-40h]
  float v12; // [esp+64h] [ebp-3Ch]
  float v13; // [esp+68h] [ebp-38h]
  GLfloat v14; // [esp+6Ch] [ebp-34h]
  GLfloat v15; // [esp+78h] [ebp-28h]
  GLfloat v16; // [esp+84h] [ebp-1Ch]
  GLfloat v; // [esp+90h] [ebp-10h]
  void *v18; // [esp+9Ch] [ebp-4h]

  v18 = this;
  v13 = a4[1] + *(a3 + 4);
  v12 = *a3 - *a4;
  Vector3f::Vector3f(&v, &v12, &v13, (a3 + 8));
  v11 = a4[1] + *(a3 + 4);
  v10 = *a4 + *a3;
  Vector3f::Vector3f(&v16, &v10, &v11, (a3 + 8));
  v9 = *(a3 + 4) - a4[1];
  v8 = *a4 + *a3;
  Vector3f::Vector3f(&v15, &v8, &v9, (a3 + 8));
  v7 = *(a3 + 4) - a4[1];
  v6 = *a3 - *a4;
  Vector3f::Vector3f(&v14, &v6, &v7, (a3 + 8));
  glBegin(7u);
  glTexCoord2f(*a5, a5[1]);
  glVertex3fv(&v);
  glTexCoord2f(*a6, a5[1]);
  glVertex3fv(&v16);
  glTexCoord2f(*a6, a6[1]);
  glVertex3fv(&v15);
  glTexCoord2f(*a5, a6[1]);
  glVertex3fv(&v14);
  glEnd();
}

//----- (1005F4D0) --------------------------------------------------------
void __stdcall sub_1005F4D0(GLvoid *pointer, GLsizei count)
{
  glEnableClientState(0x8074u);
  glVertexPointer(3, 0x1406u, 0, pointer);
  glDrawArrays(0, 0, count);
  glDisableClientState(0x8074u);
}

//----- (1005F580) --------------------------------------------------------
void __stdcall sub_1005F580(const GLfloat *a1, const GLfloat *a2, const GLfloat *a3, int a4)
{
  const GLfloat *v4; // ST00_4
  const GLfloat *v5; // ST00_4
  const GLfloat *v6; // ST00_4
  int i; // [esp+58h] [ebp-8h]

  glBegin(6u);
  for ( i = 0; i < a4; ++i )
  {
    if ( a3 )
    {
      v4 = a3;
      a3 += 2;
      glTexCoord2fv(v4);
    }
    if ( a2 )
    {
      v5 = a2;
      a2 += 3;
      glNormal3fv(v5);
    }
    v6 = a1;
    a1 += 3;
    glVertex3fv(v6);
  }
  glEnd();
}

//----- (1005F6A0) --------------------------------------------------------
void __stdcall sub_1005F6A0(const GLfloat *a1, const GLfloat *a2, const GLfloat *a3, int a4)
{
  const GLfloat *v4; // ST00_4
  const GLfloat *v5; // ST00_4
  const GLfloat *v6; // ST00_4
  int i; // [esp+58h] [ebp-8h]

  glBegin(5u);
  for ( i = 0; i < a4; ++i )
  {
    if ( a3 )
    {
      v4 = a3;
      a3 += 2;
      glTexCoord2fv(v4);
    }
    if ( a2 )
    {
      v5 = a2;
      a2 += 3;
      glNormal3fv(v5);
    }
    v6 = a1;
    a1 += 3;
    glVertex3fv(v6);
  }
  glEnd();
}

//----- (1005F7C0) --------------------------------------------------------
void __stdcall sub_1005F7C0(GLfloat *a1, GLfloat *a2)
{
  glBegin(1u);
  glVertex3f(*a1, a1[1], a1[2]);
  glVertex3f(*a2, a2[1], a2[2]);
  glEnd();
}

//----- (1005F880) --------------------------------------------------------
char *sub_1005F880(int a1, Font *a2, int a3, int a4, char *Format, ...)
{
  char *result; // eax
  int v6; // edx
  signed int *v7; // STA4_4
  GLfloat alpha; // ST14_4
  GLfloat blue; // ST10_4
  GLfloat green; // ST0C_4
  GLfloat red; // ST08_4
  GLfloat v12; // ST14_4
  GLfloat v13; // ST10_4
  GLfloat v14; // ST10_4
  GLfloat v15; // ST0C_4
  GLfloat v16; // ST14_4
  GLfloat v17; // ST10_4
  GLfloat v18; // ST0C_4
  GLfloat v19; // ST08_4
  GLfloat v20; // ST14_4
  GLfloat v21; // ST10_4
  GLfloat v22; // ST10_4
  GLfloat v23; // ST0C_4
  GLfloat v24; // ST14_4
  GLfloat v25; // ST10_4
  GLfloat v26; // ST0C_4
  GLfloat v27; // ST08_4
  GLfloat v28; // ST14_4
  GLfloat v29; // ST10_4
  GLfloat v30; // ST10_4
  GLfloat v31; // ST0C_4
  GLfloat v32; // ST14_4
  GLfloat v33; // ST10_4
  GLfloat v34; // ST0C_4
  GLfloat v35; // ST08_4
  GLfloat v36; // ST14_4
  GLfloat v37; // ST10_4
  GLfloat v38; // ST10_4
  GLfloat v39; // ST0C_4
  int v40; // [esp+A8h] [ebp-128h]
  int v41; // [esp+ACh] [ebp-124h]
  int v42; // [esp+B0h] [ebp-120h]
  int v43; // [esp+B4h] [ebp-11Ch]
  unsigned __int16 v44; // [esp+B8h] [ebp-118h]
  int v45; // [esp+BCh] [ebp-114h]
  char *v46; // [esp+C0h] [ebp-110h]
  int v47; // [esp+C4h] [ebp-10Ch]
  int v48; // [esp+C8h] [ebp-108h]
  va_list Args; // [esp+CCh] [ebp-104h]
  char Dest; // [esp+D0h] [ebp-100h]
  va_list va; // [esp+1ECh] [ebp+1Ch]

  va_start(va, Format);
  vsprintf(&Dest, Format, va);
  Args = 0;
  glDisable(0xB71u);
  glEnable(0xDE1u);
  (*(*a1 + 196))(a1, *a2, 0);
  v48 = a3;
  v47 = a4;
  v46 = &Dest;
  while ( 1 )
  {
    result = v46;
    if ( !*v46 )
      break;
    if ( *v46 & 0x80 )
    {
      v6 = v46[1] | (*v46 << 8);
      v44 = _byteswap_ushort(*v46);
      v45 = Font::charToIndex(a2, v44);
      v46 += 2;
    }
    else
    {
      v45 = Font::charToIndex(a2, *v46++);
    }
    RectArea::RectArea(
      &v40,
      v48 - *(*(a2 + 3) + 28 * v45 + 10),
      v47,
      *(*(a2 + 3) + 28 * v45 + 4) + v48 - *(*(a2 + 3) + 28 * v45 + 10),
      *(*(a2 + 3) + 28 * v45 + 6) + v47);
    v7 = (*(a2 + 3) + 28 * v45 + 12);
    glBegin(7u);
    alpha = *(a1 + 799) / 255.0;
    blue = *(a1 + 798) / 255.0;
    green = *(a1 + 797) / 255.0;
    red = *(a1 + 796) / 255.0;
    glColor4f(red, green, blue, alpha);
    v12 = v7[1] * *(*(a1 + 748) + 32);
    v13 = *v7 * *(*(a1 + 748) + 28);
    glTexCoord2f(v13, v12);
    v14 = v41;
    v15 = v40;
    glVertex3f(v15, v14, 0.0);
    v16 = *(a1 + 799) / 255.0;
    v17 = *(a1 + 798) / 255.0;
    v18 = *(a1 + 797) / 255.0;
    v19 = *(a1 + 796) / 255.0;
    glColor4f(v19, v18, v17, v16);
    v20 = v7[1] * *(*(a1 + 748) + 32);
    v21 = v7[2] * *(*(a1 + 748) + 28);
    glTexCoord2f(v21, v20);
    v22 = v41;
    v23 = v42;
    glVertex3f(v23, v22, 0.0);
    v24 = *(a1 + 803) / 255.0;
    v25 = *(a1 + 802) / 255.0;
    v26 = *(a1 + 801) / 255.0;
    v27 = *(a1 + 800) / 255.0;
    glColor4f(v27, v26, v25, v24);
    v28 = v7[3] * *(*(a1 + 748) + 32);
    v29 = v7[2] * *(*(a1 + 748) + 28);
    glTexCoord2f(v29, v28);
    v30 = v43;
    v31 = v42;
    glVertex3f(v31, v30, 0.0);
    v32 = *(a1 + 803) / 255.0;
    v33 = *(a1 + 802) / 255.0;
    v34 = *(a1 + 801) / 255.0;
    v35 = *(a1 + 800) / 255.0;
    glColor4f(v35, v34, v33, v32);
    v36 = v7[3] * *(*(a1 + 748) + 32);
    v37 = *v7 * *(*(a1 + 748) + 28);
    glTexCoord2f(v37, v36);
    v38 = v43;
    v39 = v40;
    glVertex3f(v39, v38, 0.0);
    glEnd();
    v48 += *(*(a2 + 3) + 28 * v45 + 8);
  }
  return result;
}

//----- (10060030) --------------------------------------------------------
void __thiscall sub_10060030(char *this, AgeServer *a2)
{
  char *v2; // ST54_4

  v2 = this;
  AgeServer::StartSection(a2, "GLRenderer", 1);
  AgeServer::StartGroup(a2, "Lighting");
  Colour::genAge((v2 + 876), a2, "ambient");
  AgeServer::EndGroup(a2);
  AgeServer::EndSection(a2);
}

//----- (100600C0) --------------------------------------------------------
void sub_100600C0()
{
  ;
}

//----- (100600F0) --------------------------------------------------------
char __stdcall sub_100600F0(int a1)
{
  return 1;
}

//----- (10060130) --------------------------------------------------------
int __thiscall sub_10060130(void *this, int a2, int a3)
{
  void *v4; // [esp+4Ch] [ebp-4h]

  v4 = this;
  return (*(*this + 160))(this, a2, 1);
}

//----- (10060190) --------------------------------------------------------
void __stdcall sub_10060190(int a1)
{
  ;
}

//----- (100601C0) --------------------------------------------------------
void __thiscall Shape::optimize(Shape *this)
{
  HGLOBAL v1; // [esp+4Ch] [ebp-1Ch]
  HGLOBAL hMem; // [esp+50h] [ebp-18h]
  Shape *v3; // [esp+58h] [ebp-10h]

  v3 = this;
  if ( !*(this + 172) )
  {
    hMem = sub_10001AC3(8u);
    if ( hMem )
    {
      sub_1000291E(hMem, 8, 1, Vector2f::Vector2f);
      v1 = hMem;
    }
    else
    {
      v1 = 0;
    }
    *(v3 + 172) = v1;
    **(v3 + 172) = 0;
    *(*(v3 + 172) + 4) = 0;
  }
}
// 1000291E: using guessed type _DWORD __stdcall sub_1000291E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100602C0) --------------------------------------------------------
int __cdecl Texture::offsetGXtoGL(int a1, int a2, int a3, int a4)
{
  return ((a1 - 1) & a4)
       + a3 * (((a2 * a1 - 1) & a4) / a1)
       + a2 * a3 * (a4 / (a2 * a3))
       + a1 * (a4 / (a2 * a1) % (a3 / a1));
}

//----- (10060370) --------------------------------------------------------
int __thiscall Texture::offsetGXtoGL(Texture *this, int a2)
{
  return Texture::offsetGXtoGL(*(this + 3), *(this + 4), *(this + 4), a2);
}

//----- (100603E0) --------------------------------------------------------
unsigned __int8 __thiscall Texture::getAlpha(Texture *this, int a2, int a3)
{
  return *(*(this + 5) + 4 * (a2 + *(this + 4) * a3)) >> 24;
}

//----- (10060440) --------------------------------------------------------
unsigned __int8 __thiscall Texture::getRed(Texture *this, int a2, int a3)
{
  return *(*(this + 5) + 4 * (a2 + *(this + 4) * a3));
}

//----- (100604A0) --------------------------------------------------------
void __thiscall Texture::read(Texture *this, struct RandomAccessStream *a2)
{
  size_t v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  TexImg *v5; // [esp+4Ch] [ebp-30h]
  TexImg *v6; // [esp+50h] [ebp-2Ch]
  TexImg *v7; // [esp+54h] [ebp-28h]
  TexImg *hMem; // [esp+5Ch] [ebp-20h]
  struct Texture *v9; // [esp+6Ch] [ebp-10h]

  v9 = this;
  v2 = strlen(*(a2 + 1));
  if ( !strcmp((*(a2 + 1) + v2 - 3), "txe") )
  {
    hMem = sub_10002A81(0x34u);
    if ( hMem )
      v6 = TexImg::TexImg(hMem);
    else
      v6 = 0;
    TexImg::importTxe(v6, v9, a2);
  }
  else
  {
    v3 = strlen(*(a2 + 1));
    if ( strcmp((*(a2 + 1) + v3 - 3), "bti") )
    {
      v4 = strlen(*(a2 + 1));
      sub_10060690("Unknown texture extension (%s)!!\n", *(a2 + 1) + v4 - 3);
    }
    v7 = sub_10002A81(0x34u);
    if ( v7 )
      v5 = TexImg::TexImg(v7);
    else
      v5 = 0;
    TexImg::importBti(v5, v9, a2, 0);
  }
  StdSystem::addTexture(gsys, v9, *(a2 + 1));
}

//----- (10060690) --------------------------------------------------------
void __noreturn sub_10060690(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscore\\texture.cpp", 14, &Dest);
}

//----- (10060730) --------------------------------------------------------
void __thiscall Texture::write(Texture *this, struct Stream *a2)
{
  int v2; // edx
  int v3; // edx
  __int16 v4; // [esp+4Ch] [ebp-24h]
  int v5; // [esp+50h] [ebp-20h]
  int m; // [esp+54h] [ebp-1Ch]
  int l; // [esp+58h] [ebp-18h]
  int k; // [esp+5Ch] [ebp-14h]
  int j; // [esp+60h] [ebp-10h]
  int v10; // [esp+64h] [ebp-Ch]
  int i; // [esp+68h] [ebp-8h]
  Texture *v12; // [esp+6Ch] [ebp-4h]

  v12 = this;
  LOWORD(this) = *(this + 4);
  (*(*a2 + 36))(a2, this);
  LOWORD(v2) = *(v12 + 5);
  (*(*a2 + 36))(a2, v2);
  (*(*a2 + 36))(a2, 2);
  (*(*a2 + 36))(a2, 0);
  (*(*a2 + 28))(a2, 2 * *(v12 + 5) * *(v12 + 4));
  for ( i = 0; i < 10; ++i )
    (*(*a2 + 36))(a2, 0);
  v10 = *(v12 + 5);
  for ( j = 0; j < *(v12 + 5) / 4; ++j )
  {
    for ( k = 0; k < *(v12 + 4) / 4; ++k )
    {
      for ( l = 0; l < 4; ++l )
      {
        for ( m = 0; m < 4; ++m )
        {
          v5 = m + *(v12 + 4) * (l + 4 * j) + 4 * k;
          v4 = 0;
          if ( *(v10 + 4 * v5 + 3) == 255 )
          {
            v4 |= (*(v10 + 4 * v5) >> 3) << 10;
            v4 |= 32 * (*(v10 + 4 * v5 + 1) >> 3);
            HIWORD(v3) = HIWORD(v5);
            v4 |= *(v10 + 4 * v5 + 2) >> 3;
            v4 |= 0x8000u;
          }
          else
          {
            v4 |= (*(v10 + 4 * v5) >> 4) << 8;
            v4 |= 16 * (*(v10 + 4 * v5 + 1) >> 4);
            v4 |= *(v10 + 4 * v5 + 2) >> 4;
            HIWORD(v3) = HIWORD(v10);
            v4 |= (*(v10 + 4 * v5 + 3) >> 5) << 12;
          }
          LOWORD(v3) = v4;
          (*(*a2 + 36))(a2, v3);
        }
      }
    }
  }
}

//----- (10060AB0) --------------------------------------------------------
void __thiscall Texture::createBuffer(Texture *this, int a2, int a3, int a4, void *a5)
{
  void *v5; // [esp+4Ch] [ebp-Ch]
  Texture *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  if ( a5 )
    v5 = a5;
  else
    v5 = sub_10001AC3(4 * a3 * a2);
  *(v6 + 5) = v5;
  *(v6 + 4) = a2;
  *(v6 + 5) = a3;
}

//----- (10060B50) --------------------------------------------------------
void __thiscall Texture::grabBuffer(Texture *this, GLsizei width, GLsizei height, bool a4, bool a5)
{
  Texture *v5; // ST70_4
  bool v6; // zf

  v5 = this;
  glReadPixels(0, glnHeight - width, width, height, 0x1908u, 0x1401u, *(this + 5));
  v6 = *(v5 + 6) == 0;
  glBindTexture(0xDE1u, *(v5 + 6));
  glTexSubImage2D(0xDE1u, 0, 0, 0, width, height, 0x1908u, 0x1401u, *(v5 + 5));
}

//----- (10060C40) --------------------------------------------------------
void __thiscall Texture::detach(Texture *this)
{
  Texture *v1; // ST54_4
  bool v2; // zf

  v1 = this;
  v2 = *(this + 6) == 0;
  glDeleteTextures(1, this + 6);
  *(v1 + 6) = -1;
}

//----- (10060CB0) --------------------------------------------------------
void __thiscall Texture::attach(Texture *this)
{
  int v1; // eax
  signed int i; // [esp+4Ch] [ebp-Ch]
  int v3; // [esp+50h] [ebp-8h]
  Texture *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  if ( *(this + 6) == -1 )
  {
    glGenTextures(1, this + 6);
    glBindTexture(0xDE1u, *(v4 + 6));
    if ( *(v4 + 3) & 1 )
      glTexParameteri(0xDE1u, 0x2802u, 10496);
    else
      glTexParameteri(0xDE1u, 0x2802u, 10497);
    if ( *(v4 + 3) & 0x100 )
      glTexParameteri(0xDE1u, 0x2803u, 10496);
    else
      glTexParameteri(0xDE1u, 0x2803u, 10497);
    glTexParameteri(0xDE1u, 0x2800u, 9729);
    v3 = 0;
    for ( i = 0; i < 12; ++i )
    {
      if ( *(v4 + 4) == 1 << i )
        v3 |= 1u;
      if ( *(v4 + 5) == 1 << i )
      {
        v1 = v3;
        LOBYTE(v1) = v3 | 2;
        v3 = v1;
      }
    }
    if ( v3 == 3 && (!*(gsys + 588) || *(v4 + 3) & 4) )
    {
      glTexParameteri(0xDE1u, 0x2801u, 9729);
      glTexImage2D(0xDE1u, 0, 4, *(v4 + 4), *(v4 + 5), 0, 0x1908u, 0x1401u, *(v4 + 5));
    }
    else
    {
      glTexParameteri(0xDE1u, 0x2801u, 9987);
      gluBuild2DMipmaps(0xDE1u, 4, *(v4 + 4), *(v4 + 5), 0x1908u, 0x1401u, *(v4 + 5));
    }
  }
}

//----- (10060FB0) --------------------------------------------------------
void __cdecl Texture::decodeS3TC(int a1, int a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v4; // ST6C_4
  int v5; // ST68_4
  int v6; // ST64_4
  int v7; // [esp+4Ch] [ebp-54h]
  int v8; // [esp+50h] [ebp-50h]
  signed int l; // [esp+54h] [ebp-4Ch]
  int v10; // [esp+58h] [ebp-48h]
  signed int k; // [esp+5Ch] [ebp-44h]
  signed int v12; // [esp+60h] [ebp-40h]
  int v13; // [esp+7Ch] [ebp-24h]
  int v14; // [esp+80h] [ebp-20h]
  char v15; // [esp+84h] [ebp-1Ch]
  char v16; // [esp+85h] [ebp-1Bh]
  char v17; // [esp+86h] [ebp-1Ah]
  char v18; // [esp+87h] [ebp-19h]
  char v19; // [esp+88h] [ebp-18h]
  char v20; // [esp+89h] [ebp-17h]
  char v21; // [esp+8Ah] [ebp-16h]
  char v22; // [esp+8Bh] [ebp-15h]
  int j; // [esp+8Ch] [ebp-14h]
  int i; // [esp+90h] [ebp-10h]
  int v25; // [esp+94h] [ebp-Ch]
  int v26; // [esp+98h] [ebp-8h]
  int v27; // [esp+9Ch] [ebp-4h]

  v27 = (a2 + 3) >> 2;
  v26 = (a1 + 3) >> 2;
  v25 = 0;
  for ( i = 0; i < v27; ++i )
  {
    for ( j = 0; j < v26; ++j )
    {
      v4 = 8 * (2 * v26 * (v25 / (2 * v26)) + 2 * (v25 / v26 & 1) + ((2 * v26 - 1) & ((v25 & 1) + 4 * (v25 >> 1))));
      v5 = (a3[v4] << 8) | a3[v4 + 1];
      v6 = (a3[v4 + 2] << 8) | a3[v4 + 3];
      v12 = _byteswap_ulong(*&a3[v4 + 4]);
      LOBYTE(v13) = (_byteswap_ushort(*&a3[v4]) & 0xF800) >> 8;
      BYTE1(v13) = (v5 & 0x7E0) >> 3;
      BYTE2(v13) = 8 * (v5 & 0x1F);
      HIBYTE(v13) = -1;
      LOBYTE(v14) = (v6 & 0xF800) >> 8;
      BYTE1(v14) = (v6 & 0x7E0) >> 3;
      BYTE2(v14) = 8 * (v6 & 0x1F);
      HIBYTE(v14) = -1;
      v18 = -1;
      if ( v5 <= v6 )
      {
        v15 = (v14 + v13) >> 1;
        v16 = (BYTE1(v14) + BYTE1(v13)) >> 1;
        v17 = (BYTE2(v14) + BYTE2(v13)) >> 1;
        v19 = (v13 + v14) >> 1;
        v20 = (BYTE1(v13) + BYTE1(v14)) >> 1;
        v21 = (BYTE2(v13) + BYTE2(v14)) >> 1;
        v22 = 0;
      }
      else
      {
        v15 = (3 * v14 + 5 * v13) >> 3;
        v16 = (3 * BYTE1(v14) + 5 * BYTE1(v13)) >> 3;
        v17 = (3 * BYTE2(v14) + 5 * BYTE2(v13)) >> 3;
        v19 = (3 * v13 + 5 * v14) >> 3;
        v20 = (3 * BYTE1(v13) + 5 * BYTE1(v14)) >> 3;
        v21 = (3 * BYTE2(v13) + 5 * BYTE2(v14)) >> 3;
        v22 = -1;
      }
      for ( k = 0; k < 4; ++k )
      {
        v10 = k + 4 * i;
        if ( k + 4 * i < a2 )
        {
          for ( l = 0; l < 4; ++l )
          {
            v8 = l + 4 * j;
            v7 = (v12 >> 30) & 3;
            v12 *= 4;
            if ( l + 4 * j < a1 )
            {
              a4[4 * (v8 + a1 * v10)] = *(&v13 + 4 * v7);
              a4[4 * (v8 + a1 * v10) + 1] = *(&v13 + 4 * v7 + 1);
              a4[4 * (v8 + a1 * v10) + 2] = *(&v13 + 4 * v7 + 2);
              a4[4 * (v8 + a1 * v10) + 3] = *(&v13 + 4 * v7 + 3);
            }
          }
        }
      }
      ++v25;
    }
  }
}

//----- (100614B0) --------------------------------------------------------
void __thiscall Texture::decodeData(Texture *this, struct TexImg *a2)
{
  int v2; // ST0C_4
  int v3; // ST08_4
  char v4; // STFC_1
  char v5; // STE0_1
  __int16 v6; // STC4_2
  unsigned int v7; // esi
  __int16 v8; // ST90_2
  unsigned __int8 v9; // ST8C_1
  unsigned __int8 v10; // ST88_1
  int v11; // eax
  unsigned int v12; // esi
  char v13; // [esp+0h] [ebp-14Ch]
  int kk; // [esp+68h] [ebp-E4h]
  int v15; // [esp+6Ch] [ebp-E0h]
  int ii; // [esp+90h] [ebp-BCh]
  int jj; // [esp+90h] [ebp-BCh]
  int v18; // [esp+94h] [ebp-B8h]
  int l; // [esp+ACh] [ebp-A0h]
  int v20; // [esp+B0h] [ebp-9Ch]
  int n; // [esp+C8h] [ebp-84h]
  int v22; // [esp+CCh] [ebp-80h]
  int m; // [esp+E4h] [ebp-68h]
  int v24; // [esp+E8h] [ebp-64h]
  int k; // [esp+100h] [ebp-4Ch]
  int v26; // [esp+104h] [ebp-48h]
  int v27; // [esp+108h] [ebp-44h]
  unsigned __int16 v28; // [esp+10Ch] [ebp-40h]
  unsigned __int8 v29; // [esp+114h] [ebp-38h]
  int i; // [esp+120h] [ebp-2Ch]
  int v31; // [esp+124h] [ebp-28h]
  int v32; // [esp+128h] [ebp-24h]
  unsigned __int16 v33; // [esp+12Ch] [ebp-20h]
  unsigned __int8 v34; // [esp+130h] [ebp-1Ch]
  unsigned __int8 v35; // [esp+134h] [ebp-18h]
  unsigned __int8 v36; // [esp+138h] [ebp-14h]
  unsigned __int8 v37; // [esp+13Ch] [ebp-10h]
  int j; // [esp+140h] [ebp-Ch]
  int v39; // [esp+144h] [ebp-8h]
  Texture *v40; // [esp+148h] [ebp-4h]

  v40 = this;
  Texture::createBuffer(this, *(a2 + 7), *(a2 + 8), *(a2 + 6), *(a2 + 12));
  if ( !*(a2 + 12) )
  {
    v2 = *(a2 + 11);
    v3 = *(a2 + 8);
    sub_10062280("decoding data %d x %d : %08x\n", *(a2 + 7));
    switch ( *(a2 + 6) )
    {
      case 0:
        v31 = *(a2 + 11);
        for ( i = 0; i < *(v40 + 5) * *(v40 + 4); ++i )
        {
          v28 = ((*(v31 + 2 * i) & 0xFF00) >> 8) | ((*(v31 + 2 * i) & 0xFF) << 8);
          *(v31 + 2 * i);
          v29 = 8 * (((*(v31 + 2 * i) & 0xFF00) >> 8) & 0x1F);
          v27 = Texture::offsetGXtoGL(v40, i);
          if ( v27 >= *(v40 + 5) * *(v40 + 4) )
          {
            sub_10062280("too big an offset!\n", v13);
            v27 = 0;
          }
          *(*(v40 + 5) + 4 * v27) = (8 * ((v28 >> 11) & 0x1F)) | ((4 * ((v28 >> 5) & 0x3F)) << 8) | (v29 << 16) | 0xFF000000;
        }
        break;
      case 1:
        Texture::decodeS3TC(*(v40 + 4), *(v40 + 5), *(a2 + 11), *(v40 + 5));
        break;
      case 2:
        v39 = *(a2 + 11);
        for ( j = 0; j < *(v40 + 5) * *(v40 + 4); ++j )
        {
          v33 = ((*(v39 + 2 * j) & 0xFF00) >> 8) | ((*(v39 + 2 * j) & 0xFF) << 8);
          if ( v33 & 0x8000 )
          {
            v37 = 8 * ((v33 >> 10) & 0x1F);
            v36 = 8 * ((v33 >> 5) & 0x1F);
            *(v39 + 2 * j);
            v35 = 8 * (((*(v39 + 2 * j) & 0xFF00) >> 8) & 0x1F);
            v34 = -1;
          }
          else
          {
            v37 = 16 * (HIBYTE(v33) & 0xF);
            v36 = 16 * ((v33 >> 4) & 0xF);
            v35 = 16 * (v33 & 0xF);
            v34 = 32 * ((v33 >> 12) & 7);
          }
          v32 = Texture::offsetGXtoGL(v40, j);
          if ( v32 >= *(v40 + 5) * *(v40 + 4) )
          {
            sub_10062280("too big an offset!\n", v13);
            v32 = 0;
          }
          *(*(v40 + 5) + 4 * v32) = v37 | (v36 << 8) | (v35 << 16) | (v34 << 24);
        }
        break;
      case 3:
        v26 = *(a2 + 11);
        for ( k = 0; k < *(v40 + 5) * (*(v40 + 4) / 2); ++k )
        {
          v4 = *(k + v26);
          *(*(v40 + 5) + 4 * Texture::offsetGXtoGL(v40, 2 * k)) = (16 * ((v4 & 0xF0) >> 4)) | ((16 * ((v4 & 0xF0) >> 4)) << 8) | ((16 * ((v4 & 0xF0) >> 4)) << 16) | 0xFF000000;
          *(*(v40 + 5) + 4 * Texture::offsetGXtoGL(v40, 2 * k + 1)) = (16 * (v4 & 0xF)) | ((16 * (v4 & 0xF)) << 8) | ((16 * (v4 & 0xF)) << 16) | 0xFF000000;
        }
        break;
      case 4:
        v20 = *(a2 + 11);
        for ( l = 0; l < *(v40 + 5) * *(v40 + 4); ++l )
        {
          v7 = *(l + v20) | (*(l + v20) << 8) | (*(l + v20) << 16) | 0xFF000000;
          *(*(v40 + 5) + 4 * Texture::offsetGXtoGL(v40, l)) = v7;
        }
        break;
      case 5:
        v24 = *(a2 + 11);
        for ( m = 0; m < *(v40 + 5) * *(v40 + 4); ++m )
        {
          v5 = *(m + v24);
          *(*(v40 + 5) + 4 * Texture::offsetGXtoGL(v40, m)) = (16 * (v5 & 0xF)) | ((16 * (v5 & 0xF)) << 8) | ((16 * (v5 & 0xF)) << 16) | ((16 * ((v5 & 0xF0) >> 4)) << 24);
        }
        break;
      case 6:
        v22 = *(a2 + 11);
        for ( n = 0; n < *(v40 + 5) * *(v40 + 4); ++n )
        {
          v6 = ((*(v22 + 2 * n) & 0xFF00) >> 8) | ((*(v22 + 2 * n) & 0xFF) << 8);
          *(v22 + 2 * n);
          *(*(v40 + 5) + 4 * Texture::offsetGXtoGL(v40, n)) = v6 | (v6 << 8) | (v6 << 16) | (HIBYTE(v6) << 24);
        }
        break;
      case 7:
        v18 = *(a2 + 11);
        for ( ii = 0; ii < *(v40 + 5) * *(v40 + 4); ++ii )
        {
          v8 = ((*(v18 + 2 * ((ii & 0xF) + 32 * (ii / 16))) & 0xFF00) >> 8) | ((*(v18 + 2
                                                                                      * ((ii & 0xF) + 32 * (ii / 16))) & 0xFF) << 8);
          *(*(v40 + 5) + 4 * Texture::offsetGXtoGL(v40, ii)) = v8 | (HIBYTE(v8) << 24);
        }
        for ( jj = 0; jj < *(v40 + 5) * *(v40 + 4); ++jj )
        {
          v9 = (((*(v18 + 2 * ((jj & 0xF) + 32 * (jj / 16)) + 32) & 0xFF00) >> 8) | ((*(v18
                                                                                      + 2
                                                                                      * ((jj & 0xF) + 32 * (jj / 16))
                                                                                      + 32) & 0xFF) << 8)) >> 8;
          *(v18 + 2 * ((jj & 0xF) + 32 * (jj / 16)) + 32);
          v10 = (*(v18 + 2 * ((jj & 0xF) + 32 * (jj / 16)) + 32) & 0xFF00) >> 8;
          v11 = Texture::offsetGXtoGL(v40, jj);
          *(*(v40 + 5) + 4 * v11) |= (v9 << 8) | (v10 << 16);
        }
        break;
      case 9:
        v15 = *(a2 + 11);
        for ( kk = 0; kk < *(v40 + 5) * *(v40 + 4); ++kk )
        {
          v12 = *(kk + v15) | (*(kk + v15) << 8) | (*(kk + v15) << 16) | 0xFF000000;
          *(*(v40 + 5) + 4 * Texture::offsetGXtoGL(v40, kk)) = v12;
        }
        break;
      default:
        sub_10060690("Unknown texture format\n");
        return;
    }
    *(a2 + 12) = *(v40 + 5);
  }
}

//----- (10062280) --------------------------------------------------------
char *__cdecl sub_10062280(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "Texture" )
      Stream::print(sysCon, "%s: ", "Texture");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (100627E0) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 )
    hInstance = hinstDLL;
  return 1;
}

//----- (10062970) --------------------------------------------------------
void __noreturn sub_10062970(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscore\\atxbuffer.cpp", 5, &Dest);
}

//----- (10062A50) --------------------------------------------------------
_DWORD *__thiscall sub_10062A50(int this)
{
  _DWORD *v1; // ST58_4
  _DWORD *result; // eax

  v1 = this;
  RandomAccessStream::readFrom(*(this + 8), *(this + 12), this, 8);
  v1[6] = ((v1[1] & 0xFF000000) >> 24) | ((v1[1] & 0xFF0000) >> 8) | ((v1[1] & 0xFF00) << 8) | (v1[1] << 24);
  result = v1;
  v1[5] = ((*v1 & 0xFF000000) >> 24) | ((*v1 & 0xFF0000) >> 8) | ((*v1 & 0xFF00) << 8) | (*v1 << 24);
  return result;
}

//----- (10062B60) --------------------------------------------------------
void __thiscall sub_10062B60(void *this)
{
  *(this + 1) = ((*(this + 6) & 0xFF000000) >> 24) | ((*(this + 6) & 0xFF0000u) >> 8) | ((*(this + 6) & 0xFF00) << 8) | (*(this + 6) << 24);
  *this = ((*(this + 5) & 0xFF000000) >> 24) | ((*(this + 5) & 0xFF0000u) >> 8) | ((*(this + 5) & 0xFF00) << 8) | (*(this + 5) << 24);
  RandomAccessStream::writeTo(*(this + 2), *(this + 3), this, 8);
}

//----- (10062C70) --------------------------------------------------------
int __thiscall sub_10062C70(_DWORD *this)
{
  int v2; // [esp+4Ch] [ebp-8h]
  _DWORD *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  sub_10001A9B(this);
  v2 = v3[6] - v3[5] - 8;
  if ( v2 <= 0 )
    v2 = v3[4] - v3[5];
  return v2;
}
// 10001A9B: using guessed type int __thiscall sub_10001A9B(_DWORD);

//----- (10062CF0) --------------------------------------------------------
int __thiscall sub_10062CF0(_DWORD *this)
{
  int v2; // [esp+4Ch] [ebp-8h]
  _DWORD *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  sub_10001A9B(this);
  v2 = v3[5] - v3[6];
  if ( v2 < 0 )
    v2 = v3[4] - v3[6];
  return v2;
}
// 10001A9B: using guessed type int __thiscall sub_10001A9B(_DWORD);

//----- (10062EA0) --------------------------------------------------------
char *__cdecl sub_10062EA0(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "atxBuffer" )
      Stream::print(sysCon, "%s: ", "atxBuffer");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10063120) --------------------------------------------------------
AtxRouter *__thiscall AtxDirectRouter::AtxDirectRouter(AtxDirectRouter *this, char *Str1)
{
  char *v3; // [esp+4Ch] [ebp-8h]
  AtxRouter *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  AtxRouter::AtxRouter(this);
  *v4 = &AtxDirectRouter::`vftable';
  if ( !strcmp(Str1, "self") )
    v3 = gsys + 952;
  else
    v3 = StdSystem::stringDup(Str1);
  *(v4 + 1) = v3;
  *(v4 + 4) = 0;
  return v4;
}
// 101AFA94: using guessed type void *AtxDirectRouter::`vftable';

//----- (100631D0) --------------------------------------------------------
void __thiscall AtxDirectRouter::setWindow(AtxDirectRouter *this, unsigned __int32 a2)
{
  if ( a2 )
  {
    if ( *(this + 4) )
      WSocket::setASync(*(*(this + 4) + 8), a2, 0x433u, 0x21u, -1);
  }
}

//----- (10063240) --------------------------------------------------------
char __thiscall AtxDirectRouter::openRoute(AtxDirectRouter *this, struct AtxStream *a2, int a3)
{
  int v4; // [esp+4Ch] [ebp-20h]
  TcpStream *hMem; // [esp+50h] [ebp-1Ch]
  AtxDirectRouter *v6; // [esp+5Ch] [ebp-10h]

  v6 = this;
  hMem = sub_10002A81(0x10u);
  if ( hMem )
    v4 = TcpStream::TcpStream(hMem);
  else
    v4 = 0;
  *(v6 + 4) = v4;
  *(*(v6 + 4) + 12) = 2;
  if ( !TcpStream::connect(*(v6 + 4), *(v6 + 1), 1369) )
    return 0;
  if ( sysCurrWnd )
    WSocket::setASync(*(*(v6 + 4) + 8), sysCurrWnd, 0x433u, 0x21u, -1);
  *(a2 + 2) = *(v6 + 4);
  return 1;
}

//----- (10063380) --------------------------------------------------------
void __stdcall AtxDirectRouter::closeRoute(struct AtxStream *a2)
{
  ;
}

//----- (100633B0) --------------------------------------------------------
void AtxDirectRouter::reset()
{
  ;
}

//----- (100633E0) --------------------------------------------------------
void AtxDirectRouter::closeAll()
{
  ;
}

//----- (10063410) --------------------------------------------------------
int WSocket::closing()
{
  return 0;
}

//----- (10063440) --------------------------------------------------------
_DWORD *__thiscall WSocket::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (10063490) --------------------------------------------------------
TcpStream *__thiscall TcpStream::TcpStream(TcpStream *this)
{
  TcpStream *v1; // ST50_4

  v1 = this;
  Stream::Stream(this);
  *v1 = &TcpStream::`vftable';
  *(v1 + 2) = 0;
  *(v1 + 3) = 0;
  return v1;
}
// 101AFABC: using guessed type void *TcpStream::`vftable';

//----- (10063500) --------------------------------------------------------
TcpStream *__thiscall TcpStream::TcpStream(TcpStream *this, const struct TcpStream *a2)
{
  TcpStream *v2; // ST50_4

  v2 = this;
  Stream::Stream(this, a2);
  *(v2 + 2) = *(a2 + 2);
  *(v2 + 3) = *(a2 + 3);
  *v2 = &TcpStream::`vftable';
  return v2;
}
// 101AFABC: using guessed type void *TcpStream::`vftable';

//----- (10063580) --------------------------------------------------------
_DWORD *__thiscall TcpStream::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  Stream::operator=(a2);
  v2[2] = *(a2 + 8);
  v2[3] = *(a2 + 12);
  return v2;
}
// 100024B4: using guessed type _DWORD __stdcall Stream::operator=(_DWORD);

//----- (100635F0) --------------------------------------------------------
bool __thiscall AtxDirectRouter::isConnected(AtxDirectRouter *this)
{
  return *(this + 13);
}

//----- (10063630) --------------------------------------------------------
void AtxDirectRouter::lock()
{
  ;
}

//----- (10063660) --------------------------------------------------------
void AtxDirectRouter::unlock()
{
  ;
}

//----- (10063690) --------------------------------------------------------
AtxRouter *__thiscall AtxDirectRouter::AtxDirectRouter(AtxDirectRouter *this, const struct AtxDirectRouter *a2)
{
  AtxRouter *v2; // ST50_4

  v2 = this;
  AtxRouter::AtxRouter(this, a2);
  *(v2 + 1) = *(a2 + 1);
  *(v2 + 2) = *(a2 + 2);
  *(v2 + 12) = *(a2 + 12);
  *(v2 + 13) = *(a2 + 13);
  *(v2 + 4) = *(a2 + 4);
  *v2 = &AtxDirectRouter::`vftable';
  return v2;
}
// 101AFA94: using guessed type void *AtxDirectRouter::`vftable';

//----- (10063740) --------------------------------------------------------
_DWORD *__thiscall AtxDirectRouter::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  AtxRouter::operator=(a2);
  v2[1] = *(a2 + 4);
  v2[2] = *(a2 + 8);
  *(v2 + 12) = *(a2 + 12);
  *(v2 + 13) = *(a2 + 13);
  v2[4] = *(a2 + 16);
  return v2;
}
// 10002996: using guessed type _DWORD __stdcall AtxRouter::operator=(_DWORD);

//----- (100637E0) --------------------------------------------------------
void __thiscall ControllerMgr::update(ControllerMgr *this)
{
  GetKeyboardState(this + 4);
}

//----- (10063840) --------------------------------------------------------
void __thiscall ControllerMgr::updateController(ControllerMgr *this, struct Controller *a2)
{
  unsigned __int32 v2; // eax
  unsigned __int32 v3; // eax
  unsigned __int32 v4; // eax
  unsigned __int32 v5; // eax
  unsigned __int32 v6; // eax
  unsigned __int32 v7; // eax
  unsigned __int32 v8; // eax
  unsigned __int32 v9; // eax
  unsigned __int32 v10; // eax
  unsigned __int32 v11; // eax
  unsigned __int32 v12; // eax
  unsigned __int32 v13; // eax
  unsigned __int32 v14; // [esp+4Ch] [ebp-8h]
  ControllerMgr *v15; // [esp+50h] [ebp-4h]

  v15 = this;
  v14 = 0;
  if ( (**this)(this, 'V') & 0xFF )
  {
    v2 = v14;
    BYTE1(v2) |= 0x40u;
    v14 = v2;
  }
  if ( (**v15)(v15, 'N') & 0xFF )
  {
    v3 = v14;
    BYTE1(v3) |= 0x80u;
    v14 = v3;
  }
  if ( (**v15)(v15, '\r') & 0xFF )
    v14 |= 0x1000000u;
  if ( (**v15)(v15, '\t') & 0xFF )
    v14 |= 0x10000u;
  if ( (**v15)(v15, 'g') & 0xFF )
    v14 |= 0x20000u;
  if ( (**v15)(v15, 'i') & 0xFF )
    v14 |= 0x40000u;
  if ( (**v15)(v15, 'd') & 0xFF )
    v14 |= 0x400000u;
  if ( (**v15)(v15, 'f') & 0xFF )
    v14 |= 0x100000u;
  if ( (**v15)(v15, 'h') & 0xFF )
    v14 |= 0x80000u;
  if ( (**v15)(v15, 'b') & 0xFF )
    v14 |= 0x200000u;
  if ( (**v15)(v15, ' ') & 0xFF )
  {
    v4 = v14;
    BYTE1(v4) |= 0x10u;
    v14 = v4;
  }
  if ( (**v15)(v15, 'B') & 0xFF )
  {
    v5 = v14;
    BYTE1(v5) |= 0x20u;
    v14 = v5;
  }
  if ( (**v15)(v15, '%') & 0xFF )
  {
    v6 = v14;
    LOBYTE(v6) = v14 | 1;
    v14 = v6;
  }
  if ( (**v15)(v15, '\'') & 0xFF )
  {
    v7 = v14;
    LOBYTE(v7) = v14 | 2;
    v14 = v7;
  }
  if ( (**v15)(v15, '&') & 0xFF )
  {
    v8 = v14;
    LOBYTE(v8) = v14 | 4;
    v14 = v8;
  }
  if ( (**v15)(v15, '(') & 0xFF )
  {
    v9 = v14;
    LOBYTE(v9) = v14 | 8;
    v14 = v9;
  }
  if ( (**v15)(v15, 'S') & 0xFF )
  {
    v10 = v14;
    BYTE1(v10) |= 1u;
    v14 = v10;
  }
  if ( (**v15)(v15, 'D') & 0xFF )
  {
    v11 = v14;
    BYTE1(v11) |= 2u;
    v14 = v11;
  }
  if ( (**v15)(v15, 'A') & 0xFF )
  {
    v12 = v14;
    BYTE1(v12) |= 4u;
    v14 = v12;
  }
  if ( (**v15)(v15, 'Z') & 0xFF )
  {
    v13 = v14;
    BYTE1(v13) |= 8u;
    v14 = v13;
  }
  a2->byte45 = 0;
  if ( v14 & 0x400000 )
  {
    a2->byte45 = -74;
  }
  else if ( v14 & 0x100000 )
  {
    a2->byte45 = 74;
  }
  a2->byte46 = 0;
  if ( v14 & 0x200000 )
  {
    a2->byte46 = -74;
  }
  else if ( v14 & 0x80000 )
  {
    a2->byte46 = 74;
  }
  a2->byte47 = 0;
  if ( v14 & 1 )
  {
    a2->byte47 = -74;
  }
  else if ( v14 & 2 )
  {
    a2->byte47 = 74;
  }
  a2->byte48 = 0;
  if ( v14 & 8 )
  {
    a2->byte48 = -74;
  }
  else if ( v14 & 4 )
  {
    a2->byte48 = 74;
  }
  a2->byte49 = (v14 & 0x1000) != 0 ? 0xF : 0;
  a2->byte4A = (v14 & 0x2000) != 0 ? 0xF : 0;
  a2->byte4B = (v14 & 0x20000) != 0 ? 0xAA : 0;
  a2->byte4C = (v14 & 0x40000) != 0 ? 0xAA : 0;
  Controller::updateCont(a2, v14);
}

//----- (10063DD0) --------------------------------------------------------
LPSTR __cdecl getOpenFilename(HWND a1, char *Str)
{
  char *v2; // eax
  LPSTR result; // eax
  int v4; // [esp+4Ch] [ebp-4h]

  sprintf(Dest, "Open file ...");
  v2 = getcwd(0, 0);
  sprintf(byte_101D5F2C, "%s", v2);
  sprintf(byte_101D602C, `string');
  sub_10063F10(a1, Str);
  stru_101D5DE0.Flags = 8913440;
  stru_101D5DE0.lpstrTitle = Dest;
  stru_101D5DE0.lpstrFile = byte_101D602C;
  stru_101D5DE0.lpstrInitialDir = byte_101D5F2C;
  stru_101D5DE0.hwndOwner = a1;
  LOBYTE(v4) = GetOpenFileNameA(&stru_101D5DE0) != 0;
  if ( v4 )
    result = stru_101D5DE0.lpstrFile;
  else
    result = 0;
  return result;
}

//----- (10063F10) --------------------------------------------------------
int __cdecl sub_10063F10(int a1, char *Str)
{
  int result; // eax
  signed int i; // [esp+4Ch] [ebp-8h]
  signed int v4; // [esp+50h] [ebp-4h]

  v4 = strlen(Str);
  for ( i = 0; i < v4; ++i )
  {
    if ( Str[i] == 124 )
      Str[i] = 0;
  }
  stru_101D5DE0.lStructSize = 76;
  result = a1;
  stru_101D5DE0.hwndOwner = a1;
  stru_101D5DE0.hInstance = sysHInst;
  stru_101D5DE0.lpstrFilter = Str;
  stru_101D5DE0.lpstrCustomFilter = 0;
  stru_101D5DE0.nMaxCustFilter = 0;
  stru_101D5DE0.nFilterIndex = 0;
  stru_101D5DE0.lpstrFile = 0;
  stru_101D5DE0.nMaxFile = 260;
  stru_101D5DE0.lpstrFileTitle = 0;
  stru_101D5DE0.nMaxFileTitle = 512;
  stru_101D5DE0.lpstrInitialDir = 0;
  stru_101D5DE0.lpstrTitle = 0;
  stru_101D5DE0.Flags = 0;
  stru_101D5DE0.nFileOffset = 0;
  stru_101D5DE0.nFileExtension = 0;
  stru_101D5DE0.lpstrDefExt = 0;
  stru_101D5DE0.lCustData = 0;
  stru_101D5DE0.lpfnHook = sub_10064090;
  stru_101D5DE0.lpTemplateName = 0;
  return result;
}

//----- (10064090) --------------------------------------------------------
BOOL __stdcall sub_10064090(int a1, int a2, int a3, int a4)
{
  return a2 == 272;
}

//----- (100640E0) --------------------------------------------------------
LPSTR __cdecl getSaveFilename(HWND a1, char *Str, char *a3)
{
  char *v3; // eax
  LPSTR result; // eax
  char *Format; // [esp+4Ch] [ebp-8h]
  int v6; // [esp+50h] [ebp-4h]

  sprintf(Dest, "Save file as ...");
  v3 = getcwd(0, 0);
  sprintf(byte_101D5F2C, "%s", v3);
  if ( a3 )
    Format = a3;
  else
    Format = `string';
  sprintf(byte_101D602C, Format);
  sub_10063F10(a1, Str);
  stru_101D5DE0.Flags = 557094;
  stru_101D5DE0.lpstrTitle = Dest;
  stru_101D5DE0.lpstrFile = byte_101D602C;
  stru_101D5DE0.lpstrInitialDir = byte_101D5F2C;
  stru_101D5DE0.hwndOwner = a1;
  LOBYTE(v6) = GetSaveFileNameA(&stru_101D5DE0) != 0;
  if ( v6 )
    result = stru_101D5DE0.lpstrFile;
  else
    result = 0;
  return result;
}

//----- (10064240) --------------------------------------------------------
int __thiscall sub_10064240(BaseApp **this, HWND hWnd, unsigned int a3, int a4, int a5)
{
  AppWindow *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  switch ( a3 )
  {
    case 6u:
      sub_100643D0("active %d\n", a4);
      *(*(v6 + 34) + 40) = a4 != 0;
      break;
    case 0x100u:
      switch ( a4 )
      {
        case 112:
          if ( *(gsys + 148) == 1 )
            *(this[34] + 88) = 1;
          break;
        case 113:
          *(gsys + 7) = (*(gsys + 7) + 1) % 3u;
          Timers::reset(*(gsys + 14));
          break;
        case 114:
          *(gsys + 588) ^= 1u;
          StdSystem::detachObjs(gsys);
          StdSystem::attachObjs(gsys);
          break;
      }
      break;
    case 0x433u:
      BaseApp::idleupdate(this[34]);
      break;
  }
  return AppWindow::processMessage(v6, hWnd, a3, a4, a5);
}

//----- (100643D0) --------------------------------------------------------
char *__cdecl sub_100643D0(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "gameApp" )
      Stream::print(sysCon, "%s: ", "gameApp");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (100644E0) --------------------------------------------------------
void __thiscall GameApp::doInitApp(GameApp *this)
{
  struct RectArea *v1; // eax
  char *v2; // eax
  int v3; // ST0C_4
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // [esp+4Ch] [ebp-94h]
  char *v7; // [esp+50h] [ebp-90h]
  char v8; // [esp+54h] [ebp-8Ch]
  HGLOBAL v9; // [esp+58h] [ebp-88h]
  _DWORD *v10; // [esp+5Ch] [ebp-84h]
  char v11; // [esp+60h] [ebp-80h]
  HGLOBAL hMem; // [esp+70h] [ebp-70h]
  char *v13; // [esp+74h] [ebp-6Ch]
  UIWindow *v14; // [esp+78h] [ebp-68h]
  int v15; // [esp+7Ch] [ebp-64h]
  int v16; // [esp+80h] [ebp-60h]
  int v17; // [esp+84h] [ebp-5Ch]
  int v18; // [esp+88h] [ebp-58h]
  int v19; // [esp+8Ch] [ebp-54h]
  struct tagRECT Rect; // [esp+90h] [ebp-50h]
  int v21; // [esp+A0h] [ebp-40h]
  int v22; // [esp+A4h] [ebp-3Ch]
  int v23; // [esp+A8h] [ebp-38h]
  int v24; // [esp+ACh] [ebp-34h]
  int v25; // [esp+B0h] [ebp-30h]
  int v26; // [esp+B4h] [ebp-2Ch]
  int v27; // [esp+B8h] [ebp-28h]
  int v28; // [esp+BCh] [ebp-24h]
  int v29; // [esp+C0h] [ebp-20h]
  int v30; // [esp+C4h] [ebp-1Ch]
  DWORD dwStyle; // [esp+C8h] [ebp-18h]
  DWORD dwExStyle; // [esp+CCh] [ebp-14h]
  CoreNode *v33; // [esp+D0h] [ebp-10h]
  int v34; // [esp+DCh] [ebp-4h]

  v33 = this;
  if ( *(gsys + 589) )
  {
    dwExStyle = 0x40000;
    dwStyle = -1879048192;
    v29 = 0;
    v30 = 0;
    v28 = glnWidth;
    v27 = glnHeight;
  }
  else
  {
    dwExStyle = 0x40000;
    dwStyle = -2143027200;
    v21 = 32;
    v22 = 32;
    v23 = 128;
    v24 = 128;
    Rect.left = 32;
    Rect.top = 32;
    Rect.right = 128;
    Rect.bottom = 128;
    AdjustWindowRectEx(&Rect, 0x80440000, 0, 0x40000u);
    v19 = Rect.left - v21;
    v18 = Rect.top - v22;
    v17 = Rect.right - v23;
    v16 = Rect.bottom - v24;
    v26 = Rect.right - v23 + v21 - Rect.left;
    v25 = Rect.bottom - v24 + v22 - Rect.top;
    v30 = 24;
    v29 = 32;
    v28 = v26 + glnWidth;
    v27 = v25 + glnHeight;
  }
  hMem = sub_10002A81(0x90u);
  v34 = 0;
  if ( hMem )
    v7 = sub_10001EAB(0, 0, dwStyle | 0x6000000, dwExStyle, 0);
  else
    v7 = 0;
  v13 = v7;
  v34 = -1;
  v33[4].name = v7;
  *(v33[4].name + 34) = v33;
  v1 = RectArea::RectArea(&v11, v30, v29, v28 + v30, v27 + v29);
  UIFrame::setFrame(v33[4].name, v1);
  v2 = CoreNode::Name(v33);
  (*(*v33[4].name + 80))(v33[4].name, "DUIGenWin", v2, 0);
  v15 = System::getAtxRouter(gsys);
  if ( v15 )
    (*(*v15 + 28))(v15, *(v33[4].name + 25));
  v9 = sub_10002A81(0xA4u);
  v34 = 1;
  if ( v9 )
    v6 = RenderWindow::RenderWindow(v9, v33[4].name, 15, 1342177280, 0, 0);
  else
    v6 = 0;
  v10 = v6;
  v34 = -1;
  v14 = v6;
  v6[37] = v33;
  *(v14 + 39) = v33[4].name;
  v3 = RectArea::height((v33[4].name + 64));
  v4 = RectArea::width((v33[4].name + 64));
  UIWindow::sizeWindow(v14, v4, v3, 0);
  (*(*v14 + 80))(v14, "DUIClearWin", "Render", 0);
  *(v33[4].name + 35) = v14;
  v5 = Colour::Colour(&v8, 0, 0, 0, 0);
  (*(**(v14 + 40) + 172))(*(v14 + 40), v5);
  (*(*v33[4].name + 52))(v33[4].name);
  ShowWindow(*(v33[4].name + 25), 1);
  if ( *(gsys + 589) )
    ShowCursor(0);
  LOBYTE(v33[4].Parent) = 0;
}
// 10002626: using guessed type int __thiscall System::getAtxRouter(_DWORD);

//----- (100649B0) --------------------------------------------------------
AppWindow *__thiscall sub_100649B0(AppWindow *this, struct UIWindow *a2, int a3, int a4, int a5, char a6)
{
  AppWindow *v6; // ST60_4

  v6 = this;
  AppWindow::AppWindow(this, a2, a3, a4, a5, a6);
  *v6 = off_101AFB84;
  return v6;
}
// 101AFB84: using guessed type void (__thiscall *off_101AFB84[2])(CoreNode *this, struct AgeServer *);

//----- (10064A20) --------------------------------------------------------
int __thiscall GameApp::idle(GameApp *this)
{
  int v2; // [esp+4Ch] [ebp-Ch]
  int v3; // [esp+50h] [ebp-8h]
  GameApp *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  sysCurrWnd = *(*(this + 21) + 100);
  v3 = BaseApp::idleupdate(this);
  sysCurrWnd = 0;
  if ( !*(v4 + 40) && !v3 )
    return 0;
  v2 = StdSystem::setHeap(gsys, -1);
  if ( *(v4 + 88) )
  {
    *(gsys + 590) = 1;
    SendMessageA(*(*(v4 + 21) + 100), 0x10u, 0, 0);
    *(gsys + 590) = 0;
    *(gsys + 589) ^= 1u;
    GameApp::doInitApp(v4);
    StdSystem::attachObjs(gsys);
    *(v4 + 88) = 0;
  }
  StdSystem::setHeap(gsys, v2);
  return 1;
}

//----- (10064B70) --------------------------------------------------------
void __thiscall GameApp::renderall(GameApp *this)
{
  GameApp *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  (*(**(this + 21) + 20))(*(this + 21));
}

//----- (10064BD0) --------------------------------------------------------
void __thiscall UIFrame::calcClientFromFrame(UIFrame *this, struct RectArea *a2)
{
  UIFrame *v2; // ST50_4

  v2 = this;
  *a2 = 0;
  *(a2 + 1) = 0;
  *(a2 + 2) = RectArea::width((this + 32)) - (*(v2 + 14) - *(v2 + 12));
  *(a2 + 3) = RectArea::height((v2 + 32)) - (*(v2 + 15) - *(v2 + 13));
}

//----- (10064C80) --------------------------------------------------------
void __thiscall UIFrame::calcFrameFromClient(UIFrame *this, struct RectArea *a2)
{
  UIFrame *v2; // ST50_4

  v2 = this;
  *a2 += *(this + 12);
  *(a2 + 1) += *(this + 13);
  *(a2 + 2) = *(v2 + 14) + *(v2 + 18) + *a2 - *(v2 + 12);
  *(a2 + 3) = *(v2 + 15) + *(v2 + 19) + *(a2 + 1) - *(this + 13);
}

//----- (10064D30) --------------------------------------------------------
void __thiscall UIFrame::setFrame(UIFrame *this, struct RectArea *a2)
{
  UIFrame *v2; // ST50_4
  _DWORD *v3; // ecx

  v2 = this;
  v3 = (this + 32);
  *v3 = *a2;
  v3[1] = *(a2 + 1);
  v3[2] = *(a2 + 2);
  v3[3] = *(a2 + 3);
  UIFrame::calcClientFromFrame(v2, (v2 + 64));
}

//----- (10064DB0) --------------------------------------------------------
void __thiscall UIFrame::setClient(UIFrame *this, struct RectArea *a2)
{
  UIFrame *v2; // ST50_4
  _DWORD *v3; // ecx

  v2 = this;
  v3 = (this + 64);
  *v3 = *a2;
  v3[1] = *(a2 + 1);
  v3[2] = *(a2 + 2);
  v3[3] = *(a2 + 3);
  UIFrame::calcFrameFromClient(v2, (v2 + 32));
}

//----- (10064E30) --------------------------------------------------------
UIFrame *__thiscall UIFrame::UIFrame(UIFrame *this, const struct UIFrame *a2)
{
  UIFrame *v2; // ST50_4
  _DWORD *v3; // edx
  _DWORD *v4; // eax
  _DWORD *v5; // ecx

  v2 = this;
  Node::Node(this, a2);
  v3 = (v2 + 32);
  *v3 = *(a2 + 8);
  v3[1] = *(a2 + 9);
  v3[2] = *(a2 + 10);
  v3[3] = *(a2 + 11);
  v4 = (v2 + 48);
  *v4 = *(a2 + 12);
  v4[1] = *(a2 + 13);
  v4[2] = *(a2 + 14);
  v4[3] = *(a2 + 15);
  v5 = (v2 + 64);
  *v5 = *(a2 + 16);
  v5[1] = *(a2 + 17);
  v5[2] = *(a2 + 18);
  v5[3] = *(a2 + 19);
  *v2 = &UIFrame::`vftable';
  return v2;
}
// 101AFBF0: using guessed type void *UIFrame::`vftable';

//----- (10064F10) --------------------------------------------------------
_DWORD *__thiscall UIFrame::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // edx
  _DWORD *v4; // eax
  _DWORD *v5; // ecx

  v2 = this;
  Node::operator=(a2);
  v3 = v2 + 8;
  *v3 = a2[8];
  v3[1] = a2[9];
  v3[2] = a2[10];
  v3[3] = a2[11];
  v4 = v2 + 12;
  *v4 = a2[12];
  v4[1] = a2[13];
  v4[2] = a2[14];
  v4[3] = a2[15];
  v5 = v2 + 16;
  *v5 = a2[16];
  v5[1] = a2[17];
  v5[2] = a2[18];
  v5[3] = a2[19];
  return v2;
}
// 1000171C: using guessed type _DWORD __stdcall Node::operator=(_DWORD);

//----- (10064FE0) --------------------------------------------------------
void __thiscall UIWindow::refreshWindow(UIWindow *this)
{
  int v1; // ST04_4
  int v2; // eax
  UIWindow *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v1 = RectArea::height((this + 64));
  v2 = RectArea::width((v3 + 64));
  (*(*v3 + 56))(v3, v2, v1);
}

//----- (10065050) --------------------------------------------------------
UIFrame *__thiscall UIWindow::UIWindow(UIWindow *this, const struct UIWindow *a2)
{
  UIFrame *v2; // ST50_4
  _DWORD *v3; // edx

  v2 = this;
  UIFrame::UIFrame(this, a2);
  v3 = (v2 + 80);
  *v3 = *(a2 + 20);
  v3[1] = *(a2 + 21);
  v3[2] = *(a2 + 22);
  v3[3] = *(a2 + 23);
  *(v2 + 24) = *(a2 + 24);
  *(v2 + 25) = *(a2 + 25);
  *(v2 + 26) = *(a2 + 26);
  *(v2 + 27) = *(a2 + 27);
  *(v2 + 28) = *(a2 + 28);
  *(v2 + 29) = *(a2 + 29);
  *(v2 + 30) = *(a2 + 30);
  *(v2 + 31) = *(a2 + 31);
  *(v2 + 128) = *(a2 + 128);
  *(v2 + 33) = *(a2 + 33);
  *v2 = &UIWindow::`vftable';
  return v2;
}
// 101AFC30: using guessed type void *UIWindow::`vftable';

//----- (10065180) --------------------------------------------------------
_DWORD *__thiscall UIWindow::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4
  _DWORD *v3; // edx

  v2 = this;
  UIFrame::operator=(a2);
  v3 = v2 + 20;
  *v3 = *(a2 + 80);
  v3[1] = *(a2 + 84);
  v3[2] = *(a2 + 88);
  v3[3] = *(a2 + 92);
  v2[24] = *(a2 + 96);
  v2[25] = *(a2 + 100);
  v2[26] = *(a2 + 104);
  v2[27] = *(a2 + 108);
  v2[28] = *(a2 + 112);
  v2[29] = *(a2 + 116);
  v2[30] = *(a2 + 120);
  v2[31] = *(a2 + 124);
  *(v2 + 128) = *(a2 + 128);
  v2[33] = *(a2 + 132);
  return v2;
}
// 10002DB0: using guessed type _DWORD __stdcall UIFrame::operator=(_DWORD);

//----- (100652A0) --------------------------------------------------------
UIWindow *__thiscall ToolWindow::ToolWindow(ToolWindow *this, const struct ToolWindow *a2)
{
  UIWindow *v2; // ST50_4

  v2 = this;
  UIWindow::UIWindow(this, a2);
  *(v2 + 34) = *(a2 + 34);
  *(v2 + 35) = *(a2 + 35);
  *v2 = &ToolWindow::`vftable';
  return v2;
}
// 101AFC9C: using guessed type void *ToolWindow::`vftable';

//----- (10065330) --------------------------------------------------------
_DWORD *__thiscall ToolWindow::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  UIWindow::operator=(a2);
  v2[34] = *(a2 + 136);
  v2[35] = *(a2 + 140);
  return v2;
}
// 10001D16: using guessed type _DWORD __stdcall UIWindow::operator=(_DWORD);

//----- (100653B0) --------------------------------------------------------
int __thiscall ToolWindow::~ToolWindow(ToolWindow *this)
{
  return UIWindow::~UIWindow(this);
}

//----- (10065400) --------------------------------------------------------
UIWindow *__thiscall SplitBar::SplitBar(SplitBar *this, const struct SplitBar *a2)
{
  UIWindow *v2; // ST50_4

  v2 = this;
  UIWindow::UIWindow(this, a2);
  *(v2 + 136) = *(a2 + 136);
  *(v2 + 35) = *(a2 + 35);
  *(v2 + 36) = *(a2 + 36);
  *(v2 + 37) = *(a2 + 37);
  *(v2 + 38) = *(a2 + 38);
  *(v2 + 39) = *(a2 + 39);
  *(v2 + 40) = *(a2 + 40);
  *v2 = &SplitBar::`vftable';
  return v2;
}
// 101AFD08: using guessed type void *SplitBar::`vftable';

//----- (10065500) --------------------------------------------------------
_BYTE *__thiscall SplitBar::operator=(_BYTE *this, int a2)
{
  _BYTE *v2; // ST50_4

  v2 = this;
  UIWindow::operator=(a2);
  v2[136] = *(a2 + 136);
  *(v2 + 35) = *(a2 + 140);
  *(v2 + 36) = *(a2 + 144);
  *(v2 + 37) = *(a2 + 148);
  *(v2 + 38) = *(a2 + 152);
  *(v2 + 39) = *(a2 + 156);
  *(v2 + 40) = *(a2 + 160);
  return v2;
}
// 10001D16: using guessed type _DWORD __stdcall UIWindow::operator=(_DWORD);

//----- (100655F0) --------------------------------------------------------
int __thiscall SplitBar::~SplitBar(SplitBar *this)
{
  return UIWindow::~UIWindow(this);
}

//----- (10065640) --------------------------------------------------------
SplitBar *__thiscall VertSplitBar::VertSplitBar(VertSplitBar *this, const struct VertSplitBar *a2)
{
  SplitBar *v2; // ST50_4

  v2 = this;
  SplitBar::SplitBar(this, a2);
  *v2 = &VertSplitBar::`vftable';
  return v2;
}
// 101AFD78: using guessed type void *VertSplitBar::`vftable';

//----- (100656A0) --------------------------------------------------------
void *__thiscall VertSplitBar::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  SplitBar::operator=(a2);
  return v2;
}
// 10001BF9: using guessed type _DWORD __stdcall SplitBar::operator=(_DWORD);

//----- (100656F0) --------------------------------------------------------
int __thiscall VertSplitBar::~VertSplitBar(VertSplitBar *this)
{
  return SplitBar::~SplitBar(this);
}

//----- (10065740) --------------------------------------------------------
SplitBar *__thiscall HorzSplitBar::HorzSplitBar(HorzSplitBar *this, const struct HorzSplitBar *a2)
{
  SplitBar *v2; // ST50_4

  v2 = this;
  SplitBar::SplitBar(this, a2);
  *v2 = &HorzSplitBar::`vftable';
  return v2;
}
// 101AFDE8: using guessed type void *HorzSplitBar::`vftable';

//----- (100657A0) --------------------------------------------------------
void *__thiscall HorzSplitBar::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  SplitBar::operator=(a2);
  return v2;
}
// 10001BF9: using guessed type _DWORD __stdcall SplitBar::operator=(_DWORD);

//----- (100657F0) --------------------------------------------------------
int __thiscall HorzSplitBar::~HorzSplitBar(HorzSplitBar *this)
{
  return SplitBar::~SplitBar(this);
}

//----- (10065840) --------------------------------------------------------
void __stdcall ComboBox::entryHandler(char *a2)
{
  ;
}

//----- (10065870) --------------------------------------------------------
ComboBox *__thiscall ComboBox::ComboBox(ComboBox *this, const struct ComboBox *a2)
{
  ComboBox *v2; // ST50_4

  v2 = this;
  UIWindow::UIWindow(this, a2);
  *(v2 + 34) = *(a2 + 34);
  *(v2 + 35) = *(a2 + 35);
  *v2 = &ComboBox::`vftable';
  return v2;
}
// 101AFE58: using guessed type void *ComboBox::`vftable';

//----- (10065900) --------------------------------------------------------
_DWORD *__thiscall ComboBox::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  UIWindow::operator=(a2);
  v2[34] = *(a2 + 136);
  v2[35] = *(a2 + 140);
  return v2;
}
// 10001D16: using guessed type _DWORD __stdcall UIWindow::operator=(_DWORD);

//----- (10065980) --------------------------------------------------------
int __thiscall ComboBox::~ComboBox(ComboBox *this)
{
  return UIWindow::~UIWindow(this);
}

//----- (100659D0) --------------------------------------------------------
ComboBox *__thiscall EditBox::EditBox(EditBox *this, const struct EditBox *a2)
{
  ComboBox *v2; // ST50_4

  v2 = this;
  ComboBox::ComboBox(this, a2);
  *v2 = &EditBox::`vftable';
  return v2;
}
// 101AFEC8: using guessed type void *EditBox::`vftable';

//----- (10065A30) --------------------------------------------------------
void *__thiscall EditBox::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  ComboBox::operator=(a2);
  return v2;
}
// 10002680: using guessed type _DWORD __stdcall ComboBox::operator=(_DWORD);

//----- (10065A80) --------------------------------------------------------
int __thiscall EditBox::~EditBox(EditBox *this)
{
  return ComboBox::~ComboBox(this);
}

//----- (10065AD0) --------------------------------------------------------
void __stdcall OptionBox::selectionChanged(int a2)
{
  ;
}

//----- (10065B00) --------------------------------------------------------
ComboBox *__thiscall OptionBox::OptionBox(OptionBox *this, const struct OptionBox *a2)
{
  ComboBox *v2; // ST50_4

  v2 = this;
  ComboBox::ComboBox(this, a2);
  *v2 = &OptionBox::`vftable';
  return v2;
}
// 101AFF38: using guessed type void *OptionBox::`vftable';

//----- (10065B60) --------------------------------------------------------
void *__thiscall OptionBox::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  ComboBox::operator=(a2);
  return v2;
}
// 10002680: using guessed type _DWORD __stdcall ComboBox::operator=(_DWORD);

//----- (10065BB0) --------------------------------------------------------
int __thiscall OptionBox::~OptionBox(OptionBox *this)
{
  return ComboBox::~ComboBox(this);
}

//----- (10065C00) --------------------------------------------------------
UIWindow *__thiscall RenderWindow::RenderWindow(RenderWindow *this, const struct RenderWindow *a2)
{
  UIWindow *v2; // ST50_4

  v2 = this;
  UIWindow::UIWindow(this, a2);
  *(v2 + 34) = *(a2 + 34);
  *(v2 + 35) = *(a2 + 35);
  *(v2 + 36) = *(a2 + 36);
  *(v2 + 37) = *(a2 + 37);
  *(v2 + 152) = *(a2 + 152);
  *(v2 + 39) = *(a2 + 39);
  *(v2 + 40) = *(a2 + 40);
  *v2 = &RenderWindow::`vftable';
  return v2;
}
// 101AFFAC: using guessed type void *RenderWindow::`vftable';

//----- (10065D00) --------------------------------------------------------
_DWORD *__thiscall RenderWindow::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  UIWindow::operator=(a2);
  v2[34] = *(a2 + 136);
  v2[35] = *(a2 + 140);
  v2[36] = *(a2 + 144);
  v2[37] = *(a2 + 148);
  *(v2 + 152) = *(a2 + 152);
  v2[39] = *(a2 + 156);
  v2[40] = *(a2 + 160);
  return v2;
}
// 10001D16: using guessed type _DWORD __stdcall UIWindow::operator=(_DWORD);

//----- (10065DF0) --------------------------------------------------------
int __thiscall RenderWindow::~RenderWindow(RenderWindow *this)
{
  return UIWindow::~UIWindow(this);
}

//----- (10065E40) --------------------------------------------------------
UIWindow *__thiscall AppWindow::AppWindow(AppWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6)
{
  UIWindow *v6; // ST60_4

  v6 = this;
  UIWindow::UIWindow(this, a2, a3, a4, a5, a6);
  *v6 = &AppWindow::`vftable';
  return v6;
}
// 101B0018: using guessed type void *AppWindow::`vftable';

//----- (10065EB0) --------------------------------------------------------
UIWindow *__thiscall AppWindow::AppWindow(AppWindow *this, const struct AppWindow *a2)
{
  UIWindow *v2; // ST50_4

  v2 = this;
  UIWindow::UIWindow(this, a2);
  *(v2 + 34) = *(a2 + 34);
  *v2 = &AppWindow::`vftable';
  return v2;
}
// 101B0018: using guessed type void *AppWindow::`vftable';

//----- (10065F20) --------------------------------------------------------
_DWORD *__thiscall AppWindow::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  UIWindow::operator=(a2);
  v2[34] = *(a2 + 136);
  return v2;
}
// 10001D16: using guessed type _DWORD __stdcall UIWindow::operator=(_DWORD);

//----- (10065F90) --------------------------------------------------------
int __thiscall AppWindow::~AppWindow(AppWindow *this)
{
  return UIWindow::~UIWindow(this);
}

//----- (10065FE0) --------------------------------------------------------
char __thiscall UIMgr::isActive(UIMgr *this)
{
  CoreNode *i; // [esp+4Ch] [ebp-Ch]
  char v3; // [esp+50h] [ebp-8h]

  v3 = 0;
  for ( i = CoreNode::Child(this); i; i = CoreNode::Next(i) )
  {
    if ( i[5].Parent & 0x40000 )
      v3 = 1;
  }
  return v3;
}

//----- (10066070) --------------------------------------------------------
Node *__thiscall UIMgr::UIMgr(UIMgr *this, const struct UIMgr *a2)
{
  Node *v2; // ST50_4

  v2 = this;
  Node::Node(this, a2);
  Node::Node(v2 + 1, a2 + 1);
  v2->pVtbl = &UIMgr::`vftable';
  return v2;
}
// 101B0084: using guessed type void *UIMgr::`vftable';

//----- (100660E0) --------------------------------------------------------
void *__thiscall UIMgr::operator=(void *this, int a2)
{
  void *v2; // ST50_4

  v2 = this;
  Node::operator=(a2);
  Node::operator=(a2 + 32);
  return v2;
}
// 1000171C: using guessed type _DWORD __stdcall Node::operator=(_DWORD);

//----- (10066150) --------------------------------------------------------
void *__thiscall Module::operator=(void *this, const void *a2)
{
  qmemcpy(this, a2, 0x1Cu);
  return this;
}

//----- (100661A0) --------------------------------------------------------
_DWORD *__thiscall ModuleMgr::operator=(_DWORD *this, _DWORD *a2)
{
  int v2; // edx

  v2 = a2[1];
  *this = *a2;
  this[1] = v2;
  return this;
}

//----- (100661F0) --------------------------------------------------------
BaseApp *__thiscall GameApp::GameApp(GameApp *this)
{
  BaseApp *v1; // ST50_4

  v1 = this;
  BaseApp::BaseApp(this);
  *v1 = &GameApp::`vftable';
  return v1;
}
// 101B00C4: using guessed type void *GameApp::`vftable';

//----- (10066250) --------------------------------------------------------
BaseApp *__thiscall GameApp::GameApp(GameApp *this, const struct GameApp *a2)
{
  BaseApp *v2; // ST50_4

  v2 = this;
  BaseApp::BaseApp(this, a2);
  *(v2 + 21) = *(a2 + 21);
  *(v2 + 88) = *(a2 + 88);
  *v2 = &GameApp::`vftable';
  return v2;
}
// 101B00C4: using guessed type void *GameApp::`vftable';

//----- (100662D0) --------------------------------------------------------
_DWORD *__thiscall GameApp::operator=(_DWORD *this, int a2)
{
  _DWORD *v2; // ST50_4

  v2 = this;
  BaseApp::operator=(a2);
  v2[21] = *(a2 + 84);
  *(v2 + 88) = *(a2 + 88);
  return v2;
}
// 100022D9: using guessed type _DWORD __stdcall BaseApp::operator=(_DWORD);

//----- (10066340) --------------------------------------------------------
int __thiscall GameApp::~GameApp(GameApp *this)
{
  return BaseApp::~BaseApp(this);
}

//----- (10066400) --------------------------------------------------------
int __thiscall sub_10066400(char *this, char a2)
{
  int result; // eax
  char *hMem; // [esp+4Ch] [ebp-4h]

  hMem = this;
  if ( a2 & 2 )
  {
    `eh vector destructor iterator'(this, 0x5Cu, *(this - 1), GameApp::~GameApp);
    if ( a2 & 1 )
      sub_1000136B(hMem - 4);
    result = (hMem - 4);
  }
  else
  {
    GameApp::~GameApp(this);
    if ( a2 & 1 )
      sub_10001938(hMem);
    result = hMem;
  }
  return result;
}

//----- (100664C0) --------------------------------------------------------
void __thiscall Module::Load(Module *this, char *Src)
{
  Module *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  this->fileName = strdup(Src);
  sub_10066610("opening %s\n", v2->fileName);
  v2->loadedLibrary = LoadLibraryA(v2->fileName);
  if ( v2->loadedLibrary )
  {
    v2->newObjAddr = GetProcAddress(v2->loadedLibrary, "NewObject");
    v2->objListAddr = GetProcAddress(v2->loadedLibrary, "GetObjectList");
    v2->autoStartAddr = GetProcAddress(v2->loadedLibrary, "AutoStart");
  }
  else
  {
    v2->newObjAddr = 0;
    v2->objListAddr = 0;
    v2->autoStartAddr = 0;
  }
}

//----- (10066610) --------------------------------------------------------
char *__cdecl sub_10066610(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "moduleMgr" )
      Stream::print(sysCon, "%s: ", "moduleMgr");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10066720) --------------------------------------------------------
void __thiscall Module::menuPlugins(Module *this, struct MenuPlugin *a2, HMENU hmenu)
{
  UINT v3; // ST04_4
  UINT item; // [esp+4Ch] [ebp-58h]
  HBITMAP v5; // [esp+50h] [ebp-54h]
  HGLOBAL hMem; // [esp+54h] [ebp-50h]
  HBITMAP v7; // [esp+58h] [ebp-4Ch]
  MENUITEMINFOA mi; // [esp+5Ch] [ebp-48h]
  UINT v9; // [esp+8Ch] [ebp-18h]
  int i; // [esp+90h] [ebp-14h]
  int v12; // [esp+A0h] [ebp-4h]

  for ( i = (this->objListAddr)(); *i; i += 12 )
  {
    if ( *(i + 4) )
    {
      v9 = RegisterWindowMessageA(*i);
      hMem = sub_10002A81(0xCu);
      v12 = 0;
      if ( hMem )
        v5 = sub_10001343(hMem);
      else
        v5 = 0;
      v7 = v5;
      v12 = -1;
      mi.hbmpItem = v5;
      *v5 = v9;
      *(mi.hbmpItem + 1) = *i;
      sub_100010A5(mi.hbmpItem);
      mi.cbSize = 44;
      mi.fMask = 18;
      mi.wID = v9;
      mi.fType = 0;
      mi.dwTypeData = *i;
      mi.cch = strlen(*i);
      item = dword_101D61D8;
      v3 = dword_101D61D8++;
      InsertMenuItemA(hmenu, v3, 1, &mi);
    }
  }
}
// 100010A5: using guessed type _DWORD __stdcall sub_100010A5(_DWORD);
// 101D61D8: using guessed type int dword_101D61D8;

//----- (10066900) --------------------------------------------------------
void __thiscall Module::~Module(Module *this)
{
  Module *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  if ( this->loadedLibrary )
  {
    this->newObjAddr = 0;
    this->autoStartAddr = 0;
    FreeLibrary(this->loadedLibrary);
    v1->loadedLibrary = 0;
    free(v1->fileName);
  }
}

//----- (100669B0) --------------------------------------------------------
struct Module *__thiscall ModuleMgr::findModule(ModuleMgr *this, char *Str2)
{
  int i; // [esp+4Ch] [ebp-8h]
  ModuleMgr *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  for ( i = *(*this + 20); i != *v4; i = *(i + 20) )
  {
    if ( !strcmp(*(i + 16), Str2) )
      return i;
  }
  return 0;
}

//----- (10066A40) --------------------------------------------------------
struct Module *__thiscall ModuleMgr::loadModule(ModuleMgr *this, char *a2)
{
  int v3; // [esp+4Ch] [ebp-Ch]
  Module *v4; // [esp+50h] [ebp-8h]
  ModuleMgr *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  v4 = ModuleMgr::findModule(this, a2);
  if ( !v4 )
  {
    v3 = sub_10002A81(0x1Cu);
    v4 = (v3 != 0 ? v3 : 0);
    Module::Load((v3 != 0 ? v3 : 0), a2);
    v4[1].newObjAddr = *v5;
    v4[1].objListAddr = *(*v5 + 24);
    *(*v5 + 24) = v4;
    *(v4[1].objListAddr + 20) = v4;
    ++*(v5 + 1);
    if ( v4->autoStartAddr )
      (v4->autoStartAddr)();
  }
  return v4;
}

//----- (10066B40) --------------------------------------------------------
int __thiscall ModuleMgr::Alloc(ModuleMgr *this, char *a2)
{
  int i; // [esp+4Ch] [ebp-Ch]
  int v4; // [esp+50h] [ebp-8h]
  ModuleMgr *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  for ( i = *(*this + 20); i != *v5; i = *(i + 20) )
  {
    v4 = (*i)(a2);
    if ( v4 )
      return v4;
  }
  sub_10066610("ModuleMgr: !!!!! could not allocate %s !!!!!\n", a2);
  return 0;
}

//----- (10066BF0) --------------------------------------------------------
void __thiscall ModuleMgr::listModules(ModuleMgr *this)
{
  int i; // [esp+50h] [ebp-8h]

  if ( *(*this + 20) != *this )
  {
    *(this + 1);
    for ( i = *(*this + 20); i != *this; i = *(i + 20) )
      ;
  }
}

//----- (10066C80) --------------------------------------------------------
void __thiscall ModuleMgr::UnLoad(ModuleMgr *this, struct Module *a2)
{
  *(a2[1].newObjAddr + 24) = a2[1].objListAddr;
  *(a2[1].objListAddr + 20) = a2[1].newObjAddr;
  --*(this + 1);
  if ( a2 )
    sub_100029E6(1);
}
// 100029E6: using guessed type _DWORD __stdcall sub_100029E6(_DWORD);

//----- (10066D30) --------------------------------------------------------
Module *__thiscall sub_10066D30(Module *this, char a2)
{
  Module *hMem; // [esp+4Ch] [ebp-4h]

  hMem = this;
  Module::~Module(this);
  if ( a2 & 1 )
    sub_10001938(hMem);
  return hMem;
}

//----- (10066DA0) --------------------------------------------------------
ModuleMgr *__thiscall ModuleMgr::ModuleMgr(ModuleMgr *this)
{
  ModuleMgr *v1; // ST54_4
  int v2; // eax
  char v4; // [esp+0h] [ebp-54h]

  v1 = this;
  sub_10066610("Creating moduleMgr ...\n", v4);
  v2 = sub_10002A81(0x1Cu);
  *v1 = v2 != 0 ? v2 : 0;
  *(*v1 + 24) = *v1;
  *(*v1 + 20) = *(*v1 + 24);
  *(v1 + 1) = 0;
  return v1;
}

//----- (10066E50) --------------------------------------------------------
ModuleMgr *__thiscall ModuleMgr::~ModuleMgr(ModuleMgr *this)
{
  ModuleMgr *result; // eax
  struct Module *v2; // ST54_4
  struct Module *i; // [esp+4Ch] [ebp-Ch]
  ModuleMgr *v4; // [esp+54h] [ebp-4h]

  v4 = this;
  for ( i = *(*this + 20); ; i = v2 )
  {
    result = v4;
    if ( i == *v4 )
      break;
    v2 = i[1].newObjAddr;
    ModuleMgr::UnLoad(v4, i);
  }
  return result;
}

//----- (10066ED0) --------------------------------------------------------
_DWORD *__thiscall sub_10066ED0(_DWORD *this)
{
  this[2] = 0;
  return this;
}

//----- (10066F10) --------------------------------------------------------
_DWORD *__thiscall sub_10066F10(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  *(a2 + 8) = this[2];
  result = this;
  this[2] = a2;
  return result;
}

//----- (10066F60) --------------------------------------------------------
_BYTE *__cdecl sub_10066F60(SIZE_T dwBytes)
{
  int i; // [esp+4Ch] [ebp-10h]
  _BYTE *v3; // [esp+50h] [ebp-Ch]
  AyuStack *v4; // [esp+54h] [ebp-8h]
  _BYTE *v5; // [esp+58h] [ebp-4h]

  v5 = 0;
  if ( *(gsys + 102) < 0 )
  {
    v5 = GlobalAlloc(0, dwBytes);
    if ( !v5 )
      sub_100670A0("new[] %d failed", dwBytes);
  }
  else
  {
    v4 = (gsys + 40 * *(gsys + 102) + 88);
    if ( !dwBytes )
      sub_10067140("trying to allocate %d bytes on heap\n", 0);
    v5 = AyuStack::push(v4, dwBytes);
    if ( !v5 )
      sub_100670A0("new[] %d failed in heap '%s'", dwBytes, *(v4 + 8));
    v3 = v5;
    for ( i = 0; i < dwBytes; ++i )
      v3[i] = 0;
  }
  return v5;
}

//----- (100670A0) --------------------------------------------------------
void __noreturn sub_100670A0(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscore\\sysnew.cpp", 6, &Dest);
}

//----- (10067140) --------------------------------------------------------
char *__cdecl sub_10067140(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "sysNew" )
      Stream::print(sysCon, "%s: ", "sysNew");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10067250) --------------------------------------------------------
_BYTE *__cdecl sub_10067250(SIZE_T dwBytes)
{
  int i; // [esp+4Ch] [ebp-10h]
  _BYTE *v3; // [esp+50h] [ebp-Ch]
  AyuStack *v4; // [esp+54h] [ebp-8h]
  _BYTE *v5; // [esp+58h] [ebp-4h]

  v5 = 0;
  if ( *(gsys + 102) < 0 )
  {
    v5 = GlobalAlloc(0, dwBytes);
    if ( !v5 )
      sub_100670A0("new[] %d failed", dwBytes);
  }
  else
  {
    v4 = (gsys + 40 * *(gsys + 102) + 88);
    if ( !dwBytes )
      sub_10067140("trying to allocate %d bytes on heap\n", 0);
    v5 = AyuStack::push(v4, dwBytes);
    if ( !v5 )
      sub_100670A0("new[] %d failed in heap '%s'", dwBytes, *(v4 + 8));
    v3 = v5;
    for ( i = 0; i < dwBytes; ++i )
      v3[i] = 0;
  }
  return v5;
}

//----- (10067410) --------------------------------------------------------
int __cdecl sub_10067410(int a1, int a2)
{
  return ~(a2 - 1) & (sub_10001AC3(a2 + a1) + a2 - 1);
}

//----- (10067490) --------------------------------------------------------
StdSystem *__cdecl sub_10067490(HGLOBAL hMem)
{
  StdSystem *result; // eax

  result = gsys;
  if ( *(gsys + 102) < 0 )
    result = GlobalFree(hMem);
  return result;
}

//----- (100674F0) --------------------------------------------------------
StdSystem *__cdecl sub_100674F0(HGLOBAL hMem)
{
  StdSystem *result; // eax

  result = gsys;
  if ( *(gsys + 102) < 0 )
    result = GlobalFree(hMem);
  return result;
}

//----- (10067550) --------------------------------------------------------
BOOL __thiscall System::buildModeList(_DWORD *this)
{
  BOOL result; // eax
  int v2; // [esp+50h] [ebp-A0h]
  DWORD iModeNum; // [esp+54h] [ebp-9Ch]
  DWORD iModeNuma; // [esp+54h] [ebp-9Ch]
  DEVMODEA DevMode; // [esp+58h] [ebp-98h]

  DevMode.dmPanningWidth = this;
  this[146] = 0;
  for ( iModeNum = 0; EnumDisplaySettingsA(0, iModeNum, &DevMode); ++iModeNum )
  {
    if ( DevMode.dmBitsPerPel == 16 || DevMode.dmBitsPerPel == 32 )
      ++*(DevMode.dmPanningWidth + 584);
  }
  *(DevMode.dmPanningWidth + 580) = sub_10001AC3(6 * *(DevMode.dmPanningWidth + 584));
  sub_10067750("Found %d displaymodes\n", *(DevMode.dmPanningWidth + 584));
  iModeNuma = 0;
  v2 = 0;
  while ( 1 )
  {
    result = EnumDisplaySettingsA(0, iModeNuma, &DevMode);
    if ( !result )
      break;
    if ( DevMode.dmBitsPerPel == 16 || DevMode.dmBitsPerPel == 32 )
    {
      *(*(DevMode.dmPanningWidth + 580) + 6 * v2) = DevMode.dmPelsWidth;
      *(*(DevMode.dmPanningWidth + 580) + 6 * v2 + 2) = DevMode.dmPelsHeight;
      *(*(DevMode.dmPanningWidth + 580) + 6 * v2++ + 4) = DevMode.dmBitsPerPel;
    }
    ++iModeNuma;
  }
  return result;
}

//----- (10067750) --------------------------------------------------------
char *__cdecl sub_10067750(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "system" )
      Stream::print(sysCon, "%s: ", "system");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (10067860) --------------------------------------------------------
char __thiscall System::setVideoMode(int this, int a2, int a3, int a4, int a5)
{
  int i; // [esp+4Ch] [ebp-134h]
  char v7; // [esp+50h] [ebp-130h]
  char Dst; // [esp+54h] [ebp-12Ch]
  __int16 v9; // [esp+78h] [ebp-108h]
  int v10; // [esp+7Ch] [ebp-104h]
  int v11; // [esp+BCh] [ebp-C4h]
  int v12; // [esp+C0h] [ebp-C0h]
  int v13; // [esp+C4h] [ebp-BCh]
  struct _OSVERSIONINFOA VersionInformation; // [esp+E8h] [ebp-98h]
  int v15; // [esp+17Ch] [ebp-4h]

  v15 = this;
  v7 = 0;
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( !GetVersionExA(&VersionInformation) )
    sub_10067AD0("setVideoMode - GetVersionEx failed!!\n");
  if ( VersionInformation.dwMajorVersion <= 4 )
  {
    if ( VersionInformation.dwMajorVersion == 4 )
    {
      if ( VersionInformation.dwPlatformId == 2 )
      {
        v7 = 1;
      }
      else if ( VersionInformation.dwPlatformId == 1 && LOWORD(VersionInformation.dwBuildNumber) >= 1111 )
      {
        v7 = 1;
      }
    }
  }
  else
  {
    v7 = 1;
  }
  if ( a2 )
  {
    for ( i = 0; i < *(v15 + 584); ++i )
    {
      if ( *(*(v15 + 580) + 6 * i) == a3 && *(*(v15 + 580) + 6 * i + 2) == a4 && *(*(v15 + 580) + 6 * i + 4) == a5 )
      {
        memset(&Dst, 0, 0x94u);
        v9 = 148;
        v12 = a3;
        v13 = a4;
        v11 = a5;
        v10 = 1835008;
        if ( ChangeDisplaySettingsA(&Dst, 4u) )
          *(v15 + 589) = 0;
      }
    }
  }
  else
  {
    ChangeDisplaySettingsA(0, 0);
  }
  return 1;
}

//----- (10067AD0) --------------------------------------------------------
void __noreturn sub_10067AD0(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscore\\system.cpp", 21, &Dest);
}

//----- (10067B70) --------------------------------------------------------
struct RandomAccessStream *__thiscall System::openFile(char *this, int a2, bool a3, char a4)
{
  int v5; // [esp+4Ch] [ebp-128h]
  char *v6; // [esp+50h] [ebp-124h]
  char *v7; // [esp+54h] [ebp-120h]
  HGLOBAL hMem; // [esp+58h] [ebp-11Ch]
  int v9; // [esp+5Ch] [ebp-118h]
  FILE *v10; // [esp+60h] [ebp-114h]
  char Dest; // [esp+64h] [ebp-110h]
  char *v12; // [esp+164h] [ebp-10h]
  int v13; // [esp+170h] [ebp-4h]

  v12 = this;
  if ( a3 )
    v7 = *(v12 + 20);
  else
    v7 = `string';
  sprintf(&Dest, "%s", v7);
  if ( a3 )
    v6 = *(v12 + 21);
  else
    v6 = `string';
  sprintf(&Dest, "%s%s%s", &Dest, v6, a2);
  ++*(v12 + 143);
  v10 = fopen(&Dest, "rb");
  if ( !v10 )
    return 0;
  if ( a4 )
    sub_10067750("Opened file %s\n", &Dest);
  hMem = sub_10002A81(0x14u);
  v13 = 0;
  if ( hMem )
    v5 = sub_10001F46(v10, a2);
  else
    v5 = 0;
  v9 = v5;
  v13 = -1;
  return v5;
}
// 10001F46: using guessed type _DWORD __stdcall sub_10001F46(_DWORD, _DWORD);

//----- (10067DB0) --------------------------------------------------------
RandomAccessStream *__thiscall sub_10067DB0(RandomAccessStream *this, int a2, int a3)
{
  RandomAccessStream *v3; // ST5C_4
  int Offset; // ST58_4

  v3 = this;
  RandomAccessStream::RandomAccessStream(this);
  *v3 = &off_101B0314;
  *(v3 + 1) = a3;
  *(v3 + 2) = a2;
  *(v3 + 3) = 0;
  Offset = sub_1000261C(v3);
  fseek(*(v3 + 2), 0, 2);
  *(v3 + 4) = ftell(*(v3 + 2));
  fseek(*(v3 + 2), Offset, 0);
  return v3;
}
// 1000261C: using guessed type int __thiscall sub_1000261C(_DWORD);
// 101B0314: using guessed type int (__thiscall *off_101B0314)(Stream *this);

//----- (10067EB0) --------------------------------------------------------
int __thiscall sub_10067EB0(FILE **this, void *DstBuf, size_t Count)
{
  int v3; // ST5C_4
  int result; // eax

  v3 = this;
  *(gsys + 144) += Count;
  fread(DstBuf, 1u, Count, this[2]);
  result = v3;
  *(v3 + 12) += Count;
  return result;
}

//----- (10067F50) --------------------------------------------------------
size_t __thiscall sub_10067F50(FILE **this, void *Str, size_t Count)
{
  return fwrite(Str, 1u, Count, this[2]);
}

//----- (10067FC0) --------------------------------------------------------
int __thiscall sub_10067FC0(_DWORD *this)
{
  return this[4] - this[3];
}

//----- (10068000) --------------------------------------------------------
int __thiscall sub_10068000(_DWORD *this)
{
  return this[4];
}

//----- (10068040) --------------------------------------------------------
int __thiscall sub_10068040(FILE **this)
{
  return ftell(this[2]);
}

//----- (100680A0) --------------------------------------------------------
int __thiscall sub_100680A0(FILE **this, int Offset)
{
  return fseek(this[2], Offset, 0);
}

//----- (10068110) --------------------------------------------------------
int __thiscall sub_10068110(FILE **this)
{
  FILE **v1; // ST50_4

  v1 = this;
  fflush(this[2]);
  return fclose(v1[2]);
}

//----- (10068190) --------------------------------------------------------
struct RandomAccessStream *__thiscall System::createFile(char *this, int a2, char a3)
{
  int v4; // [esp+4Ch] [ebp-128h]
  char *v5; // [esp+50h] [ebp-124h]
  char *v6; // [esp+54h] [ebp-120h]
  HGLOBAL hMem; // [esp+58h] [ebp-11Ch]
  int v8; // [esp+5Ch] [ebp-118h]
  FILE *v9; // [esp+60h] [ebp-114h]
  char Dest; // [esp+64h] [ebp-110h]
  char *v11; // [esp+164h] [ebp-10h]
  int v12; // [esp+170h] [ebp-4h]

  v11 = this;
  if ( a3 )
    v6 = *(v11 + 20);
  else
    v6 = `string';
  sprintf(&Dest, "%s", v6);
  if ( a3 )
    v5 = *(v11 + 21);
  else
    v5 = `string';
  sprintf(&Dest, "%s%s", v5, a2);
  v9 = fopen(&Dest, "wb");
  if ( !v9 )
    return 0;
  hMem = sub_10002A81(0x14u);
  v12 = 0;
  if ( hMem )
    v4 = sub_10001F46(v9, a2);
  else
    v4 = 0;
  v8 = v4;
  v12 = -1;
  return v4;
}
// 10001F46: using guessed type _DWORD __stdcall sub_10001F46(_DWORD, _DWORD);

//----- (10068380) --------------------------------------------------------
struct UIWindow *__stdcall System::createDebugStream(struct UIWindow *a2)
{
  int v3; // [esp+4Ch] [ebp-20h]

  if ( sub_10002A81(0x118u) )
    v3 = sub_10002BB2(a2);
  else
    v3 = 0;
  errCon = v3;
  sysCon = v3;
  return *(v3 + 276);
}
// 101D61E4: using guessed type struct Stream *errCon;

//----- (10068470) --------------------------------------------------------
Stream *__thiscall sub_10068470(Stream *this, struct UIWindow *a2)
{
  int v2; // ST0C_4
  int v3; // eax
  struct RandomAccessStream *v4; // eax
  int v6; // [esp+4Ch] [ebp-20h]
  HGLOBAL hMem; // [esp+50h] [ebp-1Ch]
  int v8; // [esp+54h] [ebp-18h]
  WPARAM wParam; // [esp+58h] [ebp-14h]
  Stream *v10; // [esp+5Ch] [ebp-10h]
  int v11; // [esp+68h] [ebp-4h]

  v10 = this;
  Stream::Stream(this);
  *v10 = &off_101B03A4;
  *(v10 + 2) = 0;
  *(v10 + 3) = 0;
  hMem = sub_10002A81(0x88u);
  v11 = 0;
  if ( hMem )
    v6 = UIWindow::UIWindow(hMem, a2, 15, 1344274752, 512, 0);
  else
    v6 = 0;
  v8 = v6;
  v11 = -1;
  *(v10 + 69) = v6;
  v2 = RectArea::height((a2 + 64));
  v3 = RectArea::width((a2 + 64));
  UIWindow::sizeWindow(*(v10 + 69), v3, v2, 0);
  (*(**(v10 + 69) + 80))(*(v10 + 69), "Listbox", 0, 0);
  wParam = GetStockObject(17);
  SendMessageA(*(*(v10 + 69) + 100), 0x30u, wParam, 0);
  v4 = System::createFile(gsys, "../log.txt");
  *(v10 + 68) = v4;
  return v10;
}
// 101B03A4: using guessed type int (__thiscall *off_101B03A4)(Stream *this);

//----- (10068650) --------------------------------------------------------
int __thiscall sub_10068650(const char *this)
{
  int result; // eax
  WPARAM v2; // ST08_4
  HWND v3; // ST00_4
  size_t v4; // eax
  size_t v5; // eax
  WPARAM wParam; // [esp+4Ch] [ebp-Ch]
  char Str[2]; // [esp+50h] [ebp-8h]
  const char *v8; // [esp+54h] [ebp-4h]

  v8 = this;
  this[*(this + 2) + 16] = 0;
  result = v8;
  if ( *(v8 + 69) )
  {
    if ( *(gsys + 8) )
    {
      SendMessageA(*(*(v8 + 69) + 100), 0x180u, 0, (v8 + 16));
      wParam = *(v8 + 3);
      v2 = wParam;
      v3 = *(*(v8 + 69) + 100);
      ++*(v8 + 3);
      SendMessageA(v3, 0x186u, v2, 0);
      result = v8;
      if ( *(v8 + 68) )
      {
        strcpy(Str, "\n");
        v4 = strlen(v8 + 16);
        (*(**(v8 + 68) + 56))(*(v8 + 68), v8 + 4, v4);
        v5 = strlen(Str);
        result = (*(**(v8 + 68) + 56))(*(v8 + 68), Str, v5);
      }
    }
  }
  *(v8 + 2) = 0;
  return result;
}

//----- (10068800) --------------------------------------------------------
int __thiscall sub_10068800(void *this, int a2, int a3)
{
  int result; // eax
  char v4; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]
  void *v6; // [esp+54h] [ebp-4h]

  v6 = this;
  for ( i = 0; i < a3; ++i )
  {
    v4 = *(i + a2);
    if ( v4 == 10 )
    {
      (*(*v6 + 76))(v6);
    }
    else if ( v4 == 9 )
    {
      sub_10001221(32);
      sub_10001221(32);
    }
    else
    {
      sub_10001221(v4);
    }
    result = i + 1;
  }
  return result;
}
// 10001221: using guessed type _DWORD __stdcall sub_10001221(char);

//----- (100688D0) --------------------------------------------------------
_DWORD *__thiscall sub_100688D0(_DWORD *this, char a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  if ( this[2] >= 255 )
    (*(*v3 + 76))(v3);
  *(v3 + v3[2] + 16) = a2;
  result = v3;
  ++v3[2];
  return result;
}

//----- (10068960) --------------------------------------------------------
struct CoreNode *System::firstApp()
{
  CoreNode *v0; // eax
  CoreNode *v1; // eax

  v0 = NodeMgr::firstNode(nodeMgr);
  v1 = CoreNode::Child(v0);
  return CoreNode::Next(v1);
}

//----- (100689C0) --------------------------------------------------------
WPARAM __thiscall System::run(struct BaseApp *this, int a2)
{
  int v2; // eax
  char v4; // [esp+0h] [ebp-88h]
  int v5; // [esp+4Ch] [ebp-3Ch]
  struct CoreNode *v6; // [esp+50h] [ebp-38h]
  struct CoreNode *v7; // [esp+54h] [ebp-34h]
  int v8; // [esp+58h] [ebp-30h]
  struct CoreNode *i; // [esp+5Ch] [ebp-2Ch]
  struct CoreNode *v10; // [esp+60h] [ebp-28h]
  int v11; // [esp+64h] [ebp-24h]
  struct tagMSG Msg; // [esp+68h] [ebp-20h]
  struct BaseApp *v13; // [esp+84h] [ebp-4h]

  v13 = this;
  while ( 1 )
  {
    while ( !PeekMessageA(&Msg, 0, 0, 0, 0) )
    {
      v11 = 0;
      if ( !UIMgr::isActive(uiMgr) && !System::firstApp() )
      {
        sub_10067750("shutting down because no toplevel windows", v4);
        StdSystem::Shutdown(gsys);
      }
      if ( StdSystem::isShutdown(gsys) )
      {
        PostQuitMessage(0);
      }
      else
      {
        System::updateSysClock(v13);
        ControllerMgr::update((v13 + 692));
        for ( i = System::firstApp(); i; i = v10 )
        {
          v10 = i->Next;
          v8 = (*(i->vtblPointer + 60))(i);
          if ( v8 == -1 )
          {
            v6 = i;
            v7 = i;
            if ( i )
              v5 = (*(v7->vtblPointer + 52))(v7, 1);
            else
              v5 = 0;
            v2 = v11;
            LOBYTE(v2) = v11 | 1;
            v11 = v2;
          }
          else
          {
            v11 |= v8;
          }
        }
      }
      if ( !v11 )
        WaitMessage();
    }
    if ( !GetMessageA(&Msg, 0, 0, 0) )
      break;
    TranslateMessage(&Msg);
    DispatchMessageA(&Msg);
  }
  return Msg.wParam;
}

//----- (10068C00) --------------------------------------------------------
int __thiscall System::searchFiles(void *this, int a2, int a3, void (__thiscall ***a4)(_DWORD, char *, _fsize_t), char a5)
{
  int result; // eax
  int v6; // edx
  char v7; // [esp+4Ch] [ebp-728h]
  int v8; // [esp+14Ch] [ebp-628h]
  char v9; // [esp+150h] [ebp-624h]
  int v10; // [esp+550h] [ebp-224h]
  int v11; // [esp+554h] [ebp-220h]
  struct _finddata_t v12; // [esp+558h] [ebp-21Ch]
  char Dest; // [esp+670h] [ebp-104h]
  void *v14; // [esp+770h] [ebp-4h]

  v14 = this;
  sprintf(&Dest, "%s/%s", a2, a3);
  sub_10067750("base = %s : type = %s\n", a2);
  v11 = findfirst(&Dest, &v12);
  LOBYTE(v10) = v11 == -1;
  while ( !v10 )
  {
    if ( !(v12.attrib & 0x10) )
    {
      sprintf(&v9, "%s/%s", a2, v12.name);
      (**a4)(a4, &v9, v12.size);
    }
    LOBYTE(v10) = findnext(v11, &v12) != 0;
  }
  result = findclose(v11);
  if ( a5 )
  {
    sprintf(&Dest, "%s/*.*", a2);
    v11 = findfirst(&Dest, &v12);
    LOBYTE(v8) = v11 == -1;
    while ( !v8 )
    {
      if ( v12.attrib & 0x10 && strcmp(v12.name, ".") && strcmp(v12.name, "..") )
      {
        sprintf(&v7, "%s/%s", a2, v12.name);
        LOBYTE(v6) = a5;
        System::searchFiles(&v7, a3, a4, v6);
      }
      LOBYTE(v8) = findnext(v11, &v12) != 0;
    }
    result = findclose(v11);
  }
  return result;
}
// 1000202C: using guessed type _DWORD __stdcall System::searchFiles(char, _DWORD, _DWORD, _DWORD);

//----- (10068F50) --------------------------------------------------------
double __thiscall System::getTime(void *this)
{
  LARGE_INTEGER PerformanceCount; // [esp+50h] [ebp-14h]
  LARGE_INTEGER Frequency; // [esp+58h] [ebp-Ch]
  void *v4; // [esp+60h] [ebp-4h]

  v4 = this;
  QueryPerformanceFrequency(&Frequency);
  QueryPerformanceCounter(&PerformanceCount);
  return PerformanceCount.QuadPart / Frequency.QuadPart * 1000.0;
}

//----- (10068FD0) --------------------------------------------------------
LARGE_INTEGER *__thiscall System::updateSysClock(LARGE_INTEGER *this)
{
  LONG v1; // ecx
  LARGE_INTEGER *v2; // edx
  LARGE_INTEGER *result; // eax
  LARGE_INTEGER PerformanceCount; // [esp+68h] [ebp-14h]
  LARGE_INTEGER Frequency; // [esp+70h] [ebp-Ch]

  QueryPerformanceFrequency(&Frequency);
  QueryPerformanceCounter(&PerformanceCount);
  ++this[140].LowPart;
  v1 = (PerformanceCount.QuadPart - this[136].QuadPart) >> 32;
  v2 = this;
  this[138].LowPart = PerformanceCount.LowPart - this[136].LowPart;
  v2[138].HighPart = v1;
  *&this[139].LowPart = this[138].QuadPart / Frequency.QuadPart;
  ++this[141].LowPart;
  if ( *&this[139].LowPart > 0.033333335 )
    this[139].LowPart = 1023969417;
  if ( *&this[139].LowPart < 0.0 )
    this[139].LowPart = 0;
  if ( PerformanceCount.QuadPart - this[137].QuadPart >= Frequency.QuadPart )
  {
    *&this[139].HighPart = ((this[140].LowPart - this[140].HighPart) * Frequency.QuadPart)
                         / (PerformanceCount.QuadPart - this[137].QuadPart);
    this[137] = PerformanceCount;
    this[140].HighPart = this[140].LowPart;
  }
  result = this;
  this[136] = PerformanceCount;
  return result;
}

//----- (10069210) --------------------------------------------------------
StdSystem *__thiscall System::System(StdSystem *this)
{
  char *v1; // eax
  char *v2; // eax
  HGLOBAL v3; // eax
  char Dest; // [esp+4Ch] [ebp-204h]
  StdSystem *v6; // [esp+24Ch] [ebp-4h]

  v6 = this;
  StdSystem::StdSystem(this);
  AtxFileStream::AtxFileStream((v6 + 612));
  BufferedStream::BufferedStream((v6 + 644));
  ControllerMgr::ControllerMgr((v6 + 692));
  *v6 = &System::`vftable';
  *(v6 + 7) = 0;
  *(v6 + 8) = 1;
  *(v6 + 9) = 0;
  *(v6 + 10) = 1;
  *(v6 + 11) = 1;
  *(v6 + 172) = 0;
  *(v6 + 270) = 0;
  sysCurrWnd = 0;
  *(v6 + 588) = 0;
  *(v6 + 589) = 0;
  *(v6 + 149) = 32;
  *(v6 + 114) = 0x200000;
  *(v6 + 102) = -1;
  gsys = v6;
  *(v6 + 590) = 0;
  v1 = getcwd(0, 0);
  sprintf(&Dest, "%s\\", v1);
  v2 = strdup(&Dest);
  *(v6 + 20) = v2;
  *(v6 + 152) = 83886080;
  v3 = GlobalAlloc(0, *(v6 + 152));
  *(v6 + 151) = v3;
  AyuHeap::init((v6 + 88), "sys", 1, *(v6 + 151), *(v6 + 152));
  System::buildModeList(v6);
  WSocket::init();
  gethostname(v6 + 952, 128);
  StdSystem::onceInit(v6);
  *(v6 + 278) = 953267991;
  return v6;
}
// 10001483: using guessed type int __thiscall System::buildModeList(_DWORD);
// 101ADB64: using guessed type void *System::`vftable';

//----- (10069490) --------------------------------------------------------
HGLOBAL __thiscall System::~System(HGLOBAL *this)
{
  HGLOBAL result; // eax

  result = this;
  *this = &System::`vftable';
  if ( this[151] )
    result = GlobalFree(this[151]);
  return result;
}
// 101ADB64: using guessed type void *System::`vftable';

//----- (10069510) --------------------------------------------------------
StdSystem *__thiscall System::hardReset(StdSystem *this)
{
  StdSystem *v1; // ST60_4
  struct Texture *v2; // eax
  StdSystem *result; // eax

  v1 = this;
  *(this + 5) = sub_10002A81(0x10u);
  v2 = StdSystem::loadTexture(v1, "consFont.bti", 1);
  Font::setTexture(*(v1 + 5), v2, 16, 8);
  StdSystem::set2DRoot(gsys, "screen/eng_blo/", "screen/eng_tex/");
  result = v1;
  *(v1 + 282) = 0;
  return result;
}

//----- (100695C0) --------------------------------------------------------
void __cdecl __noreturn System::halt(char *a1, int a2, char *a3)
{
  char Dest; // [esp+4Ch] [ebp-800h]

  sprintf(&Dest, "%s\n\nClick OK to quit now !", a3);
  MessageBoxA(0, &Dest, "Error!", 0x30u);
  exit(0);
}

//----- (10069670) --------------------------------------------------------
void __stdcall System::sleep(float a2)
{
  SleepEx((a2 * 1000.0), 1);
}

//----- (100696E0) --------------------------------------------------------
HANDLE __cdecl startThread(LPTHREAD_START_ROUTINE lpStartAddress, void *lpParameter, int a3)
{
  signed int nPriority; // [esp+4Ch] [ebp-Ch]
  HANDLE hThread; // [esp+50h] [ebp-8h]
  DWORD ThreadId; // [esp+54h] [ebp-4h]

  hThread = CreateThread(0, 0, lpStartAddress, lpParameter, 4u, &ThreadId);
  if ( hThread )
  {
    nPriority = 0;
    if ( a3 >= 0 )
    {
      if ( a3 > 0 )
        nPriority = 2;
      SetThreadPriority(hThread, nPriority);
    }
    else
    {
      SetThreadPriority(hThread, -1);
    }
    ResumeThread(hThread);
  }
  return hThread;
}

//----- (100697B0) --------------------------------------------------------
void __thiscall System::genAge(struct AgeServer *this, struct AgeServer *a2)
{
  StdSystem *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  (*(**(this + 150) + 236))(*(this + 150), a2);
  StdSystem::genAge(v2, a2);
}

//----- (10069830) --------------------------------------------------------
TcpStream *__thiscall TcpStream::TcpStream(TcpStream *this, struct WSocket *a2)
{
  TcpStream *v2; // ST54_4

  v2 = this;
  Stream::Stream(this);
  *v2 = &TcpStream::`vftable';
  *(v2 + 2) = sub_10002A81(8u);
  **(v2 + 2) = *a2;
  WSocket::connect(*(v2 + 2));
  return v2;
}
// 101AFABC: using guessed type void *TcpStream::`vftable';

//----- (100698C0) --------------------------------------------------------
BOOL __thiscall TcpStream::connect(TcpStream *this, char *a2, int a3)
{
  TcpStream *v3; // ST58_4

  v3 = this;
  *(this + 2) = sub_10002A81(8u);
  return WSocket::open(*(v3 + 2), a2, a3) != 0;
}

//----- (10069940) --------------------------------------------------------
int __thiscall TcpStream::getPending(TcpStream *this)
{
  return WSocket::pending(*(this + 2));
}

//----- (10069990) --------------------------------------------------------
int TcpStream::getAvailable()
{
  return 0;
}

//----- (100699C0) --------------------------------------------------------
void __thiscall TcpStream::flush(TcpStream *this)
{
  WSocket::flushWrite(*(this + 2));
}

//----- (10069A10) --------------------------------------------------------
void __thiscall TcpStream::read(TcpStream *this, char *buf, int a3)
{
  TcpStream *v3; // ST58_4
  int v4; // ST04_4

  v3 = this;
  v4 = *(this + 3);
  System::setStreamType(gsys);
  WSocket::read(*(v3 + 2), buf, a3);
  System::setStreamType(gsys);
}

//----- (10069A90) --------------------------------------------------------
void __thiscall TcpStream::write(TcpStream *this, void *a2, int a3)
{
  WSocket::write(*(this + 2), a2, a3);
}

//----- (10069AF0) --------------------------------------------------------
void __thiscall TcpStream::close(TcpStream *this)
{
  WSocket::close(*(this + 2));
}

//----- (10069B40) --------------------------------------------------------
BOOL __thiscall TcpStream::closing(TcpStream *this)
{
  return WSocket::closing(*(this + 2)) != 0;
}

//----- (10069B90) --------------------------------------------------------
void __stdcall handlePopupMenu(HWND hWnd, int *a2, struct tagPOINT Point, HMENU hMenu)
{
  RECT prcRect; // [esp+4Ch] [ebp-14h]
  HMENU v5; // [esp+5Ch] [ebp-4h]

  if ( hMenu )
  {
    if ( a2 )
      *a2 = 1;
    v5 = GetSubMenu(hMenu, 0);
    ClientToScreen(hWnd, &Point);
    RectArea::RectArea(&prcRect, 0, 0, 32, 32);
    TrackPopupMenu(v5, 0, Point.x, Point.y, 0, hWnd, &prcRect);
    DestroyMenu(hMenu);
  }
}

//----- (10069C80) --------------------------------------------------------
LRESULT __stdcall sub_10069C80(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  struct Node *v4; // eax
  struct UIWindow *v5; // eax
  LRESULT result; // eax
  UINT v7; // [esp+4Ch] [ebp-8h]
  LONG v8; // [esp+50h] [ebp-4h]

  v7 = Msg;
  if ( Msg == 1 )
  {
    SetWindowLongA(hWnd, 0, 0);
    goto LABEL_16;
  }
  if ( v7 == 2 )
  {
    v4 = GetWindowLongA(hWnd, 0);
    NodeMgr::Del(nodeMgr, v4);
LABEL_16:
    v8 = GetWindowLongA(hWnd, 0);
    if ( !v8 || StdSystem::isShutdown(gsys) )
      result = DefWindowProcA(hWnd, Msg, wParam, lParam);
    else
      result = (*(*v8 + 64))(v8, hWnd, Msg, wParam, lParam);
    return result;
  }
  if ( v7 != 28 )
    goto LABEL_16;
  if ( wParam )
  {
    if ( !StdSystem::isShutdown(gsys) && !StdSystem::isActive(gsys) )
    {
      StdSystem::setActive(gsys, 1);
      if ( uiMgr )
      {
        v5 = GetWindowLongA(hWnd, 0);
        UIMgr::activateWindow(uiMgr, hWnd, v5);
      }
    }
  }
  else if ( StdSystem::isActive(gsys) )
  {
    StdSystem::setActive(gsys, 0);
  }
  return 0;
}

//----- (10069E80) --------------------------------------------------------
void __thiscall UIMgr::activateWindow(UIMgr *this, HWND a2, struct UIWindow *a3)
{
  CoreNode *i; // [esp+4Ch] [ebp-8h]
  CoreNode *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  for ( i = CoreNode::Child(this); i; i = CoreNode::Next(i) )
    (*(i->vtblPointer + 60))(i);
}

//----- (10069F00) --------------------------------------------------------
void __thiscall UIMgr::RegisterGenWindowClass(UIMgr *this, LPCSTR lpszClass, void *a3, bool a4)
{
  LRESULT (__stdcall *v4)(HWND, UINT, WPARAM, LPARAM); // [esp+4Ch] [ebp-38h]
  struct tagWNDCLASSEXA wcx; // [esp+50h] [ebp-34h]
  UIMgr *v6; // [esp+80h] [ebp-4h]

  v6 = this;
  if ( !GetClassInfoExA(sysHInst, lpszClass, &wcx) )
  {
    wcx.cbSize = 48;
    wcx.lpszClassName = lpszClass;
    wcx.hInstance = sysHInst;
    if ( a3 )
      v4 = a3;
    else
      v4 = sub_100013B1;
    wcx.lpfnWndProc = v4;
    wcx.hCursor = LoadCursorA(0, 0x7F00);
    wcx.hIcon = LoadIconA(hInstance, 0x65);
    wcx.lpszMenuName = 0;
    wcx.hbrBackground = (a4 != 0 ? 0x10 : 0);
    wcx.style = 32;
    wcx.cbClsExtra = 0;
    wcx.cbWndExtra = 4;
    wcx.hIconSm = LoadIconA(hInstance, 0x65);
    RegisterClassExA(&wcx);
  }
}

//----- (1006A060) --------------------------------------------------------
Node *__thiscall UIMgr::UIMgr(UIMgr *this)
{
  Node *v1; // ST58_4
  CoreNode *v2; // eax

  v1 = this;
  Node::Node(this, "UIMgr");
  Node::Node(v1 + 1, "<Node>");
  v1->pVtbl = &UIMgr::`vftable';
  UIMgr::RegisterGenWindowClass(v1, "DUIGenWin", 0, 1);
  UIMgr::RegisterGenWindowClass(v1, "DUIClearWin", 0, 0);
  InitCommonControls();
  v2 = NodeMgr::firstNode(nodeMgr);
  CoreNode::add(v2, v1);
  return v1;
}
// 101B0084: using guessed type void *UIMgr::`vftable';

//----- (1006A130) --------------------------------------------------------
struct CoreNode *__thiscall UIMgr::~UIMgr(UIMgr *this)
{
  struct CoreNode *result; // eax
  CoreNode *i; // [esp+4Ch] [ebp-8h]

  *this = &UIMgr::`vftable';
  result = CoreNode::Child(this);
  for ( i = result; i; i = result )
  {
    DestroyWindow(i[5].vtblPointer);
    result = CoreNode::Next(i);
  }
  return result;
}
// 101B0084: using guessed type void *UIMgr::`vftable';

//----- (1006A1C0) --------------------------------------------------------
UIWindow *__thiscall RenderWindow::RenderWindow(RenderWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6)
{
  UIWindow *v6; // ST60_4

  v6 = this;
  UIWindow::UIWindow(this, a2, a3, a4, a5, a6);
  *v6 = &RenderWindow::`vftable';
  *(v6 + 37) = 0;
  *(v6 + 39) = 0;
  return v6;
}
// 101AFFAC: using guessed type void *RenderWindow::`vftable';

//----- (1006A250) --------------------------------------------------------
void __thiscall RenderWindow::initOpenGL(RenderWindow *this)
{
  int v1; // ST0C_4
  int v2; // edx
  HDC v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // [esp+4Ch] [ebp-4Ch]
  char v8; // [esp+50h] [ebp-48h]
  HGLOBAL hMem; // [esp+54h] [ebp-44h]
  int v10; // [esp+58h] [ebp-40h]
  int format; // [esp+5Ch] [ebp-3Ch]
  __int16 Dst; // [esp+60h] [ebp-38h]
  __int16 v13; // [esp+62h] [ebp-36h]
  int v14; // [esp+64h] [ebp-34h]
  char v15; // [esp+68h] [ebp-30h]
  char v16; // [esp+69h] [ebp-2Fh]
  char v17; // [esp+70h] [ebp-28h]
  char v18; // [esp+77h] [ebp-21h]
  char v19; // [esp+7Ah] [ebp-1Eh]
  RenderWindow *v20; // [esp+88h] [ebp-10h]
  int v21; // [esp+94h] [ebp-4h]

  v20 = this;
  v1 = *(gsys + 149);
  v2 = glnHeight;
  LOBYTE(v2) = *(gsys + 589);
  System::setVideoMode(gsys, v2, glnWidth, glnHeight);
  memset(&Dst, 0, 0x28u);
  Dst = 40;
  v13 = 1;
  v14 = 37;
  v15 = 0;
  v17 = 0;
  v18 = 32;
  v16 = 32;
  v19 = 0;
  v3 = GetDC(*(v20 + 25));
  *(v20 + 36) = v3;
  if ( *(v20 + 36) )
  {
    format = ChoosePixelFormat(*(v20 + 36), &Dst);
    if ( format )
    {
      if ( SetPixelFormat(*(v20 + 36), format, &Dst) )
      {
        DescribePixelFormat(*(v20 + 36), format, 0x28u, &Dst);
        if ( !*(gsys + 148) )
          RenderWindow::hGLRC = wglCreateContext(*(v20 + 36));
        wglMakeCurrent(*(v20 + 36), RenderWindow::hGLRC);
        v4 = RectArea::width((v20 + 64));
        *(v20 + 34) = v4;
        v5 = RectArea::height((v20 + 64));
        *(v20 + 35) = v5;
        glViewport(0, 0, *(v20 + 34), *(v20 + 35));
        hMem = sub_10002A81(0x3E8u);
        v21 = 0;
        if ( hMem )
          v7 = sub_100016EA(*(v20 + 34), *(v20 + 35));
        else
          v7 = 0;
        v10 = v7;
        v21 = -1;
        *(v20 + 40) = v7;
        *(gsys + 115) = *(v20 + 40);
        v6 = Colour::Colour(&v8, 0, 0, 0, 0);
        (*(**(v20 + 40) + 172))(*(v20 + 40), v6);
        ++*(gsys + 148);
      }
      else
      {
        ChangeDisplaySettingsA(0, 0);
        MessageBoxA(0, "SetPixelFormat failed\n", "FATAL ERROR", 0);
      }
    }
    else
    {
      ChangeDisplaySettingsA(0, 0);
      MessageBoxA(0, "ChoosePixelFormat failed\n", "FATAL ERROR", 0);
    }
  }
  else
  {
    ChangeDisplaySettingsA(0, 0);
    MessageBoxA(0, "GetDC on main window failed", "FATAL ERROR", 0);
  }
}
// 100016EA: using guessed type _DWORD __stdcall sub_100016EA(_DWORD, _DWORD);

//----- (1006A680) --------------------------------------------------------
void __thiscall RenderWindow::shutdownOpenGL(RenderWindow *this)
{
  RenderWindow *v1; // [esp+50h] [ebp-4h]

  v1 = this;
  StdSystem::detachObjs(gsys);
  sub_10001938(*(v1 + 40));
  --*(gsys + 148);
  if ( !wglMakeCurrent(0, 0) )
    MessageBoxA(0, "ShutdownOpenGL - wglMakeCurrent failed\n", "ERROR", 0);
  if ( !*(gsys + 148) && RenderWindow::hGLRC )
  {
    if ( !wglDeleteContext(RenderWindow::hGLRC) )
      MessageBoxA(0, "ShutdownOpenGL - wglDeleteContext failed\n", "ERROR", 0);
    RenderWindow::hGLRC = 0;
  }
  if ( *(v1 + 36) )
  {
    if ( !ReleaseDC(*(v1 + 25), *(v1 + 36)) )
      MessageBoxA(0, "ShutdownOpenGL - ReleaseDC failed\n", "ERROR", 0);
    *(v1 + 36) = 0;
  }
  if ( *(gsys + 589) )
  {
    ChangeDisplaySettingsA(0, 0);
    ShowCursor(1);
  }
}

//----- (1006A870) --------------------------------------------------------
void RenderWindow::clearRender()
{
  glColorMask(1u, 1u, 1u, 1u);
  glDepthMask(1u);
  glClearDepth(1.0);
}

//----- (1006A900) --------------------------------------------------------
void __thiscall RenderWindow::paintRender(RenderWindow *this, struct RectArea *a2)
{
  RenderWindow *v2; // [esp+4Ch] [ebp-4h]

  v2 = this;
  wglMakeCurrent(*(this + 36), RenderWindow::hGLRC);
  RenderWindow::clearRender(v2);
  (*(**(v2 + 40) + 28))(*(v2 + 40), *(v2 + 34), *(v2 + 35));
  StdSystem::attachObjs(gsys);
  if ( *(v2 + 37) )
  {
    *(gsys + 150) = *(v2 + 40);
    (*(**(v2 + 37) + 24))(*(v2 + 37), *(v2 + 40));
  }
  glFinish();
  if ( !SwapBuffers(*(v2 + 36)) )
  {
    ChangeDisplaySettingsA(0, 0);
    MessageBoxA(0, "RenderScene - SwapBuffers failed!\n", "FATAL ERROR", 0);
    *(v2 + 152) = 1;
    SendMessageA(*(v2 + 25), 0x10u, 0, 0);
  }
}

//----- (1006AAC0) --------------------------------------------------------
void __thiscall RenderWindow::update(RenderWindow *this)
{
  Node *v1; // [esp+4Ch] [ebp-4h]

  v1 = this;
  if ( !*(this + 152) )
    RenderWindow::paintRender(this, 0);
  Node::update(v1);
}

//----- (1006AB30) --------------------------------------------------------
void __thiscall RenderWindow::createWindow(RenderWindow *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU a4)
{
  UIWindow *v4; // ST58_4

  v4 = this;
  UIWindow::createWindow(this, lpClassName, lpWindowName, a4);
  RenderWindow::initOpenGL(v4);
  *(v4 + 152) = 0;
}

//----- (1006ABA0) --------------------------------------------------------
int __thiscall RenderWindow::processMessage(RenderWindow *this, HWND hWnd, UINT Msg, WPARAM wParam, int lParam)
{
  int v5; // ST0C_4
  int v6; // eax
  RenderWindow *v8; // [esp+50h] [ebp-4h]

  v8 = this;
  if ( Msg > 0x10 )
  {
    switch ( Msg )
    {
      case 0x200u:
      case 0x201u:
      case 0x202u:
      case 0x204u:
      case 0x205u:
        if ( *(this + 39) )
          SendMessageA(*(*(this + 39) + 100), Msg, wParam, lParam);
        break;
      default:
        return UIWindow::processMessage(v8, hWnd, Msg, wParam, lParam);
    }
    return UIWindow::processMessage(v8, hWnd, Msg, wParam, lParam);
  }
  if ( Msg == 16 )
  {
    RenderWindow::shutdownOpenGL(this);
    return UIWindow::processMessage(v8, hWnd, Msg, wParam, lParam);
  }
  if ( Msg == 5 )
  {
    if ( RenderWindow::hGLRC )
    {
      *(this + 34) = lParam;
      *(*(this + 40) + 784) = *(this + 34);
      *(this + 35) = lParam >> 16;
      *(*(this + 40) + 788) = *(this + 35);
    }
    return UIWindow::processMessage(v8, hWnd, Msg, wParam, lParam);
  }
  if ( Msg != 6 )
  {
    if ( Msg == 15 )
      RenderWindow::paintRender(this, 0);
    return UIWindow::processMessage(v8, hWnd, Msg, wParam, lParam);
  }
  if ( wParam )
  {
    v5 = *(gsys + 149);
    v6 = glnHeight;
    LOBYTE(v6) = *(gsys + 589);
    if ( System::setVideoMode(gsys, v6, glnWidth, glnHeight) )
    {
      ShowWindow(*(*(v8 + 39) + 100), 9);
      SetForegroundWindow(*(*(v8 + 39) + 100));
      *(v8 + 152) = 0;
    }
    else
    {
      SendMessageA(hWnd, 0x10u, 0, 0);
    }
  }
  else if ( *(gsys + 589) && RenderWindow::hGLRC )
  {
    *(this + 152) = 1;
    ShowWindow(*(*(this + 39) + 100), 6);
    ChangeDisplaySettingsA(0, 0);
  }
  return 0;
}

//----- (1006AEB0) --------------------------------------------------------
int __thiscall ToolWindow::processMessage(ToolWindow *this, HWND hWnd, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v6; // [esp+4Ch] [ebp-214h]
  CHAR Buffer; // [esp+50h] [ebp-210h]
  int v8; // [esp+250h] [ebp-10h]
  unsigned int v9; // [esp+254h] [ebp-Ch]
  int v10; // [esp+258h] [ebp-8h]
  UIWindow *v11; // [esp+25Ch] [ebp-4h]

  v11 = this;
  v6 = a3;
  if ( a3 == 78 )
  {
    v10 = a5;
    v9 = a4;
    if ( *(a5 + 8) == -520 )
    {
      v8 = a5;
      LoadStringA(*(v11 + 35), *(a5 + 4), &Buffer, 256);
      sprintf(*(v8 + 12), &Buffer);
    }
  }
  return UIWindow::processMessage(v11, hWnd, a3, a4, a5);
}

//----- (1006AFC0) --------------------------------------------------------
void __thiscall ToolWindow::initTools(ToolWindow *this, HINSTANCE hInstance, WPARAM wParam, LPARAM a4, struct tagTBADDBITMAP *a5)
{
  HBITMAP v5; // ST5C_4
  LPARAM lParam; // [esp+50h] [ebp-Ch]
  HBITMAP v7; // [esp+54h] [ebp-8h]
  ToolWindow *v8; // [esp+58h] [ebp-4h]

  v8 = this;
  *(this + 35) = hInstance;
  v5 = LoadBitmapA(hInstance, LOWORD(a5->nID));
  lParam = 0;
  v7 = v5;
  SendMessageA(*(*(v8 + 34) + 100), 0x41Eu, 0x14u, 0);
  SendMessageA(*(*(v8 + 34) + 100), 0x420u, 0, 1638425);
  SendMessageA(*(*(v8 + 34) + 100), 0x413u, wParam, &lParam);
  SendMessageA(*(*(v8 + 34) + 100), 0x414u, wParam, a4);
  SendMessageA(*(*(v8 + 34) + 100), 0x421u, 0, 0);
}

//----- (1006B140) --------------------------------------------------------
void __thiscall ToolWindow::createWindow(ToolWindow *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU a4)
{
  int v4; // [esp+4Ch] [ebp-1Ch]
  HGLOBAL hMem; // [esp+50h] [ebp-18h]
  int v6; // [esp+54h] [ebp-14h]
  UIWindow *v7; // [esp+58h] [ebp-10h]
  int v8; // [esp+64h] [ebp-4h]

  v7 = this;
  UIWindow::createWindow(this, lpClassName, lpWindowName, a4);
  hMem = sub_10002A81(0x88u);
  v8 = 0;
  if ( hMem )
    v4 = UIWindow::UIWindow(hMem, v7, 15, 1375732544, 0, 0);
  else
    v4 = 0;
  v6 = v4;
  v8 = -1;
  *(v7 + 34) = v4;
  UIWindow::sizeWindow(*(v7 + 34), *(v7 + 30), *(v7 + 31), 0);
  (*(**(v7 + 34) + 80))(*(v7 + 34), "ToolbarWindow32", "toolbar", 0);
}

//----- (1006B290) --------------------------------------------------------
UIWindow *__thiscall ToolWindow::ToolWindow(ToolWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6)
{
  UIWindow *v6; // ST60_4

  v6 = this;
  UIWindow::UIWindow(this, a2, a3, a4, a5, a6);
  *v6 = &ToolWindow::`vftable';
  return v6;
}
// 101AFC9C: using guessed type void *ToolWindow::`vftable';

//----- (1006B300) --------------------------------------------------------
UIFrame *__thiscall UIFrame::UIFrame(UIFrame *this)
{
  UIFrame *v1; // ST50_4

  v1 = this;
  Node::Node(this, "UIFrame");
  RectArea::RectArea((v1 + 32));
  RectArea::RectArea((v1 + 48));
  RectArea::RectArea((v1 + 64));
  *v1 = &UIFrame::`vftable';
  return v1;
}
// 101AFBF0: using guessed type void *UIFrame::`vftable';

//----- (1006B390) --------------------------------------------------------
HDWP __thiscall UIWindow::resizeFrame(UIWindow *this, HDWP hWinPosInfo, struct RectArea *a3)
{
  int v3; // ST18_4
  int v4; // eax
  int v6; // [esp+4Ch] [ebp-28h]
  int v7; // [esp+50h] [ebp-24h]
  int v8; // [esp+54h] [ebp-20h]
  int v9; // [esp+58h] [ebp-1Ch]
  int v10; // [esp+5Ch] [ebp-18h]
  int x; // [esp+60h] [ebp-14h]
  int y; // [esp+64h] [ebp-10h]
  int v13; // [esp+68h] [ebp-Ch]
  int v14; // [esp+6Ch] [ebp-8h]
  UIWindow *v15; // [esp+70h] [ebp-4h]

  v15 = this;
  RectArea::RectArea(&x);
  v10 = *(v15 + 30);
  v9 = *(v15 + 31);
  if ( *(v15 + 28) & 1 && *(v15 + 28) & 2 )
  {
    x = *a3;
    v13 = *(a3 + 2);
  }
  else if ( *(v15 + 28) & 1 )
  {
    x = *a3;
    if ( v10 >= RectArea::width(a3) )
      v8 = RectArea::width(a3);
    else
      v8 = v10;
    v13 = v8 + x;
    *a3 = v8 + x;
  }
  else if ( *(v15 + 28) & 2 )
  {
    v13 = *(a3 + 2);
    if ( v10 >= RectArea::width(a3) )
      v7 = RectArea::width(a3);
    else
      v7 = v10;
    x = v13 - v7;
    *(a3 + 2) = v13 - v7;
  }
  else
  {
    x = *(v15 + 8);
    v13 = *(v15 + 10);
  }
  if ( *(v15 + 28) & 4 && *(v15 + 28) & 8 )
  {
    y = *(a3 + 1);
    v14 = *(a3 + 3);
  }
  else if ( *(v15 + 28) & 4 )
  {
    (*(*v15 + 84))(v15, v9, &x, a3);
  }
  else if ( *(v15 + 28) & 8 )
  {
    v14 = *(a3 + 3);
    if ( v9 >= RectArea::height(a3) )
      v6 = RectArea::height(a3);
    else
      v6 = v9;
    y = v14 - v6;
    *(a3 + 3) = v14 - v6;
  }
  else
  {
    y = *(v15 + 9);
    v14 = *(v15 + 11);
  }
  x += *(v15 + 20);
  y += *(v15 + 21);
  v13 -= *(v15 + 22);
  v14 -= *(v15 + 23);
  v3 = RectArea::height(&x);
  v4 = RectArea::width(&x);
  return DeferWindowPos(hWinPosInfo, *(v15 + 25), 0, x, y, v4, v3, 0);
}

//----- (1006B670) --------------------------------------------------------
void __stdcall UIWindow::dockTop(int a2, struct RectArea *a3, struct RectArea *a4)
{
  int v4; // [esp+4Ch] [ebp-8h]

  *(a3 + 1) = *(a4 + 1);
  if ( a2 >= RectArea::height(a4) )
    v4 = RectArea::height(a4);
  else
    v4 = a2;
  *(a3 + 3) = v4 + *(a3 + 1);
  *(a4 + 1) = *(a3 + 3);
}

//----- (1006B710) --------------------------------------------------------
void *__thiscall UIWindow::resizeChildren(UIWindow *this, void *a2, struct RectArea *a3)
{
  CoreNode *i; // [esp+4Ch] [ebp-8h]
  CoreNode *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  for ( i = CoreNode::Child(this); i; i = CoreNode::Next(i) )
    a2 = (*(i->vtblPointer + 76))(i, a2, a3);
  return a2;
}

//----- (1006B7A0) --------------------------------------------------------
void __thiscall UIWindow::updateSizes(UIWindow *this, int a2, int a3)
{
  CoreNode **v3; // eax
  CoreNode **v4; // ecx
  int v5; // eax
  char v6; // [esp+4Ch] [ebp-38h]
  char v7; // [esp+5Ch] [ebp-28h]
  HDWP hWinPosInfo; // [esp+6Ch] [ebp-18h]
  int v9; // [esp+70h] [ebp-14h]
  int v10; // [esp+74h] [ebp-10h]
  int v11; // [esp+78h] [ebp-Ch]
  int v12; // [esp+7Ch] [ebp-8h]
  CoreNode *v13; // [esp+80h] [ebp-4h]

  v13 = this;
  v12 = *(this + 8);
  v11 = *(this + 9);
  v10 = *(this + 14) - *(this + 12) + a2;
  v9 = *(this + 15) - *(this + 13) + a3;
  v3 = RectArea::RectArea(&v7, v12, v11, v10 + v12, v9 + v11);
  v4 = &v13[1].Next;
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  v4[3] = v3[3];
  UIFrame::calcClientFromFrame(v13, &v13[3].name);
  hWinPosInfo = BeginDeferWindowPos(40);
  if ( CoreNode::Child(v13) )
  {
    v5 = RectArea::RectArea(&v6, 0, 0, a2, a3);
    hWinPosInfo = (*(v13->vtblPointer + 72))(v13, hWinPosInfo, v5);
  }
  EndDeferWindowPos(hWinPosInfo);
}

//----- (1006B900) --------------------------------------------------------
void __thiscall UIWindow::updateMove(UIWindow *this, int a2, int a3)
{
  int v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // edx
  char v6; // [esp+4Ch] [ebp-24h]
  int v7; // [esp+5Ch] [ebp-14h]
  int v8; // [esp+60h] [ebp-10h]
  int v9; // [esp+64h] [ebp-Ch]
  int v10; // [esp+68h] [ebp-8h]
  UIFrame *v11; // [esp+6Ch] [ebp-4h]

  v11 = this;
  v10 = *(this + 12) + a2;
  v9 = *(this + 13) + a3;
  v8 = RectArea::width((this + 32));
  v3 = RectArea::height((v11 + 32));
  v7 = v3;
  v4 = RectArea::RectArea(&v6, v10, v9, v8 + v10, v3 + v9);
  v5 = (v11 + 32);
  *v5 = *v4;
  v5[1] = v4[1];
  v5[2] = v4[2];
  v5[3] = v4[3];
  UIFrame::calcClientFromFrame(v11, (v11 + 64));
}

//----- (1006B9E0) --------------------------------------------------------
void UIWindow::activate()
{
  ;
}

//----- (1006BA10) --------------------------------------------------------
int __thiscall UIWindow::processMessage(UIWindow *this, HWND hWnd, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v6; // [esp+4Ch] [ebp-18h]
  unsigned int v7; // [esp+50h] [ebp-14h]
  UIWindow *v8; // [esp+54h] [ebp-10h]
  LONG v9; // [esp+58h] [ebp-Ch]
  struct Node *v10; // [esp+5Ch] [ebp-8h]
  UIWindow *v11; // [esp+60h] [ebp-4h]

  v11 = this;
  v7 = a3 - 3;
  switch ( a3 )
  {
    case 3u:
      v8 = GetWindowLongA(hWnd, 0);
      if ( v8 )
        UIWindow::updateMove(v8, a5, a5 >> 16);
      return 0;
    case 5u:
      v9 = GetWindowLongA(hWnd, 0);
      if ( v9 )
        (*(*v9 + 56))(v9, a5, a5 >> 16);
      return 0;
    case 0x10u:
      v10 = GetWindowLongA(hWnd, 0);
      if ( v10 )
      {
        UIWindow::closeChildren(v11);
        NodeMgr::Del(nodeMgr, v10);
        SetWindowLongA(hWnd, 0, 0);
      }
      return (*(*v11 + 68))(v11, hWnd, a3, a4, a5);
    case 0xA1u:
      if ( a4 == 2 && GetFocus() != hWnd )
        SetFocus(hWnd);
      break;
    case 0x100u:
      v6 = a4;
      if ( a4 == 27 )
        SendMessageA(hWnd, 0x10u, 0, 0);
      break;
    default:
      return (*(*v11 + 68))(v11, hWnd, a3, a4, a5);
  }
  return (*(*v11 + 68))(v11, hWnd, a3, a4, a5);
}

//----- (1006BDB0) --------------------------------------------------------
LRESULT __stdcall UIWindow::returnMessage(HWND hWnd, UINT Msg, WPARAM wParam, int lParam)
{
  return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

//----- (1006BE20) --------------------------------------------------------
void __thiscall UIWindow::sizeWindow(UIWindow *this, int a2, int a3, int a4)
{
  int *v4; // ecx
  int v5; // eax
  int v6; // eax
  struct RectArea *v7; // eax
  char v8; // [esp+4Ch] [ebp-2Ch]
  int pvParam; // [esp+5Ch] [ebp-1Ch]
  int v10; // [esp+60h] [ebp-18h]
  int v11; // [esp+64h] [ebp-14h]
  int v12; // [esp+68h] [ebp-10h]
  int v13; // [esp+6Ch] [ebp-Ch]
  int v14; // [esp+70h] [ebp-8h]
  UIFrame *v15; // [esp+74h] [ebp-4h]
  int v16; // [esp+80h] [ebp+8h]
  int v17; // [esp+84h] [ebp+Ch]

  v15 = this;
  v16 = *(this + 14) - *(this + 12) + a2;
  v17 = *(this + 15) - *(this + 13) + a3;
  *(this + 30) = v16;
  *(v15 + 31) = v17;
  if ( a4 == 1 )
  {
    RectArea::RectArea(&pvParam);
    if ( *(v15 + 26) & 0x40000000 )
    {
      v4 = (*(v15 + 24) + 64);
      pvParam = *v4;
      v10 = v4[1];
      v11 = v4[2];
      v12 = v4[3];
    }
    else
    {
      SystemParametersInfoA(0x30u, 0, &pvParam, 0);
    }
    v5 = RectArea::width(&pvParam);
    v14 = v5 / 2 + pvParam - v16 / 2;
    v6 = RectArea::height(&pvParam);
    v13 = v6 / 2 + v10 - v17 / 2;
    if ( v14 < 0 )
      v14 = 0;
    if ( v13 < 0 )
      v13 = 0;
    if ( v16 > RectArea::width(&pvParam) )
      v16 = RectArea::width(&pvParam);
    if ( v17 > RectArea::height(&pvParam) )
      v17 = RectArea::height(&pvParam);
  }
  else
  {
    v13 = 0;
    v14 = 0;
  }
  v7 = RectArea::RectArea(&v8, v14, v13, v16 + v14, v17 + v13);
  UIFrame::setFrame(v15, v7);
}

//----- (1006C010) --------------------------------------------------------
void __thiscall UIWindow::createWindow(UIWindow *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU a4)
{
  HINSTANCE v4; // ST28_4
  HMENU v5; // ST24_4
  int v6; // ST1C_4
  int v7; // eax
  HWND hWndParent; // [esp+50h] [ebp-8h]
  UIWindow *dwNewLong; // [esp+54h] [ebp-4h]

  dwNewLong = this;
  *(this + 33) = a4;
  if ( *(this + 24) )
    hWndParent = *(*(this + 24) + 100);
  else
    hWndParent = 0;
  v4 = sysHInst;
  v5 = *(this + 33);
  v6 = RectArea::height((this + 32));
  v7 = RectArea::width((dwNewLong + 32));
  *(dwNewLong + 25) = CreateWindowExA(
                        *(dwNewLong + 27),
                        lpClassName,
                        lpWindowName,
                        *(dwNewLong + 26),
                        *(dwNewLong + 8),
                        *(dwNewLong + 9),
                        v7,
                        v6,
                        hWndParent,
                        v5,
                        v4,
                        0);
  if ( lpWindowName )
    CoreNode::setName(dwNewLong, lpWindowName);
  else
    CoreNode::setName(dwNewLong, lpClassName);
  if ( !strcmp(lpClassName, "DUIGenWin") || !strcmp(lpClassName, "DUIClearWin") )
    SetWindowLongA(*(dwNewLong + 25), 0, dwNewLong);
}

//----- (1006C180) --------------------------------------------------------
void __thiscall UIWindow::initFrame(UIWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6)
{
  struct tagRECT Rect; // [esp+4Ch] [ebp-24h]
  int v7; // [esp+5Ch] [ebp-14h]
  int v8; // [esp+60h] [ebp-10h]
  int v9; // [esp+64h] [ebp-Ch]
  int v10; // [esp+68h] [ebp-8h]
  struct CoreNode *v11; // [esp+6Ch] [ebp-4h]

  v11 = this;
  *(this + 24) = a2;
  v11[5].name = a4;
  v11[5].Parent = a5;
  v11[5].Next = a3;
  LOBYTE(v11[6].Parent) = a6;
  v7 = 32;
  v8 = 32;
  v9 = 128;
  v10 = 128;
  Rect.left = 32;
  Rect.top = 32;
  Rect.right = 128;
  Rect.bottom = 128;
  AdjustWindowRectEx(&Rect, v11[5].name, 0, v11[5].Parent);
  v11[2].Parent = (Rect.left - v7);
  v11[2].Next = (Rect.top - v8);
  v11[2].Child = (Rect.right - v9);
  v11[3].vtblPointer = Rect.bottom - v10;
  if ( LOBYTE(v11[6].Parent) )
    v11[2].Next = (v11[2].Next - GetSystemMetrics(15));
  if ( v11[5].name & 0x200000 )
    v11[2].Child = (v11[2].Child + GetSystemMetrics(2));
  if ( v11[5].name & 0x100000 )
    v11[3].vtblPointer += GetSystemMetrics(3);
  if ( a4 & 0x40000000 )
    CoreNode::add(v11[4].Child, v11);
  else
    CoreNode::add(uiMgr, v11);
}

//----- (1006C390) --------------------------------------------------------
void __thiscall UIWindow::closeChildren(UIWindow *this)
{
  struct CoreNode *v1; // ST60_4
  CoreNode *i; // [esp+4Ch] [ebp-Ch]

  for ( i = CoreNode::Child(this); i; i = v1 )
  {
    v1 = CoreNode::Next(i);
    SendMessageA(i[5].vtblPointer, 0x10u, 0, 0);
  }
}

//----- (1006C420) --------------------------------------------------------
UIFrame *__thiscall UIWindow::UIWindow(UIWindow *this)
{
  UIFrame *v1; // ST5C_4

  v1 = this;
  UIFrame::UIFrame(this);
  RectArea::RectArea((v1 + 80));
  *v1 = &UIWindow::`vftable';
  *(v1 + 24) = 0;
  *(v1 + 27) = 0;
  *(v1 + 26) = 0;
  *(v1 + 128) = 0;
  *(v1 + 33) = 0;
  *(v1 + 29) = 0;
  RectArea::set((v1 + 80), 0, 0, 0, 0);
  return v1;
}
// 101AFC30: using guessed type void *UIWindow::`vftable';

//----- (1006C4F0) --------------------------------------------------------
UIWindow *__thiscall UIWindow::UIWindow(UIWindow *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6)
{
  UIWindow *v6; // ST60_4

  v6 = this;
  UIFrame::UIFrame(this);
  RectArea::RectArea((v6 + 80));
  *v6 = &UIWindow::`vftable';
  *(v6 + 29) = 0;
  *(v6 + 128) = 0;
  *(v6 + 33) = 0;
  UIWindow::initFrame(v6, a2, a3, a4, a5, a6);
  return v6;
}
// 101AFC30: using guessed type void *UIWindow::`vftable';

//----- (1006C5A0) --------------------------------------------------------
char *__thiscall UIWindow::~UIWindow(UIWindow *this)
{
  *this = &UIWindow::`vftable';
  return sub_1006C600("now closing window %s", *(this + 1));
}
// 101AFC30: using guessed type void *UIWindow::`vftable';

//----- (1006C600) --------------------------------------------------------
char *__cdecl sub_1006C600(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "uiWindow" )
      Stream::print(sysCon, "%s: ", "uiWindow");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1006C710) --------------------------------------------------------
UIWindow *__thiscall SplitBar::SplitBar(SplitBar *this, struct UIWindow *a2, struct UIWindow *a3, COLORREF color, int a5)
{
  UIWindow *v5; // ST60_4

  v5 = this;
  UIWindow::UIWindow(this, a2, a5, 1451229184, 0x20000, 0);
  *v5 = &SplitBar::`vftable';
  *(v5 + 136) = 0;
  *(v5 + 37) = a3;
  *(v5 + 38) = 0;
  *(v5 + 39) = 0;
  *(v5 + 40) = CreateSolidBrush(color);
  return v5;
}
// 101AFD08: using guessed type void *SplitBar::`vftable';

//----- (1006C7E0) --------------------------------------------------------
int __thiscall SplitBar::processMessage(SplitBar *this, HWND hWnd, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v6; // [esp+4Ch] [ebp-24h]
  HGDIOBJ h; // [esp+50h] [ebp-20h]
  HRGN hrgn; // [esp+54h] [ebp-1Ch]
  struct tagRECT Rect; // [esp+58h] [ebp-18h]
  HDC hdc; // [esp+68h] [ebp-8h]
  SplitBar *v11; // [esp+6Ch] [ebp-4h]

  v11 = this;
  v6 = a3;
  if ( a3 > 0x201 )
  {
    if ( v6 == 514 )
      SplitBar::handleRelease(v11, a5, SHIWORD(a5));
  }
  else
  {
    switch ( v6 )
    {
      case 0x201u:
        SplitBar::handleClick(v11, a5, SHIWORD(a5));
        break;
      case 0xFu:
        hdc = GetDC(hWnd);
        RectArea::RectArea(&Rect);
        GetUpdateRect(hWnd, &Rect, 1);
        hrgn = CreateRectRgn(Rect.left, Rect.top, Rect.right, Rect.bottom);
        SelectClipRgn(hdc, hrgn);
        h = SelectObject(hdc, *(v11 + 40));
        FillRect(hdc, &Rect, *(v11 + 40));
        DeleteObject(hrgn);
        SelectObject(hdc, h);
        ReleaseDC(hWnd, hdc);
        ValidateRect(hWnd, &Rect);
        break;
      case 0x200u:
        (*(*v11 + 88))(v11, a4, a5, SHIWORD(a5));
        break;
    }
  }
  return UIWindow::processMessage(v11, hWnd, a3, a4, a5);
}

//----- (1006CA70) --------------------------------------------------------
void __thiscall SplitBar::handleClick(SplitBar *this, int a2, int a3)
{
  SplitBar *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  if ( !*(this + 136) )
  {
    if ( *(this + 37) )
    {
      *(this + 35) = a2;
      *(this + 36) = a3;
      SetCapture(*(this + 25));
      *(v3 + 136) = 1;
    }
  }
}

//----- (1006CB20) --------------------------------------------------------
void __thiscall SplitBar::handleRelease(SplitBar *this, int a2, int a3)
{
  SplitBar *v3; // [esp+4Ch] [ebp-4h]

  v3 = this;
  if ( *(this + 136) )
  {
    ReleaseCapture();
    *(v3 + 136) = 0;
  }
}

//----- (1006CB90) --------------------------------------------------------
VertSplitBar *__thiscall VertSplitBar::VertSplitBar(VertSplitBar *this, struct UIWindow *a2, struct UIWindow *a3, COLORREF color, int a5)
{
  VertSplitBar *v5; // ST5C_4
  int v6; // eax

  v5 = this;
  v6 = a5;
  LOBYTE(v6) = a5 | 3;
  SplitBar::SplitBar(this, a2, a3, color, v6);
  *v5 = &VertSplitBar::`vftable';
  UIWindow::sizeWindow(v5, 4, 4, 0);
  UIWindow::createWindow(v5, "DUIGenWin", "VertSplit", 0);
  return v5;
}
// 101AFD78: using guessed type void *VertSplitBar::`vftable';

//----- (1006CC60) --------------------------------------------------------
void __thiscall VertSplitBar::trackMouse(VertSplitBar *this, int a2, int a3, int a4)
{
  int v4; // [esp+4Ch] [ebp-8h]
  VertSplitBar *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  if ( *(this + 136) )
  {
    v4 = a4 - *(v5 + 36);
    if ( *(v5 + 28) & 8 )
      v4 = -v4;
    if ( v4 )
    {
      *(*(v5 + 37) + 124) += v4;
      (*(**(v5 + 24) + 52))(*(v5 + 24));
      if ( *(v5 + 38) )
      {
        *(*(v5 + 38) + 124) += v4;
        (*(**(v5 + 39) + 52))(*(v5 + 39));
      }
    }
    if ( *(v5 + 28) & 4 )
      *(v5 + 36) = a4 - v4;
    else
      *(v5 + 36) = v4 + a4;
  }
}

//----- (1006CDC0) --------------------------------------------------------
HorzSplitBar *__thiscall HorzSplitBar::HorzSplitBar(HorzSplitBar *this, struct UIWindow *a2, struct UIWindow *a3, COLORREF color, int a5)
{
  HorzSplitBar *v5; // ST5C_4
  int v6; // eax

  v5 = this;
  v6 = a5;
  LOBYTE(v6) = a5 | 0xC;
  SplitBar::SplitBar(this, a2, a3, color, v6);
  *v5 = &HorzSplitBar::`vftable';
  UIWindow::sizeWindow(v5, 4, 4, 0);
  UIWindow::createWindow(v5, "DUIGenWin", "HorizSplit", 0);
  return v5;
}
// 101AFDE8: using guessed type void *HorzSplitBar::`vftable';

//----- (1006CE90) --------------------------------------------------------
void __thiscall HorzSplitBar::trackMouse(HorzSplitBar *this, int a2, int a3, int a4)
{
  int v4; // [esp+4Ch] [ebp-8h]
  HorzSplitBar *v5; // [esp+50h] [ebp-4h]

  v5 = this;
  if ( *(this + 136) )
  {
    v4 = a3 - *(v5 + 35);
    if ( *(v5 + 28) & 2 )
      v4 = -v4;
    if ( v4 )
    {
      *(*(v5 + 37) + 120) += v4;
      (*(**(v5 + 24) + 52))(*(v5 + 24));
      if ( *(v5 + 38) )
      {
        *(*(v5 + 38) + 120) += v4;
        (*(**(v5 + 39) + 52))(*(v5 + 39));
      }
    }
    if ( *(v5 + 28) & 1 )
      *(v5 + 35) = a3 - v4;
    else
      *(v5 + 35) = v4 + a3;
  }
}

//----- (1006CFF0) --------------------------------------------------------
ComboBox *__thiscall ComboBox::ComboBox(ComboBox *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6)
{
  ComboBox *v6; // ST60_4

  v6 = this;
  UIWindow::UIWindow(this, a2, a3, a4, a5, a6);
  *v6 = &ComboBox::`vftable';
  *(v6 + 35) = 258;
  return v6;
}
// 101AFE58: using guessed type void *ComboBox::`vftable';

//----- (1006D070) --------------------------------------------------------
LRESULT __stdcall sub_1006D070(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // eax

  if ( Msg == 7 )
  {
    v4 = GetParent(hWnd);
    ::hWnd = GetParent(v4);
  }
  else if ( Msg == 8 )
  {
    PostMessageA(::hWnd, 0x400u, 0, 0);
  }
  else if ( Msg == 256 && wParam == 13 )
  {
    PostMessageA(::hWnd, 0x400u, 0, 0);
  }
  return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
}

//----- (1006D190) --------------------------------------------------------
int __thiscall ComboBox::processMessage(ComboBox *this, HWND hWnd, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v6; // [esp+4Ch] [ebp-Ch]
  LRESULT v7; // [esp+50h] [ebp-8h]
  UIWindow *v8; // [esp+54h] [ebp-4h]

  v8 = this;
  v6 = a3;
  if ( a3 == 1024 )
  {
    SendMessageA(*(*(v8 + 34) + 100), 0xDu, 0x100u, &unk_101D6200);
    (*(*v8 + 88))(v8, &unk_101D6200);
    v7 = SendMessageA(*(*(v8 + 34) + 100), 0x158u, 0xFFFFFFFF, &unk_101D6200);
    if ( v7 == -1 )
      SendMessageA(*(*(v8 + 34) + 100), 0x143u, 0, &unk_101D6200);
  }
  return UIWindow::processMessage(v8, hWnd, a3, a4, a5);
}

//----- (1006D2D0) --------------------------------------------------------
void __thiscall ComboBox::createWindow(ComboBox *this, LPCSTR lpClassName, LPCSTR lpWindowName, HMENU a4)
{
  int v4; // eax
  int v5; // [esp+4Ch] [ebp-2Ch]
  HGLOBAL hMem; // [esp+50h] [ebp-28h]
  int v7; // [esp+54h] [ebp-24h]
  HWND hWnd; // [esp+58h] [ebp-20h]
  POINT Point; // [esp+5Ch] [ebp-1Ch]
  WPARAM wParam; // [esp+64h] [ebp-14h]
  UIWindow *v11; // [esp+68h] [ebp-10h]
  int v12; // [esp+74h] [ebp-4h]

  v11 = this;
  UIWindow::createWindow(this, lpClassName, lpWindowName, a4);
  hMem = sub_10002A81(0x88u);
  v12 = 0;
  if ( hMem )
    v5 = UIWindow::UIWindow(hMem, v11, 15, *(v11 + 35) | 0x50200000, 0, 0);
  else
    v5 = 0;
  v7 = v5;
  v12 = -1;
  *(v11 + 34) = v5;
  v4 = RectArea::width((v11 + 64));
  UIWindow::sizeWindow(*(v11 + 34), v4 - 16, 150, 0);
  (*(**(v11 + 34) + 80))(*(v11 + 34), "ComboBox", 0, 0);
  wParam = GetStockObject(17);
  SendMessageA(*(*(v11 + 34) + 100), 0x30u, wParam, 0);
  Point.y = 4;
  Point.x = 4;
  ::hWnd = *(v11 + 25);
  hWnd = ChildWindowFromPoint(*(*(v11 + 34) + 100), 17179869188i64);
  lpPrevWndFunc = SetWindowLongA(hWnd, -4, sub_10002261);
}

//----- (1006D4F0) --------------------------------------------------------
void __thiscall ComboBox::addOption(ComboBox *this, LPARAM lParam, bool a3)
{
  LRESULT v3; // [esp+4Ch] [ebp-8h]
  ComboBox *v4; // [esp+50h] [ebp-4h]

  v4 = this;
  SendMessageA(*(*(this + 34) + 100), 0x143u, 0, lParam);
  v3 = SendMessageA(*(*(v4 + 34) + 100), 0x1A2u, 0, lParam);
  if ( v3 != -1 )
    ComboBox::selOption(v4, v3);
}

//----- (1006D5B0) --------------------------------------------------------
void __thiscall ComboBox::selOption(ComboBox *this, int wParam)
{
  SendMessageA(*(*(this + 34) + 100), 0x14Eu, wParam, 0);
}

//----- (1006D620) --------------------------------------------------------
ComboBox *__thiscall EditBox::EditBox(EditBox *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6)
{
  ComboBox *v6; // ST60_4

  v6 = this;
  ComboBox::ComboBox(this, a2, a3, a4, a5, a6);
  *v6 = &EditBox::`vftable';
  *(v6 + 35) = 65;
  return v6;
}
// 101AFEC8: using guessed type void *EditBox::`vftable';

//----- (1006D6A0) --------------------------------------------------------
void __thiscall EditBox::entryHandler(EditBox *this, char *lParam)
{
  EditBox *v2; // ST5C_4

  v2 = this;
  sub_1006C600("got new text %s\n", lParam);
  sub_1006C600("sending message to %s\n", *(*(v2 + 24) + 4));
  SendMessageA(*(*(v2 + 24) + 100), 0x400u, 0, lParam);
}

//----- (1006D740) --------------------------------------------------------
int __thiscall EditBox::processMessage(EditBox *this, HWND hWnd, unsigned int a3, unsigned int a4, int a5)
{
  LRESULT wParam; // ST64_4
  ComboBox *v7; // [esp+58h] [ebp-4h]

  v7 = this;
  if ( a3 == 273 && a4 >> 16 == 1 )
  {
    wParam = SendMessageA(*(*(this + 34) + 100), 0x147u, 0, 0);
    SendMessageA(*(*(v7 + 34) + 100), 0x148u, wParam, &unk_101D6300);
    PostMessageA(*(*(v7 + 24) + 100), 0x400u, 0, &unk_101D6300);
  }
  return ComboBox::processMessage(v7, hWnd, a3, a4, a5);
}

//----- (1006D870) --------------------------------------------------------
ComboBox *__thiscall OptionBox::OptionBox(OptionBox *this, struct UIWindow *a2, int a3, int a4, int a5, bool a6)
{
  ComboBox *v6; // ST60_4

  v6 = this;
  ComboBox::ComboBox(this, a2, a3, a4, a5, a6);
  *v6 = &OptionBox::`vftable';
  *(v6 + 35) = 3;
  return v6;
}
// 101AFF38: using guessed type void *OptionBox::`vftable';

//----- (1006D8F0) --------------------------------------------------------
int __thiscall OptionBox::processMessage(OptionBox *this, HWND a2, unsigned int a3, unsigned int a4, int hWnd)
{
  char v6; // [esp+0h] [ebp-5Ch]
  unsigned int v7; // [esp+4Ch] [ebp-10h]
  unsigned int v8; // [esp+50h] [ebp-Ch]
  LRESULT v9; // [esp+54h] [ebp-8h]
  ComboBox *v10; // [esp+58h] [ebp-4h]

  v10 = this;
  v8 = a3;
  if ( a3 == 273 )
  {
    v7 = a4 >> 16;
    if ( a4 >> 16 == 1 )
    {
      v9 = SendMessageA(hWnd, 0x147u, 0, 0);
      sub_1006C600("got selection change %d, %08x\n", a4);
      (*(*v10 + 92))(v10, v9);
    }
    else if ( v7 == 5 )
    {
      sub_1006C600("got edit change\n", v6);
    }
  }
  return ComboBox::processMessage(v10, a2, a3, a4, hWnd);
}

//----- (1006DA10) --------------------------------------------------------
int __thiscall AppWindow::processMessage(AppWindow *this, HWND hWnd, unsigned int a3, unsigned int a4, int a5)
{
  int v6; // [esp+4Ch] [ebp-14h]
  unsigned int v7; // [esp+50h] [ebp-10h]
  int v8; // [esp+54h] [ebp-Ch]
  int v9; // [esp+58h] [ebp-8h]
  UIWindow *v10; // [esp+5Ch] [ebp-4h]

  v10 = this;
  v7 = a3;
  if ( a3 == 16 && !*(gsys + 590) )
  {
    v8 = *(v10 + 34);
    v9 = v8;
    if ( v8 )
      v6 = (*(*v9 + 52))(v9, 1);
    else
      v6 = 0;
  }
  return UIWindow::processMessage(v10, hWnd, a3, a4, a5);
}

//----- (1006DAE0) --------------------------------------------------------
void __cdecl WSocket::init()
{
  char v0; // [esp+0h] [ebp-1E4h]
  struct WSAData WSAData; // [esp+50h] [ebp-194h]
  WORD wVersionRequested; // [esp+1E0h] [ebp-4h]

  wVersionRequested = 2;
  if ( WSAStartup(2u, &WSAData) )
    sub_1006DB60("Can't open win sock DLL !!\n", v0);
}

//----- (1006DB60) --------------------------------------------------------
char *__cdecl sub_1006DB60(char *Format, char a2)
{
  char *result; // eax
  size_t v3; // eax
  char Dest; // [esp+4Ch] [ebp-404h]
  va_list Args; // [esp+44Ch] [ebp-4h]

  result = &a2;
  Args = &a2;
  if ( sysCon )
  {
    if ( "wSocket" )
      Stream::print(sysCon, "%s: ", "wSocket");
    vsprintf(&Dest, Format, Args);
    result = strlen(&Dest);
    if ( result )
    {
      v3 = strlen(&Dest);
      result = (*(*sysCon + 56))(sysCon, &Dest, v3);
    }
  }
  return result;
}

//----- (1006DC70) --------------------------------------------------------
char __thiscall WSocket::open(WSocket *this, char *name, int hostshort)
{
  char result; // al
  char v4; // [esp+0h] [ebp-68h]
  __int16 Dst; // [esp+50h] [ebp-18h]
  u_short v6; // [esp+52h] [ebp-16h]
  int v7; // [esp+54h] [ebp-14h]
  struct hostent *v8; // [esp+60h] [ebp-8h]
  WSocket *v9; // [esp+64h] [ebp-4h]

  v9 = this;
  v8 = gethostbyname(name);
  if ( v8 )
  {
    *(v9 + 1) = socket(2, 1, 6);
    if ( *(v9 + 1) > 0 )
    {
      memset(&Dst, 0, 0x10u);
      Dst = 2;
      v7 = 0;
      v6 = htons(0);
      if ( bind(*(v9 + 1), &Dst, 16) )
      {
        sub_1006DB60("Error binding socket!!\n", v4);
        result = 0;
      }
      else
      {
        v6 = htons(hostshort);
        memcpy(&v7, *v8->h_addr_list, v8->h_length);
        if ( connect(*(v9 + 1), &Dst, 16) == -1 )
        {
          sub_1006DB60("Could not connect to server\n", v4);
          result = 0;
        }
        else
        {
          result = 1;
        }
      }
    }
    else
    {
      sub_1006DB60("Could not create socket!!\n", v4);
      result = 0;
    }
  }
  else
  {
    sub_1006DB60("could not get host by name\n", v4);
    result = 0;
  }
  return result;
}

//----- (1006DDF0) --------------------------------------------------------
char __thiscall WSocket::create(WSocket *this, char *a2, int hostshort)
{
  char result; // al
  char v4; // [esp+0h] [ebp-68h]
  struct sockaddr name; // [esp+54h] [ebp-14h]
  SOCKET *v6; // [esp+64h] [ebp-4h]

  v6 = this;
  *this = socket(2, 1, 6);
  if ( *v6 > 0 )
  {
    sub_1006DB60("got socket id %d\n", *v6);
    name.sa_family = 2;
    *&name.sa_data[2] = 0;
    *name.sa_data = htons(hostshort);
    if ( bind(*v6, &name, 16) )
    {
      sub_1006DB60("Error binding socket!!\n", v4);
      result = 0;
    }
    else
    {
      listen(*v6, 0x8000);
      result = 1;
    }
  }
  else
  {
    sub_1006DB60("Could not create socket!!\n", v4);
    result = 0;
  }
  return result;
}

//----- (1006DEF0) --------------------------------------------------------
void WSocket::flushWrite()
{
  ;
}

//----- (1006DF20) --------------------------------------------------------
u_long __thiscall WSocket::pending(WSocket *this)
{
  u_long result; // eax
  u_long argp; // [esp+4Ch] [ebp-8h]
  WSocket *v3; // [esp+50h] [ebp-4h]

  v3 = this;
  argp = 0;
  if ( ioctlsocket(*(this + 1), 1074030207, &argp) >= 0 )
    result = argp;
  else
    result = 0;
  return result;
}

//----- (1006DF90) --------------------------------------------------------
char __thiscall WSocket::checkForConnections(WSocket *this)
{
  int v2; // [esp+4Ch] [ebp-114h]
  char Dst; // [esp+50h] [ebp-110h]
  int v4; // [esp+54h] [ebp-10Ch]
  fd_set readfds; // [esp+58h] [ebp-108h]
  SOCKET *v6; // [esp+15Ch] [ebp-4h]

  v6 = this;
  readfds.fd_count = 0;
  readfds.fd_array[readfds.fd_count++] = *v6;
  memset(&Dst, 0, 8u);
  v4 = 1;
  v2 = select(1, &readfds, 0, 0, &Dst);
  if ( v2 < 0 )
    return 0;
  if ( v2 > 0 && _WSAFDIsSet(*v6, &readfds) )
    return 1;
  return 0;
}

//----- (1006E0B0) --------------------------------------------------------
void __thiscall WSocket::connect(WSocket *this)
{
  SOCKET v1; // eax
  int addrlen; // [esp+4Ch] [ebp-18h]
  struct sockaddr addr; // [esp+50h] [ebp-14h]
  WSocket *v4; // [esp+60h] [ebp-4h]

  v4 = this;
  addrlen = 16;
  v1 = accept(*this, &addr, &addrlen);
  *(v4 + 1) = v1;
  sub_1006DB60("got connected socket = %d : connection from %d.%d.%d.%d\n", *(v4 + 1));
}

//----- (1006E160) --------------------------------------------------------
void __thiscall WSocket::write(WSocket *this, void *buf, int len)
{
  signed int v3; // ecx
  char v4; // [esp+0h] [ebp-5Ch]
  int v5; // [esp+4Ch] [ebp-10h]
  int v6; // [esp+50h] [ebp-Ch]
  signed int v7; // [esp+54h] [ebp-8h]
  WSocket *v8; // [esp+58h] [ebp-4h]

  v8 = this;
  v7 = 200;
  while ( len )
  {
    v6 = send(*(v8 + 1), buf, len, 0);
    if ( v6 >= 0 )
    {
      if ( v6 != len )
        sub_1006DB60("!!! Not sent all data !!\n", v4);
    }
    else
    {
      v5 = WSAGetLastError();
      if ( v5 != 10035 )
        sub_1006E290("send error %d", v5);
      v3 = v7--;
      if ( v3 <= 0 )
        sub_1006E290("write timeout");
      System::sleep(*&gsys);
      v6 = 0;
    }
    len -= v6;
    buf = buf + v6;
  }
}

//----- (1006E290) --------------------------------------------------------
void __noreturn sub_1006E290(char *Format, ...)
{
  char Dest; // [esp+4Ch] [ebp-804h]
  va_list Args; // [esp+84Ch] [ebp-4h]
  va_list va; // [esp+85Ch] [ebp+Ch]

  va_start(va, Format);
  va_copy(Args, va);
  vsprintf(&Dest, Format, va);
  Args = 0;
  System::halt("c:\\development\\dolphinpiki\\syscore\\wsocket.cpp", 7, &Dest);
}

//----- (1006E330) --------------------------------------------------------
void __thiscall WSocket::read(WSocket *this, char *buf, int len)
{
  int v3; // [esp+4Ch] [ebp-Ch]
  int v4; // [esp+50h] [ebp-8h]
  WSocket *v5; // [esp+54h] [ebp-4h]

  v5 = this;
  while ( len )
  {
    v4 = recv(*(v5 + 1), buf, len, 0);
    if ( v4 < 0 )
    {
      v3 = WSAGetLastError();
      if ( v3 != 10035 )
        sub_1006E290("recv on sock %d : error %d", *(v5 + 1), v3);
      WaitMessage();
      v4 = 0;
    }
    len -= v4;
    buf += v4;
  }
}

//----- (1006E410) --------------------------------------------------------
void __thiscall WSocket::setASync(WSocket *this, HWND hWnd, unsigned __int32 wMsg, unsigned __int32 lEvent, int a5)
{
  char v5; // [esp+0h] [ebp-58h]
  int v6; // [esp+4Ch] [ebp-Ch]

  if ( a5 == -1 )
    v6 = *(this + 1);
  else
    v6 = a5;
  if ( WSAAsyncSelect(v6, hWnd, wMsg, lEvent) == -1 )
    sub_1006DB60("Error switching to Async mode\n", v5);
}

//----- (1006E4B0) --------------------------------------------------------
void __thiscall WSocket::close(WSocket *this)
{
  closesocket(*(this + 1));
}

//----- (1006F72B) --------------------------------------------------------
int PVWTextureInfo::read()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F74B) --------------------------------------------------------
int Font::setTexture()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F76B) --------------------------------------------------------
int GfxInfo::createCollData()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F796) --------------------------------------------------------
int Graphics::Graphics()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F7C6) --------------------------------------------------------
int CurveSection::genCurve()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F7EE) --------------------------------------------------------
int TexAttr::initImage()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F80B) --------------------------------------------------------
int TextureCacher::TextureCacher()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F82B) --------------------------------------------------------
int LightGroup::addLight()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F84B) --------------------------------------------------------
int AnimPalette::AnimPalette()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F86B) --------------------------------------------------------
int BaseShape::makeRouteGroup()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F896) --------------------------------------------------------
int Light::updAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F8BE) --------------------------------------------------------
int Light::genAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F8EC) --------------------------------------------------------
int DispList::prepareTriList()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F909) --------------------------------------------------------
int DispList::exportData()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F935) --------------------------------------------------------
int SEH_10025670()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F966) --------------------------------------------------------
int MtxGroup::read()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F98B) --------------------------------------------------------
int Mesh::read()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F9AB) --------------------------------------------------------
int Joint::read()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F9CB) --------------------------------------------------------
int Joint::genAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006F9F6) --------------------------------------------------------
int SceneData::parse()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FA26) --------------------------------------------------------
int SceneData::getAnimInfo()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FA4B) --------------------------------------------------------
int AnimData::initData()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FA76) --------------------------------------------------------
int AnimData::genAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FABC) --------------------------------------------------------
int AnimDca::read()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FB01) --------------------------------------------------------
int AnimDca::parse()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FB2B) --------------------------------------------------------
int AnimDca::getAnimInfo()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FB4B) --------------------------------------------------------
int AnimDck::AnimDck()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FB8C) --------------------------------------------------------
int AnimDck::read()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FBD1) --------------------------------------------------------
int AnimDck::parse()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FBFB) --------------------------------------------------------
int AnimDck::getAnimInfo()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FC31) --------------------------------------------------------
int BaseShape::importIni()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FC5B) --------------------------------------------------------
int BaseShape::instanceMaterials()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FC86) --------------------------------------------------------
int BaseShape::makeInstance()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FCBC) --------------------------------------------------------
int BaseShape::resolveTextureNames()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FD6A) --------------------------------------------------------
int BaseShape::read()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FDAB) --------------------------------------------------------
int BaseShape::initialise()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FDCE) --------------------------------------------------------
int BaseShape::createCollisions()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FDEB) --------------------------------------------------------
int BaseShape::loadDck()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FE16) --------------------------------------------------------
int BaseShape::importDck()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FE3B) --------------------------------------------------------
int BaseShape::loadDca()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FE66) --------------------------------------------------------
int BaseShape::importDca()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FE8B) --------------------------------------------------------
int BaseShape::loadAnimation()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FEAB) --------------------------------------------------------
int AnimFrameCacher::AnimFrameCacher()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FECC) --------------------------------------------------------
int SEH_10037C10()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FEF5) --------------------------------------------------------
int SEH_10037FC0()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FF1B) --------------------------------------------------------
int LightFlare::genAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FF51) --------------------------------------------------------
int LightGroup::genAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FF7B) --------------------------------------------------------
int LightGroup::loadini()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FF9B) --------------------------------------------------------
int ObjCollInfo::newCollInfoButton()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1006FFE8) --------------------------------------------------------
int ObjCollInfo::genAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007001B) --------------------------------------------------------
int ObjCollInfo::loadini()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (10070046) --------------------------------------------------------
int RouteGroup::loadini()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (10070076) --------------------------------------------------------
int CoreNode::genAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007009B) --------------------------------------------------------
int BaseApp::startAgeServer()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100700BB) --------------------------------------------------------
int LightCamera::initLightmap()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100700DB) --------------------------------------------------------
int ID32::genAge()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100700FB) --------------------------------------------------------
int StdSystem::loadTexture()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007011E) --------------------------------------------------------
int StdSystem::loadShape()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007013B) --------------------------------------------------------
int StdSystem::addAnimation()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007015B) --------------------------------------------------------
int StdSystem::addTexture()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007017B) --------------------------------------------------------
int StdSystem::getShape()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007019B) --------------------------------------------------------
int StdSystem::initLFlares()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100701BB) --------------------------------------------------------
int StdSystem::registerLFlare()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100701F1) --------------------------------------------------------
int StdSystem::loadBundle()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007021B) --------------------------------------------------------
int Timers::_start()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (10070251) --------------------------------------------------------
int SEH_10058350()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (10070279) --------------------------------------------------------
int SEH_10058C90()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007029B) --------------------------------------------------------
int Shape::optimize()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100702C6) --------------------------------------------------------
int Texture::read()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100702EB) --------------------------------------------------------
int AtxDirectRouter::openRoute()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (10070319) --------------------------------------------------------
int GameApp::doInitApp()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007033B) --------------------------------------------------------
int Module::menuPlugins()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007035E) --------------------------------------------------------
int System::openFile()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007037E) --------------------------------------------------------
int System::createFile()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007039B) --------------------------------------------------------
int System::createDebugStream()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100703BB) --------------------------------------------------------
int SEH_10068470()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100703DB) --------------------------------------------------------
int RenderWindow::initOpenGL()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (100703FB) --------------------------------------------------------
int ToolWindow::createWindow()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (10070419) --------------------------------------------------------
int VertSplitBar::VertSplitBar()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (10070439) --------------------------------------------------------
int HorzSplitBar::HorzSplitBar()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

//----- (1007045B) --------------------------------------------------------
int ComboBox::createWindow()
{
  return _CxxFrameHandler();
}
// 1006E8DE: using guessed type int _CxxFrameHandler(void);

// ALL OK, 1672 function(s) have been successfully decompiled
